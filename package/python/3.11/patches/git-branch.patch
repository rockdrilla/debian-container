 Doc/c-api/allocation.rst                         |   28 +-
 Doc/c-api/apiabiversion.rst                      |    2 +-
 Doc/c-api/arg.rst                                |   25 +-
 Doc/c-api/bool.rst                               |    6 +
 Doc/c-api/buffer.rst                             |   13 +-
 Doc/c-api/bytes.rst                              |   28 +-
 Doc/c-api/call.rst                               |   14 +-
 Doc/c-api/capsule.rst                            |    4 +-
 Doc/c-api/cell.rst                               |    2 +-
 Doc/c-api/code.rst                               |    8 +-
 Doc/c-api/codec.rst                              |    2 +-
 Doc/c-api/complex.rst                            |   14 +-
 Doc/c-api/conversion.rst                         |    4 +-
 Doc/c-api/dict.rst                               |   19 +-
 Doc/c-api/exceptions.rst                         |   31 +-
 Doc/c-api/file.rst                               |    2 +-
 Doc/c-api/float.rst                              |   18 +-
 Doc/c-api/gcsupport.rst                          |   32 +-
 Doc/c-api/import.rst                             |   32 +-
 Doc/c-api/init.rst                               |   87 +-
 Doc/c-api/init_config.rst                        |   18 +-
 Doc/c-api/intro.rst                              |   61 +-
 Doc/c-api/iterator.rst                           |    6 +-
 Doc/c-api/long.rst                               |   44 +-
 Doc/c-api/mapping.rst                            |    6 +-
 Doc/c-api/memory.rst                             |   38 +-
 Doc/c-api/method.rst                             |    4 +-
 Doc/c-api/module.rst                             |   26 +-
 Doc/c-api/none.rst                               |    2 +-
 Doc/c-api/object.rst                             |   49 +-
 Doc/c-api/refcounting.rst                        |   49 +-
 Doc/c-api/sequence.rst                           |    2 +-
 Doc/c-api/set.rst                                |    8 +-
 Doc/c-api/slice.rst                              |    4 +-
 Doc/c-api/stable.rst                             |    2 +-
 Doc/c-api/structures.rst                         |   80 +-
 Doc/c-api/sys.rst                                |   15 +-
 Doc/c-api/tuple.rst                              |   52 +-
 Doc/c-api/type.rst                               |   12 +-
 Doc/c-api/typehints.rst                          |    2 +-
 Doc/c-api/typeobj.rst                            |  267 +--
 Doc/c-api/unicode.rst                            |   48 +-
 Doc/c-api/veryhigh.rst                           |   14 +-
 Doc/c-api/weakref.rst                            |    8 +-
 Doc/conf.py                                      |   86 +
 Doc/extending/embedding.rst                      |    2 +-
 Doc/extending/extending.rst                      |   62 +-
 Doc/extending/newtypes.rst                       |   26 +-
 Doc/extending/newtypes_tutorial.rst              |  112 +-
 Doc/faq/extending.rst                            |    4 +-
 Doc/faq/general.rst                              |    6 +-
 Doc/faq/library.rst                              |    2 +-
 Doc/glossary.rst                                 |   29 +-
 Doc/howto/annotations.rst                        |  326 +--
 Doc/howto/argparse.rst                           |   53 +
 Doc/howto/clinic.rst                             | 1280 ++++++------
 Doc/howto/curses.rst                             |    2 +-
 Doc/howto/descriptor.rst                         |   10 +-
 Doc/howto/enum.rst                               |   11 +-
 Doc/howto/functional.rst                         |    4 +-
 Doc/howto/instrumentation.rst                    |    6 +-
 Doc/howto/isolating-extensions.rst               |   16 +-
 Doc/howto/regex.rst                              |    2 +
 Doc/howto/sorting.rst                            |    6 +-
 Doc/howto/unicode.rst                            |    8 +-
 Doc/includes/turtle-star.py                      |   10 -
 Doc/install/index.rst                            |   10 +-
 Doc/library/__main__.rst                         |    4 +-
 Doc/library/_thread.rst                          |   13 +-
 Doc/library/array.rst                            |    4 +-
 Doc/library/ast.rst                              |  101 +
 Doc/library/asyncio-dev.rst                      |    4 +-
 Doc/library/asyncio-eventloop.rst                |   42 +-
 Doc/library/asyncio-exceptions.rst               |    2 +-
 Doc/library/asyncio-extending.rst                |    2 +-
 Doc/library/asyncio-future.rst                   |    2 +-
 Doc/library/asyncio-platforms.rst                |    2 +-
 Doc/library/asyncio-subprocess.rst               |    6 +-
 Doc/library/asyncio-task.rst                     |    8 +-
 Doc/library/bz2.rst                              |    3 +-
 Doc/library/cmath.rst                            |    2 +-
 Doc/library/code.rst                             |    4 +-
 Doc/library/codeop.rst                           |    4 +-
 Doc/library/compileall.rst                       |    4 +-
 Doc/library/concurrent.rst                       |    4 +-
 Doc/library/constants.rst                        |    6 +-
 Doc/library/crypt.rst                            |    1 +
 Doc/library/ctypes.rst                           |   17 +-
 Doc/library/curses.rst                           |   22 +-
 Doc/library/dataclasses.rst                      |    2 +-
 Doc/library/decimal.rst                          |   43 +-
 Doc/library/devmode.rst                          |   10 +-
 Doc/library/dis.rst                              |   11 +-
 Doc/library/email.charset.rst                    |    2 +-
 Doc/library/email.encoders.rst                   |    2 +-
 Doc/library/email.generator.rst                  |    4 +-
 Doc/library/email.message.rst                    |    8 +-
 Doc/library/email.parser.rst                     |    4 +-
 Doc/library/exceptions.rst                       |   38 +-
 Doc/library/fcntl.rst                            |    8 +-
 Doc/library/filecmp.rst                          |    4 +-
 Doc/library/fileinput.rst                        |    2 +-
 Doc/library/fractions.rst                        |    2 +-
 Doc/library/ftplib.rst                           |    6 +-
 Doc/library/functions.rst                        |   40 +-
 Doc/library/gc.rst                               |    2 +-
 Doc/library/gettext.rst                          |    1 +
 Doc/library/graphlib.rst                         |    4 +-
 Doc/library/gzip.rst                             |    6 +-
 Doc/library/hashlib.rst                          |  143 +-
 Doc/library/http.client.rst                      |    2 +-
 Doc/library/imaplib.rst                          |    4 +-
 Doc/library/imp.rst                              |    2 +-
 Doc/library/importlib.resources.abc.rst          |    8 +-
 Doc/library/importlib.rst                        |   18 +-
 Doc/library/io.rst                               |    2 +-
 Doc/library/json.rst                             |   12 +-
 Doc/library/logging.handlers.rst                 |   17 +-
 Doc/library/logging.rst                          |   30 +-
 Doc/library/lzma.rst                             |    3 +-
 Doc/library/mailbox.rst                          |    8 +-
 Doc/library/msvcrt.rst                           |    2 +-
 Doc/library/multiprocessing.rst                  |   10 +-
 Doc/library/multiprocessing.shared_memory.rst    |   44 +-
 Doc/library/netrc.rst                            |   16 +-
 Doc/library/operator.rst                         |    6 +-
 Doc/library/optparse.rst                         |   59 +-
 Doc/library/os.path.rst                          |    2 +-
 Doc/library/os.rst                               |  126 +-
 Doc/library/platform.rst                         |    2 +-
 Doc/library/poplib.rst                           |    6 +-
 Doc/library/pprint.rst                           |    2 +-
 Doc/library/pty.rst                              |    2 +-
 Doc/library/random.rst                           |    2 +-
 Doc/library/re.rst                               |   23 +-
 Doc/library/runpy.rst                            |   25 +-
 Doc/library/sched.rst                            |    2 +-
 Doc/library/select.rst                           |   42 +-
 Doc/library/selectors.rst                        |    8 +-
 Doc/library/shelve.rst                           |    8 +-
 Doc/library/shutil.rst                           |   10 +-
 Doc/library/signal.rst                           |    4 +-
 Doc/library/smtplib.rst                          |    4 +-
 Doc/library/socket.rst                           |    2 +-
 Doc/library/sqlite3.rst                          |   53 +-
 Doc/library/ssl.rst                              |   12 +-
 Doc/library/stat.rst                             |    8 +-
 Doc/library/stdtypes.rst                         |   49 +-
 Doc/library/string.rst                           |    4 +-
 Doc/library/struct.rst                           |    8 +-
 Doc/library/subprocess.rst                       |   14 +-
 Doc/library/sys.rst                              |   71 +-
 Doc/library/sysconfig.rst                        |    2 +-
 Doc/library/tarfile.rst                          |   18 +-
 Doc/library/tempfile.rst                         |    4 +-
 Doc/library/test.rst                             |    4 +-
 Doc/library/textwrap.rst                         |    4 +-
 Doc/library/tkinter.rst                          |    2 +-
 Doc/library/tkinter.ttk.rst                      |    2 +-
 Doc/library/tokenize.rst                         |    9 +
 Doc/library/turtle.rst                           |  323 ++-
 Doc/library/typing.rst                           | 2359 +++++++++++++---------
 Doc/library/unittest.mock.rst                    |    2 +-
 Doc/library/unittest.rst                         |    4 +-
 Doc/library/urllib.error.rst                     |    6 +-
 Doc/library/urllib.parse.rst                     |    6 +-
 Doc/library/urllib.request.rst                   |    2 +-
 Doc/library/venv.rst                             |    6 +-
 Doc/library/winreg.rst                           |    8 +-
 Doc/library/winsound.rst                         |    4 +-
 Doc/library/xml.rst                              |   10 +-
 Doc/library/xml.sax.handler.rst                  |    2 +-
 Doc/library/xml.sax.utils.rst                    |    2 +-
 Doc/library/xmlrpc.rst                           |    4 +-
 Doc/license.rst                                  |  308 +--
 Doc/reference/compound_stmts.rst                 |    4 +-
 Doc/reference/datamodel.rst                      |   12 +-
 Doc/reference/expressions.rst                    |   27 +-
 Doc/reference/lexical_analysis.rst               |    2 +-
 Doc/reference/simple_stmts.rst                   |    2 +-
 Doc/requirements-oldest-sphinx.txt               |   10 +-
 Doc/requirements.txt                             |    2 +-
 Doc/tools/extensions/pyspecific.py               |   44 +-
 Doc/tools/templates/layout.html                  |   11 +-
 Doc/tools/templates/search.html                  |   74 +-
 Doc/tutorial/controlflow.rst                     |   36 +-
 Doc/tutorial/errors.rst                          |   25 +-
 Doc/tutorial/interactive.rst                     |    2 +-
 Doc/tutorial/introduction.rst                    |   44 +-
 Doc/tutorial/modules.rst                         |   16 +
 Doc/using/cmdline.rst                            |    8 +-
 Doc/using/configure.rst                          |    4 +-
 Doc/using/windows.rst                            |    2 +-
 Include/cpython/modsupport.h                     |    1 +
 Include/modsupport.h                             |    2 +
 Include/patchlevel.h                             |    2 +-
 Lib/asyncio/base_events.py                       |    2 +-
 Lib/asyncio/events.py                            |    2 +-
 Lib/colorsys.py                                  |    2 +-
 Lib/concurrent/futures/process.py                |    4 +
 Lib/configparser.py                              |    2 +-
 Lib/ctypes/test/test_as_parameter.py             |    6 +-
 Lib/ctypes/test/test_byteswap.py                 |    8 -
 Lib/ctypes/test/test_callbacks.py                |   10 +-
 Lib/ctypes/test/test_keeprefs.py                 |   58 +-
 Lib/ctypes/test/test_numbers.py                  |   85 +-
 Lib/ctypes/test/test_parameters.py               |    6 +-
 Lib/ctypes/test/test_structures.py               |    9 -
 Lib/email/feedparser.py                          |    2 +-
 Lib/enum.py                                      |   55 +-
 Lib/gettext.py                                   |   10 +-
 Lib/idlelib/idle_test/test_stackviewer.py        |   14 +-
 Lib/idlelib/pyshell.py                           |   12 +-
 Lib/idlelib/run.py                               |   18 +-
 Lib/idlelib/stackviewer.py                       |   41 +-
 Lib/logging/handlers.py                          |    2 +-
 Lib/multiprocessing/spawn.py                     |    6 +-
 Lib/pydoc.py                                     |   29 +-
 Lib/re/_compiler.py                              |    7 +
 Lib/re/_parser.py                                |    4 +-
 Lib/subprocess.py                                |    2 +-
 Lib/test/_test_multiprocessing.py                |   82 +-
 Lib/test/{clinic.test => clinic.test.c}          |  694 ++++++-
 Lib/test/libregrtest/runtest_mp.py               |   12 +-
 Lib/test/test_abc.py                             |    5 +-
 Lib/test/test_ast.py                             |   27 +
 Lib/test/test_capi/test_codecs.py                |   54 +
 Lib/test/test_capi/test_misc.py                  |   43 +
 Lib/test/test_clinic.py                          | 1612 +++++++++++----
 Lib/test/test_cmd_line_script.py                 |    2 +-
 Lib/test/test_codecs.py                          |    5 +-
 Lib/test/test_colorsys.py                        |   10 +
 Lib/test/test_concurrent_futures.py              |   18 +
 Lib/test/test_decimal.py                         |  309 +--
 Lib/test/test_dtrace.py                          |   70 +
 Lib/test/test_email/data/msg_47.txt              |   14 +
 Lib/test/test_email/test_email.py                |   10 +
 Lib/test/test_email/test_message.py              |    6 +-
 Lib/test/test_enum.py                            |  135 +-
 Lib/test/test_gettext.py                         |    4 +
 Lib/test/test_import/__init__.py                 |    8 +
 Lib/test/test_importlib/test_main.py             |    2 +-
 Lib/test/test_logging.py                         |    8 +-
 Lib/test/test_mailbox.py                         |    7 +-
 Lib/test/test_mmap.py                            |   21 +
 Lib/test/test_opcache.py                         |   29 +
 Lib/test/test_pydoc.py                           |   18 +-
 Lib/test/test_re.py                              |  131 +-
 Lib/test/test_regrtest.py                        |   36 +
 Lib/test/test_shutil.py                          |    2 +-
 Lib/test/test_sqlite3/test_userfunctions.py      |    9 +-
 Lib/test/test_subprocess.py                      |    8 +
 Lib/test/test_tcl.py                             |   13 +-
 Lib/test/test_types.py                           |   52 +-
 Lib/test/test_typing.py                          |  164 ++
 Lib/test/test_warnings/__init__.py               |   10 +-
 Lib/test/test_zipfile.py                         |    9 +
 Lib/tkinter/test/support.py                      |   18 +-
 Lib/tkinter/test/test_tkinter/test_images.py     |    6 +-
 Lib/tkinter/test/test_tkinter/test_widgets.py    |   16 +-
 Lib/tkinter/test/test_ttk/test_style.py          |    2 +-
 Lib/tkinter/test/test_ttk/test_widgets.py        |    8 +-
 Lib/tkinter/test/widget_tests.py                 |    6 +-
 Lib/typing.py                                    |   96 +-
 Lib/unittest/test/testmock/testasync.py          |    5 +-
 Lib/urllib/parse.py                              |   10 +-
 Lib/zipfile.py                                   |   11 +-
 Makefile.pre.in                                  |    9 +-
 Misc/ACKS                                        |    1 +
 Modules/_ctypes/_ctypes.c                        |   29 +
 Modules/_ctypes/callbacks.c                      |   18 +-
 Modules/_curses_panel.c                          |    4 +-
 Modules/_datetimemodule.c                        |   35 +-
 Modules/_decimal/_decimal.c                      |   82 +-
 Modules/_elementtree.c                           |   10 +-
 Modules/_hashopenssl.c                           |   13 +-
 Modules/_pickle.c                                |  139 +-
 Modules/_sqlite/connection.c                     |    8 +-
 Modules/_ssl.c                                   |   40 +-
 Modules/_stat.c                                  |   18 +-
 Modules/_testcapimodule.c                        |   78 +-
 Modules/_testinternalcapi.c                      |  116 +-
 Modules/_threadmodule.c                          |    4 +-
 Modules/_tkinter.c                               |    5 +-
 Modules/_winapi.c                                |   14 +-
 Modules/_zoneinfo.c                              |   17 +-
 Modules/arraymodule.c                            |    8 +-
 Modules/cmathmodule.c                            |   16 +-
 Modules/errnomodule.c                            |    7 +-
 Modules/grpmodule.c                              |   10 +-
 Modules/mathmodule.c                             |   10 +-
 Modules/mmapmodule.c                             |    7 +-
 Modules/posixmodule.c                            |   93 +-
 Modules/pyexpat.c                                |   20 +-
 Modules/socketmodule.c                           |   22 +-
 Modules/timemodule.c                             |    7 +-
 Modules/xxsubtype.c                              |   10 +-
 Objects/bytesobject.c                            |   21 +-
 Objects/clinic/codeobject.c.h                    |   34 +-
 Objects/codeobject.c                             |   59 +-
 Objects/exceptions.c                             |   31 +-
 Objects/frameobject.c                            |   13 +-
 Objects/moduleobject.c                           |   48 +-
 Objects/typeobject.c                             |   33 +-
 Objects/unicodeobject.c                          |   32 +-
 Parser/asdl_c.py                                 |    1 +
 Python/Python-ast.c                              |    7 +
 Python/_warnings.c                               |   28 +-
 Python/bltinmodule.c                             |   40 +-
 Python/compile.c                                 |    6 +-
 Python/import.c                                  |    1 +
 Python/initconfig.c                              |    4 +-
 Python/marshal.c                                 |  132 +-
 Python/modsupport.c                              |   29 +-
 Python/pythonrun.c                               |   12 +-
 Python/specialize.c                              |    4 +-
 Python/suggestions.c                             |   12 +-
 Python/sysmodule.c                               |   26 +-
 Tools/c-analyzer/c_parser/preprocessor/common.py |    8 +-
 Tools/c-analyzer/cpython/ignored.tsv             |    1 +
 Tools/clinic/clinic.py                           |  302 +--
 configure.ac                                     |    6 +-
 pyconfig.h.in                                    |    3 +
 323 files changed, 8992 insertions(+), 4977 deletions(-)

--- a/Doc/c-api/allocation.rst
+++ b/Doc/c-api/allocation.rst
@@ -27,22 +27,26 @@ Allocating Objects on the Heap
    length information for a variable-size object.
 
 
-.. c:function:: TYPE* PyObject_New(TYPE, PyTypeObject *type)
+.. c:macro:: PyObject_New(TYPE, typeobj)
 
-   Allocate a new Python object using the C structure type *TYPE* and the
-   Python type object *type*.  Fields not defined by the Python object header
-   are not initialized; the object's reference count will be one.  The size of
-   the memory allocation is determined from the :c:member:`~PyTypeObject.tp_basicsize` field of
-   the type object.
+   Allocate a new Python object using the C structure type *TYPE*
+   and the Python type object *typeobj* (``PyTypeObject*``).
+   Fields not defined by the Python object header are not initialized.
+   The caller will own the only reference to the object
+   (i.e. its reference count will be one).
+   The size of the memory allocation is determined from the
+   :c:member:`~PyTypeObject.tp_basicsize` field of the type object.
 
 
-.. c:function:: TYPE* PyObject_NewVar(TYPE, PyTypeObject *type, Py_ssize_t size)
+.. c:macro:: PyObject_NewVar(TYPE, typeobj, size)
 
    Allocate a new Python object using the C structure type *TYPE* and the
-   Python type object *type*.  Fields not defined by the Python object header
+   Python type object *typeobj* (``PyTypeObject*``).
+   Fields not defined by the Python object header
    are not initialized.  The allocated memory allows for the *TYPE* structure
-   plus *size* fields of the size given by the :c:member:`~PyTypeObject.tp_itemsize` field of
-   *type*.  This is useful for implementing objects like tuples, which are
+   plus *size* (``Py_ssize_t``) fields of the size
+   given by the :c:member:`~PyTypeObject.tp_itemsize` field of
+   *typeobj*.  This is useful for implementing objects like tuples, which are
    able to determine their size at construction time.  Embedding the array of
    fields into the same allocation decreases the number of allocations,
    improving the memory management efficiency.
@@ -50,8 +54,8 @@ Allocating Objects on the Heap
 
 .. c:function:: void PyObject_Del(void *op)
 
-   Releases memory allocated to an object using :c:func:`PyObject_New` or
-   :c:func:`PyObject_NewVar`.  This is normally called from the
+   Releases memory allocated to an object using :c:macro:`PyObject_New` or
+   :c:macro:`PyObject_NewVar`.  This is normally called from the
    :c:member:`~PyTypeObject.tp_dealloc` handler specified in the object's type.  The fields of
    the object should not be accessed after this call as the memory is no
    longer a valid Python object.
--- a/Doc/c-api/apiabiversion.rst
+++ b/Doc/c-api/apiabiversion.rst
@@ -60,7 +60,7 @@ See :ref:`stable` for a discussion of AP
 
    Use this for numeric comparisons, e.g. ``#if PY_VERSION_HEX >= ...``.
 
-   This version is also available via the symbol :data:`Py_Version`.
+   This version is also available via the symbol :c:var:`Py_Version`.
 
 .. c:var:: const unsigned long Py_Version
 
--- a/Doc/c-api/arg.rst
+++ b/Doc/c-api/arg.rst
@@ -330,8 +330,10 @@ Other objects
 
 ``O`` (object) [PyObject \*]
    Store a Python object (without any conversion) in a C object pointer.  The C
-   program thus receives the actual object that was passed.  The object's reference
-   count is not increased.  The pointer stored is not ``NULL``.
+   program thus receives the actual object that was passed.  A new
+   :term:`strong reference` to the object is not created
+   (i.e. its reference count is not increased).
+   The pointer stored is not ``NULL``.
 
 ``O!`` (object) [*typeobject*, PyObject \*]
    Store a Python object in a C object pointer.  This is similar to ``O``, but
@@ -380,7 +382,7 @@ Other objects
    *items*.  Format units for sequences may be nested.
 
 It is possible to pass "long" integers (integers whose value exceeds the
-platform's :const:`LONG_MAX`) however no proper range checking is done --- the
+platform's :c:macro:`LONG_MAX`) however no proper range checking is done --- the
 most significant bits are silently truncated when the receiving field is too
 small to receive the value (actually, the semantics are inherited from downcasts
 in C --- your mileage may vary).
@@ -415,7 +417,8 @@ inside nested parentheses.  They are:
    mutually exclude each other.
 
 Note that any Python object references which are provided to the caller are
-*borrowed* references; do not decrement their reference count!
+*borrowed* references; do not release them
+(i.e. do not decrement their reference count)!
 
 Additional arguments passed to these functions must be addresses of variables
 whose type is determined by the format string; these are used to store values
@@ -492,7 +495,7 @@ API Functions
 
    A simpler form of parameter retrieval which does not use a format string to
    specify the types of the arguments.  Functions which use this method to retrieve
-   their parameters should be declared as :const:`METH_VARARGS` in function or
+   their parameters should be declared as :c:macro:`METH_VARARGS` in function or
    method tables.  The tuple containing the actual parameters should be passed as
    *args*; it must actually be a tuple.  The length of the tuple must be at least
    *min* and no more than *max*; *min* and *max* may be equal.  Additional
@@ -506,7 +509,7 @@ API Functions
    will be set if there was a failure.
 
    This is an example of the use of this function, taken from the sources for the
-   :mod:`_weakref` helper module for weak references::
+   :mod:`!_weakref` helper module for weak references::
 
       static PyObject *
       weakref_ref(PyObject *self, PyObject *args)
@@ -584,7 +587,7 @@ Building values
       Same as ``s#``.
 
    ``u`` (:class:`str`) [const wchar_t \*]
-      Convert a null-terminated :c:expr:`wchar_t` buffer of Unicode (UTF-16 or UCS-4)
+      Convert a null-terminated :c:type:`wchar_t` buffer of Unicode (UTF-16 or UCS-4)
       data to a Python Unicode object.  If the Unicode buffer pointer is ``NULL``,
       ``None`` is returned.
 
@@ -650,8 +653,10 @@ Building values
       Convert a C :c:type:`Py_complex` structure to a Python complex number.
 
    ``O`` (object) [PyObject \*]
-      Pass a Python object untouched (except for its reference count, which is
-      incremented by one).  If the object passed in is a ``NULL`` pointer, it is assumed
+      Pass a Python object untouched but create a new
+      :term:`strong reference` to it
+      (i.e. its reference count is incremented by one).
+      If the object passed in is a ``NULL`` pointer, it is assumed
       that this was caused because the call producing the argument found an error and
       set an exception. Therefore, :c:func:`Py_BuildValue` will return ``NULL`` but won't
       raise an exception.  If no exception has been raised yet, :exc:`SystemError` is
@@ -661,7 +666,7 @@ Building values
       Same as ``O``.
 
    ``N`` (object) [PyObject \*]
-      Same as ``O``, except it doesn't increment the reference count on the object.
+      Same as ``O``, except it doesn't create a new :term:`strong reference`.
       Useful when the object is created by a call to an object constructor in the
       argument list.
 
--- a/Doc/c-api/bool.rst
+++ b/Doc/c-api/bool.rst
@@ -11,6 +11,12 @@ creation and deletion functions don't ap
 are available, however.
 
 
+.. c:var:: PyTypeObject PyBool_Type
+
+   This instance of :c:type:`PyTypeObject` represents the Python boolean type; it
+   is the same object as :class:`bool` in the Python layer.
+
+
 .. c:function:: int PyBool_Check(PyObject *o)
 
    Return true if *o* is of type :c:data:`PyBool_Type`.  This function always
--- a/Doc/c-api/buffer.rst
+++ b/Doc/c-api/buffer.rst
@@ -44,7 +44,7 @@ the elements exposed by an :class:`array
 
 An example consumer of the buffer interface is the :meth:`~io.BufferedIOBase.write`
 method of file objects: any object that can export a series of bytes through
-the buffer interface can be written to a file.  While :meth:`write` only
+the buffer interface can be written to a file.  While :meth:`!write` only
 needs read-only access to the internal contents of the object passed to it,
 other methods such as :meth:`~io.BufferedIOBase.readinto` need write access
 to the contents of their argument.  The buffer interface allows objects to
@@ -102,7 +102,9 @@ a buffer, see :c:func:`PyObject_GetBuffe
    .. c:member:: PyObject *obj
 
       A new reference to the exporting object. The reference is owned by
-      the consumer and automatically decremented and set to ``NULL`` by
+      the consumer and automatically released
+      (i.e. reference count decremented)
+      and set to ``NULL`` by
       :c:func:`PyBuffer_Release`. The field is the equivalent of the return
       value of any standard C-API function.
 
@@ -225,7 +227,7 @@ object via :c:func:`PyObject_GetBuffer`.
 structure of the memory can vary drastically, the consumer uses the *flags*
 argument to specify the exact buffer type it can handle.
 
-All :c:data:`Py_buffer` fields are unambiguously defined by the request
+All :c:type:`Py_buffer` fields are unambiguously defined by the request
 type.
 
 request-independent fields
@@ -454,7 +456,8 @@ Buffer-related functions
 
 .. c:function:: void PyBuffer_Release(Py_buffer *view)
 
-   Release the buffer *view* and decrement the reference count for
+   Release the buffer *view* and release the :term:`strong reference`
+   (i.e. decrement the reference count) to the view's supporting object,
    ``view->obj``. This function MUST be called when the buffer
    is no longer being used, otherwise reference leaks may occur.
 
@@ -464,7 +467,7 @@ Buffer-related functions
 
 .. c:function:: Py_ssize_t PyBuffer_SizeFromFormat(const char *format)
 
-   Return the implied :c:data:`~Py_buffer.itemsize` from :c:data:`~Py_buffer.format`.
+   Return the implied :c:member:`~Py_buffer.itemsize` from :c:member:`~Py_buffer.format`.
    On error, raise an exception and return -1.
 
    .. versionadded:: 3.9
--- a/Doc/c-api/bytes.rst
+++ b/Doc/c-api/bytes.rst
@@ -67,39 +67,39 @@ called with a non-bytes parameter.
    +-------------------+---------------+--------------------------------+
    | Format Characters | Type          | Comment                        |
    +===================+===============+================================+
-   | :attr:`%%`        | *n/a*         | The literal % character.       |
+   | ``%%``            | *n/a*         | The literal % character.       |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%c`        | int           | A single byte,                 |
+   | ``%c``            | int           | A single byte,                 |
    |                   |               | represented as a C int.        |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%d`        | int           | Equivalent to                  |
+   | ``%d``            | int           | Equivalent to                  |
    |                   |               | ``printf("%d")``. [1]_         |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%u`        | unsigned int  | Equivalent to                  |
+   | ``%u``            | unsigned int  | Equivalent to                  |
    |                   |               | ``printf("%u")``. [1]_         |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%ld`       | long          | Equivalent to                  |
+   | ``%ld``           | long          | Equivalent to                  |
    |                   |               | ``printf("%ld")``. [1]_        |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%lu`       | unsigned long | Equivalent to                  |
+   | ``%lu``           | unsigned long | Equivalent to                  |
    |                   |               | ``printf("%lu")``. [1]_        |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%zd`       | :c:type:`\    | Equivalent to                  |
+   | ``%zd``           | :c:type:`\    | Equivalent to                  |
    |                   | Py_ssize_t`   | ``printf("%zd")``. [1]_        |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%zu`       | size_t        | Equivalent to                  |
+   | ``%zu``           | size_t        | Equivalent to                  |
    |                   |               | ``printf("%zu")``. [1]_        |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%i`        | int           | Equivalent to                  |
+   | ``%i``            | int           | Equivalent to                  |
    |                   |               | ``printf("%i")``. [1]_         |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%x`        | int           | Equivalent to                  |
+   | ``%x``            | int           | Equivalent to                  |
    |                   |               | ``printf("%x")``. [1]_         |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%s`        | const char\*  | A null-terminated C character  |
+   | ``%s``            | const char\*  | A null-terminated C character  |
    |                   |               | array.                         |
    +-------------------+---------------+--------------------------------+
-   | :attr:`%p`        | const void\*  | The hex representation of a C  |
+   | ``%p``            | const void\*  | The hex representation of a C  |
    |                   |               | pointer. Mostly equivalent to  |
    |                   |               | ``printf("%p")`` except that   |
    |                   |               | it is guaranteed to start with |
@@ -187,8 +187,8 @@ called with a non-bytes parameter.
 .. c:function:: void PyBytes_ConcatAndDel(PyObject **bytes, PyObject *newpart)
 
    Create a new bytes object in *\*bytes* containing the contents of *newpart*
-   appended to *bytes*.  This version decrements the reference count of
-   *newpart*.
+   appended to *bytes*.  This version releases the :term:`strong reference`
+   to *newpart* (i.e. decrements its reference count).
 
 
 .. c:function:: int _PyBytes_Resize(PyObject **bytes, Py_ssize_t newsize)
--- a/Doc/c-api/call.rst
+++ b/Doc/c-api/call.rst
@@ -63,7 +63,7 @@ the arguments to an args tuple and kwarg
 in implementing vectorcall.
 
 Classes can implement the vectorcall protocol by enabling the
-:const:`Py_TPFLAGS_HAVE_VECTORCALL` flag and setting
+:c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag and setting
 :c:member:`~PyTypeObject.tp_vectorcall_offset` to the offset inside the
 object structure where a *vectorcallfunc* appears.
 This is a pointer to a function with the following signature:
@@ -75,7 +75,7 @@ This is a pointer to a function with the
    values of the keyword arguments.
    This can be *NULL* if there are no arguments.
 - *nargsf* is the number of positional arguments plus possibly the
-   :const:`PY_VECTORCALL_ARGUMENTS_OFFSET` flag.
+   :c:macro:`PY_VECTORCALL_ARGUMENTS_OFFSET` flag.
    To get the actual number of positional arguments from *nargsf*,
    use :c:func:`PyVectorcall_NARGS`.
 - *kwnames* is a tuple containing the names of the keyword arguments;
@@ -95,7 +95,7 @@ This is a pointer to a function with the
    ``args[0]`` may be changed.
 
    Whenever they can do so cheaply (without additional allocation), callers
-   are encouraged to use :const:`PY_VECTORCALL_ARGUMENTS_OFFSET`.
+   are encouraged to use :c:macro:`PY_VECTORCALL_ARGUMENTS_OFFSET`.
    Doing so will allow callables such as bound methods to make their onward
    calls (which include a prepended *self* argument) very efficiently.
 
@@ -156,7 +156,7 @@ Vectorcall Support API
    This is mostly useful to check whether or not *op* supports vectorcall,
    which can be done by checking ``PyVectorcall_Function(op) != NULL``.
 
-   .. versionadded:: 3.8
+   .. versionadded:: 3.9
 
 .. c:function:: PyObject* PyVectorcall_Call(PyObject *callable, PyObject *tuple, PyObject *dict)
 
@@ -165,7 +165,7 @@ Vectorcall Support API
 
    This is a specialized function, intended to be put in the
    :c:member:`~PyTypeObject.tp_call` slot or be used in an implementation of ``tp_call``.
-   It does not check the :const:`Py_TPFLAGS_HAVE_VECTORCALL` flag
+   It does not check the :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag
    and it does not fall back to ``tp_call``.
 
    .. versionadded:: 3.8
@@ -383,11 +383,11 @@ please see individual documentation for
    *args[0]*, and the *args* array starting at *args[1]* represents the arguments
    of the call. There must be at least one positional argument.
    *nargsf* is the number of positional arguments including *args[0]*,
-   plus :const:`PY_VECTORCALL_ARGUMENTS_OFFSET` if the value of ``args[0]`` may
+   plus :c:macro:`PY_VECTORCALL_ARGUMENTS_OFFSET` if the value of ``args[0]`` may
    temporarily be changed. Keyword arguments can be passed just like in
    :c:func:`PyObject_Vectorcall`.
 
-   If the object has the :const:`Py_TPFLAGS_METHOD_DESCRIPTOR` feature,
+   If the object has the :c:macro:`Py_TPFLAGS_METHOD_DESCRIPTOR` feature,
    this will call the unbound method object with the full
    *args* vector as arguments.
 
--- a/Doc/c-api/capsule.rst
+++ b/Doc/c-api/capsule.rst
@@ -64,7 +64,7 @@ Refer to :ref:`using-capsules` for more
 
    The *name* parameter must compare exactly to the name stored in the capsule.
    If the name stored in the capsule is ``NULL``, the *name* passed in must also
-   be ``NULL``.  Python uses the C function :c:func:`strcmp` to compare capsule
+   be ``NULL``.  Python uses the C function :c:func:`!strcmp` to compare capsule
    names.
 
 
@@ -121,7 +121,7 @@ Refer to :ref:`using-capsules` for more
    compared.)
 
    In other words, if :c:func:`PyCapsule_IsValid` returns a true value, calls to
-   any of the accessors (any function starting with :c:func:`PyCapsule_Get`) are
+   any of the accessors (any function starting with ``PyCapsule_Get``) are
    guaranteed to succeed.
 
    Return a nonzero value if the object is valid and matches the name passed in.
--- a/Doc/c-api/cell.rst
+++ b/Doc/c-api/cell.rst
@@ -25,7 +25,7 @@ Cell objects are not likely to be useful
    The type object corresponding to cell objects.
 
 
-.. c:function:: int PyCell_Check(ob)
+.. c:function:: int PyCell_Check(PyObject *ob)
 
    Return true if *ob* is a cell object; *ob* must not be ``NULL``.  This
    function always succeeds.
--- a/Doc/c-api/code.rst
+++ b/Doc/c-api/code.rst
@@ -33,7 +33,7 @@ bound into a function.
 
    Return the number of free variables in *co*.
 
-.. c:function:: PyCodeObject* PyCode_New(int argcount, int kwonlyargcount, int nlocals, int stacksize, int flags, PyObject *code, PyObject *consts, PyObject *names, PyObject *varnames, PyObject *freevars, PyObject *cellvars, PyObject *filename, PyObject *name, int firstlineno, PyObject *linetable, PyObject *exceptiontable)
+.. c:function:: PyCodeObject* PyCode_New(int argcount, int kwonlyargcount, int nlocals, int stacksize, int flags, PyObject *code, PyObject *consts, PyObject *names, PyObject *varnames, PyObject *freevars, PyObject *cellvars, PyObject *filename, PyObject *name, PyObject *qualname, int firstlineno, PyObject *linetable, PyObject *exceptiontable)
 
    Return a new code object.  If you need a dummy code object to create a frame,
    use :c:func:`PyCode_NewEmpty` instead.  Calling :c:func:`PyCode_New` directly
@@ -43,9 +43,9 @@ bound into a function.
    execution or VM crashes. Use this function only with extreme care.
 
    .. versionchanged:: 3.11
-      Added ``exceptiontable`` parameter.
+      Added ``qualname`` and ``exceptiontable`` parameters.
 
-.. c:function:: PyCodeObject* PyCode_NewWithPosOnlyArgs(int argcount, int posonlyargcount, int kwonlyargcount, int nlocals, int stacksize, int flags, PyObject *code, PyObject *consts, PyObject *names, PyObject *varnames, PyObject *freevars, PyObject *cellvars, PyObject *filename, PyObject *name, int firstlineno, PyObject *linetable, PyObject *exceptiontable)
+.. c:function:: PyCodeObject* PyCode_NewWithPosOnlyArgs(int argcount, int posonlyargcount, int kwonlyargcount, int nlocals, int stacksize, int flags, PyObject *code, PyObject *consts, PyObject *names, PyObject *varnames, PyObject *freevars, PyObject *cellvars, PyObject *filename, PyObject *name, PyObject *qualname, int firstlineno, PyObject *linetable, PyObject *exceptiontable)
 
    Similar to :c:func:`PyCode_New`, but with an extra "posonlyargcount" for positional-only arguments.
    The same caveats that apply to ``PyCode_New`` also apply to this function.
@@ -53,7 +53,7 @@ bound into a function.
    .. versionadded:: 3.8
 
    .. versionchanged:: 3.11
-      Added ``exceptiontable`` parameter.
+      Added ``qualname`` and  ``exceptiontable`` parameters.
 
 .. c:function:: PyCodeObject* PyCode_NewEmpty(const char *filename, const char *funcname, int firstlineno)
 
--- a/Doc/c-api/codec.rst
+++ b/Doc/c-api/codec.rst
@@ -7,7 +7,7 @@ Codec registry and support functions
 
    Register a new codec search function.
 
-   As side effect, this tries to load the :mod:`encodings` package, if not yet
+   As side effect, this tries to load the :mod:`!encodings` package, if not yet
    done, to make sure that it is always first in the list of search functions.
 
 .. c:function:: int PyCodec_Unregister(PyObject *search_function)
--- a/Doc/c-api/complex.rst
+++ b/Doc/c-api/complex.rst
@@ -64,7 +64,7 @@ pointers.  This is consistent throughout
    representation.
 
    If *divisor* is null, this method returns zero and sets
-   :c:data:`errno` to :c:data:`EDOM`.
+   :c:data:`errno` to :c:macro:`!EDOM`.
 
 
 .. c:function:: Py_complex _Py_c_pow(Py_complex num, Py_complex exp)
@@ -73,7 +73,7 @@ pointers.  This is consistent throughout
    representation.
 
    If *num* is null and *exp* is not a positive real number,
-   this method returns zero and sets :c:data:`errno` to :c:data:`EDOM`.
+   this method returns zero and sets :c:data:`errno` to :c:macro:`!EDOM`.
 
 
 Complex Numbers as Python Objects
@@ -127,12 +127,12 @@ Complex Numbers as Python Objects
 
    Return the :c:type:`Py_complex` value of the complex number *op*.
 
-   If *op* is not a Python complex number object but has a :meth:`__complex__`
+   If *op* is not a Python complex number object but has a :meth:`~object.__complex__`
    method, this method will first be called to convert *op* to a Python complex
-   number object.  If ``__complex__()`` is not defined then it falls back to
-   :meth:`__float__`.  If ``__float__()`` is not defined then it falls back
-   to :meth:`__index__`.  Upon failure, this method returns ``-1.0`` as a real
+   number object.  If :meth:`!__complex__` is not defined then it falls back to
+   :meth:`~object.__float__`.  If :meth:`!__float__` is not defined then it falls back
+   to :meth:`~object.__index__`.  Upon failure, this method returns ``-1.0`` as a real
    value.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
--- a/Doc/c-api/conversion.rst
+++ b/Doc/c-api/conversion.rst
@@ -119,10 +119,10 @@ The following functions provide locale-i
 .. c:function:: int PyOS_stricmp(const char *s1, const char *s2)
 
    Case insensitive comparison of strings. The function works almost
-   identically to :c:func:`strcmp` except that it ignores the case.
+   identically to :c:func:`!strcmp` except that it ignores the case.
 
 
 .. c:function:: int PyOS_strnicmp(const char *s1, const char *s2, Py_ssize_t  size)
 
    Case insensitive comparison of strings. The function works almost
-   identically to :c:func:`strncmp` except that it ignores the case.
+   identically to :c:func:`!strncmp` except that it ignores the case.
--- a/Doc/c-api/dict.rst
+++ b/Doc/c-api/dict.rst
@@ -98,9 +98,11 @@ Dictionary Objects
    Return the object from dictionary *p* which has a key *key*.  Return ``NULL``
    if the key *key* is not present, but *without* setting an exception.
 
-   Note that exceptions which occur while calling :meth:`__hash__` and
-   :meth:`__eq__` methods will get suppressed.
-   To get error reporting use :c:func:`PyDict_GetItemWithError()` instead.
+   .. note::
+
+      Exceptions that occur while this calls :meth:`~object.__hash__` and
+      :meth:`~object.__eq__` methods are silently ignored.
+      Prefer the :c:func:`PyDict_GetItemWithError` function instead.
 
    .. versionchanged:: 3.10
       Calling this API without :term:`GIL` held had been allowed for historical
@@ -120,10 +122,13 @@ Dictionary Objects
    This is the same as :c:func:`PyDict_GetItem`, but *key* is specified as a
    :c:expr:`const char*`, rather than a :c:expr:`PyObject*`.
 
-   Note that exceptions which occur while calling :meth:`__hash__` and
-   :meth:`__eq__` methods and creating a temporary string object
-   will get suppressed.
-   To get error reporting use :c:func:`PyDict_GetItemWithError()` instead.
+   .. note::
+
+      Exceptions that occur while this calls :meth:`~object.__hash__` and
+      :meth:`~object.__eq__` methods or while creating the temporary :class:`str`
+      object are silently ignored.
+      Prefer using the :c:func:`PyDict_GetItemWithError` function with your own
+      :c:func:`PyUnicode_FromString` *key* instead.
 
 
 .. c:function:: PyObject* PyDict_SetDefault(PyObject *p, PyObject *key, PyObject *defaultobj)
--- a/Doc/c-api/exceptions.rst
+++ b/Doc/c-api/exceptions.rst
@@ -78,7 +78,7 @@ Printing and clearing
    This utility function prints a warning message to ``sys.stderr`` when an
    exception has been set but it is impossible for the interpreter to actually
    raise the exception.  It is used, for example, when an exception occurs in an
-   :meth:`__del__` method.
+   :meth:`~object.__del__` method.
 
    The function is called with a single argument *obj* that identifies the context
    in which the unraisable exception occurred. If possible,
@@ -99,7 +99,8 @@ For convenience, some of these functions
 
    This is the most common way to set the error indicator.  The first argument
    specifies the exception type; it is normally one of the standard exceptions,
-   e.g. :c:data:`PyExc_RuntimeError`.  You need not increment its reference count.
+   e.g. :c:data:`PyExc_RuntimeError`.  You need not create a new
+   :term:`strong reference` to it (e.g. with :c:func:`Py_INCREF`).
    The second argument is an error message; it is decoded from ``'utf-8'``.
 
 
@@ -152,9 +153,9 @@ For convenience, some of these functions
    This is a convenience function to raise an exception when a C library function
    has returned an error and set the C variable :c:data:`errno`.  It constructs a
    tuple object whose first item is the integer :c:data:`errno` value and whose
-   second item is the corresponding error message (gotten from :c:func:`strerror`),
+   second item is the corresponding error message (gotten from :c:func:`!strerror`),
    and then calls ``PyErr_SetObject(type, object)``.  On Unix, when the
-   :c:data:`errno` value is :const:`EINTR`, indicating an interrupted system call,
+   :c:data:`errno` value is :c:macro:`!EINTR`, indicating an interrupted system call,
    this calls :c:func:`PyErr_CheckSignals`, and if that set the error indicator,
    leaves it set to that.  The function always returns ``NULL``, so a wrapper
    function around a system call can write ``return PyErr_SetFromErrno(type);``
@@ -166,7 +167,7 @@ For convenience, some of these functions
    Similar to :c:func:`PyErr_SetFromErrno`, with the additional behavior that if
    *filenameObject* is not ``NULL``, it is passed to the constructor of *type* as
    a third parameter.  In the case of :exc:`OSError` exception,
-   this is used to define the :attr:`filename` attribute of the
+   this is used to define the :attr:`!filename` attribute of the
    exception instance.
 
 
@@ -189,12 +190,12 @@ For convenience, some of these functions
 .. c:function:: PyObject* PyErr_SetFromWindowsErr(int ierr)
 
    This is a convenience function to raise :exc:`WindowsError`. If called with
-   *ierr* of ``0``, the error code returned by a call to :c:func:`GetLastError`
-   is used instead.  It calls the Win32 function :c:func:`FormatMessage` to retrieve
-   the Windows description of error code given by *ierr* or :c:func:`GetLastError`,
+   *ierr* of ``0``, the error code returned by a call to :c:func:`!GetLastError`
+   is used instead.  It calls the Win32 function :c:func:`!FormatMessage` to retrieve
+   the Windows description of error code given by *ierr* or :c:func:`!GetLastError`,
    then it constructs a tuple object whose first item is the *ierr* value and whose
    second item is the corresponding error message (gotten from
-   :c:func:`FormatMessage`), and then calls ``PyErr_SetObject(PyExc_WindowsError,
+   :c:func:`!FormatMessage`), and then calls ``PyErr_SetObject(PyExc_WindowsError,
    object)``. This function always returns ``NULL``.
 
    .. availability:: Windows.
@@ -567,7 +568,7 @@ Signal Handling
    be interruptible by user requests (such as by pressing Ctrl-C).
 
    .. note::
-      The default Python signal handler for :const:`SIGINT` raises the
+      The default Python signal handler for :c:macro:`!SIGINT` raises the
       :exc:`KeyboardInterrupt` exception.
 
 
@@ -578,7 +579,7 @@ Signal Handling
       single: SIGINT
       single: KeyboardInterrupt (built-in exception)
 
-   Simulate the effect of a :const:`SIGINT` signal arriving.
+   Simulate the effect of a :c:macro:`!SIGINT` signal arriving.
    This is equivalent to ``PyErr_SetInterruptEx(SIGINT)``.
 
    .. note::
@@ -602,7 +603,7 @@ Signal Handling
    to interrupt an operation).
 
    If the given signal isn't handled by Python (it was set to
-   :data:`signal.SIG_DFL` or :data:`signal.SIG_IGN`), it will be ignored.
+   :py:const:`signal.SIG_DFL` or :py:const:`signal.SIG_IGN`), it will be ignored.
 
    If *signum* is outside of the allowed range of signal numbers, ``-1``
    is returned.  Otherwise, ``0`` is returned.  The error indicator is
@@ -690,7 +691,7 @@ Exception Objects
 
 .. c:function:: PyObject* PyException_GetCause(PyObject *ex)
 
-   Return the cause (either an exception instance, or :const:`None`,
+   Return the cause (either an exception instance, or ``None``,
    set by ``raise ... from ...``) associated with the exception as a new
    reference, as accessible from Python through :attr:`__cause__`.
 
@@ -699,7 +700,7 @@ Exception Objects
 
    Set the cause associated with the exception to *cause*.  Use ``NULL`` to clear
    it.  There is no type check to make sure that *cause* is either an exception
-   instance or :const:`None`.  This steals a reference to *cause*.
+   instance or ``None``.  This steals a reference to *cause*.
 
    :attr:`__suppress_context__` is implicitly set to ``True`` by this function.
 
@@ -788,7 +789,7 @@ because the :ref:`call protocol <call>`
 
    Marks a point where a recursive C-level call is about to be performed.
 
-   If :const:`USE_STACKCHECK` is defined, this function checks if the OS
+   If :c:macro:`USE_STACKCHECK` is defined, this function checks if the OS
    stack overflowed using :c:func:`PyOS_CheckStack`.  In this is the case, it
    sets a :exc:`MemoryError` and returns a nonzero value.
 
--- a/Doc/c-api/file.rst
+++ b/Doc/c-api/file.rst
@@ -93,7 +93,7 @@ the :mod:`io` APIs instead.
    .. index:: single: Py_PRINT_RAW
 
    Write object *obj* to file object *p*.  The only supported flag for *flags* is
-   :const:`Py_PRINT_RAW`; if given, the :func:`str` of the object is written
+   :c:macro:`Py_PRINT_RAW`; if given, the :func:`str` of the object is written
    instead of the :func:`repr`.  Return ``0`` on success or ``-1`` on failure; the
    appropriate exception will be set.
 
--- a/Doc/c-api/float.rst
+++ b/Doc/c-api/float.rst
@@ -3,7 +3,7 @@
 .. _floatobjects:
 
 Floating Point Objects
-----------------------
+======================
 
 .. index:: pair: object; floating point
 
@@ -45,14 +45,14 @@ Floating Point Objects
 .. c:function:: double PyFloat_AsDouble(PyObject *pyfloat)
 
    Return a C :c:expr:`double` representation of the contents of *pyfloat*.  If
-   *pyfloat* is not a Python floating point object but has a :meth:`__float__`
+   *pyfloat* is not a Python floating point object but has a :meth:`~object.__float__`
    method, this method will first be called to convert *pyfloat* into a float.
-   If ``__float__()`` is not defined then it falls back to :meth:`__index__`.
+   If :meth:`!__float__` is not defined then it falls back to :meth:`~object.__index__`.
    This method returns ``-1.0`` upon failure, so one should call
    :c:func:`PyErr_Occurred` to check for errors.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
 
 .. c:function:: double PyFloat_AS_DOUBLE(PyObject *pyfloat)
@@ -79,7 +79,7 @@ Floating Point Objects
 
 
 Pack and Unpack functions
-=========================
+-------------------------
 
 The pack and unpack functions provide an efficient platform-independent way to
 store floating-point values as byte strings. The Pack routines produce a bytes
@@ -104,12 +104,12 @@ happens in such cases is partly accident
 .. versionadded:: 3.11
 
 Pack functions
---------------
+^^^^^^^^^^^^^^
 
 The pack routines write 2, 4 or 8 bytes, starting at *p*. *le* is an
 :c:expr:`int` argument, non-zero if you want the bytes string in little-endian
 format (exponent last, at ``p+1``, ``p+3``, or ``p+6`` ``p+7``), zero if you
-want big-endian format (exponent first, at *p*). The :c:data:`PY_BIG_ENDIAN`
+want big-endian format (exponent first, at *p*). The :c:macro:`PY_BIG_ENDIAN`
 constant can be used to use the native endian: it is equal to ``1`` on big
 endian processor, or ``0`` on little endian processor.
 
@@ -135,12 +135,12 @@ There are two problems on non-IEEE platf
 
 
 Unpack functions
-----------------
+^^^^^^^^^^^^^^^^
 
 The unpack routines read 2, 4 or 8 bytes, starting at *p*.  *le* is an
 :c:expr:`int` argument, non-zero if the bytes string is in little-endian format
 (exponent last, at ``p+1``, ``p+3`` or ``p+6`` and ``p+7``), zero if big-endian
-(exponent first, at *p*). The :c:data:`PY_BIG_ENDIAN` constant can be used to
+(exponent first, at *p*). The :c:macro:`PY_BIG_ENDIAN` constant can be used to
 use the native endian: it is equal to ``1`` on big endian processor, or ``0``
 on little endian processor.
 
--- a/Doc/c-api/gcsupport.rst
+++ b/Doc/c-api/gcsupport.rst
@@ -13,22 +13,20 @@ or strings), do not need to provide any
 collection.
 
 To create a container type, the :c:member:`~PyTypeObject.tp_flags` field of the type object must
-include the :const:`Py_TPFLAGS_HAVE_GC` and provide an implementation of the
+include the :c:macro:`Py_TPFLAGS_HAVE_GC` and provide an implementation of the
 :c:member:`~PyTypeObject.tp_traverse` handler.  If instances of the type are mutable, a
 :c:member:`~PyTypeObject.tp_clear` implementation must also be provided.
 
 
-.. data:: Py_TPFLAGS_HAVE_GC
-   :noindex:
-
+:c:macro:`Py_TPFLAGS_HAVE_GC`
    Objects with a type with this flag set must conform with the rules
    documented here.  For convenience these objects will be referred to as
    container objects.
 
 Constructors for container types must conform to two rules:
 
-#. The memory for the object must be allocated using :c:func:`PyObject_GC_New`
-   or :c:func:`PyObject_GC_NewVar`.
+#. The memory for the object must be allocated using :c:macro:`PyObject_GC_New`
+   or :c:macro:`PyObject_GC_NewVar`.
 
 #. Once all the fields which may contain references to other containers are
    initialized, it must call :c:func:`PyObject_GC_Track`.
@@ -52,23 +50,23 @@ rules:
       :c:member:`~PyTypeObject.tp_flags`, :c:member:`~PyTypeObject.tp_traverse`
       and :c:member:`~PyTypeObject.tp_clear` fields if the type inherits from a
       class that implements the garbage collector protocol and the child class
-      does *not* include the :const:`Py_TPFLAGS_HAVE_GC` flag.
+      does *not* include the :c:macro:`Py_TPFLAGS_HAVE_GC` flag.
 
-.. c:function:: TYPE* PyObject_GC_New(TYPE, PyTypeObject *type)
+.. c:macro:: PyObject_GC_New(TYPE, typeobj)
 
-   Analogous to :c:func:`PyObject_New` but for container objects with the
-   :const:`Py_TPFLAGS_HAVE_GC` flag set.
+   Analogous to :c:macro:`PyObject_New` but for container objects with the
+   :c:macro:`Py_TPFLAGS_HAVE_GC` flag set.
 
 
-.. c:function:: TYPE* PyObject_GC_NewVar(TYPE, PyTypeObject *type, Py_ssize_t size)
+.. c:macro:: PyObject_GC_NewVar(TYPE, typeobj, size)
 
-   Analogous to :c:func:`PyObject_NewVar` but for container objects with the
-   :const:`Py_TPFLAGS_HAVE_GC` flag set.
+   Analogous to :c:macro:`PyObject_NewVar` but for container objects with the
+   :c:macro:`Py_TPFLAGS_HAVE_GC` flag set.
 
 
 .. c:function:: TYPE* PyObject_GC_Resize(TYPE, PyVarObject *op, Py_ssize_t newsize)
 
-   Resize an object allocated by :c:func:`PyObject_NewVar`.  Returns the
+   Resize an object allocated by :c:macro:`PyObject_NewVar`.  Returns the
    resized object or ``NULL`` on failure.  *op* must not be tracked by the collector yet.
 
 
@@ -111,8 +109,8 @@ rules:
 
 .. c:function:: void PyObject_GC_Del(void *op)
 
-   Releases memory allocated to an object using :c:func:`PyObject_GC_New` or
-   :c:func:`PyObject_GC_NewVar`.
+   Releases memory allocated to an object using :c:macro:`PyObject_GC_New` or
+   :c:macro:`PyObject_GC_NewVar`.
 
 
 .. c:function:: void PyObject_GC_UnTrack(void *op)
@@ -126,7 +124,7 @@ rules:
 
 .. versionchanged:: 3.8
 
-   The :c:func:`_PyObject_GC_TRACK` and :c:func:`_PyObject_GC_UNTRACK` macros
+   The :c:func:`!_PyObject_GC_TRACK` and :c:func:`!_PyObject_GC_UNTRACK` macros
    have been removed from the public C API.
 
 The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function parameter of this type:
--- a/Doc/c-api/import.rst
+++ b/Doc/c-api/import.rst
@@ -126,19 +126,19 @@ Importing Modules
    read from a Python bytecode file or obtained from the built-in function
    :func:`compile`, load the module.  Return a new reference to the module object,
    or ``NULL`` with an exception set if an error occurred.  *name*
-   is removed from :attr:`sys.modules` in error cases, even if *name* was already
-   in :attr:`sys.modules` on entry to :c:func:`PyImport_ExecCodeModule`.  Leaving
-   incompletely initialized modules in :attr:`sys.modules` is dangerous, as imports of
+   is removed from :data:`sys.modules` in error cases, even if *name* was already
+   in :data:`sys.modules` on entry to :c:func:`PyImport_ExecCodeModule`.  Leaving
+   incompletely initialized modules in :data:`sys.modules` is dangerous, as imports of
    such modules have no way to know that the module object is an unknown (and
    probably damaged with respect to the module author's intents) state.
 
    The module's :attr:`__spec__` and :attr:`__loader__` will be set, if
    not set already, with the appropriate values.  The spec's loader will
    be set to the module's ``__loader__`` (if set) and to an instance of
-   :class:`SourceFileLoader` otherwise.
+   :class:`~importlib.machinery.SourceFileLoader` otherwise.
 
    The module's :attr:`__file__` attribute will be set to the code object's
-   :c:member:`co_filename`.  If applicable, :attr:`__cached__` will also
+   :attr:`!co_filename`.  If applicable, :attr:`__cached__` will also
    be set.
 
    This function will reload the module if it was already imported.  See
@@ -214,7 +214,7 @@ Importing Modules
 
 .. c:function:: PyObject* PyImport_GetImporter(PyObject *path)
 
-   Return a finder object for a :data:`sys.path`/:attr:`pkg.__path__` item
+   Return a finder object for a :data:`sys.path`/:attr:`!pkg.__path__` item
    *path*, possibly by fetching it from the :data:`sys.path_importer_cache`
    dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook
    is found that can handle the path item.  Return ``None`` if no hook could;
@@ -283,23 +283,25 @@ Importing Modules
 
 .. c:struct:: _inittab
 
-   Structure describing a single entry in the list of built-in modules.  Each of
-   these structures gives the name and initialization function for a module built
-   into the interpreter.  The name is an ASCII encoded string.  Programs which
+   Structure describing a single entry in the list of built-in modules.
+   Programs which
    embed Python may use an array of these structures in conjunction with
    :c:func:`PyImport_ExtendInittab` to provide additional built-in modules.
-   The structure is defined in :file:`Include/import.h` as::
+   The structure consists of two members:
 
-      struct _inittab {
-          const char *name;           /* ASCII encoded string */
-          PyObject* (*initfunc)(void);
-      };
+   .. c:member:: const char *name
+
+      The module name, as an ASCII encoded string.
+
+   .. c: member:: PyObject* (*initfunc)(void)
+
+      Initialization function for a module built into the interpreter.
 
 
 .. c:function:: int PyImport_ExtendInittab(struct _inittab *newtab)
 
    Add a collection of modules to the table of built-in modules.  The *newtab*
-   array must end with a sentinel entry which contains ``NULL`` for the :attr:`name`
+   array must end with a sentinel entry which contains ``NULL`` for the :c:member:`~_inittab.name`
    field; failure to provide the sentinel value can result in a memory fault.
    Returns ``0`` on success or ``-1`` if insufficient memory could be allocated to
    extend the internal table.  In the event of failure, no modules are added to the
--- a/Doc/c-api/init.rst
+++ b/Doc/c-api/init.rst
@@ -25,7 +25,7 @@ The following functions can be safely ca
 
   * :c:func:`PyImport_AppendInittab`
   * :c:func:`PyImport_ExtendInittab`
-  * :c:func:`PyInitFrozenExtensions`
+  * :c:func:`!PyInitFrozenExtensions`
   * :c:func:`PyMem_SetAllocator`
   * :c:func:`PyMem_SetupDebugHooks`
   * :c:func:`PyObject_SetArenaAllocator`
@@ -122,7 +122,7 @@ to 1 and ``-bb`` sets :c:data:`Py_BytesW
 
 .. c:var:: int Py_IgnoreEnvironmentFlag
 
-   Ignore all :envvar:`PYTHON*` environment variables, e.g.
+   Ignore all :envvar:`!PYTHON*` environment variables, e.g.
    :envvar:`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set.
 
    Set by the :option:`-E` and :option:`-I` options.
@@ -165,7 +165,7 @@ to 1 and ``-bb`` sets :c:data:`Py_BytesW
 .. c:var:: int Py_LegacyWindowsStdioFlag
 
    If the flag is non-zero, use :class:`io.FileIO` instead of
-   :class:`WindowsConsoleIO` for :mod:`sys` standard streams.
+   :class:`!io._WindowsConsoleIO` for :mod:`sys` standard streams.
 
    Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment
    variable is set to a non-empty string.
@@ -292,7 +292,7 @@ Initializing and finalizing the interpre
    the application.
 
    **Bugs and caveats:** The destruction of modules and objects in modules is done
-   in random order; this may cause destructors (:meth:`__del__` methods) to fail
+   in random order; this may cause destructors (:meth:`~object.__del__` methods) to fail
    when they depend on other objects (even functions) or modules.  Dynamically
    loaded extension modules loaded by Python are not unloaded.  Small amounts of
    memory allocated by the Python interpreter may not be freed (if you find a leak,
@@ -381,7 +381,7 @@ Process-wide parameters
    .. deprecated:: 3.11
 
 
-.. c:function:: wchar* Py_GetProgramName()
+.. c:function:: wchar_t* Py_GetProgramName()
 
    .. index:: single: Py_SetProgramName()
 
@@ -872,7 +872,7 @@ the fork, and releasing them afterwards.
 :ref:`lock-objects` in the child. When extending or embedding Python, there
 is no way to inform Python of additional (non-Python) locks that need to be
 acquired before or reset after a fork. OS facilities such as
-:c:func:`pthread_atfork` would need to be used to accomplish the same thing.
+:c:func:`!pthread_atfork` would need to be used to accomplish the same thing.
 Additionally, when extending or embedding Python, calling :c:func:`fork`
 directly rather than through :func:`os.fork` (and returning to or calling
 into Python) may result in a deadlock by one of Python's internal locks
@@ -914,8 +914,11 @@ code, or when embedding the Python inter
 .. c:type:: PyThreadState
 
    This data structure represents the state of a single thread.  The only public
-   data member is :attr:`interp` (:c:expr:`PyInterpreterState *`), which points to
-   this thread's interpreter state.
+   data member is:
+
+   .. c:member:: PyInterpreterState *interp
+
+      This thread's interpreter state.
 
 
 .. c:function:: void PyEval_InitThreads()
@@ -975,7 +978,7 @@ code, or when embedding the Python inter
    .. note::
       Calling this function from a thread when the runtime is finalizing
       will terminate the thread, even if the thread was not created by Python.
-      You can use :c:func:`_Py_IsFinalizing` or :func:`sys.is_finalizing` to
+      You can use :c:func:`!_Py_IsFinalizing` or :func:`sys.is_finalizing` to
       check if the interpreter is in process of being finalized before calling
       this function to avoid unwanted termination.
 
@@ -1021,7 +1024,7 @@ with sub-interpreters:
    .. note::
       Calling this function from a thread when the runtime is finalizing
       will terminate the thread, even if the thread was not created by Python.
-      You can use :c:func:`_Py_IsFinalizing` or :func:`sys.is_finalizing` to
+      You can use :c:func:`!_Py_IsFinalizing` or :func:`sys.is_finalizing` to
       check if the interpreter is in process of being finalized before calling
       this function to avoid unwanted termination.
 
@@ -1287,7 +1290,7 @@ All of the following functions must be c
    function does not steal any references to *exc*. To prevent naive misuse, you
    must write your own C extension to call this.  Must be called with the GIL held.
    Returns the number of thread states modified; this is normally one, but will be
-   zero if the thread id isn't found.  If *exc* is :const:`NULL`, the pending
+   zero if the thread id isn't found.  If *exc* is ``NULL``, the pending
    exception (if any) for the thread is cleared. This raises no exceptions.
 
    .. versionchanged:: 3.7
@@ -1303,7 +1306,7 @@ All of the following functions must be c
    .. note::
       Calling this function from a thread when the runtime is finalizing
       will terminate the thread, even if the thread was not created by Python.
-      You can use :c:func:`_Py_IsFinalizing` or :func:`sys.is_finalizing` to
+      You can use :c:func:`!_Py_IsFinalizing` or :func:`sys.is_finalizing` to
       check if the interpreter is in process of being finalized before calling
       this function to avoid unwanted termination.
 
@@ -1566,32 +1569,32 @@ Python-level trace functions in previous
    The type of the trace function registered using :c:func:`PyEval_SetProfile` and
    :c:func:`PyEval_SetTrace`. The first parameter is the object passed to the
    registration function as *obj*, *frame* is the frame object to which the event
-   pertains, *what* is one of the constants :const:`PyTrace_CALL`,
-   :const:`PyTrace_EXCEPTION`, :const:`PyTrace_LINE`, :const:`PyTrace_RETURN`,
-   :const:`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION`, :const:`PyTrace_C_RETURN`,
-   or :const:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:
-
-   +------------------------------+----------------------------------------+
-   | Value of *what*              | Meaning of *arg*                       |
-   +==============================+========================================+
-   | :const:`PyTrace_CALL`        | Always :c:data:`Py_None`.              |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_EXCEPTION`   | Exception information as returned by   |
-   |                              | :func:`sys.exc_info`.                  |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_LINE`        | Always :c:data:`Py_None`.              |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_RETURN`      | Value being returned to the caller,    |
-   |                              | or ``NULL`` if caused by an exception. |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_C_CALL`      | Function object being called.          |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_C_EXCEPTION` | Function object being called.          |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_C_RETURN`    | Function object being called.          |
-   +------------------------------+----------------------------------------+
-   | :const:`PyTrace_OPCODE`      | Always :c:data:`Py_None`.              |
-   +------------------------------+----------------------------------------+
+   pertains, *what* is one of the constants :c:data:`PyTrace_CALL`,
+   :c:data:`PyTrace_EXCEPTION`, :c:data:`PyTrace_LINE`, :c:data:`PyTrace_RETURN`,
+   :c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION`, :c:data:`PyTrace_C_RETURN`,
+   or :c:data:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:
+
+   +-------------------------------+----------------------------------------+
+   | Value of *what*               | Meaning of *arg*                       |
+   +===============================+========================================+
+   | :c:data:`PyTrace_CALL`        | Always :c:data:`Py_None`.              |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_EXCEPTION`   | Exception information as returned by   |
+   |                               | :func:`sys.exc_info`.                  |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_LINE`        | Always :c:data:`Py_None`.              |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_RETURN`      | Value being returned to the caller,    |
+   |                               | or ``NULL`` if caused by an exception. |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_C_CALL`      | Function object being called.          |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_C_EXCEPTION` | Function object being called.          |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_C_RETURN`    | Function object being called.          |
+   +-------------------------------+----------------------------------------+
+   | :c:data:`PyTrace_OPCODE`      | Always :c:data:`Py_None`.              |
+   +-------------------------------+----------------------------------------+
 
 .. c:var:: int PyTrace_CALL
 
@@ -1658,8 +1661,8 @@ Python-level trace functions in previous
    function as its first parameter, and may be any Python object, or ``NULL``.  If
    the profile function needs to maintain state, using a different value for *obj*
    for each thread provides a convenient and thread-safe place to store it.  The
-   profile function is called for all monitored events except :const:`PyTrace_LINE`
-   :const:`PyTrace_OPCODE` and :const:`PyTrace_EXCEPTION`.
+   profile function is called for all monitored events except :c:data:`PyTrace_LINE`
+   :c:data:`PyTrace_OPCODE` and :c:data:`PyTrace_EXCEPTION`.
 
    See also the :func:`sys.setprofile` function.
 
@@ -1672,8 +1675,8 @@ Python-level trace functions in previous
    :c:func:`PyEval_SetProfile`, except the tracing function does receive line-number
    events and per-opcode events, but does not receive any event related to C function
    objects being called.  Any trace function registered using :c:func:`PyEval_SetTrace`
-   will not receive :const:`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION` or
-   :const:`PyTrace_C_RETURN` as a value for the *what* parameter.
+   will not receive :c:data:`PyTrace_C_CALL`, :c:data:`PyTrace_C_EXCEPTION` or
+   :c:data:`PyTrace_C_RETURN` as a value for the *what* parameter.
 
    See also the :func:`sys.settrace` function.
 
--- a/Doc/c-api/init_config.rst
+++ b/Doc/c-api/init_config.rst
@@ -135,6 +135,8 @@ PyStatus
 
       Name of the function which created an error, can be ``NULL``.
 
+   .. c:namespace:: NULL
+
    Functions to create a status:
 
    .. c:function:: PyStatus PyStatus_Ok(void)
@@ -210,6 +212,8 @@ PyPreConfig
 
    Structure used to preinitialize Python.
 
+   .. c:namespace:: NULL
+
    Function to initialize a preconfiguration:
 
    .. c:function:: void PyPreConfig_InitPythonConfig(PyPreConfig *preconfig)
@@ -222,6 +226,8 @@ PyPreConfig
       Initialize the preconfiguration with :ref:`Isolated Configuration
       <init-isolated-conf>`.
 
+   .. c:namespace:: PyPreConfig
+
    Structure fields:
 
    .. c:member:: int allocator
@@ -429,6 +435,8 @@ PyConfig
    When done, the :c:func:`PyConfig_Clear` function must be used to release the
    configuration memory.
 
+   .. c:namespace:: NULL
+
    Structure methods:
 
    .. c:function:: void PyConfig_InitPythonConfig(PyConfig *config)
@@ -522,11 +530,13 @@ PyConfig
    Moreover, if :c:func:`PyConfig_SetArgv` or :c:func:`PyConfig_SetBytesArgv`
    is used, this method must be called before other methods, since the
    preinitialization configuration depends on command line arguments (if
-   :c:member:`parse_argv` is non-zero).
+   :c:member:`~PyConfig.parse_argv` is non-zero).
 
    The caller of these methods is responsible to handle exceptions (error or
    exit) using ``PyStatus_Exception()`` and ``Py_ExitStatusException()``.
 
+   .. c:namespace:: PyConfig
+
    Structure fields:
 
    .. c:member:: PyWideStringList argv
@@ -850,7 +860,7 @@ PyConfig
    .. c:member:: int legacy_windows_stdio
 
       If non-zero, use :class:`io.FileIO` instead of
-      :class:`io.WindowsConsoleIO` for :data:`sys.stdin`, :data:`sys.stdout`
+      :class:`!io._WindowsConsoleIO` for :data:`sys.stdin`, :data:`sys.stdout`
       and :data:`sys.stderr`.
 
       Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment
@@ -899,7 +909,7 @@ PyConfig
    .. c:member:: wchar_t* pythonpath_env
 
       Module search paths (:data:`sys.path`) as a string separated by ``DELIM``
-      (:data:`os.path.pathsep`).
+      (:data:`os.pathsep`).
 
       Set by the :envvar:`PYTHONPATH` environment variable.
 
@@ -1096,7 +1106,7 @@ PyConfig
 
       Set to ``0`` by the :option:`-S` command line option.
 
-      :data:`sys.flags.no_site` is set to the inverted value of
+      :data:`sys.flags.no_site <sys.flags>` is set to the inverted value of
       :c:member:`~PyConfig.site_import`.
 
       Default: ``1``.
--- a/Doc/c-api/intro.rst
+++ b/Doc/c-api/intro.rst
@@ -287,52 +287,58 @@ true if (and only if) the object pointed
 Reference Counts
 ----------------
 
-The reference count is important because today's computers have a  finite (and
-often severely limited) memory size; it counts how many  different places there
-are that have a reference to an object.  Such a  place could be another object,
-or a global (or static) C variable, or  a local variable in some C function.
-When an object's reference count  becomes zero, the object is deallocated.  If
-it contains references to  other objects, their reference count is decremented.
-Those other  objects may be deallocated in turn, if this decrement makes their
-reference count become zero, and so on.  (There's an obvious problem  with
-objects that reference each other here; for now, the solution is  "don't do
-that.")
+The reference count is important because today's computers have a  finite
+(and often severely limited) memory size; it counts how many different
+places there are that have a :term:`strong reference` to an object.
+Such a place could be another object, or a global (or static) C variable,
+or a local variable in some C function.
+When the last :term:`strong reference` to an object is released
+(i.e. its reference count becomes zero), the object is deallocated.
+If it contains references to other objects, those references are released.
+Those other objects may be deallocated in turn, if there are no more
+references to them, and so on.  (There's an obvious problem  with
+objects that reference each other here; for now, the solution
+is "don't do that.")
 
 .. index::
    single: Py_INCREF()
    single: Py_DECREF()
 
-Reference counts are always manipulated explicitly.  The normal way is  to use
-the macro :c:func:`Py_INCREF` to increment an object's reference count by one,
-and :c:func:`Py_DECREF` to decrement it by   one.  The :c:func:`Py_DECREF` macro
+Reference counts are always manipulated explicitly.  The normal way is
+to use the macro :c:func:`Py_INCREF` to take a new reference to an
+object (i.e. increment its reference count by one),
+and :c:func:`Py_DECREF` to release that reference (i.e. decrement the
+reference count by one).  The :c:func:`Py_DECREF` macro
 is considerably more complex than the incref one, since it must check whether
 the reference count becomes zero and then cause the object's deallocator to be
-called. The deallocator is a function pointer contained in the object's type
-structure.  The type-specific deallocator takes care of decrementing the
-reference counts for other objects contained in the object if this is a compound
+called.  The deallocator is a function pointer contained in the object's type
+structure.  The type-specific deallocator takes care of releasing references
+for other objects contained in the object if this is a compound
 object type, such as a list, as well as performing any additional finalization
 that's needed.  There's no chance that the reference count can overflow; at
 least as many bits are used to hold the reference count as there are distinct
 memory locations in virtual memory (assuming ``sizeof(Py_ssize_t) >= sizeof(void*)``).
 Thus, the reference count increment is a simple operation.
 
-It is not necessary to increment an object's reference count for every  local
-variable that contains a pointer to an object.  In theory, the  object's
+It is not necessary to hold a :term:`strong reference` (i.e. increment
+the reference count) for every local variable that contains a pointer
+to an object.  In theory, the  object's
 reference count goes up by one when the variable is made to  point to it and it
 goes down by one when the variable goes out of  scope.  However, these two
 cancel each other out, so at the end the  reference count hasn't changed.  The
 only real reason to use the  reference count is to prevent the object from being
 deallocated as  long as our variable is pointing to it.  If we know that there
 is at  least one other reference to the object that lives at least as long as
-our variable, there is no need to increment the reference count  temporarily.
+our variable, there is no need to take a new :term:`strong reference`
+(i.e. increment the reference count) temporarily.
 An important situation where this arises is in objects  that are passed as
 arguments to C functions in an extension module  that are called from Python;
 the call mechanism guarantees to hold a  reference to every argument for the
 duration of the call.
 
 However, a common pitfall is to extract an object from a list and hold on to it
-for a while without incrementing its reference count. Some other operation might
-conceivably remove the object from the list, decrementing its reference count
+for a while without taking a new reference.  Some other operation might
+conceivably remove the object from the list, releasing that reference,
 and possibly deallocating it. The real danger is that innocent-looking
 operations may invoke arbitrary Python code which could do this; there is a code
 path which allows control to flow back to the user from a :c:func:`Py_DECREF`, so
@@ -340,7 +346,8 @@ almost any operation is potentially dang
 
 A safe approach is to always use the generic operations (functions  whose name
 begins with ``PyObject_``, ``PyNumber_``, ``PySequence_`` or ``PyMapping_``).
-These operations always increment the reference count of the object they return.
+These operations always create a new :term:`strong reference`
+(i.e. increment the reference count) of the object they return.
 This leaves the caller with the responsibility to call :c:func:`Py_DECREF` when
 they are done with the result; this soon becomes second nature.
 
@@ -356,7 +363,7 @@ to objects (objects are not owned: they
 reference" means being responsible for calling Py_DECREF on it when the
 reference is no longer needed.  Ownership can also be transferred, meaning that
 the code that receives ownership of the reference then becomes responsible for
-eventually decref'ing it by calling :c:func:`Py_DECREF` or :c:func:`Py_XDECREF`
+eventually releasing it by calling :c:func:`Py_DECREF` or :c:func:`Py_XDECREF`
 when it's no longer needed---or passing on this responsibility (usually to its
 caller). When a function passes ownership of a reference on to its caller, the
 caller is said to receive a *new* reference.  When no ownership is transferred,
@@ -414,9 +421,9 @@ For example, the above two blocks of cod
 
 It is much more common to use :c:func:`PyObject_SetItem` and friends with items
 whose references you are only borrowing, like arguments that were passed in to
-the function you are writing.  In that case, their behaviour regarding reference
-counts is much saner, since you don't have to increment a reference count so you
-can give a reference away ("have it be stolen").  For example, this function
+the function you are writing.  In that case, their behaviour regarding references
+is much saner, since you don't have to take a new reference just so you
+can give that reference away ("have it be stolen").  For example, this function
 sets all items of a list (actually, any mutable sequence) to a given item::
 
    int
@@ -616,7 +623,7 @@ and lose important information about the
 .. index:: single: sum_sequence()
 
 A simple example of detecting exceptions and passing them on is shown in the
-:c:func:`sum_sequence` example above.  It so happens that this example doesn't
+:c:func:`!sum_sequence` example above.  It so happens that this example doesn't
 need to clean up any owned references when it detects an error.  The following
 example function shows some error cleanup.  First, to remind you why you like
 Python, we show the equivalent Python code::
--- a/Doc/c-api/iterator.rst
+++ b/Doc/c-api/iterator.rst
@@ -6,7 +6,7 @@ Iterator Objects
 ----------------
 
 Python provides two general-purpose iterator objects.  The first, a sequence
-iterator, works with an arbitrary sequence supporting the :meth:`__getitem__`
+iterator, works with an arbitrary sequence supporting the :meth:`~object.__getitem__`
 method.  The second works with a callable object and a sentinel value, calling
 the callable for each item in the sequence, and ending the iteration when the
 sentinel value is returned.
@@ -19,7 +19,7 @@ sentinel value is returned.
    types.
 
 
-.. c:function:: int PySeqIter_Check(op)
+.. c:function:: int PySeqIter_Check(PyObject *op)
 
    Return true if the type of *op* is :c:data:`PySeqIter_Type`.  This function
    always succeeds.
@@ -38,7 +38,7 @@ sentinel value is returned.
    two-argument form of the :func:`iter` built-in function.
 
 
-.. c:function:: int PyCallIter_Check(op)
+.. c:function:: int PyCallIter_Check(PyObject *op)
 
    Return true if the type of *op* is :c:data:`PyCallIter_Type`.  This
    function always succeeds.
--- a/Doc/c-api/long.rst
+++ b/Doc/c-api/long.rst
@@ -120,7 +120,7 @@ distinguished from a number.  Use :c:fun
       single: OverflowError (built-in exception)
 
    Return a C :c:expr:`long` representation of *obj*.  If *obj* is not an
-   instance of :c:type:`PyLongObject`, first call its :meth:`__index__` method
+   instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__` method
    (if present) to convert it to a :c:type:`PyLongObject`.
 
    Raise :exc:`OverflowError` if the value of *obj* is out of range for a
@@ -129,30 +129,30 @@ distinguished from a number.  Use :c:fun
    Returns ``-1`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
    .. versionchanged:: 3.10
-      This function will no longer use :meth:`__int__`.
+      This function will no longer use :meth:`~object.__int__`.
 
 
 .. c:function:: long PyLong_AsLongAndOverflow(PyObject *obj, int *overflow)
 
    Return a C :c:expr:`long` representation of *obj*.  If *obj* is not an
-   instance of :c:type:`PyLongObject`, first call its :meth:`__index__`
+   instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__`
    method (if present) to convert it to a :c:type:`PyLongObject`.
 
-   If the value of *obj* is greater than :const:`LONG_MAX` or less than
-   :const:`LONG_MIN`, set *\*overflow* to ``1`` or ``-1``, respectively, and
+   If the value of *obj* is greater than :c:macro:`LONG_MAX` or less than
+   :c:macro:`LONG_MIN`, set *\*overflow* to ``1`` or ``-1``, respectively, and
    return ``-1``; otherwise, set *\*overflow* to ``0``.  If any other exception
    occurs set *\*overflow* to ``0`` and return ``-1`` as usual.
 
    Returns ``-1`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
    .. versionchanged:: 3.10
-      This function will no longer use :meth:`__int__`.
+      This function will no longer use :meth:`~object.__int__`.
 
 
 .. c:function:: long long PyLong_AsLongLong(PyObject *obj)
@@ -161,7 +161,7 @@ distinguished from a number.  Use :c:fun
       single: OverflowError (built-in exception)
 
    Return a C :c:expr:`long long` representation of *obj*.  If *obj* is not an
-   instance of :c:type:`PyLongObject`, first call its :meth:`__index__` method
+   instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__` method
    (if present) to convert it to a :c:type:`PyLongObject`.
 
    Raise :exc:`OverflowError` if the value of *obj* is out of range for a
@@ -170,20 +170,20 @@ distinguished from a number.  Use :c:fun
    Returns ``-1`` on error.  Use :c:func:`PyErr_Occurred` to disambiguate.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
    .. versionchanged:: 3.10
-      This function will no longer use :meth:`__int__`.
+      This function will no longer use :meth:`~object.__int__`.
 
 
 .. c:function:: long long PyLong_AsLongLongAndOverflow(PyObject *obj, int *overflow)
 
    Return a C :c:expr:`long long` representation of *obj*.  If *obj* is not an
-   instance of :c:type:`PyLongObject`, first call its :meth:`__index__` method
+   instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__` method
    (if present) to convert it to a :c:type:`PyLongObject`.
 
-   If the value of *obj* is greater than :const:`LLONG_MAX` or less than
-   :const:`LLONG_MIN`, set *\*overflow* to ``1`` or ``-1``, respectively,
+   If the value of *obj* is greater than :c:macro:`LLONG_MAX` or less than
+   :c:macro:`LLONG_MIN`, set *\*overflow* to ``1`` or ``-1``, respectively,
    and return ``-1``; otherwise, set *\*overflow* to ``0``.  If any other
    exception occurs set *\*overflow* to ``0`` and return ``-1`` as usual.
 
@@ -192,10 +192,10 @@ distinguished from a number.  Use :c:fun
    .. versionadded:: 3.2
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
    .. versionchanged:: 3.10
-      This function will no longer use :meth:`__int__`.
+      This function will no longer use :meth:`~object.__int__`.
 
 
 .. c:function:: Py_ssize_t PyLong_AsSsize_t(PyObject *pylong)
@@ -266,7 +266,7 @@ distinguished from a number.  Use :c:fun
 .. c:function:: unsigned long PyLong_AsUnsignedLongMask(PyObject *obj)
 
    Return a C :c:expr:`unsigned long` representation of *obj*.  If *obj* is not
-   an instance of :c:type:`PyLongObject`, first call its :meth:`__index__`
+   an instance of :c:type:`PyLongObject`, first call its :meth:`~object.__index__`
    method (if present) to convert it to a :c:type:`PyLongObject`.
 
    If the value of *obj* is out of range for an :c:expr:`unsigned long`,
@@ -276,17 +276,17 @@ distinguished from a number.  Use :c:fun
    disambiguate.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
    .. versionchanged:: 3.10
-      This function will no longer use :meth:`__int__`.
+      This function will no longer use :meth:`~object.__int__`.
 
 
 .. c:function:: unsigned long long PyLong_AsUnsignedLongLongMask(PyObject *obj)
 
    Return a C :c:expr:`unsigned long long` representation of *obj*.  If *obj*
    is not an instance of :c:type:`PyLongObject`, first call its
-   :meth:`__index__` method (if present) to convert it to a
+   :meth:`~object.__index__` method (if present) to convert it to a
    :c:type:`PyLongObject`.
 
    If the value of *obj* is out of range for an :c:expr:`unsigned long long`,
@@ -296,10 +296,10 @@ distinguished from a number.  Use :c:fun
    to disambiguate.
 
    .. versionchanged:: 3.8
-      Use :meth:`__index__` if available.
+      Use :meth:`~object.__index__` if available.
 
    .. versionchanged:: 3.10
-      This function will no longer use :meth:`__int__`.
+      This function will no longer use :meth:`~object.__int__`.
 
 
 .. c:function:: double PyLong_AsDouble(PyObject *pylong)
--- a/Doc/c-api/mapping.rst
+++ b/Doc/c-api/mapping.rst
@@ -13,7 +13,7 @@ See also :c:func:`PyObject_GetItem`, :c:
 
    Return ``1`` if the object provides the mapping protocol or supports slicing,
    and ``0`` otherwise.  Note that it returns ``1`` for Python classes with
-   a :meth:`__getitem__` method, since in general it is impossible to
+   a :meth:`~object.__getitem__` method, since in general it is impossible to
    determine what type of keys the class supports. This function always succeeds.
 
 
@@ -60,7 +60,7 @@ See also :c:func:`PyObject_GetItem`, :c:
    This is equivalent to the Python expression ``key in o``.
    This function always succeeds.
 
-   Note that exceptions which occur while calling the :meth:`__getitem__`
+   Note that exceptions which occur while calling the :meth:`~object.__getitem__`
    method will get suppressed.
    To get error reporting use :c:func:`PyObject_GetItem()` instead.
 
@@ -71,7 +71,7 @@ See also :c:func:`PyObject_GetItem`, :c:
    This is equivalent to the Python expression ``key in o``.
    This function always succeeds.
 
-   Note that exceptions which occur while calling the :meth:`__getitem__`
+   Note that exceptions which occur while calling the :meth:`~object.__getitem__`
    method and creating a temporary string object will get suppressed.
    To get error reporting use :c:func:`PyMapping_GetItemString()` instead.
 
--- a/Doc/c-api/memory.rst
+++ b/Doc/c-api/memory.rst
@@ -136,7 +136,7 @@ need to be held.
 
 The :ref:`default raw memory allocator <default-memory-allocators>` uses
 the following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc`
-and :c:func:`free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting
+and :c:func:`!free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting
 zero bytes.
 
 .. versionadded:: 3.4
@@ -264,14 +264,14 @@ The following type-oriented macros are p
 *TYPE* refers to any C type.
 
 
-.. c:function:: TYPE* PyMem_New(TYPE, size_t n)
+.. c:macro:: PyMem_New(TYPE, n)
 
    Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes of
    memory.  Returns a pointer cast to :c:expr:`TYPE*`.  The memory will not have
    been initialized in any way.
 
 
-.. c:function:: TYPE* PyMem_Resize(void *p, TYPE, size_t n)
+.. c:macro:: PyMem_Resize(p, TYPE, n)
 
    Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n *
    sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:expr:`TYPE*`. On return,
@@ -423,7 +423,7 @@ Customize Memory Allocators
    +----------------------------------------------------------+---------------------------------------+
 
    .. versionchanged:: 3.5
-      The :c:type:`PyMemAllocator` structure was renamed to
+      The :c:type:`!PyMemAllocator` structure was renamed to
       :c:type:`PyMemAllocatorEx` and a new ``calloc`` field was added.
 
 
@@ -431,6 +431,8 @@ Customize Memory Allocators
 
    Enum used to identify an allocator domain. Domains:
 
+   .. c:namespace:: NULL
+
    .. c:macro:: PYMEM_DOMAIN_RAW
 
       Functions:
@@ -470,7 +472,7 @@ Customize Memory Allocators
    The new allocator must return a distinct non-``NULL`` pointer when requesting
    zero bytes.
 
-   For the :c:data:`PYMEM_DOMAIN_RAW` domain, the allocator must be
+   For the :c:macro:`PYMEM_DOMAIN_RAW` domain, the allocator must be
    thread-safe: the :term:`GIL <global interpreter lock>` is not held when the
    allocator is called.
 
@@ -536,8 +538,8 @@ Runtime checks:
 - Detect write before the start of the buffer (buffer underflow).
 - Detect write after the end of the buffer (buffer overflow).
 - Check that the :term:`GIL <global interpreter lock>` is held when
-  allocator functions of :c:data:`PYMEM_DOMAIN_OBJ` (ex:
-  :c:func:`PyObject_Malloc`) and :c:data:`PYMEM_DOMAIN_MEM` (ex:
+  allocator functions of :c:macro:`PYMEM_DOMAIN_OBJ` (ex:
+  :c:func:`PyObject_Malloc`) and :c:macro:`PYMEM_DOMAIN_MEM` (ex:
   :c:func:`PyMem_Malloc`) domains are called.
 
 On error, the debug hooks use the :mod:`tracemalloc` module to get the
@@ -557,9 +559,9 @@ that the treatment of negative indices d
 ``p[-S]``
     API identifier (ASCII character):
 
-    * ``'r'`` for :c:data:`PYMEM_DOMAIN_RAW`.
-    * ``'m'`` for :c:data:`PYMEM_DOMAIN_MEM`.
-    * ``'o'`` for :c:data:`PYMEM_DOMAIN_OBJ`.
+    * ``'r'`` for :c:macro:`PYMEM_DOMAIN_RAW`.
+    * ``'m'`` for :c:macro:`PYMEM_DOMAIN_MEM`.
+    * ``'o'`` for :c:macro:`PYMEM_DOMAIN_OBJ`.
 
 ``p[-S+1:0]``
     Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads.
@@ -581,7 +583,7 @@ that the treatment of negative indices d
     default).
 
     A serial number, incremented by 1 on each call to a malloc-like or
-    realloc-like function.  Big-endian ``size_t``.  If "bad memory" is detected
+    realloc-like function.  Big-endian :c:type:`size_t`.  If "bad memory" is detected
     later, the serial number gives an excellent way to set a breakpoint on the
     next run, to capture the instant at which this block was passed out.  The
     static function bumpserialno() in obmalloc.c is the only place the serial
@@ -601,7 +603,7 @@ PYMEM_CLEANBYTE (meaning uninitialized m
    compiled in release mode.  On error, the debug hooks now use
    :mod:`tracemalloc` to get the traceback where a memory block was allocated.
    The debug hooks now also check if the GIL is held when functions of
-   :c:data:`PYMEM_DOMAIN_OBJ` and :c:data:`PYMEM_DOMAIN_MEM` domains are
+   :c:macro:`PYMEM_DOMAIN_OBJ` and :c:macro:`PYMEM_DOMAIN_MEM` domains are
    called.
 
 .. versionchanged:: 3.8
@@ -622,13 +624,13 @@ with a fixed size of 256 KiB. It falls b
 :c:func:`PyMem_RawRealloc` for allocations larger than 512 bytes.
 
 *pymalloc* is the :ref:`default allocator <default-memory-allocators>` of the
-:c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and
-:c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains.
+:c:macro:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and
+:c:macro:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains.
 
 The arena allocator uses the following functions:
 
-* :c:func:`VirtualAlloc` and :c:func:`VirtualFree` on Windows,
-* :c:func:`mmap` and :c:func:`munmap` if available,
+* :c:func:`!VirtualAlloc` and :c:func:`!VirtualFree` on Windows,
+* :c:func:`!mmap` and :c:func:`!munmap` if available,
 * :c:func:`malloc` and :c:func:`free` otherwise.
 
 This allocator is disabled if Python is configured with the
@@ -732,8 +734,8 @@ allocators operating on different heaps.
    free(buf1);       /* Fatal -- should be PyMem_Del()  */
 
 In addition to the functions aimed at handling raw memory blocks from the Python
-heap, objects in Python are allocated and released with :c:func:`PyObject_New`,
-:c:func:`PyObject_NewVar` and :c:func:`PyObject_Del`.
+heap, objects in Python are allocated and released with :c:macro:`PyObject_New`,
+:c:macro:`PyObject_NewVar` and :c:func:`PyObject_Del`.
 
 These will be explained in the next chapter on defining and implementing new
 object types in C.
--- a/Doc/c-api/method.rst
+++ b/Doc/c-api/method.rst
@@ -7,8 +7,8 @@ Instance Method Objects
 
 .. index:: pair: object; instancemethod
 
-An instance method is a wrapper for a :c:data:`PyCFunction` and the new way
-to bind a :c:data:`PyCFunction` to a class object. It replaces the former call
+An instance method is a wrapper for a :c:type:`PyCFunction` and the new way
+to bind a :c:type:`PyCFunction` to a class object. It replaces the former call
 ``PyMethod_New(func, NULL, class)``.
 
 
--- a/Doc/c-api/module.rst
+++ b/Doc/c-api/module.rst
@@ -119,7 +119,7 @@ Module Objects
    encoded to 'utf-8'.
 
    .. deprecated:: 3.2
-      :c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on
+      :c:func:`PyModule_GetFilename` raises :exc:`UnicodeEncodeError` on
       unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead.
 
 
@@ -145,7 +145,7 @@ or request "multi-phase initialization"
 
    .. c:member:: PyModuleDef_Base m_base
 
-      Always initialize this member to :const:`PyModuleDef_HEAD_INIT`.
+      Always initialize this member to :c:macro:`PyModuleDef_HEAD_INIT`.
 
    .. c:member:: const char *m_name
 
@@ -164,7 +164,7 @@ or request "multi-phase initialization"
 
       This memory area is allocated based on *m_size* on module creation,
       and freed when the module object is deallocated, after the
-      :c:member:`m_free` function has been called, if present.
+      :c:member:`~PyModuleDef.m_free` function has been called, if present.
 
       Setting ``m_size`` to ``-1`` means that the module does not support
       sub-interpreters, because it has global state.
@@ -202,7 +202,7 @@ or request "multi-phase initialization"
       This function is not called if the module state was requested but is not
       allocated yet. This is the case immediately after the module is created
       and before the module is executed (:c:data:`Py_mod_exec` function). More
-      precisely, this function is not called if :c:member:`m_size` is greater
+      precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is greater
       than 0 and the module state (as returned by :c:func:`PyModule_GetState`)
       is ``NULL``.
 
@@ -217,7 +217,7 @@ or request "multi-phase initialization"
       This function is not called if the module state was requested but is not
       allocated yet. This is the case immediately after the module is created
       and before the module is executed (:c:data:`Py_mod_exec` function). More
-      precisely, this function is not called if :c:member:`m_size` is greater
+      precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is greater
       than 0 and the module state (as returned by :c:func:`PyModule_GetState`)
       is ``NULL``.
 
@@ -238,7 +238,7 @@ or request "multi-phase initialization"
       This function is not called if the module state was requested but is not
       allocated yet. This is the case immediately after the module is created
       and before the module is executed (:c:data:`Py_mod_exec` function). More
-      precisely, this function is not called if :c:member:`m_size` is greater
+      precisely, this function is not called if :c:member:`~PyModuleDef.m_size` is greater
       than 0 and the module state (as returned by :c:func:`PyModule_GetState`)
       is ``NULL``.
 
@@ -256,7 +256,7 @@ of the following two module creation fun
 
    Create a new module object, given the definition in *def*.  This behaves
    like :c:func:`PyModule_Create2` with *module_api_version* set to
-   :const:`PYTHON_API_VERSION`.
+   :c:macro:`PYTHON_API_VERSION`.
 
 
 .. c:function:: PyObject* PyModule_Create2(PyModuleDef *def, int module_api_version)
@@ -282,7 +282,7 @@ An alternate way to specify extensions i
 Extension modules created this way behave more like Python modules: the
 initialization is split between the *creation phase*, when the module object
 is created, and the *execution phase*, when it is populated.
-The distinction is similar to the :py:meth:`__new__` and :py:meth:`__init__` methods
+The distinction is similar to the :py:meth:`!__new__` and :py:meth:`!__init__` methods
 of classes.
 
 Unlike modules created using single-phase initialization, these modules are not
@@ -293,7 +293,7 @@ By default, multiple modules created fro
 independent: changes to one should not affect the others.
 This means that all state should be specific to the module object (using e.g.
 using :c:func:`PyModule_GetState`), or its contents (such as the module's
-:attr:`__dict__` or individual classes created with :c:func:`PyType_FromSpec`).
+:attr:`~object.__dict__` or individual classes created with :c:func:`PyType_FromSpec`).
 
 All modules created using multi-phase initialization are expected to support
 :ref:`sub-interpreters <sub-interpreter-support>`. Making sure multiple modules
@@ -390,7 +390,7 @@ objects dynamically. Note that both ``Py
 
    Create a new module object, given the definition in *def* and the
    ModuleSpec *spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2`
-   with *module_api_version* set to :const:`PYTHON_API_VERSION`.
+   with *module_api_version* set to :c:macro:`PYTHON_API_VERSION`.
 
    .. versionadded:: 3.5
 
@@ -498,7 +498,7 @@ state:
    .. note::
 
       Unlike other functions that steal references, ``PyModule_AddObject()``
-      only decrements the reference count of *value* **on success**.
+      only releases the reference to *value* **on success**.
 
       This means that its return value must be checked, and calling code must
       :c:func:`Py_DECREF` *value* manually on error.
@@ -555,7 +555,7 @@ state:
    ``NULL``-terminated.  Return ``-1`` on error, ``0`` on success.
 
 
-.. c:function:: int PyModule_AddIntMacro(PyObject *module, macro)
+.. c:macro:: PyModule_AddIntMacro(module, macro)
 
    Add an int constant to *module*. The name and the value are taken from
    *macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int
@@ -563,7 +563,7 @@ state:
    Return ``-1`` on error, ``0`` on success.
 
 
-.. c:function:: int PyModule_AddStringMacro(PyObject *module, macro)
+.. c:macro:: PyModule_AddStringMacro(module, macro)
 
    Add a string constant to *module*.
 
--- a/Doc/c-api/none.rst
+++ b/Doc/c-api/none.rst
@@ -9,7 +9,7 @@ The ``None`` Object
 
 Note that the :c:type:`PyTypeObject` for ``None`` is not directly exposed in the
 Python/C API.  Since ``None`` is a singleton, testing for object identity (using
-``==`` in C) is sufficient. There is no :c:func:`PyNone_Check` function for the
+``==`` in C) is sufficient. There is no :c:func:`!PyNone_Check` function for the
 same reason.
 
 
--- a/Doc/c-api/object.rst
+++ b/Doc/c-api/object.rst
@@ -15,15 +15,15 @@ Object Protocol
 .. c:macro:: Py_RETURN_NOTIMPLEMENTED
 
    Properly handle returning :c:data:`Py_NotImplemented` from within a C
-   function (that is, increment the reference count of NotImplemented and
-   return it).
+   function (that is, create a new :term:`strong reference`
+   to NotImplemented and return it).
 
 
 .. c:function:: int PyObject_Print(PyObject *o, FILE *fp, int flags)
 
    Print an object *o*, on file *fp*.  Returns ``-1`` on error.  The flags argument
    is used to enable certain printing options.  The only option currently supported
-   is :const:`Py_PRINT_RAW`; if given, the :func:`str` of the object is written
+   is :c:macro:`Py_PRINT_RAW`; if given, the :func:`str` of the object is written
    instead of the :func:`repr`.
 
 
@@ -33,9 +33,11 @@ Object Protocol
    is equivalent to the Python expression ``hasattr(o, attr_name)``.  This function
    always succeeds.
 
-   Note that exceptions which occur while calling :meth:`__getattr__` and
-   :meth:`__getattribute__` methods will get suppressed.
-   To get error reporting use :c:func:`PyObject_GetAttr()` instead.
+   .. note::
+
+      Exceptions that occur when this calls :meth:`~object.__getattr__` and
+      :meth:`~object.__getattribute__` methods are silently ignored.
+      For proper error handling, use :c:func:`PyObject_GetAttr` instead.
 
 
 .. c:function:: int PyObject_HasAttrString(PyObject *o, const char *attr_name)
@@ -44,10 +46,12 @@ Object Protocol
    is equivalent to the Python expression ``hasattr(o, attr_name)``.  This function
    always succeeds.
 
-   Note that exceptions which occur while calling :meth:`__getattr__` and
-   :meth:`__getattribute__` methods and creating a temporary string object
-   will get suppressed.
-   To get error reporting use :c:func:`PyObject_GetAttrString()` instead.
+   .. note::
+
+      Exceptions that occur when this calls :meth:`~object.__getattr__` and
+      :meth:`~object.__getattribute__` methods or while creating the temporary :class:`str`
+      object are silently ignored.
+      For proper error handling, use :c:func:`PyObject_GetAttrString` instead.
 
 
 .. c:function:: PyObject* PyObject_GetAttr(PyObject *o, PyObject *attr_name)
@@ -158,8 +162,8 @@ Object Protocol
 .. c:function:: PyObject* PyObject_RichCompare(PyObject *o1, PyObject *o2, int opid)
 
    Compare the values of *o1* and *o2* using the operation specified by *opid*,
-   which must be one of :const:`Py_LT`, :const:`Py_LE`, :const:`Py_EQ`,
-   :const:`Py_NE`, :const:`Py_GT`, or :const:`Py_GE`, corresponding to ``<``,
+   which must be one of :c:macro:`Py_LT`, :c:macro:`Py_LE`, :c:macro:`Py_EQ`,
+   :c:macro:`Py_NE`, :c:macro:`Py_GT`, or :c:macro:`Py_GE`, corresponding to ``<``,
    ``<=``, ``==``, ``!=``, ``>``, or ``>=`` respectively. This is the equivalent of
    the Python expression ``o1 op o2``, where ``op`` is the operator corresponding
    to *opid*. Returns the value of the comparison on success, or ``NULL`` on failure.
@@ -168,8 +172,8 @@ Object Protocol
 .. c:function:: int PyObject_RichCompareBool(PyObject *o1, PyObject *o2, int opid)
 
    Compare the values of *o1* and *o2* using the operation specified by *opid*,
-   which must be one of :const:`Py_LT`, :const:`Py_LE`, :const:`Py_EQ`,
-   :const:`Py_NE`, :const:`Py_GT`, or :const:`Py_GE`, corresponding to ``<``,
+   which must be one of :c:macro:`Py_LT`, :c:macro:`Py_LE`, :c:macro:`Py_EQ`,
+   :c:macro:`Py_NE`, :c:macro:`Py_GT`, or :c:macro:`Py_GE`, corresponding to ``<``,
    ``<=``, ``==``, ``!=``, ``>``, or ``>=`` respectively. Returns ``-1`` on error,
    ``0`` if the result is false, ``1`` otherwise. This is the equivalent of the
    Python expression ``o1 op o2``, where ``op`` is the operator corresponding to
@@ -177,7 +181,7 @@ Object Protocol
 
 .. note::
    If *o1* and *o2* are the same object, :c:func:`PyObject_RichCompareBool`
-   will always return ``1`` for :const:`Py_EQ` and ``0`` for :const:`Py_NE`.
+   will always return ``1`` for :c:macro:`Py_EQ` and ``0`` for :c:macro:`Py_NE`.
 
 .. c:function:: PyObject* PyObject_Format(PyObject *obj, PyObject *format_spec)
 
@@ -252,7 +256,7 @@ Object Protocol
 
    Normally only class objects, i.e. instances of :class:`type` or a derived
    class, are considered classes.  However, objects can override this by having
-   a :attr:`__bases__` attribute (which must be a tuple of base classes).
+   a :attr:`~class.__bases__` attribute (which must be a tuple of base classes).
 
 
 .. c:function:: int PyObject_IsInstance(PyObject *inst, PyObject *cls)
@@ -269,10 +273,10 @@ Object Protocol
    is an instance of *cls* if its class is a subclass of *cls*.
 
    An instance *inst* can override what is considered its class by having a
-   :attr:`__class__` attribute.
+   :attr:`~instance.__class__` attribute.
 
    An object *cls* can override if it is considered a class, and what its base
-   classes are, by having a :attr:`__bases__` attribute (which must be a tuple
+   classes are, by having a :attr:`~class.__bases__` attribute (which must be a tuple
    of base classes).
 
 
@@ -316,11 +320,12 @@ Object Protocol
 
    When *o* is non-``NULL``, returns a type object corresponding to the object type
    of object *o*. On failure, raises :exc:`SystemError` and returns ``NULL``.  This
-   is equivalent to the Python expression ``type(o)``. This function increments the
-   reference count of the return value. There's really no reason to use this
+   is equivalent to the Python expression ``type(o)``.
+   This function creates a new :term:`strong reference` to the return value.
+   There's really no reason to use this
    function instead of the :c:func:`Py_TYPE()` function, which returns a
-   pointer of type :c:expr:`PyTypeObject*`, except when the incremented reference
-   count is needed.
+   pointer of type :c:expr:`PyTypeObject*`, except when a new
+   :term:`strong reference` is needed.
 
 
 .. c:function:: int PyObject_TypeCheck(PyObject *o, PyTypeObject *type)
--- a/Doc/c-api/refcounting.rst
+++ b/Doc/c-api/refcounting.rst
@@ -13,31 +13,36 @@ objects.
 
 .. c:function:: void Py_INCREF(PyObject *o)
 
-   Increment the reference count for object *o*.
+   Indicate taking a new :term:`strong reference` to object *o*,
+   indicating it is in use and should not be destroyed.
 
    This function is usually used to convert a :term:`borrowed reference` to a
    :term:`strong reference` in-place. The :c:func:`Py_NewRef` function can be
    used to create a new :term:`strong reference`.
 
+   When done using the object, release it by calling :c:func:`Py_DECREF`.
+
    The object must not be ``NULL``; if you aren't sure that it isn't
    ``NULL``, use :c:func:`Py_XINCREF`.
 
+   Do not expect this function to actually modify *o* in any way.
+
 
 .. c:function:: void Py_XINCREF(PyObject *o)
 
-   Increment the reference count for object *o*.  The object may be ``NULL``, in
-   which case the macro has no effect.
+   Similar to :c:func:`Py_INCREF`, but the object *o* can be ``NULL``,
+   in which case this has no effect.
 
    See also :c:func:`Py_XNewRef`.
 
 
 .. c:function:: PyObject* Py_NewRef(PyObject *o)
 
-   Create a new :term:`strong reference` to an object: increment the reference
-   count of the object *o* and return the object *o*.
+   Create a new :term:`strong reference` to an object:
+   call :c:func:`Py_INCREF` on *o* and return the object *o*.
 
    When the :term:`strong reference` is no longer needed, :c:func:`Py_DECREF`
-   should be called on it to decrement the object reference count.
+   should be called on it to release the reference.
 
    The object *o* must not be ``NULL``; use :c:func:`Py_XNewRef` if *o* can be
    ``NULL``.
@@ -67,9 +72,12 @@ objects.
 
 .. c:function:: void Py_DECREF(PyObject *o)
 
-   Decrement the reference count for object *o*.
+   Release a :term:`strong reference` to object *o*, indicating the
+   reference is no longer used.
 
-   If the reference count reaches zero, the object's type's deallocation
+   Once the last :term:`strong reference` is released
+   (i.e. the object's reference count reaches 0),
+   the object's type's deallocation
    function (which must not be ``NULL``) is invoked.
 
    This function is usually used to delete a :term:`strong reference` before
@@ -78,10 +86,12 @@ objects.
    The object must not be ``NULL``; if you aren't sure that it isn't ``NULL``,
    use :c:func:`Py_XDECREF`.
 
+   Do not expect this function to actually modify *o* in any way.
+
    .. warning::
 
       The deallocation function can cause arbitrary Python code to be invoked (e.g.
-      when a class instance with a :meth:`__del__` method is deallocated).  While
+      when a class instance with a :meth:`~object.__del__` method is deallocated).  While
       exceptions in such code are not propagated, the executed code has free access to
       all Python global variables.  This means that any object that is reachable from
       a global variable should be in a consistent state before :c:func:`Py_DECREF` is
@@ -92,32 +102,35 @@ objects.
 
 .. c:function:: void Py_XDECREF(PyObject *o)
 
-   Decrement the reference count for object *o*.  The object may be ``NULL``, in
-   which case the macro has no effect; otherwise the effect is the same as for
-   :c:func:`Py_DECREF`, and the same warning applies.
+   Similar to :c:func:`Py_DECREF`, but the object *o* can be ``NULL``,
+   in which case this has no effect.
+   The same warning from :c:func:`Py_DECREF` applies here as well.
 
 
 .. c:function:: void Py_CLEAR(PyObject *o)
 
-   Decrement the reference count for object *o*.  The object may be ``NULL``, in
+   Release a :term:`strong reference` for object *o*.
+   The object may be ``NULL``, in
    which case the macro has no effect; otherwise the effect is the same as for
    :c:func:`Py_DECREF`, except that the argument is also set to ``NULL``.  The warning
    for :c:func:`Py_DECREF` does not apply with respect to the object passed because
    the macro carefully uses a temporary variable and sets the argument to ``NULL``
-   before decrementing its reference count.
+   before releasing the reference.
 
-   It is a good idea to use this macro whenever decrementing the reference
-   count of an object that might be traversed during garbage collection.
+   It is a good idea to use this macro whenever releasing a reference
+   to an object that might be traversed during garbage collection.
 
 .. c:function:: void Py_IncRef(PyObject *o)
 
-   Increment the reference count for object *o*. A function version of :c:func:`Py_XINCREF`.
+   Indicate taking a new :term:`strong reference` to object *o*.
+   A function version of :c:func:`Py_XINCREF`.
    It can be used for runtime dynamic embedding of Python.
 
 
 .. c:function:: void Py_DecRef(PyObject *o)
 
-   Decrement the reference count for object *o*. A function version of :c:func:`Py_XDECREF`.
+   Release a :term:`strong reference` to object *o*.
+   A function version of :c:func:`Py_XDECREF`.
    It can be used for runtime dynamic embedding of Python.
 
 
--- a/Doc/c-api/sequence.rst
+++ b/Doc/c-api/sequence.rst
@@ -9,7 +9,7 @@ Sequence Protocol
 .. c:function:: int PySequence_Check(PyObject *o)
 
    Return ``1`` if the object provides the sequence protocol, and ``0`` otherwise.
-   Note that it returns ``1`` for Python classes with a :meth:`__getitem__`
+   Note that it returns ``1`` for Python classes with a :meth:`~object.__getitem__`
    method, unless they are :class:`dict` subclasses, since in general it
    is impossible to determine what type of keys the class supports.  This
    function always succeeds.
--- a/Doc/c-api/set.rst
+++ b/Doc/c-api/set.rst
@@ -110,7 +110,7 @@ or :class:`frozenset` or instances of th
    .. index:: pair: built-in function; len
 
    Return the length of a :class:`set` or :class:`frozenset` object. Equivalent to
-   ``len(anyset)``.  Raises a :exc:`PyExc_SystemError` if *anyset* is not a
+   ``len(anyset)``.  Raises a :exc:`SystemError` if *anyset* is not a
    :class:`set`, :class:`frozenset`, or an instance of a subtype.
 
 
@@ -122,9 +122,9 @@ or :class:`frozenset` or instances of th
 .. c:function:: int PySet_Contains(PyObject *anyset, PyObject *key)
 
    Return ``1`` if found, ``0`` if not found, and ``-1`` if an error is encountered.  Unlike
-   the Python :meth:`__contains__` method, this function does not automatically
+   the Python :meth:`~object.__contains__` method, this function does not automatically
    convert unhashable sets into temporary frozensets.  Raise a :exc:`TypeError` if
-   the *key* is unhashable. Raise :exc:`PyExc_SystemError` if *anyset* is not a
+   the *key* is unhashable. Raise :exc:`SystemError` if *anyset* is not a
    :class:`set`, :class:`frozenset`, or an instance of a subtype.
 
 
@@ -149,7 +149,7 @@ subtypes but not for instances of :class
    error is encountered.  Does not raise :exc:`KeyError` for missing keys.  Raise a
    :exc:`TypeError` if the *key* is unhashable.  Unlike the Python :meth:`~set.discard`
    method, this function does not automatically convert unhashable sets into
-   temporary frozensets. Raise :exc:`PyExc_SystemError` if *set* is not an
+   temporary frozensets. Raise :exc:`SystemError` if *set* is not an
    instance of :class:`set` or its subtype.
 
 
--- a/Doc/c-api/slice.rst
+++ b/Doc/c-api/slice.rst
@@ -34,7 +34,7 @@ Slice Objects
    *length* as errors.
 
    Returns ``0`` on success and ``-1`` on error with no exception set (unless one of
-   the indices was not :const:`None` and failed to be converted to an integer,
+   the indices was not ``None`` and failed to be converted to an integer,
    in which case ``-1`` is returned with an exception set).
 
    You probably do not want to use this function.
@@ -113,7 +113,7 @@ Slice Objects
 
 
 Ellipsis Object
----------------
+^^^^^^^^^^^^^^^
 
 
 .. c:var:: PyObject *Py_Ellipsis
--- a/Doc/c-api/stable.rst
+++ b/Doc/c-api/stable.rst
@@ -44,7 +44,7 @@ embedding Python.)
    Define this macro before including ``Python.h`` to opt in to only use
    the Limited API, and to select the Limited API version.
 
-   Define ``Py_LIMITED_API`` to the value of :c:data:`PY_VERSION_HEX`
+   Define ``Py_LIMITED_API`` to the value of :c:macro:`PY_VERSION_HEX`
    corresponding to the lowest Python version your extension supports.
    The extension will work without recompilation with all Python 3 releases
    from the specified one onward, and can use Limited API introduced up to that
--- a/Doc/c-api/structures.rst
+++ b/Doc/c-api/structures.rst
@@ -34,7 +34,7 @@ the definition of all other Python objec
 
 .. c:type:: PyVarObject
 
-   This is an extension of :c:type:`PyObject` that adds the :attr:`ob_size`
+   This is an extension of :c:type:`PyObject` that adds the :c:member:`~PyVarObject.ob_size`
    field.  This is only used for objects that have some notion of *length*.
    This type does not often appear in the Python/C API.
    Access to the members must be done by using the macros
@@ -171,7 +171,7 @@ the definition of all other Python objec
 .. c:macro:: PyVarObject_HEAD_INIT(type, size)
 
    This is a macro which expands to initialization values for a new
-   :c:type:`PyVarObject` type, including the :attr:`ob_size` field.
+   :c:type:`PyVarObject` type, including the :c:member:`~PyVarObject.ob_size` field.
    This macro expands to::
 
       _PyObject_EXTRA_INIT
@@ -198,7 +198,7 @@ Implementing functions and methods
 .. c:type:: PyCFunctionWithKeywords
 
    Type of the functions used to implement Python callables in C
-   with signature :const:`METH_VARARGS | METH_KEYWORDS`.
+   with signature :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`.
    The function signature is::
 
       PyObject *PyCFunctionWithKeywords(PyObject *self,
@@ -209,7 +209,7 @@ Implementing functions and methods
 .. c:type:: _PyCFunctionFast
 
    Type of the functions used to implement Python callables in C
-   with signature :const:`METH_FASTCALL`.
+   with signature :c:macro:`METH_FASTCALL`.
    The function signature is::
 
       PyObject *_PyCFunctionFast(PyObject *self,
@@ -219,7 +219,7 @@ Implementing functions and methods
 .. c:type:: _PyCFunctionFastWithKeywords
 
    Type of the functions used to implement Python callables in C
-   with signature :const:`METH_FASTCALL | METH_KEYWORDS`.
+   with signature :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>`.
    The function signature is::
 
       PyObject *_PyCFunctionFastWithKeywords(PyObject *self,
@@ -230,7 +230,7 @@ Implementing functions and methods
 .. c:type:: PyCMethod
 
    Type of the functions used to implement Python callables in C
-   with signature :const:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`.
+   with signature :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`.
    The function signature is::
 
       PyObject *PyCMethod(PyObject *self,
@@ -247,36 +247,38 @@ Implementing functions and methods
    Structure used to describe a method of an extension type.  This structure has
    four fields:
 
-   .. c:member:: const char* ml_name
+   .. c:member:: const char *ml_name
 
-      name of the method
+      Name of the method.
 
    .. c:member:: PyCFunction ml_meth
 
-      pointer to the C implementation
+      Pointer to the C implementation.
 
    .. c:member:: int ml_flags
 
-      flags bits indicating how the call should be constructed
+      Flags bits indicating how the call should be constructed.
 
-   .. c:member:: const char* ml_doc
+   .. c:member:: const char *ml_doc
 
-      points to the contents of the docstring
+      Points to the contents of the docstring.
 
-The :c:member:`ml_meth` is a C function pointer.  The functions may be of different
+The :c:member:`~PyMethodDef.ml_meth` is a C function pointer.
+The functions may be of different
 types, but they always return :c:expr:`PyObject*`.  If the function is not of
 the :c:type:`PyCFunction`, the compiler will require a cast in the method table.
 Even though :c:type:`PyCFunction` defines the first parameter as
 :c:expr:`PyObject*`, it is common that the method implementation uses the
 specific C type of the *self* object.
 
-The :c:member:`ml_flags` field is a bitfield which can include the following flags.
+The :c:member:`~PyMethodDef.ml_flags` field is a bitfield which can include
+the following flags.
 The individual flags indicate either a calling convention or a binding
 convention.
 
 There are these calling conventions:
 
-.. data:: METH_VARARGS
+.. c:macro:: METH_VARARGS
 
    This is the typical calling convention, where the methods have the type
    :c:type:`PyCFunction`. The function expects two :c:expr:`PyObject*` values.
@@ -286,8 +288,17 @@ There are these calling conventions:
    using :c:func:`PyArg_ParseTuple` or :c:func:`PyArg_UnpackTuple`.
 
 
-.. data:: METH_VARARGS | METH_KEYWORDS
+.. c:macro:: METH_KEYWORDS
 
+   Can only be used in certain combinations with other flags:
+   :ref:`METH_VARARGS | METH_KEYWORDS <METH_VARARGS-METH_KEYWORDS>`,
+   :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>` and
+   :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`.
+
+
+.. _METH_VARARGS-METH_KEYWORDS:
+
+:c:expr:`METH_VARARGS | METH_KEYWORDS`
    Methods with these flags must be of type :c:type:`PyCFunctionWithKeywords`.
    The function expects three parameters: *self*, *args*, *kwargs* where
    *kwargs* is a dictionary of all the keyword arguments or possibly ``NULL``
@@ -295,7 +306,7 @@ There are these calling conventions:
    using :c:func:`PyArg_ParseTupleAndKeywords`.
 
 
-.. data:: METH_FASTCALL
+.. c:macro:: METH_FASTCALL
 
    Fast calling convention supporting only positional arguments.
    The methods have the type :c:type:`_PyCFunctionFast`.
@@ -310,9 +321,10 @@ There are these calling conventions:
       ``METH_FASTCALL`` is now part of the stable ABI.
 
 
-.. data:: METH_FASTCALL | METH_KEYWORDS
+.. _METH_FASTCALL-METH_KEYWORDS:
 
-   Extension of :const:`METH_FASTCALL` supporting also keyword arguments,
+:c:expr:`METH_FASTCALL | METH_KEYWORDS`
+   Extension of :c:macro:`METH_FASTCALL` supporting also keyword arguments,
    with methods of type :c:type:`_PyCFunctionFastWithKeywords`.
    Keyword arguments are passed the same way as in the
    :ref:`vectorcall protocol <vectorcall>`:
@@ -325,10 +337,18 @@ There are these calling conventions:
    .. versionadded:: 3.7
 
 
-.. data:: METH_METHOD | METH_FASTCALL | METH_KEYWORDS
+.. c:macro:: METH_METHOD
+
+   Can only be used in the combination with other flags:
+   :ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`.
+
+
+.. _METH_METHOD-METH_FASTCALL-METH_KEYWORDS:
 
-   Extension of :const:`METH_FASTCALL | METH_KEYWORDS` supporting the *defining
-   class*, that is, the class that contains the method in question.
+:c:expr:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`
+   Extension of :ref:`METH_FASTCALL | METH_KEYWORDS <METH_FASTCALL-METH_KEYWORDS>`
+   supporting the *defining class*, that is,
+   the class that contains the method in question.
    The defining class might be a superclass of ``Py_TYPE(self)``.
 
    The method needs to be of type :c:type:`PyCMethod`, the same as for
@@ -338,10 +358,10 @@ There are these calling conventions:
    .. versionadded:: 3.9
 
 
-.. data:: METH_NOARGS
+.. c:macro:: METH_NOARGS
 
    Methods without parameters don't need to check whether arguments are given if
-   they are listed with the :const:`METH_NOARGS` flag.  They need to be of type
+   they are listed with the :c:macro:`METH_NOARGS` flag.  They need to be of type
    :c:type:`PyCFunction`.  The first parameter is typically named *self* and will
    hold a reference to the module or object instance.  In all cases the second
    parameter will be ``NULL``.
@@ -350,9 +370,9 @@ There are these calling conventions:
    :c:macro:`Py_UNUSED` can be used to prevent a compiler warning.
 
 
-.. data:: METH_O
+.. c:macro:: METH_O
 
-   Methods with a single object argument can be listed with the :const:`METH_O`
+   Methods with a single object argument can be listed with the :c:macro:`METH_O`
    flag, instead of invoking :c:func:`PyArg_ParseTuple` with a ``"O"`` argument.
    They have the type :c:type:`PyCFunction`, with the *self* parameter, and a
    :c:expr:`PyObject*` parameter representing the single argument.
@@ -364,7 +384,7 @@ defined for modules.  At most one of the
 method.
 
 
-.. data:: METH_CLASS
+.. c:macro:: METH_CLASS
 
    .. index:: pair: built-in function; classmethod
 
@@ -374,7 +394,7 @@ method.
    function.
 
 
-.. data:: METH_STATIC
+.. c:macro:: METH_STATIC
 
    .. index:: pair: built-in function; staticmethod
 
@@ -386,13 +406,13 @@ One other constant controls whether a me
 definition with the same method name.
 
 
-.. data:: METH_COEXIST
+.. c:macro:: METH_COEXIST
 
    The method will be loaded in place of existing definitions.  Without
    *METH_COEXIST*, the default is to skip repeated definitions.  Since slot
    wrappers are loaded before the method table, the existence of a
    *sq_contains* slot, for example, would generate a wrapped method named
-   :meth:`__contains__` and preclude the loading of a corresponding
+   :meth:`~object.__contains__` and preclude the loading of a corresponding
    PyCFunction with the same name.  With the flag defined, the PyCFunction
    will be loaded in place of the wrapper object and will co-exist with the
    slot.  This is helpful because calls to PyCFunctions are optimized more
--- a/Doc/c-api/sys.rst
+++ b/Doc/c-api/sys.rst
@@ -8,8 +8,9 @@ Operating System Utilities
 .. c:function:: PyObject* PyOS_FSPath(PyObject *path)
 
    Return the file system representation for *path*. If the object is a
-   :class:`str` or :class:`bytes` object, then its reference count is
-   incremented. If the object implements the :class:`os.PathLike` interface,
+   :class:`str` or :class:`bytes` object, then a new
+   :term:`strong reference` is returned.
+   If the object implements the :class:`os.PathLike` interface,
    then :meth:`~os.PathLike.__fspath__` is returned as long as it is a
    :class:`str` or :class:`bytes` object. Otherwise :exc:`TypeError` is raised
    and ``NULL`` is returned.
@@ -95,16 +96,16 @@ Operating System Utilities
 .. c:function:: int PyOS_CheckStack()
 
    Return true when the interpreter runs out of stack space.  This is a reliable
-   check, but is only available when :const:`USE_STACKCHECK` is defined (currently
+   check, but is only available when :c:macro:`USE_STACKCHECK` is defined (currently
    on certain versions of Windows using the Microsoft Visual C++ compiler).
-   :const:`USE_STACKCHECK` will be defined automatically; you should never
+   :c:macro:`USE_STACKCHECK` will be defined automatically; you should never
    change the definition in your own code.
 
 
 .. c:function:: PyOS_sighandler_t PyOS_getsig(int i)
 
    Return the current signal handler for signal *i*.  This is a thin wrapper around
-   either :c:func:`sigaction` or :c:func:`signal`.  Do not call those functions
+   either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call those functions
    directly! :c:type:`PyOS_sighandler_t` is a typedef alias for :c:expr:`void
    (\*)(int)`.
 
@@ -112,7 +113,7 @@ Operating System Utilities
 .. c:function:: PyOS_sighandler_t PyOS_setsig(int i, PyOS_sighandler_t h)
 
    Set the signal handler for signal *i* to be *h*; return the old signal handler.
-   This is a thin wrapper around either :c:func:`sigaction` or :c:func:`signal`.  Do
+   This is a thin wrapper around either :c:func:`!sigaction` or :c:func:`!signal`.  Do
    not call those functions directly!  :c:type:`PyOS_sighandler_t` is a typedef
    alias for :c:expr:`void (\*)(int)`.
 
@@ -412,7 +413,7 @@ Process Control
    This function should only be invoked when a condition is detected that would
    make it dangerous to continue using the Python interpreter; e.g., when the
    object administration appears to be corrupted.  On Unix, the standard C library
-   function :c:func:`abort` is called which will attempt to produce a :file:`core`
+   function :c:func:`!abort` is called which will attempt to produce a :file:`core`
    file.
 
    The ``Py_FatalError()`` function is replaced with a macro which logs
--- a/Doc/c-api/tuple.rst
+++ b/Doc/c-api/tuple.rst
@@ -111,6 +111,8 @@ Tuple Objects
    raises :exc:`MemoryError` or :exc:`SystemError`.
 
 
+.. _struct-sequence-objects:
+
 Struct Sequence Objects
 -----------------------
 
@@ -142,39 +144,39 @@ type.
 
    Contains the meta information of a struct sequence type to create.
 
-   +-------------------+------------------------------+--------------------------------------+
-   | Field             | C Type                       | Meaning                              |
-   +===================+==============================+======================================+
-   | ``name``          | ``const char *``             | name of the struct sequence type     |
-   +-------------------+------------------------------+--------------------------------------+
-   | ``doc``           | ``const char *``             | pointer to docstring for the type    |
-   |                   |                              | or ``NULL`` to omit                  |
-   +-------------------+------------------------------+--------------------------------------+
-   | ``fields``        | ``PyStructSequence_Field *`` | pointer to ``NULL``-terminated array |
-   |                   |                              | with field names of the new type     |
-   +-------------------+------------------------------+--------------------------------------+
-   | ``n_in_sequence`` | ``int``                      | number of fields visible to the      |
-   |                   |                              | Python side (if used as tuple)       |
-   +-------------------+------------------------------+--------------------------------------+
+   .. c:member:: const char *name
+
+      Name of the struct sequence type.
+
+   .. c:member:: const char *doc
+
+      Pointer to docstring for the type or ``NULL`` to omit.
+
+   .. c:member:: PyStructSequence_Field *fields
+
+      Pointer to ``NULL``-terminated array with field names of the new type.
+
+   .. c:member:: int n_in_sequence
+
+      Number of fields visible to the Python side (if used as tuple).
 
 
 .. c:type:: PyStructSequence_Field
 
    Describes a field of a struct sequence. As a struct sequence is modeled as a
    tuple, all fields are typed as :c:expr:`PyObject*`.  The index in the
-   :attr:`fields` array of the :c:type:`PyStructSequence_Desc` determines which
+   :c:member:`~PyStructSequence_Desc.fields` array of
+   the :c:type:`PyStructSequence_Desc` determines which
    field of the struct sequence is described.
 
-   +-----------+------------------+-----------------------------------------+
-   | Field     | C Type           | Meaning                                 |
-   +===========+==================+=========================================+
-   | ``name``  | ``const char *`` | name for the field or ``NULL`` to end   |
-   |           |                  | the list of named fields, set to        |
-   |           |                  | :c:data:`PyStructSequence_UnnamedField` |
-   |           |                  | to leave unnamed                        |
-   +-----------+------------------+-----------------------------------------+
-   | ``doc``   | ``const char *`` | field docstring or ``NULL`` to omit     |
-   +-----------+------------------+-----------------------------------------+
+   .. c:member:: const char *name
+
+      Name for the field or ``NULL`` to end the list of named fields,
+      set to :c:data:`PyStructSequence_UnnamedField` to leave unnamed.
+
+   .. c:member:: const char *doc
+
+      Field docstring or ``NULL`` to omit.
 
 
 .. c:var:: const char * const PyStructSequence_UnnamedField
--- a/Doc/c-api/type.rst
+++ b/Doc/c-api/type.rst
@@ -66,7 +66,7 @@ Type Objects
 .. c:function:: int PyType_IS_GC(PyTypeObject *o)
 
    Return true if the type object includes support for the cycle detector; this
-   tests the type flag :const:`Py_TPFLAGS_HAVE_GC`.
+   tests the type flag :c:macro:`Py_TPFLAGS_HAVE_GC`.
 
 
 .. c:function:: int PyType_IsSubtype(PyTypeObject *a, PyTypeObject *b)
@@ -99,10 +99,10 @@ Type Objects
 
    .. note::
        If some of the base classes implements the GC protocol and the provided
-       type does not include the :const:`Py_TPFLAGS_HAVE_GC` in its flags, then
+       type does not include the :c:macro:`Py_TPFLAGS_HAVE_GC` in its flags, then
        the GC protocol will be automatically implemented from its parents. On
        the contrary, if the type being created does include
-       :const:`Py_TPFLAGS_HAVE_GC` in its flags then it **must** implement the
+       :c:macro:`Py_TPFLAGS_HAVE_GC` in its flags then it **must** implement the
        GC protocol itself by at least implementing the
        :c:member:`~PyTypeObject.tp_traverse` handle.
 
@@ -149,7 +149,7 @@ Type Objects
    ``Py_TYPE(self)`` may be a *subclass* of the intended class, and subclasses
    are not necessarily defined in the same module as their superclass.
    See :c:type:`PyCMethod` to get the class that defines the method.
-   See :c:func:`PyType_GetModuleByDef` for cases when ``PyCMethod`` cannot
+   See :c:func:`PyType_GetModuleByDef` for cases when :c:type:`!PyCMethod` cannot
    be used.
 
    .. versionadded:: 3.9
@@ -193,7 +193,7 @@ The following functions and structs are
 .. c:function:: PyObject* PyType_FromModuleAndSpec(PyObject *module, PyType_Spec *spec, PyObject *bases)
 
    Creates and returns a :ref:`heap type <heap-types>` from the *spec*
-   (:const:`Py_TPFLAGS_HEAPTYPE`).
+   (:c:macro:`Py_TPFLAGS_HEAPTYPE`).
 
    The *bases* argument can be used to specify base classes; it can either
    be only one class or a tuple of classes.
@@ -292,7 +292,7 @@ The following functions and structs are
       Setting :c:data:`Py_tp_bases` or :c:data:`Py_tp_base` may be
       problematic on some platforms.
       To avoid issues, use the *bases* argument of
-      :py:func:`PyType_FromSpecWithBases` instead.
+      :c:func:`PyType_FromSpecWithBases` instead.
 
      .. versionchanged:: 3.9
 
--- a/Doc/c-api/typehints.rst
+++ b/Doc/c-api/typehints.rst
@@ -35,7 +35,7 @@ two types exist -- :ref:`GenericAlias <t
           ...
       }
 
-   .. seealso:: The data model method :meth:`__class_getitem__`.
+   .. seealso:: The data model method :meth:`~object.__class_getitem__`.
 
    .. versionadded:: 3.9
 
--- a/Doc/c-api/typeobj.rst
+++ b/Doc/c-api/typeobj.rst
@@ -161,9 +161,9 @@ Quick Reference
 
 .. [#cols] Columns:
 
-   **"O"**:  set on :c:type:`PyBaseObject_Type`
+   **"O"**:  set on :c:data:`PyBaseObject_Type`
 
-   **"T"**:  set on :c:type:`PyType_Type`
+   **"T"**:  set on :c:data:`PyType_Type`
 
    **"D"**:  default (if slot is set to ``NULL``)
 
@@ -483,17 +483,17 @@ PyObject Slots
 --------------
 
 The type object structure extends the :c:type:`PyVarObject` structure. The
-:attr:`ob_size` field is used for dynamic types (created by :func:`type_new`,
+:c:member:`~PyVarObject.ob_size` field is used for dynamic types (created by :c:func:`!type_new`,
 usually called from a class statement). Note that :c:data:`PyType_Type` (the
 metatype) initializes :c:member:`~PyTypeObject.tp_itemsize`, which means that its instances (i.e.
-type objects) *must* have the :attr:`ob_size` field.
+type objects) *must* have the :c:member:`~PyVarObject.ob_size` field.
 
 
 .. c:member:: Py_ssize_t PyObject.ob_refcnt
 
    This is the type object's reference count, initialized to ``1`` by the
    ``PyObject_HEAD_INIT`` macro.  Note that for :ref:`statically allocated type
-   objects <static-types>`, the type's instances (objects whose :attr:`ob_type`
+   objects <static-types>`, the type's instances (objects whose :c:member:`~PyObject.ob_type`
    points back to the type) do *not* count as references.  But for
    :ref:`dynamically allocated type objects <heap-types>`, the instances *do*
    count as references.
@@ -517,8 +517,8 @@ type objects) *must* have the :attr:`ob_
       Foo_Type.ob_type = &PyType_Type;
 
    This should be done before any instances of the type are created.
-   :c:func:`PyType_Ready` checks if :attr:`ob_type` is ``NULL``, and if so,
-   initializes it to the :attr:`ob_type` field of the base class.
+   :c:func:`PyType_Ready` checks if :c:member:`~PyObject.ob_type` is ``NULL``, and if so,
+   initializes it to the :c:member:`~PyObject.ob_type` field of the base class.
    :c:func:`PyType_Ready` will not change this field if it is non-zero.
 
    **Inheritance:**
@@ -567,8 +567,8 @@ PyTypeObject Slots
 
 Each slot has a section describing inheritance.  If :c:func:`PyType_Ready`
 may set a value when the field is set to ``NULL`` then there will also be
-a "Default" section.  (Note that many fields set on :c:type:`PyBaseObject_Type`
-and :c:type:`PyType_Type` effectively act as defaults.)
+a "Default" section.  (Note that many fields set on :c:data:`PyBaseObject_Type`
+and :c:data:`PyType_Type` effectively act as defaults.)
 
 .. c:member:: const char* PyTypeObject.tp_name
 
@@ -577,7 +577,7 @@ and :c:type:`PyType_Type` effectively ac
    name, followed by a dot, followed by the type name; for built-in types, it
    should be just the type name.  If the module is a submodule of a package, the
    full package name is part of the full module name.  For example, a type named
-   :class:`T` defined in module :mod:`M` in subpackage :mod:`Q` in package :mod:`P`
+   :class:`!T` defined in module :mod:`!M` in subpackage :mod:`!Q` in package :mod:`!P`
    should have the :c:member:`~PyTypeObject.tp_name` initializer ``"P.Q.M.T"``.
 
    For :ref:`dynamically allocated type objects <heap-types>`,
@@ -617,20 +617,20 @@ and :c:type:`PyType_Type` effectively ac
    instances have the same size, given in :c:member:`~PyTypeObject.tp_basicsize`.
 
    For a type with variable-length instances, the instances must have an
-   :attr:`ob_size` field, and the instance size is :c:member:`~PyTypeObject.tp_basicsize` plus N
+   :c:member:`~PyVarObject.ob_size` field, and the instance size is :c:member:`~PyTypeObject.tp_basicsize` plus N
    times :c:member:`~PyTypeObject.tp_itemsize`, where N is the "length" of the object.  The value of
-   N is typically stored in the instance's :attr:`ob_size` field.  There are
-   exceptions:  for example, ints use a negative :attr:`ob_size` to indicate a
+   N is typically stored in the instance's :c:member:`~PyVarObject.ob_size` field.  There are
+   exceptions:  for example, ints use a negative :c:member:`~PyVarObject.ob_size` to indicate a
    negative number, and N is ``abs(ob_size)`` there.  Also, the presence of an
-   :attr:`ob_size` field in the instance layout doesn't mean that the instance
+   :c:member:`~PyVarObject.ob_size` field in the instance layout doesn't mean that the instance
    structure is variable-length (for example, the structure for the list type has
-   fixed-length instances, yet those instances have a meaningful :attr:`ob_size`
+   fixed-length instances, yet those instances have a meaningful :c:member:`~PyVarObject.ob_size`
    field).
 
    The basic size includes the fields in the instance declared by the macro
    :c:macro:`PyObject_HEAD` or :c:macro:`PyObject_VAR_HEAD` (whichever is used to
-   declare the instance struct) and this in turn includes the :attr:`_ob_prev` and
-   :attr:`_ob_next` fields if they are present.  This means that the only correct
+   declare the instance struct) and this in turn includes the  :c:member:`~PyObject._ob_prev` and
+   :c:member:`~PyObject._ob_next` fields if they are present.  This means that the only correct
    way to get an initializer for the :c:member:`~PyTypeObject.tp_basicsize` is to use the
    ``sizeof`` operator on the struct used to declare the instance layout.
    The basic size does not include the GC header size.
@@ -667,15 +667,15 @@ and :c:type:`PyType_Type` effectively ac
    memory buffers owned by the instance (using the freeing function corresponding
    to the allocation function used to allocate the buffer), and call the type's
    :c:member:`~PyTypeObject.tp_free` function.  If the type is not subtypable
-   (doesn't have the :const:`Py_TPFLAGS_BASETYPE` flag bit set), it is
+   (doesn't have the :c:macro:`Py_TPFLAGS_BASETYPE` flag bit set), it is
    permissible to call the object deallocator directly instead of via
    :c:member:`~PyTypeObject.tp_free`.  The object deallocator should be the one used to allocate the
    instance; this is normally :c:func:`PyObject_Del` if the instance was allocated
-   using :c:func:`PyObject_New` or :c:func:`PyObject_VarNew`, or
+   using :c:macro:`PyObject_New` or :c:macro:`PyObject_NewVar`, or
    :c:func:`PyObject_GC_Del` if the instance was allocated using
-   :c:func:`PyObject_GC_New` or :c:func:`PyObject_GC_NewVar`.
+   :c:macro:`PyObject_GC_New` or :c:macro:`PyObject_GC_NewVar`.
 
-   If the type supports garbage collection (has the :const:`Py_TPFLAGS_HAVE_GC`
+   If the type supports garbage collection (has the :c:macro:`Py_TPFLAGS_HAVE_GC`
    flag bit set), the destructor should call :c:func:`PyObject_GC_UnTrack`
    before clearing any member fields.
 
@@ -687,8 +687,9 @@ and :c:type:`PyType_Type` effectively ac
          Py_TYPE(self)->tp_free((PyObject *)self);
      }
 
-   Finally, if the type is heap allocated (:const:`Py_TPFLAGS_HEAPTYPE`), the
-   deallocator should decrement the reference count for its type object after
+   Finally, if the type is heap allocated (:c:macro:`Py_TPFLAGS_HEAPTYPE`), the
+   deallocator should release the owned reference to its type object
+   (via :c:func:`Py_DECREF`)  after
    calling the type deallocator. In order to avoid dangling pointers, the
    recommended way to achieve this is:
 
@@ -714,12 +715,12 @@ and :c:type:`PyType_Type` effectively ac
    a more efficient alternative
    of the simpler :c:member:`~PyTypeObject.tp_call`.
 
-   This field is only used if the flag :const:`Py_TPFLAGS_HAVE_VECTORCALL`
+   This field is only used if the flag :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL`
    is set. If so, this must be a positive integer containing the offset in the
    instance of a :c:type:`vectorcallfunc` pointer.
 
    The *vectorcallfunc* pointer may be ``NULL``, in which case the instance behaves
-   as if :const:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the instance
+   as if :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` was not set: calling the instance
    falls back to :c:member:`~PyTypeObject.tp_call`.
 
    Any class that sets ``Py_TPFLAGS_HAVE_VECTORCALL`` must also set
@@ -743,12 +744,12 @@ and :c:type:`PyType_Type` effectively ac
    **Inheritance:**
 
    This field is always inherited.
-   However, the :const:`Py_TPFLAGS_HAVE_VECTORCALL` flag is not
+   However, the :c:macro:`Py_TPFLAGS_HAVE_VECTORCALL` flag is not
    always inherited. If it's not, then the subclass won't use
    :ref:`vectorcall <vectorcall>`, except when
    :c:func:`PyVectorcall_Call` is explicitly called.
    This is in particular the case for types without the
-   :const:`Py_TPFLAGS_IMMUTABLETYPE` flag set (including subclasses defined in
+   :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set (including subclasses defined in
    Python).
 
 
@@ -762,7 +763,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :attr:`tp_getattr`, :attr:`tp_getattro`
+   Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject.tp_getattro`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_getattro`: a subtype
    inherits both :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject.tp_getattro` from its base type when
@@ -779,7 +780,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :attr:`tp_setattr`, :attr:`tp_setattro`
+   Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject.tp_setattro`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_setattro`: a subtype
    inherits both :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` from its base type when
@@ -881,7 +882,7 @@ and :c:type:`PyType_Type` effectively ac
    normal return value; when an error occurs during the computation of the hash
    value, the function should set an exception and return ``-1``.
 
-   When this field is not set (*and* :attr:`tp_richcompare` is not set),
+   When this field is not set (*and* :c:member:`~PyTypeObject.tp_richcompare` is not set),
    an attempt to take the hash of the object raises :exc:`TypeError`.
    This is the same as setting it to :c:func:`PyObject_HashNotImplemented`.
 
@@ -895,7 +896,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :attr:`tp_hash`, :attr:`tp_richcompare`
+   Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject.tp_richcompare`
 
    This field is inherited by subtypes together with
    :c:member:`~PyTypeObject.tp_richcompare`: a subtype inherits both of
@@ -954,7 +955,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :attr:`tp_getattr`, :attr:`tp_getattro`
+   Group: :c:member:`~PyTypeObject.tp_getattr`, :c:member:`~PyTypeObject.tp_getattro`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_getattr`: a subtype
    inherits both :c:member:`~PyTypeObject.tp_getattr` and :c:member:`~PyTypeObject.tp_getattro` from its base type when
@@ -962,7 +963,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Default:**
 
-   :c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`.
+   :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericGetAttr`.
 
 
 .. c:member:: setattrofunc PyTypeObject.tp_setattro
@@ -980,7 +981,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :attr:`tp_setattr`, :attr:`tp_setattro`
+   Group: :c:member:`~PyTypeObject.tp_setattr`, :c:member:`~PyTypeObject.tp_setattro`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_setattr`: a subtype
    inherits both :c:member:`~PyTypeObject.tp_setattr` and :c:member:`~PyTypeObject.tp_setattro` from its base type when
@@ -988,7 +989,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Default:**
 
-   :c:type:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`.
+   :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_GenericSetAttr`.
 
 
 .. c:member:: PyBufferProcs* PyTypeObject.tp_as_buffer
@@ -1020,9 +1021,9 @@ and :c:type:`PyType_Type` effectively ac
    this flag bit.  The flag bits that pertain to extension structures are strictly
    inherited if the extension structure is inherited, i.e. the base type's value of
    the flag bit is copied into the subtype together with a pointer to the extension
-   structure.  The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with
+   structure.  The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited together with
    the :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields, i.e. if the
-   :const:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the
+   :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is clear in the subtype and the
    :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have
    ``NULL`` values.
 
@@ -1030,21 +1031,23 @@ and :c:type:`PyType_Type` effectively ac
 
    **Default:**
 
-   :c:type:`PyBaseObject_Type` uses
+   :c:data:`PyBaseObject_Type` uses
    ``Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE``.
 
    **Bit Masks:**
 
+   .. c:namespace:: NULL
+
    The following bit masks are currently defined; these can be ORed together using
    the ``|`` operator to form the value of the :c:member:`~PyTypeObject.tp_flags` field.  The macro
    :c:func:`PyType_HasFeature` takes a type and a flags value, *tp* and *f*, and
    checks whether ``tp->tp_flags & f`` is non-zero.
 
-   .. data:: Py_TPFLAGS_HEAPTYPE
+   .. c:macro:: Py_TPFLAGS_HEAPTYPE
 
       This bit is set when the type object itself is allocated on the heap, for
       example, types created dynamically using :c:func:`PyType_FromSpec`.  In this
-      case, the :attr:`ob_type` field of its instances is considered a reference to
+      case, the :c:member:`~PyObject.ob_type` field of its instances is considered a reference to
       the type, and the type object is INCREF'ed when a new instance is created, and
       DECREF'ed when an instance is destroyed (this does not apply to instances of
       subtypes; only the type referenced by the instance's ob_type gets INCREF'ed or
@@ -1055,7 +1058,7 @@ and :c:type:`PyType_Type` effectively ac
       ???
 
 
-   .. data:: Py_TPFLAGS_BASETYPE
+   .. c:macro:: Py_TPFLAGS_BASETYPE
 
       This bit is set when the type can be used as the base type of another type.  If
       this bit is clear, the type cannot be subtyped (similar to a "final" class in
@@ -1066,7 +1069,7 @@ and :c:type:`PyType_Type` effectively ac
       ???
 
 
-   .. data:: Py_TPFLAGS_READY
+   .. c:macro:: Py_TPFLAGS_READY
 
       This bit is set when the type object has been fully initialized by
       :c:func:`PyType_Ready`.
@@ -1076,7 +1079,7 @@ and :c:type:`PyType_Type` effectively ac
       ???
 
 
-   .. data:: Py_TPFLAGS_READYING
+   .. c:macro:: Py_TPFLAGS_READYING
 
       This bit is set while :c:func:`PyType_Ready` is in the process of initializing
       the type object.
@@ -1086,10 +1089,10 @@ and :c:type:`PyType_Type` effectively ac
       ???
 
 
-   .. data:: Py_TPFLAGS_HAVE_GC
+   .. c:macro:: Py_TPFLAGS_HAVE_GC
 
       This bit is set when the object supports garbage collection.  If this bit
-      is set, instances must be created using :c:func:`PyObject_GC_New` and
+      is set, instances must be created using :c:macro:`PyObject_GC_New` and
       destroyed using :c:func:`PyObject_GC_Del`.  More information in section
       :ref:`supporting-cycle-detection`.  This bit also implies that the
       GC-related fields :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear` are present in
@@ -1097,28 +1100,28 @@ and :c:type:`PyType_Type` effectively ac
 
       **Inheritance:**
 
-      Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`
+      Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`, :c:member:`~PyTypeObject.tp_clear`
 
-      The :const:`Py_TPFLAGS_HAVE_GC` flag bit is inherited
-      together with the :attr:`tp_traverse` and :attr:`tp_clear`
-      fields, i.e.  if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is
-      clear in the subtype and the :attr:`tp_traverse` and
-      :attr:`tp_clear` fields in the subtype exist and have ``NULL``
+      The :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is inherited
+      together with the :c:member:`~PyTypeObject.tp_traverse` and :c:member:`~PyTypeObject.tp_clear`
+      fields, i.e.  if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is
+      clear in the subtype and the :c:member:`~PyTypeObject.tp_traverse` and
+      :c:member:`~PyTypeObject.tp_clear` fields in the subtype exist and have ``NULL``
       values.
 
 
-   .. data:: Py_TPFLAGS_DEFAULT
+   .. c:macro:: Py_TPFLAGS_DEFAULT
 
       This is a bitmask of all the bits that pertain to the existence of certain
       fields in the type object and its extension structures. Currently, it includes
-      the following bits: :const:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`.
+      the following bits: :c:macro:`Py_TPFLAGS_HAVE_STACKLESS_EXTENSION`.
 
       **Inheritance:**
 
       ???
 
 
-   .. data:: Py_TPFLAGS_METHOD_DESCRIPTOR
+   .. c:macro:: Py_TPFLAGS_METHOD_DESCRIPTOR
 
       This bit indicates that objects behave like unbound methods.
 
@@ -1139,21 +1142,21 @@ and :c:type:`PyType_Type` effectively ac
       **Inheritance:**
 
       This flag is never inherited by types without the
-      :const:`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is
+      :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set.  For extension types, it is
       inherited whenever :c:member:`~PyTypeObject.tp_descr_get` is inherited.
 
 
    .. XXX Document more flags here?
 
 
-   .. data:: Py_TPFLAGS_LONG_SUBCLASS
-   .. data:: Py_TPFLAGS_LIST_SUBCLASS
-   .. data:: Py_TPFLAGS_TUPLE_SUBCLASS
-   .. data:: Py_TPFLAGS_BYTES_SUBCLASS
-   .. data:: Py_TPFLAGS_UNICODE_SUBCLASS
-   .. data:: Py_TPFLAGS_DICT_SUBCLASS
-   .. data:: Py_TPFLAGS_BASE_EXC_SUBCLASS
-   .. data:: Py_TPFLAGS_TYPE_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_LONG_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_LIST_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_TUPLE_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_BYTES_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_UNICODE_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_DICT_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_BASE_EXC_SUBCLASS
+   .. c:macro:: Py_TPFLAGS_TYPE_SUBCLASS
 
       These flags are used by functions such as
       :c:func:`PyLong_Check` to quickly determine if a type is a subclass
@@ -1164,7 +1167,7 @@ and :c:type:`PyType_Type` effectively ac
       will behave differently depending on what kind of check is used.
 
 
-   .. data:: Py_TPFLAGS_HAVE_FINALIZE
+   .. c:macro:: Py_TPFLAGS_HAVE_FINALIZE
 
       This bit is set when the :c:member:`~PyTypeObject.tp_finalize` slot is present in the
       type structure.
@@ -1177,7 +1180,7 @@ and :c:type:`PyType_Type` effectively ac
          type structure.
 
 
-   .. data:: Py_TPFLAGS_HAVE_VECTORCALL
+   .. c:macro:: Py_TPFLAGS_HAVE_VECTORCALL
 
       This bit is set when the class implements
       the :ref:`vectorcall protocol <vectorcall>`.
@@ -1186,12 +1189,12 @@ and :c:type:`PyType_Type` effectively ac
       **Inheritance:**
 
       This bit is inherited for types with the
-      :const:`Py_TPFLAGS_IMMUTABLETYPE` flag set, if
+      :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag set, if
       :c:member:`~PyTypeObject.tp_call` is also inherited.
 
       .. versionadded:: 3.9
 
-   .. data:: Py_TPFLAGS_IMMUTABLETYPE
+   .. c:macro:: Py_TPFLAGS_IMMUTABLETYPE
 
       This bit is set for type objects that are immutable: type attributes cannot be set nor deleted.
 
@@ -1204,7 +1207,7 @@ and :c:type:`PyType_Type` effectively ac
 
       .. versionadded:: 3.10
 
-   .. data:: Py_TPFLAGS_DISALLOW_INSTANTIATION
+   .. c:macro:: Py_TPFLAGS_DISALLOW_INSTANTIATION
 
       Disallow creating instances of the type: set
       :c:member:`~PyTypeObject.tp_new` to NULL and don't create the ``__new__``
@@ -1235,7 +1238,7 @@ and :c:type:`PyType_Type` effectively ac
       .. versionadded:: 3.10
 
 
-   .. data:: Py_TPFLAGS_MAPPING
+   .. c:macro:: Py_TPFLAGS_MAPPING
 
       This bit indicates that instances of the class may match mapping patterns
       when used as the subject of a :keyword:`match` block. It is automatically
@@ -1244,20 +1247,20 @@ and :c:type:`PyType_Type` effectively ac
 
       .. note::
 
-         :const:`Py_TPFLAGS_MAPPING` and :const:`Py_TPFLAGS_SEQUENCE` are
+         :c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are
          mutually exclusive; it is an error to enable both flags simultaneously.
 
       **Inheritance:**
 
       This flag is inherited by types that do not already set
-      :const:`Py_TPFLAGS_SEQUENCE`.
+      :c:macro:`Py_TPFLAGS_SEQUENCE`.
 
       .. seealso:: :pep:`634` -- Structural Pattern Matching: Specification
 
       .. versionadded:: 3.10
 
 
-   .. data:: Py_TPFLAGS_SEQUENCE
+   .. c:macro:: Py_TPFLAGS_SEQUENCE
 
       This bit indicates that instances of the class may match sequence patterns
       when used as the subject of a :keyword:`match` block. It is automatically
@@ -1266,13 +1269,13 @@ and :c:type:`PyType_Type` effectively ac
 
       .. note::
 
-         :const:`Py_TPFLAGS_MAPPING` and :const:`Py_TPFLAGS_SEQUENCE` are
+         :c:macro:`Py_TPFLAGS_MAPPING` and :c:macro:`Py_TPFLAGS_SEQUENCE` are
          mutually exclusive; it is an error to enable both flags simultaneously.
 
       **Inheritance:**
 
       This flag is inherited by types that do not already set
-      :const:`Py_TPFLAGS_MAPPING`.
+      :c:macro:`Py_TPFLAGS_MAPPING`.
 
       .. seealso:: :pep:`634` -- Structural Pattern Matching: Specification
 
@@ -1293,7 +1296,7 @@ and :c:type:`PyType_Type` effectively ac
 .. c:member:: traverseproc PyTypeObject.tp_traverse
 
    An optional pointer to a traversal function for the garbage collector.  This is
-   only used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature is::
+   only used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature is::
 
       int tp_traverse(PyObject *self, visitproc visit, void *arg);
 
@@ -1303,8 +1306,8 @@ and :c:type:`PyType_Type` effectively ac
    The :c:member:`~PyTypeObject.tp_traverse` pointer is used by the garbage collector to detect
    reference cycles. A typical implementation of a :c:member:`~PyTypeObject.tp_traverse` function
    simply calls :c:func:`Py_VISIT` on each of the instance's members that are Python
-   objects that the instance owns. For example, this is function :c:func:`local_traverse` from the
-   :mod:`_thread` extension module::
+   objects that the instance owns. For example, this is function :c:func:`!local_traverse` from the
+   :mod:`!_thread` extension module::
 
       static int
       local_traverse(localobject *self, visitproc visit, void *arg)
@@ -1355,10 +1358,10 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`
+   Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`, :c:member:`~PyTypeObject.tp_clear`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_clear` and the
-   :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and
+   :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and
    :c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if they are all zero in
    the subtype.
 
@@ -1366,7 +1369,7 @@ and :c:type:`PyType_Type` effectively ac
 .. c:member:: inquiry PyTypeObject.tp_clear
 
    An optional pointer to a clear function for the garbage collector. This is only
-   used if the :const:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature is::
+   used if the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit is set.  The signature is::
 
       int tp_clear(PyObject *);
 
@@ -1395,9 +1398,10 @@ and :c:type:`PyType_Type` effectively ac
       }
 
    The :c:func:`Py_CLEAR` macro should be used, because clearing references is
-   delicate:  the reference to the contained object must not be decremented until
+   delicate:  the reference to the contained object must not be released
+   (via :c:func:`Py_DECREF`) until
    after the pointer to the contained object is set to ``NULL``.  This is because
-   decrementing the reference count may cause the contained object to become trash,
+   releasing the reference may cause the contained object to become trash,
    triggering a chain of reclamation activity that may include invoking arbitrary
    Python code (due to finalizers, or weakref callbacks, associated with the
    contained object). If it's possible for such code to reference *self* again,
@@ -1422,10 +1426,10 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :const:`Py_TPFLAGS_HAVE_GC`, :attr:`tp_traverse`, :attr:`tp_clear`
+   Group: :c:macro:`Py_TPFLAGS_HAVE_GC`, :c:member:`~PyTypeObject.tp_traverse`, :c:member:`~PyTypeObject.tp_clear`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_traverse` and the
-   :const:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and
+   :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit: the flag bit, :c:member:`~PyTypeObject.tp_traverse`, and
    :c:member:`~PyTypeObject.tp_clear` are all inherited from the base type if they are all zero in
    the subtype.
 
@@ -1447,21 +1451,23 @@ and :c:type:`PyType_Type` effectively ac
    The following constants are defined to be used as the third argument for
    :c:member:`~PyTypeObject.tp_richcompare` and for :c:func:`PyObject_RichCompare`:
 
-   +----------------+------------+
-   | Constant       | Comparison |
-   +================+============+
-   | :const:`Py_LT` | ``<``      |
-   +----------------+------------+
-   | :const:`Py_LE` | ``<=``     |
-   +----------------+------------+
-   | :const:`Py_EQ` | ``==``     |
-   +----------------+------------+
-   | :const:`Py_NE` | ``!=``     |
-   +----------------+------------+
-   | :const:`Py_GT` | ``>``      |
-   +----------------+------------+
-   | :const:`Py_GE` | ``>=``     |
-   +----------------+------------+
+   .. c:namespace:: NULL
+
+   +--------------------+------------+
+   | Constant           | Comparison |
+   +====================+============+
+   | .. c:macro:: Py_LT | ``<``      |
+   +--------------------+------------+
+   | .. c:macro:: Py_LE | ``<=``     |
+   +--------------------+------------+
+   | .. c:macro:: Py_EQ | ``==``     |
+   +--------------------+------------+
+   | .. c:macro:: Py_NE | ``!=``     |
+   +--------------------+------------+
+   | .. c:macro:: Py_GT | ``>``      |
+   +--------------------+------------+
+   | .. c:macro:: Py_GE | ``>=``     |
+   +--------------------+------------+
 
    The following macro is defined to ease writing rich comparison functions:
 
@@ -1473,7 +1479,7 @@ and :c:type:`PyType_Type` effectively ac
       they may be C ints or floats). The third argument specifies the requested
       operation, as for :c:func:`PyObject_RichCompare`.
 
-      The return value's reference count is properly incremented.
+      The returned value is a new :term:`strong reference`.
 
       On error, sets an exception and returns ``NULL`` from the function.
 
@@ -1481,7 +1487,7 @@ and :c:type:`PyType_Type` effectively ac
 
    **Inheritance:**
 
-   Group: :attr:`tp_hash`, :attr:`tp_richcompare`
+   Group: :c:member:`~PyTypeObject.tp_hash`, :c:member:`~PyTypeObject.tp_richcompare`
 
    This field is inherited by subtypes together with :c:member:`~PyTypeObject.tp_hash`:
    a subtype inherits :c:member:`~PyTypeObject.tp_richcompare` and :c:member:`~PyTypeObject.tp_hash` when
@@ -1490,9 +1496,9 @@ and :c:type:`PyType_Type` effectively ac
 
    **Default:**
 
-   :c:type:`PyBaseObject_Type` provides a :attr:`tp_richcompare`
+   :c:data:`PyBaseObject_Type` provides a :c:member:`~PyTypeObject.tp_richcompare`
    implementation, which may be inherited.  However, if only
-   :attr:`tp_hash` is defined, not even the inherited function is used
+   :c:member:`~PyTypeObject.tp_hash` is defined, not even the inherited function is used
    and instances of the type will not be able to participate in any
    comparisons.
 
@@ -1654,7 +1660,7 @@ and :c:type:`PyType_Type` effectively ac
    called; it may also be initialized to a dictionary containing initial attributes
    for the type.  Once :c:func:`PyType_Ready` has initialized the type, extra
    attributes for the type may be added to this dictionary only if they don't
-   correspond to overloaded operations (like :meth:`__add__`).
+   correspond to overloaded operations (like :meth:`~object.__add__`).
 
    **Inheritance:**
 
@@ -1755,17 +1761,17 @@ and :c:type:`PyType_Type` effectively ac
    **Default:**
 
    This slot has no default.  For :ref:`static types <static-types>`, if the
-   field is ``NULL`` then no :attr:`__dict__` gets created for instances.
+   field is ``NULL`` then no :attr:`~object.__dict__` gets created for instances.
 
 
 .. c:member:: initproc PyTypeObject.tp_init
 
    An optional pointer to an instance initialization function.
 
-   This function corresponds to the :meth:`__init__` method of classes.  Like
-   :meth:`__init__`, it is possible to create an instance without calling
-   :meth:`__init__`, and it is possible to reinitialize an instance by calling its
-   :meth:`__init__` method again.
+   This function corresponds to the :meth:`~object.__init__` method of classes.  Like
+   :meth:`!__init__`, it is possible to create an instance without calling
+   :meth:`!__init__`, and it is possible to reinitialize an instance by calling its
+   :meth:`!__init__` method again.
 
    The function signature is::
 
@@ -1773,7 +1779,7 @@ and :c:type:`PyType_Type` effectively ac
 
    The self argument is the instance to be initialized; the *args* and *kwds*
    arguments represent positional and keyword arguments of the call to
-   :meth:`__init__`.
+   :meth:`~object.__init__`.
 
    The :c:member:`~PyTypeObject.tp_init` function, if not ``NULL``, is called when an instance is
    created normally by calling its type, after the type's :c:member:`~PyTypeObject.tp_new` function
@@ -1812,7 +1818,7 @@ and :c:type:`PyType_Type` effectively ac
    :c:func:`PyType_GenericAlloc`, to force a standard heap
    allocation strategy.
 
-   For static subtypes, :c:type:`PyBaseObject_Type` uses
+   For static subtypes, :c:data:`PyBaseObject_Type` uses
    :c:func:`PyType_GenericAlloc`.  That is the recommended value
    for all statically defined types.
 
@@ -1839,7 +1845,7 @@ and :c:type:`PyType_Type` effectively ac
    in :c:member:`~PyTypeObject.tp_new`, while for mutable types, most initialization should be
    deferred to :c:member:`~PyTypeObject.tp_init`.
 
-   Set the :const:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow creating
+   Set the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag to disallow creating
    instances of the type in Python.
 
    **Inheritance:**
@@ -1873,9 +1879,9 @@ and :c:type:`PyType_Type` effectively ac
 
    In dynamic subtypes, this field is set to a deallocator suitable to
    match :c:func:`PyType_GenericAlloc` and the value of the
-   :const:`Py_TPFLAGS_HAVE_GC` flag bit.
+   :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit.
 
-   For static subtypes, :c:type:`PyBaseObject_Type` uses PyObject_Del.
+   For static subtypes, :c:data:`PyBaseObject_Type` uses :c:func:`PyObject_Del`.
 
 
 .. c:member:: inquiry PyTypeObject.tp_is_gc
@@ -1884,7 +1890,7 @@ and :c:type:`PyType_Type` effectively ac
 
    The garbage collector needs to know whether a particular object is collectible
    or not.  Normally, it is sufficient to look at the object's type's
-   :c:member:`~PyTypeObject.tp_flags` field, and check the :const:`Py_TPFLAGS_HAVE_GC` flag bit.  But
+   :c:member:`~PyTypeObject.tp_flags` field, and check the :c:macro:`Py_TPFLAGS_HAVE_GC` flag bit.  But
    some types have a mixture of statically and dynamically allocated instances, and
    the statically allocated instances are not collectible.  Such types should
    define this function; it should return ``1`` for a collectible instance, and
@@ -1903,7 +1909,7 @@ and :c:type:`PyType_Type` effectively ac
    **Default:**
 
    This slot has no default.  If this field is ``NULL``,
-   :const:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent.
+   :c:macro:`Py_TPFLAGS_HAVE_GC` is used as the functional equivalent.
 
 
 .. c:member:: PyObject* PyTypeObject.tp_bases
@@ -2035,7 +2041,7 @@ and :c:type:`PyType_Type` effectively ac
    .. versionchanged:: 3.8
 
       Before version 3.8 it was necessary to set the
-      :const:`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be
+      :c:macro:`Py_TPFLAGS_HAVE_FINALIZE` flags bit in order for this field to be
       used.  This is no longer required.
 
    .. seealso:: "Safe object finalization" (:pep:`442`)
@@ -2047,7 +2053,7 @@ and :c:type:`PyType_Type` effectively ac
    In other words, it is used to implement
    :ref:`vectorcall <vectorcall>` for ``type.__call__``.
    If ``tp_vectorcall`` is ``NULL``, the default call implementation
-   using :attr:`__new__` and :attr:`__init__` is used.
+   using :meth:`~object.__new__` and :meth:`~object.__init__` is used.
 
    **Inheritance:**
 
@@ -2087,7 +2093,7 @@ Heap Types
 
 An alternative to :ref:`static types <static-types>` is *heap-allocated types*,
 or *heap types* for short, which correspond closely to classes created by
-Python's ``class`` statement. Heap types have the :const:`Py_TPFLAGS_HEAPTYPE`
+Python's ``class`` statement. Heap types have the :c:macro:`Py_TPFLAGS_HEAPTYPE`
 flag set.
 
 This is done by filling a :c:type:`PyType_Spec` structure and calling
@@ -2167,8 +2173,8 @@ Number Object Structures
 
    .. note::
 
-      The :c:data:`nb_reserved` field should always be ``NULL``.  It
-      was previously called :c:data:`nb_long`, and was renamed in
+      The :c:member:`~PyNumberMethods.nb_reserved` field should always be ``NULL``.  It
+      was previously called :c:member:`!nb_long`, and was renamed in
       Python 3.0.1.
 
 .. c:member:: binaryfunc PyNumberMethods.nb_add
@@ -2239,8 +2245,8 @@ Mapping Object Structures
 .. c:member:: objobjargproc PyMappingMethods.mp_ass_subscript
 
    This function is used by :c:func:`PyObject_SetItem`,
-   :c:func:`PyObject_DelItem`, :c:func:`PyObject_SetSlice` and
-   :c:func:`PyObject_DelSlice`.  It has the same signature as
+   :c:func:`PyObject_DelItem`, :c:func:`PySequence_SetSlice` and
+   :c:func:`PySequence_DelSlice`.  It has the same signature as
    :c:func:`!PyObject_SetItem`, but *v* can also be set to ``NULL`` to delete
    an item.  If this slot is ``NULL``, the object does not support item
    assignment and deletion.
@@ -2286,9 +2292,9 @@ Sequence Object Structures
    This slot must be filled for the :c:func:`PySequence_Check`
    function to return ``1``, it can be ``NULL`` otherwise.
 
-   Negative indexes are handled as follows: if the :attr:`sq_length` slot is
+   Negative indexes are handled as follows: if the :c:member:`~PySequenceMethods.sq_length` slot is
    filled, it is called and the sequence length is used to compute a positive
-   index which is passed to :attr:`sq_item`.  If :attr:`sq_length` is ``NULL``,
+   index which is passed to  :c:member:`~PySequenceMethods.sq_item`.  If :c:member:`!sq_length` is ``NULL``,
    the index is passed as is to the function.
 
 .. c:member:: ssizeobjargproc PySequenceMethods.sq_ass_item
@@ -2462,7 +2468,7 @@ Async Object Structures
       PyObject *am_aiter(PyObject *self);
 
    Must return an :term:`asynchronous iterator` object.
-   See :meth:`__anext__` for details.
+   See :meth:`~object.__anext__` for details.
 
    This slot may be set to ``NULL`` if an object does not implement
    asynchronous iteration protocol.
@@ -2473,7 +2479,8 @@ Async Object Structures
 
       PyObject *am_anext(PyObject *self);
 
-   Must return an :term:`awaitable` object.  See :meth:`__anext__` for details.
+   Must return an :term:`awaitable` object.
+   See :meth:`~object.__anext__` for details.
    This slot may be set to ``NULL``.
 
 .. c:member:: sendfunc PyAsyncMethods.am_send
@@ -2498,8 +2505,8 @@ Slot Type typedefs
    The purpose of this function is to separate memory allocation from memory
    initialization.  It should return a pointer to a block of memory of adequate
    length for the instance, suitably aligned, and initialized to zeros, but with
-   :attr:`ob_refcnt` set to ``1`` and :attr:`ob_type` set to the type argument.  If
-   the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, the object's :attr:`ob_size` field
+   :c:member:`~PyObject.ob_refcnt` set to ``1`` and :c:member:`~PyObject.ob_type` set to the type argument.  If
+   the type's :c:member:`~PyTypeObject.tp_itemsize` is non-zero, the object's :c:member:`~PyVarObject.ob_size` field
    should be initialized to *nitems* and the length of the allocated memory block
    should be ``tp_basicsize + nitems*tp_itemsize``, rounded up to a multiple of
    ``sizeof(void*)``; otherwise, *nitems* is not used and the length of the block
@@ -2697,7 +2704,7 @@ A type that supports weakrefs, instance
 
 A str subclass that cannot be subclassed and cannot be called
 to create instances (e.g. uses a separate factory func) using
-:c:data:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::
+:c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag::
 
    typedef struct {
        PyUnicodeObject raw;
--- a/Doc/c-api/unicode.rst
+++ b/Doc/c-api/unicode.rst
@@ -58,7 +58,7 @@ Python:
 
 .. c:type:: Py_UNICODE
 
-   This is a typedef of :c:expr:`wchar_t`, which is a 16-bit type or 32-bit type
+   This is a typedef of :c:type:`wchar_t`, which is a 16-bit type or 32-bit type
    depending on the platform.
 
    .. versionchanged:: 3.3
@@ -576,7 +576,7 @@ APIs:
 
    Copy an instance of a Unicode subtype to a new true Unicode object if
    necessary. If *obj* is already a true Unicode object (not a subtype),
-   return the reference with incremented refcount.
+   return a new :term:`strong reference` to the object.
 
    Objects other than Unicode or its subtypes will cause a :exc:`TypeError`.
 
@@ -613,7 +613,7 @@ APIs:
                                                     Py_ssize_t how_many)
 
    Copy characters from one Unicode object into another.  This function performs
-   character conversion when necessary and falls back to :c:func:`memcpy` if
+   character conversion when necessary and falls back to :c:func:`!memcpy` if
    possible.  Returns ``-1`` and sets an exception on error, otherwise returns
    the number of copied characters.
 
@@ -800,7 +800,7 @@ system.
 .. c:function:: PyObject* PyUnicode_DecodeLocale(const char *str, const char *errors)
 
    Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string
-   length using :c:func:`strlen`.
+   length using :c:func:`!strlen`.
 
    .. versionadded:: 3.3
 
@@ -935,11 +935,11 @@ conversion function:
 wchar_t Support
 """""""""""""""
 
-:c:expr:`wchar_t` support for platforms which support it:
+:c:type:`wchar_t` support for platforms which support it:
 
 .. c:function:: PyObject* PyUnicode_FromWideChar(const wchar_t *w, Py_ssize_t size)
 
-   Create a Unicode object from the :c:expr:`wchar_t` buffer *w* of the given *size*.
+   Create a Unicode object from the :c:type:`wchar_t` buffer *w* of the given *size*.
    Passing ``-1`` as the *size* indicates that the function must itself compute the length,
    using wcslen.
    Return ``NULL`` on failure.
@@ -947,9 +947,9 @@ wchar_t Support
 
 .. c:function:: Py_ssize_t PyUnicode_AsWideChar(PyObject *unicode, wchar_t *w, Py_ssize_t size)
 
-   Copy the Unicode object contents into the :c:expr:`wchar_t` buffer *w*.  At most
-   *size* :c:expr:`wchar_t` characters are copied (excluding a possibly trailing
-   null termination character).  Return the number of :c:expr:`wchar_t` characters
+   Copy the Unicode object contents into the :c:type:`wchar_t` buffer *w*.  At most
+   *size* :c:type:`wchar_t` characters are copied (excluding a possibly trailing
+   null termination character).  Return the number of :c:type:`wchar_t` characters
    copied or ``-1`` in case of an error.  Note that the resulting :c:expr:`wchar_t*`
    string may or may not be null-terminated.  It is the responsibility of the caller
    to make sure that the :c:expr:`wchar_t*` string is null-terminated in case this is
@@ -963,12 +963,12 @@ wchar_t Support
    Convert the Unicode object to a wide character string. The output string
    always ends with a null character. If *size* is not ``NULL``, write the number
    of wide characters (excluding the trailing null termination character) into
-   *\*size*. Note that the resulting :c:expr:`wchar_t` string might contain
+   *\*size*. Note that the resulting :c:type:`wchar_t` string might contain
    null characters, which would cause the string to be truncated when used with
    most C functions. If *size* is ``NULL`` and the :c:expr:`wchar_t*` string
    contains null characters a :exc:`ValueError` is raised.
 
-   Returns a buffer allocated by :c:func:`PyMem_Alloc` (use
+   Returns a buffer allocated by :c:macro:`PyMem_New` (use
    :c:func:`PyMem_Free` to free it) on success. On error, returns ``NULL``
    and *\*size* is undefined. Raises a :exc:`MemoryError` if memory allocation
    is failed.
@@ -1304,9 +1304,9 @@ Character Map Codecs
 
 This codec is special in that it can be used to implement many different codecs
 (and this is in fact what was done to obtain most of the standard codecs
-included in the :mod:`encodings` package). The codec uses mappings to encode and
+included in the :mod:`!encodings` package). The codec uses mappings to encode and
 decode characters.  The mapping objects provided must support the
-:meth:`__getitem__` mapping interface; dictionaries and sequences work well.
+:meth:`~object.__getitem__` mapping interface; dictionaries and sequences work well.
 
 These are the mapping codec APIs:
 
@@ -1349,7 +1349,7 @@ The following codec API is special in th
    The mapping table must map Unicode ordinal integers to Unicode ordinal integers
    or ``None`` (causing deletion of the character).
 
-   Mapping tables need only provide the :meth:`__getitem__` interface; dictionaries
+   Mapping tables need only provide the :meth:`~object.__getitem__` interface; dictionaries
    and sequences work well.  Unmapped character ordinals (ones which cause a
    :exc:`LookupError`) are left untouched and are copied as-is.
 
@@ -1391,7 +1391,7 @@ the user settings on the machine running
 
    Encode the Unicode object using the specified code page and return a Python
    bytes object.  Return ``NULL`` if an exception was raised by the codec. Use
-   :c:data:`CP_ACP` code page to get the MBCS encoder.
+   :c:macro:`CP_ACP` code page to get the MBCS encoder.
 
    .. versionadded:: 3.3
 
@@ -1510,11 +1510,11 @@ They all return ``NULL`` or ``-1`` if an
    Rich compare two Unicode strings and return one of the following:
 
    * ``NULL`` in case an exception was raised
-   * :const:`Py_True` or :const:`Py_False` for successful comparisons
-   * :const:`Py_NotImplemented` in case the type combination is unknown
+   * :c:data:`Py_True` or :c:data:`Py_False` for successful comparisons
+   * :c:data:`Py_NotImplemented` in case the type combination is unknown
 
-   Possible values for *op* are :const:`Py_GT`, :const:`Py_GE`, :const:`Py_EQ`,
-   :const:`Py_NE`, :const:`Py_LT`, and :const:`Py_LE`.
+   Possible values for *op* are :c:macro:`Py_GT`, :c:macro:`Py_GE`, :c:macro:`Py_EQ`,
+   :c:macro:`Py_NE`, :c:macro:`Py_LT`, and :c:macro:`Py_LE`.
 
 
 .. c:function:: PyObject* PyUnicode_Format(PyObject *format, PyObject *args)
@@ -1537,11 +1537,11 @@ They all return ``NULL`` or ``-1`` if an
    Intern the argument *\*string* in place.  The argument must be the address of a
    pointer variable pointing to a Python Unicode string object.  If there is an
    existing interned string that is the same as *\*string*, it sets *\*string* to
-   it (decrementing the reference count of the old string object and incrementing
-   the reference count of the interned string object), otherwise it leaves
-   *\*string* alone and interns it (incrementing its reference count).
-   (Clarification: even though there is a lot of talk about reference counts, think
-   of this function as reference-count-neutral; you own the object after the call
+   it (releasing the reference to the old string object and creating a new
+   :term:`strong reference` to the interned string object), otherwise it leaves
+   *\*string* alone and interns it (creating a new :term:`strong reference`).
+   (Clarification: even though there is a lot of talk about references, think
+   of this function as reference-neutral; you own the object after the call
    if and only if you owned it before the call.)
 
 
--- a/Doc/c-api/veryhigh.rst
+++ b/Doc/c-api/veryhigh.rst
@@ -12,12 +12,12 @@ file or a buffer, but they will not let
 the interpreter.
 
 Several of these functions accept a start symbol from the grammar as a
-parameter.  The available start symbols are :const:`Py_eval_input`,
-:const:`Py_file_input`, and :const:`Py_single_input`.  These are described
+parameter.  The available start symbols are :c:data:`Py_eval_input`,
+:c:data:`Py_file_input`, and :c:data:`Py_single_input`.  These are described
 following the functions which accept them as parameters.
 
 Note also that several of these functions take :c:expr:`FILE*` parameters.  One
-particular issue which needs to be handled carefully is that the :c:expr:`FILE`
+particular issue which needs to be handled carefully is that the :c:type:`FILE`
 structure for different C libraries can be different and incompatible.  Under
 Windows (at least), it is possible for dynamically linked extensions to actually
 use different libraries, so care should be taken that :c:expr:`FILE*` parameters
@@ -248,8 +248,8 @@ the same library that the Python runtime
 
    Parse and compile the Python source code in *str*, returning the resulting code
    object.  The start token is given by *start*; this can be used to constrain the
-   code which can be compiled and should be :const:`Py_eval_input`,
-   :const:`Py_file_input`, or :const:`Py_single_input`.  The filename specified by
+   code which can be compiled and should be :c:data:`Py_eval_input`,
+   :c:data:`Py_file_input`, or :c:data:`Py_single_input`.  The filename specified by
    *filename* is used to construct the code object and may appear in tracebacks or
    :exc:`SyntaxError` exception messages.  This returns ``NULL`` if the code
    cannot be parsed or compiled.
@@ -345,7 +345,7 @@ the same library that the Python runtime
    executed, it is passed as ``PyCompilerFlags *flags``.  In this case, ``from
    __future__ import`` can modify *flags*.
 
-   Whenever ``PyCompilerFlags *flags`` is ``NULL``, :attr:`cf_flags` is treated as
+   Whenever ``PyCompilerFlags *flags`` is ``NULL``, :c:member:`~PyCompilerFlags.cf_flags` is treated as
    equal to ``0``, and any modification due to ``from __future__ import`` is
    discarded.
 
@@ -359,7 +359,7 @@ the same library that the Python runtime
       initialized to ``PY_MINOR_VERSION``.
 
       The field is ignored by default, it is used if and only if
-      ``PyCF_ONLY_AST`` flag is set in *cf_flags*.
+      ``PyCF_ONLY_AST`` flag is set in :c:member:`~PyCompilerFlags.cf_flags`.
 
    .. versionchanged:: 3.8
       Added *cf_feature_version* field.
--- a/Doc/c-api/weakref.rst
+++ b/Doc/c-api/weakref.rst
@@ -11,18 +11,18 @@ simple reference object, and the second
 as much as it can.
 
 
-.. c:function:: int PyWeakref_Check(ob)
+.. c:function:: int PyWeakref_Check(PyObject *ob)
 
    Return true if *ob* is either a reference or proxy object.  This function
    always succeeds.
 
 
-.. c:function:: int PyWeakref_CheckRef(ob)
+.. c:function:: int PyWeakref_CheckRef(PyObject *ob)
 
    Return true if *ob* is a reference object.  This function always succeeds.
 
 
-.. c:function:: int PyWeakref_CheckProxy(ob)
+.. c:function:: int PyWeakref_CheckProxy(PyObject *ob)
 
    Return true if *ob* is a proxy object.  This function always succeeds.
 
@@ -54,7 +54,7 @@ as much as it can.
 .. c:function:: PyObject* PyWeakref_GetObject(PyObject *ref)
 
    Return the referenced object from a weak reference, *ref*.  If the referent is
-   no longer live, returns :const:`Py_None`.
+   no longer live, returns ``Py_None``.
 
    .. note::
 
--- a/Doc/conf.py
+++ b/Doc/conf.py
@@ -72,12 +72,98 @@ if venvdir is not None:
     exclude_patterns.append(venvdir + '/*')
 
 nitpick_ignore = [
+    # Standard C functions
+    ('c:func', 'calloc'),
+    ('c:func', 'dlopen'),
+    ('c:func', 'exec'),
+    ('c:func', 'fcntl'),
+    ('c:func', 'fork'),
+    ('c:func', 'free'),
+    ('c:func', 'gmtime'),
+    ('c:func', 'localtime'),
+    ('c:func', 'main'),
+    ('c:func', 'malloc'),
+    ('c:func', 'printf'),
+    ('c:func', 'realloc'),
+    ('c:func', 'snprintf'),
+    ('c:func', 'sprintf'),
+    ('c:func', 'stat'),
+    ('c:func', 'system'),
+    ('c:func', 'vsnprintf'),
+    # Standard C types
+    ('c:type', 'FILE'),
+    ('c:type', 'int64_t'),
+    ('c:type', 'intmax_t'),
+    ('c:type', 'off_t'),
+    ('c:type', 'ptrdiff_t'),
+    ('c:type', 'siginfo_t'),
+    ('c:type', 'size_t'),
+    ('c:type', 'ssize_t'),
+    ('c:type', 'time_t'),
+    ('c:type', 'uint64_t'),
+    ('c:type', 'uintmax_t'),
+    ('c:type', 'uintptr_t'),
+    ('c:type', 'va_list'),
+    ('c:type', 'wchar_t'),
+    # Standard C structures
+    ('c:struct', 'in6_addr'),
+    ('c:struct', 'in_addr'),
+    ('c:struct', 'stat'),
+    ('c:struct', 'statvfs'),
+    # Standard C macros
+    ('c:macro', 'LLONG_MAX'),
+    ('c:macro', 'LLONG_MIN'),
+    ('c:macro', 'LONG_MAX'),
+    ('c:macro', 'LONG_MIN'),
+    # Standard C variables
+    ('c:data', 'errno'),
+    # Standard environment variables
+    ('envvar', 'BROWSER'),
+    ('envvar', 'COLUMNS'),
+    ('envvar', 'COMSPEC'),
+    ('envvar', 'DISPLAY'),
+    ('envvar', 'HOME'),
+    ('envvar', 'HOMEDRIVE'),
+    ('envvar', 'HOMEPATH'),
+    ('envvar', 'IDLESTARTUP'),
+    ('envvar', 'LANG'),
+    ('envvar', 'LANGUAGE'),
+    ('envvar', 'LC_ALL'),
+    ('envvar', 'LC_CTYPE'),
+    ('envvar', 'LC_COLLATE'),
+    ('envvar', 'LC_MESSAGES'),
+    ('envvar', 'LC_MONETARY'),
+    ('envvar', 'LC_NUMERIC'),
+    ('envvar', 'LC_TIME'),
+    ('envvar', 'LINES'),
+    ('envvar', 'LOGNAME'),
+    ('envvar', 'PAGER'),
+    ('envvar', 'PATH'),
+    ('envvar', 'PATHEXT'),
+    ('envvar', 'SOURCE_DATE_EPOCH'),
+    ('envvar', 'TEMP'),
+    ('envvar', 'TERM'),
+    ('envvar', 'TMP'),
+    ('envvar', 'TMPDIR'),
+    ('envvar', 'TZ'),
+    ('envvar', 'USER'),
+    ('envvar', 'USERNAME'),
+    ('envvar', 'USERPROFILE'),
     # Do not error nit-picky mode builds when _SubParsersAction.add_parser cannot
     # be resolved, as the method is currently undocumented. For context, see
     # https://github.com/python/cpython/pull/103289.
     ('py:meth', '_SubParsersAction.add_parser'),
 ]
 
+# gh-106948: Copy standard C types declared in the "c:type" domain to the
+# "c:identifier" domain, since "c:function" markup looks for types in the
+# "c:identifier" domain. Use list() to not iterate on items which are being
+# added
+for role, name in list(nitpick_ignore):
+    if role == 'c:type':
+        nitpick_ignore.append(('c:identifier', name))
+del role, name
+
 # Disable Docutils smartquotes for several translations
 smartquotes_excludes = {
     'languages': ['ja', 'fr', 'zh_TW', 'zh_CN'], 'builders': ['man', 'text'],
--- a/Doc/extending/embedding.rst
+++ b/Doc/extending/embedding.rst
@@ -250,7 +250,7 @@ following two statements before the call
    PyImport_AppendInittab("emb", &PyInit_emb);
 
 These two lines initialize the ``numargs`` variable, and make the
-:func:`emb.numargs` function accessible to the embedded Python interpreter.
+:func:`!emb.numargs` function accessible to the embedded Python interpreter.
 With these extensions, the Python script can do things like
 
 .. code-block:: python
--- a/Doc/extending/extending.rst
+++ b/Doc/extending/extending.rst
@@ -195,7 +195,7 @@ The choice of which exception to raise i
 C objects corresponding to all built-in Python exceptions, such as
 :c:data:`PyExc_ZeroDivisionError`, which you can use directly. Of course, you
 should choose exceptions wisely --- don't use :c:data:`PyExc_TypeError` to mean
-that a file couldn't be opened (that should probably be :c:data:`PyExc_IOError`).
+that a file couldn't be opened (that should probably be :c:data:`PyExc_OSError`).
 If something's wrong with the argument list, the :c:func:`PyArg_ParseTuple`
 function usually raises :c:data:`PyExc_TypeError`.  If you have an argument whose
 value must be in a particular range or must satisfy other conditions,
@@ -206,7 +206,7 @@ usually declare a static object variable
 
    static PyObject *SpamError;
 
-and initialize it in your module's initialization function (:c:func:`PyInit_spam`)
+and initialize it in your module's initialization function (:c:func:`!PyInit_spam`)
 with an exception object::
 
    PyMODINIT_FUNC
@@ -230,22 +230,22 @@ with an exception object::
        return m;
    }
 
-Note that the Python name for the exception object is :exc:`spam.error`.  The
+Note that the Python name for the exception object is :exc:`!spam.error`.  The
 :c:func:`PyErr_NewException` function may create a class with the base class
 being :exc:`Exception` (unless another class is passed in instead of ``NULL``),
 described in :ref:`bltin-exceptions`.
 
-Note also that the :c:data:`SpamError` variable retains a reference to the newly
+Note also that the :c:data:`!SpamError` variable retains a reference to the newly
 created exception class; this is intentional!  Since the exception could be
 removed from the module by external code, an owned reference to the class is
-needed to ensure that it will not be discarded, causing :c:data:`SpamError` to
+needed to ensure that it will not be discarded, causing :c:data:`!SpamError` to
 become a dangling pointer. Should it become a dangling pointer, C code which
 raises the exception could cause a core dump or other unintended side effects.
 
 We discuss the use of ``PyMODINIT_FUNC`` as a function return type later in this
 sample.
 
-The :exc:`spam.error` exception can be raised in your extension module using a
+The :exc:`!spam.error` exception can be raised in your extension module using a
 call to :c:func:`PyErr_SetString` as shown below::
 
    static PyObject *
@@ -279,9 +279,9 @@ statement::
 It returns ``NULL`` (the error indicator for functions returning object pointers)
 if an error is detected in the argument list, relying on the exception set by
 :c:func:`PyArg_ParseTuple`.  Otherwise the string value of the argument has been
-copied to the local variable :c:data:`command`.  This is a pointer assignment and
+copied to the local variable :c:data:`!command`.  This is a pointer assignment and
 you are not supposed to modify the string to which it points (so in Standard C,
-the variable :c:data:`command` should properly be declared as ``const char
+the variable :c:data:`!command` should properly be declared as ``const char
 *command``).
 
 The next statement is a call to the Unix function :c:func:`system`, passing it
@@ -289,7 +289,7 @@ the string we just got from :c:func:`PyA
 
    sts = system(command);
 
-Our :func:`spam.system` function must return the value of :c:data:`sts` as a
+Our :func:`!spam.system` function must return the value of :c:data:`!sts` as a
 Python object.  This is done using the function :c:func:`PyLong_FromLong`. ::
 
    return PyLong_FromLong(sts);
@@ -315,7 +315,7 @@ contexts, as we have seen.
 The Module's Method Table and Initialization Function
 =====================================================
 
-I promised to show how :c:func:`spam_system` is called from Python programs.
+I promised to show how :c:func:`!spam_system` is called from Python programs.
 First, we need to list its name and address in a "method table"::
 
    static PyMethodDef SpamMethods[] = {
@@ -335,7 +335,7 @@ When using only ``METH_VARARGS``, the fu
 parameters to be passed in as a tuple acceptable for parsing via
 :c:func:`PyArg_ParseTuple`; more information on this function is provided below.
 
-The :const:`METH_KEYWORDS` bit may be set in the third field if keyword
+The :c:macro:`METH_KEYWORDS` bit may be set in the third field if keyword
 arguments should be passed to the function.  In this case, the C function should
 accept a third ``PyObject *`` parameter which will be a dictionary of keywords.
 Use :c:func:`PyArg_ParseTupleAndKeywords` to parse the arguments to such a
@@ -354,7 +354,7 @@ The method table must be referenced in t
 
 This structure, in turn, must be passed to the interpreter in the module's
 initialization function.  The initialization function must be named
-:c:func:`PyInit_name`, where *name* is the name of the module, and should be the
+:c:func:`!PyInit_name`, where *name* is the name of the module, and should be the
 only non-\ ``static`` item defined in the module file::
 
    PyMODINIT_FUNC
@@ -367,8 +367,8 @@ Note that PyMODINIT_FUNC declares the fu
 declares any special linkage declarations required by the platform, and for C++
 declares the function as ``extern "C"``.
 
-When the Python program imports module :mod:`spam` for the first time,
-:c:func:`PyInit_spam` is called. (See below for comments about embedding Python.)
+When the Python program imports module :mod:`!spam` for the first time,
+:c:func:`!PyInit_spam` is called. (See below for comments about embedding Python.)
 It calls :c:func:`PyModule_Create`, which returns a module object, and
 inserts built-in function objects into the newly created module based upon the
 table (an array of :c:type:`PyMethodDef` structures) found in the module definition.
@@ -378,7 +378,7 @@ certain errors, or return ``NULL`` if th
 satisfactorily. The init function must return the module object to its caller,
 so that it then gets inserted into ``sys.modules``.
 
-When embedding Python, the :c:func:`PyInit_spam` function is not called
+When embedding Python, the :c:func:`!PyInit_spam` function is not called
 automatically unless there's an entry in the :c:data:`PyImport_Inittab` table.
 To add the module to the initialization table, use :c:func:`PyImport_AppendInittab`,
 optionally followed by an import of the module::
@@ -527,7 +527,7 @@ be part of a module definition::
    }
 
 This function must be registered with the interpreter using the
-:const:`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The
+:c:macro:`METH_VARARGS` flag; this is described in section :ref:`methodtable`.  The
 :c:func:`PyArg_ParseTuple` function and its arguments are documented in section
 :ref:`parsetuple`.
 
@@ -1030,13 +1030,13 @@ Let's follow the control flow into :c:fu
 references to all its items, so when item 1 is replaced, it has to dispose of
 the original item 1.  Now let's suppose the original item 1 was an instance of a
 user-defined class, and let's further suppose that the class defined a
-:meth:`__del__` method.  If this class instance has a reference count of 1,
-disposing of it will call its :meth:`__del__` method.
+:meth:`!__del__` method.  If this class instance has a reference count of 1,
+disposing of it will call its :meth:`!__del__` method.
 
-Since it is written in Python, the :meth:`__del__` method can execute arbitrary
+Since it is written in Python, the :meth:`!__del__` method can execute arbitrary
 Python code.  Could it perhaps do something to invalidate the reference to
-``item`` in :c:func:`bug`?  You bet!  Assuming that the list passed into
-:c:func:`bug` is accessible to the :meth:`__del__` method, it could execute a
+``item`` in :c:func:`!bug`?  You bet!  Assuming that the list passed into
+:c:func:`!bug` is accessible to the :meth:`!__del__` method, it could execute a
 statement to the effect of ``del list[0]``, and assuming this was the last
 reference to that object, it would free the memory associated with it, thereby
 invalidating ``item``.
@@ -1057,7 +1057,7 @@ increment the reference count.  The corr
 
 This is a true story.  An older version of Python contained variants of this bug
 and someone spent a considerable amount of time in a C debugger to figure out
-why his :meth:`__del__` methods would fail...
+why his :meth:`!__del__` methods would fail...
 
 The second case of problems with a borrowed reference is a variant involving
 threads.  Normally, multiple threads in the Python interpreter can't get in each
@@ -1208,14 +1208,14 @@ file corresponding to the module provide
 the module and retrieving its C API pointers; client modules only have to call
 this macro before accessing the C API.
 
-The exporting module is a modification of the :mod:`spam` module from section
-:ref:`extending-simpleexample`. The function :func:`spam.system` does not call
+The exporting module is a modification of the :mod:`!spam` module from section
+:ref:`extending-simpleexample`. The function :func:`!spam.system` does not call
 the C library function :c:func:`system` directly, but a function
-:c:func:`PySpam_System`, which would of course do something more complicated in
+:c:func:`!PySpam_System`, which would of course do something more complicated in
 reality (such as adding "spam" to every command). This function
-:c:func:`PySpam_System` is also exported to other extension modules.
+:c:func:`!PySpam_System` is also exported to other extension modules.
 
-The function :c:func:`PySpam_System` is a plain C function, declared
+The function :c:func:`!PySpam_System` is a plain C function, declared
 ``static`` like everything else::
 
    static int
@@ -1224,7 +1224,7 @@ The function :c:func:`PySpam_System` is
        return system(command);
    }
 
-The function :c:func:`spam_system` is modified in a trivial way::
+The function :c:func:`!spam_system` is modified in a trivial way::
 
    static PyObject *
    spam_system(PyObject *self, PyObject *args)
@@ -1278,7 +1278,7 @@ function must take care of initializing
    }
 
 Note that ``PySpam_API`` is declared ``static``; otherwise the pointer
-array would disappear when :func:`PyInit_spam` terminates!
+array would disappear when :c:func:`!PyInit_spam` terminates!
 
 The bulk of the work is in the header file :file:`spammodule.h`, which looks
 like this::
@@ -1332,8 +1332,8 @@ like this::
    #endif /* !defined(Py_SPAMMODULE_H) */
 
 All that a client module must do in order to have access to the function
-:c:func:`PySpam_System` is to call the function (or rather macro)
-:c:func:`import_spam` in its initialization function::
+:c:func:`!PySpam_System` is to call the function (or rather macro)
+:c:func:`!import_spam` in its initialization function::
 
    PyMODINIT_FUNC
    PyInit_client(void)
--- a/Doc/extending/newtypes.rst
+++ b/Doc/extending/newtypes.rst
@@ -270,7 +270,7 @@ structure::
 One entry should be defined for each method provided by the type; no entries are
 needed for methods inherited from a base type.  One additional entry is needed
 at the end; it is a sentinel that marks the end of the array.  The
-:attr:`ml_name` field of the sentinel must be ``NULL``.
+:c:member:`~PyMethodDef.ml_name` field of the sentinel must be ``NULL``.
 
 The second table is used to define attributes which map directly to data stored
 in the instance.  A variety of primitive C types are supported, and access may
@@ -286,9 +286,9 @@ be read-only or read-write.  The structu
 
 For each entry in the table, a :term:`descriptor` will be constructed and added to the
 type which will be able to extract a value from the instance structure.  The
-:attr:`type` field should contain one of the type codes defined in the
+:c:member:`~PyMemberDef.type` field should contain one of the type codes defined in the
 :file:`structmember.h` header; the value will be used to determine how to
-convert Python values to and from C values.  The :attr:`flags` field is used to
+convert Python values to and from C values.  The :c:member:`~PyMemberDef.flags` field is used to
 store flags which control how the attribute can be accessed.
 
 The following flag constants are defined in :file:`structmember.h`; they may be
@@ -305,10 +305,10 @@ combined using bitwise-OR.
 +---------------------------+----------------------------------------------+
 
 .. versionchanged:: 3.10
-   :const:`RESTRICTED`, :const:`READ_RESTRICTED` and :const:`WRITE_RESTRICTED`
-   are deprecated. However, :const:`READ_RESTRICTED` is an alias for
-   :const:`PY_AUDIT_READ`, so fields that specify either :const:`RESTRICTED`
-   or :const:`READ_RESTRICTED` will also raise an audit event.
+   :c:macro:`RESTRICTED`, :c:macro:`READ_RESTRICTED` and :c:macro:`WRITE_RESTRICTED`
+   are deprecated. However, :c:macro:`READ_RESTRICTED` is an alias for
+   :c:macro:`PY_AUDIT_READ`, so fields that specify either :c:macro:`RESTRICTED`
+   or :c:macro:`READ_RESTRICTED` will also raise an audit event.
 
 .. index::
    single: READONLY
@@ -323,7 +323,7 @@ have an associated doc string simply by
 application can use the introspection API to retrieve the descriptor from the
 class object, and get the doc string using its :attr:`__doc__` attribute.
 
-As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry with a :attr:`name` value
+As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry with a :c:member:`~PyMethodDef.name` value
 of ``NULL`` is required.
 
 .. XXX Descriptors need to be explained in more detail somewhere, but not here.
@@ -348,7 +348,7 @@ called, so that if you do need to extend
 what needs to be done.
 
 The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object requires an attribute
-look-up.  It is called in the same situations where the :meth:`__getattr__`
+look-up.  It is called in the same situations where the :meth:`~object.__getattr__`
 method of a class would be called.
 
 Here is an example::
@@ -367,8 +367,8 @@ Here is an example::
        return NULL;
    }
 
-The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:`__setattr__` or
-:meth:`__delattr__` method of a class instance would be called.  When an
+The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:`~object.__setattr__` or
+:meth:`~object.__delattr__` method of a class instance would be called.  When an
 attribute should be deleted, the third parameter will be ``NULL``.  Here is an
 example that simply raises an exception; if this were really all you wanted, the
 :c:member:`~PyTypeObject.tp_setattr` handler should be set to ``NULL``. ::
@@ -389,7 +389,7 @@ Object Comparison
 
 The :c:member:`~PyTypeObject.tp_richcompare` handler is called when comparisons are needed.  It is
 analogous to the :ref:`rich comparison methods <richcmpfuncs>`, like
-:meth:`__lt__`, and also called by :c:func:`PyObject_RichCompare` and
+:meth:`!__lt__`, and also called by :c:func:`PyObject_RichCompare` and
 :c:func:`PyObject_RichCompareBool`.
 
 This function is called with two Python objects and the operator as arguments,
@@ -530,7 +530,7 @@ These functions provide support for the
 take exactly one parameter, the instance for which they are being called,
 and return a new reference.  In the case of an error, they should set an
 exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` corresponds
-to the Python :meth:`__iter__` method, while :c:member:`~PyTypeObject.tp_iternext`
+to the Python :meth:`~object.__iter__` method, while :c:member:`~PyTypeObject.tp_iternext`
 corresponds to the Python :meth:`~iterator.__next__` method.
 
 Any :term:`iterable` object must implement the :c:member:`~PyTypeObject.tp_iter`
--- a/Doc/extending/newtypes_tutorial.rst
+++ b/Doc/extending/newtypes_tutorial.rst
@@ -36,8 +36,8 @@ So, if you want to define a new extensio
 object.
 
 This sort of thing can only be explained by example, so here's a minimal, but
-complete, module that defines a new type named :class:`Custom` inside a C
-extension module :mod:`custom`:
+complete, module that defines a new type named :class:`!Custom` inside a C
+extension module :mod:`!custom`:
 
 .. note::
    What we're showing here is the traditional way of defining *static*
@@ -50,12 +50,12 @@ extension module :mod:`custom`:
 Now that's quite a bit to take in at once, but hopefully bits will seem familiar
 from the previous chapter.  This file defines three things:
 
-#. What a :class:`Custom` **object** contains: this is the ``CustomObject``
-   struct, which is allocated once for each :class:`Custom` instance.
-#. How the :class:`Custom` **type** behaves: this is the ``CustomType`` struct,
+#. What a :class:`!Custom` **object** contains: this is the ``CustomObject``
+   struct, which is allocated once for each :class:`!Custom` instance.
+#. How the :class:`!Custom` **type** behaves: this is the ``CustomType`` struct,
    which defines a set of flags and function pointers that the interpreter
    inspects when specific operations are requested.
-#. How to initialize the :mod:`custom` module: this is the ``PyInit_custom``
+#. How to initialize the :mod:`!custom` module: this is the ``PyInit_custom``
    function and the associated ``custommodule`` struct.
 
 The first bit is::
@@ -127,8 +127,8 @@ our objects and in some error messages,
    TypeError: can only concatenate str (not "custom.Custom") to str
 
 Note that the name is a dotted name that includes both the module name and the
-name of the type within the module. The module in this case is :mod:`custom` and
-the type is :class:`Custom`, so we set the type name to :class:`custom.Custom`.
+name of the type within the module. The module in this case is :mod:`!custom` and
+the type is :class:`!Custom`, so we set the type name to :class:`!custom.Custom`.
 Using the real dotted import path is important to make your type compatible
 with the :mod:`pydoc` and :mod:`pickle` modules. ::
 
@@ -136,7 +136,7 @@ with the :mod:`pydoc` and :mod:`pickle`
    .tp_itemsize = 0,
 
 This is so that Python knows how much memory to allocate when creating
-new :class:`Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is
+new :class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is
 only used for variable-sized objects and should otherwise be zero.
 
 .. note::
@@ -145,13 +145,13 @@ only used for variable-sized objects and
    :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have problems with multiple
    inheritance.  A Python subclass of your type will have to list your type first
    in its :attr:`~class.__bases__`, or else it will not be able to call your type's
-   :meth:`__new__` method without getting an error.  You can avoid this problem by
+   :meth:`~object.__new__` method without getting an error.  You can avoid this problem by
    ensuring that your type has a larger value for :c:member:`~PyTypeObject.tp_basicsize` than its
    base type does.  Most of the time, this will be true anyway, because either your
    base type will be :class:`object`, or else you will be adding data members to
    your base type, and therefore increasing its size.
 
-We set the class flags to :const:`Py_TPFLAGS_DEFAULT`. ::
+We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::
 
    .tp_flags = Py_TPFLAGS_DEFAULT,
 
@@ -164,20 +164,20 @@ We provide a doc string for the type in
    .tp_doc = PyDoc_STR("Custom objects"),
 
 To enable object creation, we have to provide a :c:member:`~PyTypeObject.tp_new`
-handler.  This is the equivalent of the Python method :meth:`__new__`, but
+handler.  This is the equivalent of the Python method :meth:`~object.__new__`, but
 has to be specified explicitly.  In this case, we can just use the default
 implementation provided by the API function :c:func:`PyType_GenericNew`. ::
 
    .tp_new = PyType_GenericNew,
 
 Everything else in the file should be familiar, except for some code in
-:c:func:`PyInit_custom`::
+:c:func:`!PyInit_custom`::
 
    if (PyType_Ready(&CustomType) < 0)
        return;
 
-This initializes the :class:`Custom` type, filling in a number of members
-to the appropriate default values, including :attr:`ob_type` that we initially
+This initializes the :class:`!Custom` type, filling in a number of members
+to the appropriate default values, including :c:member:`~PyObject.ob_type` that we initially
 set to ``NULL``. ::
 
    Py_INCREF(&CustomType);
@@ -188,7 +188,7 @@ set to ``NULL``. ::
    }
 
 This adds the type to the module dictionary.  This allows us to create
-:class:`Custom` instances by calling the :class:`Custom` class:
+:class:`!Custom` instances by calling the :class:`!Custom` class:
 
 .. code-block:: pycon
 
@@ -220,7 +220,7 @@ Of course, the current Custom type is pr
 doesn't do anything. It can't even be subclassed.
 
 .. note::
-   While this documentation showcases the standard :mod:`distutils` module
+   While this documentation showcases the standard :mod:`!distutils` module
    for building C extensions, it is recommended in real-world use cases to
    use the newer and better-maintained ``setuptools`` library.  Documentation
    on how to do this is out of scope for this document and can be found in
@@ -231,7 +231,7 @@ Adding data and methods to the Basic exa
 ============================================
 
 Let's extend the basic example to add some data and methods.  Let's also make
-the type usable as a base class. We'll create a new module, :mod:`custom2` that
+the type usable as a base class. We'll create a new module, :mod:`!custom2` that
 adds these capabilities:
 
 .. literalinclude:: ../includes/custom2.c
@@ -246,7 +246,7 @@ We've added an extra include::
 This include provides declarations that we use to handle attributes, as
 described a bit later.
 
-The  :class:`Custom` type now has three data attributes in its C struct,
+The  :class:`!Custom` type now has three data attributes in its C struct,
 *first*, *last*, and *number*.  The *first* and *last* variables are Python
 strings containing first and last names.  The *number* attribute is a C integer.
 
@@ -279,7 +279,7 @@ This method first clears the reference c
 ``NULL`` (which might happen here if ``tp_new`` failed midway).  It then
 calls the :c:member:`~PyTypeObject.tp_free` member of the object's type
 (computed by ``Py_TYPE(self)``) to free the object's memory.  Note that
-the object's type might not be :class:`CustomType`, because the object may
+the object's type might not be :class:`!CustomType`, because the object may
 be an instance of a subclass.
 
 .. note::
@@ -318,10 +318,10 @@ and install it in the :c:member:`~PyType
    .tp_new = Custom_new,
 
 The ``tp_new`` handler is responsible for creating (as opposed to initializing)
-objects of the type.  It is exposed in Python as the :meth:`__new__` method.
+objects of the type.  It is exposed in Python as the :meth:`~object.__new__` method.
 It is not required to define a ``tp_new`` member, and indeed many extension
 types will simply reuse :c:func:`PyType_GenericNew` as done in the first
-version of the ``Custom`` type above.  In this case, we use the ``tp_new``
+version of the :class:`!Custom` type above.  In this case, we use the ``tp_new``
 handler to initialize the ``first`` and ``last`` attributes to non-``NULL``
 default values.
 
@@ -352,7 +352,7 @@ result against ``NULL`` before proceedin
 
 .. note::
    If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one
-   that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`__new__`),
+   that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`~object.__new__`),
    you must *not* try to determine what method to call using method resolution
    order at runtime.  Always statically determine what type you are going to
    call, and call its :c:member:`~PyTypeObject.tp_new` directly, or via
@@ -395,14 +395,14 @@ by filling the :c:member:`~PyTypeObject.
    .tp_init = (initproc) Custom_init,
 
 The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the
-:meth:`__init__` method.  It is used to initialize an object after it's
+:meth:`~object.__init__` method.  It is used to initialize an object after it's
 created.  Initializers always accept positional and keyword arguments,
 and they should return either ``0`` on success or ``-1`` on error.
 
 Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init``
 is called at all (for example, the :mod:`pickle` module by default
-doesn't call :meth:`__init__` on unpickled instances).  It can also be
-called multiple times.  Anyone can call the :meth:`__init__` method on
+doesn't call :meth:`~object.__init__` on unpickled instances).  It can also be
+called multiple times.  Anyone can call the :meth:`!__init__` method on
 our objects.  For this reason, we have to be extra careful when assigning
 the new attribute values.  We might be tempted, for example to assign the
 ``first`` member like this::
@@ -460,7 +460,7 @@ Further, the attributes can be deleted,
 though we can make sure the members are initialized to non-``NULL`` values, the
 members can be set to ``NULL`` if the attributes are deleted.
 
-We define a single method, :meth:`Custom.name()`, that outputs the objects name as the
+We define a single method, :meth:`!Custom.name()`, that outputs the objects name as the
 concatenation of the first and last names. ::
 
    static PyObject *
@@ -477,8 +477,8 @@ concatenation of the first and last name
        return PyUnicode_FromFormat("%S %S", self->first, self->last);
    }
 
-The method is implemented as a C function that takes a :class:`Custom` (or
-:class:`Custom` subclass) instance as the first argument.  Methods always take an
+The method is implemented as a C function that takes a :class:`!Custom` (or
+:class:`!Custom` subclass) instance as the first argument.  Methods always take an
 instance as the first argument. Methods often take positional and keyword
 arguments as well, but in this case we don't take any and don't need to accept
 a positional argument tuple or keyword argument dictionary. This method is
@@ -489,8 +489,8 @@ equivalent to the Python method:
    def name(self):
        return "%s %s" % (self.first, self.last)
 
-Note that we have to check for the possibility that our :attr:`first` and
-:attr:`last` members are ``NULL``.  This is because they can be deleted, in which
+Note that we have to check for the possibility that our :attr:`!first` and
+:attr:`!last` members are ``NULL``.  This is because they can be deleted, in which
 case they are set to ``NULL``.  It would be better to prevent deletion of these
 attributes and to restrict the attribute values to be strings.  We'll see how to
 do that in the next section.
@@ -505,7 +505,7 @@ definitions::
        {NULL}  /* Sentinel */
    };
 
-(note that we used the :const:`METH_NOARGS` flag to indicate that the method
+(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the method
 is expecting no arguments other than *self*)
 
 and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::
@@ -515,11 +515,11 @@ and assign it to the :c:member:`~PyTypeO
 Finally, we'll make our type usable as a base class for subclassing.  We've
 written our methods carefully so far so that they don't make any assumptions
 about the type of the object being created or used, so all we need to do is
-to add the :const:`Py_TPFLAGS_BASETYPE` to our class flag definition::
+to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::
 
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
 
-We rename :c:func:`PyInit_custom` to :c:func:`PyInit_custom2`, update the
+We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update the
 module name in the :c:type:`PyModuleDef` struct, and update the full class
 name in the :c:type:`PyTypeObject` struct.
 
@@ -538,18 +538,18 @@ Finally, we update our :file:`setup.py`
 Providing finer control over data attributes
 ============================================
 
-In this section, we'll provide finer control over how the :attr:`first` and
-:attr:`last` attributes are set in the :class:`Custom` example. In the previous
-version of our module, the instance variables :attr:`first` and :attr:`last`
+In this section, we'll provide finer control over how the :attr:`!first` and
+:attr:`!last` attributes are set in the :class:`!Custom` example. In the previous
+version of our module, the instance variables :attr:`!first` and :attr:`!last`
 could be set to non-string values or even deleted. We want to make sure that
 these attributes always contain strings.
 
 .. literalinclude:: ../includes/custom3.c
 
 
-To provide greater control, over the :attr:`first` and :attr:`last` attributes,
+To provide greater control, over the :attr:`!first` and :attr:`!last` attributes,
 we'll use custom getter and setter functions.  Here are the functions for
-getting and setting the :attr:`first` attribute::
+getting and setting the :attr:`!first` attribute::
 
    static PyObject *
    Custom_getfirst(CustomObject *self, void *closure)
@@ -578,13 +578,13 @@ getting and setting the :attr:`first` at
        return 0;
    }
 
-The getter function is passed a :class:`Custom` object and a "closure", which is
+The getter function is passed a :class:`!Custom` object and a "closure", which is
 a void pointer.  In this case, the closure is ignored.  (The closure supports an
 advanced usage in which definition data is passed to the getter and setter. This
 could, for example, be used to allow a single set of getter and setter functions
 that decide the attribute to get or set based on data in the closure.)
 
-The setter function is passed the :class:`Custom` object, the new value, and the
+The setter function is passed the :class:`!Custom` object, the new value, and the
 closure.  The new value may be ``NULL``, in which case the attribute is being
 deleted.  In our setter, we raise an error if the attribute is deleted or if its
 new value is not a string.
@@ -673,11 +673,11 @@ still has a reference from itself. Its r
 Fortunately, Python's cyclic garbage collector will eventually figure out that
 the list is garbage and free it.
 
-In the second version of the :class:`Custom` example, we allowed any kind of
-object to be stored in the :attr:`first` or :attr:`last` attributes [#]_.
+In the second version of the :class:`!Custom` example, we allowed any kind of
+object to be stored in the :attr:`!first` or :attr:`!last` attributes [#]_.
 Besides, in the second and third versions, we allowed subclassing
-:class:`Custom`, and subclasses may add arbitrary attributes.  For any of
-those two reasons, :class:`Custom` objects can participate in cycles:
+:class:`!Custom`, and subclasses may add arbitrary attributes.  For any of
+those two reasons, :class:`!Custom` objects can participate in cycles:
 
 .. code-block:: pycon
 
@@ -687,8 +687,8 @@ those two reasons, :class:`Custom` objec
    >>> n = Derived()
    >>> n.some_attribute = n
 
-To allow a :class:`Custom` instance participating in a reference cycle to
-be properly detected and collected by the cyclic GC, our :class:`Custom` type
+To allow a :class:`!Custom` instance participating in a reference cycle to
+be properly detected and collected by the cyclic GC, our :class:`!Custom` type
 needs to fill two additional slots and to enable a flag that enables these slots:
 
 .. literalinclude:: ../includes/custom4.c
@@ -715,8 +715,8 @@ participate in cycles::
    }
 
 For each subobject that can participate in cycles, we need to call the
-:c:func:`visit` function, which is passed to the traversal method. The
-:c:func:`visit` function takes as arguments the subobject and the extra argument
+:c:func:`!visit` function, which is passed to the traversal method. The
+:c:func:`!visit` function takes as arguments the subobject and the extra argument
 *arg* passed to the traversal method.  It returns an integer value that must be
 returned if it is non-zero.
 
@@ -781,7 +781,7 @@ and ``Custom_clear``::
        Py_TYPE(self)->tp_free((PyObject *) self);
    }
 
-Finally, we add the :const:`Py_TPFLAGS_HAVE_GC` flag to the class flags::
+Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::
 
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
 
@@ -798,9 +798,9 @@ types. It is easiest to inherit from the
 easily use the :c:type:`PyTypeObject` it needs. It can be difficult to share
 these :c:type:`PyTypeObject` structures between extension modules.
 
-In this example we will create a :class:`SubList` type that inherits from the
+In this example we will create a :class:`!SubList` type that inherits from the
 built-in :class:`list` type. The new type will be completely compatible with
-regular lists, but will have an additional :meth:`increment` method that
+regular lists, but will have an additional :meth:`!increment` method that
 increases an internal counter:
 
 .. code-block:: pycon
@@ -818,7 +818,7 @@ increases an internal counter:
 .. literalinclude:: ../includes/sublist.c
 
 
-As you can see, the source code closely resembles the :class:`Custom` examples in
+As you can see, the source code closely resembles the :class:`!Custom` examples in
 previous sections. We will break down the main differences between them. ::
 
    typedef struct {
@@ -830,7 +830,7 @@ The primary difference for derived type
 object structure must be the first value.  The base type will already include
 the :c:func:`PyObject_HEAD` at the beginning of its structure.
 
-When a Python object is a :class:`SubList` instance, its ``PyObject *`` pointer
+When a Python object is a :class:`!SubList` instance, its ``PyObject *`` pointer
 can be safely cast to both ``PyListObject *`` and ``SubListObject *``::
 
    static int
@@ -842,7 +842,7 @@ can be safely cast to both ``PyListObjec
        return 0;
    }
 
-We see above how to call through to the :attr:`__init__` method of the base
+We see above how to call through to the :meth:`~object.__init__` method of the base
 type.
 
 This pattern is important when writing a type with custom
@@ -886,7 +886,7 @@ slot with :c:func:`PyType_GenericNew` --
 type will be inherited.
 
 After that, calling :c:func:`PyType_Ready` and adding the type object to the
-module is the same as with the basic :class:`Custom` examples.
+module is the same as with the basic :class:`!Custom` examples.
 
 
 .. rubric:: Footnotes
--- a/Doc/faq/extending.rst
+++ b/Doc/faq/extending.rst
@@ -81,13 +81,13 @@ How do I extract C values from a Python
 
 That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size`
 returns its length and :c:func:`PyTuple_GetItem` returns the item at a specified
-index.  Lists have similar functions, :c:func:`PyListSize` and
+index.  Lists have similar functions, :c:func:`PyList_Size` and
 :c:func:`PyList_GetItem`.
 
 For bytes, :c:func:`PyBytes_Size` returns its length and
 :c:func:`PyBytes_AsStringAndSize` provides a pointer to its value and its
 length.  Note that Python bytes objects may contain null bytes so C's
-:c:func:`strlen` should not be used.
+:c:func:`!strlen` should not be used.
 
 To test the type of an object, first make sure it isn't ``NULL``, and then use
 :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:`PyList_Check`, etc.
--- a/Doc/faq/general.rst
+++ b/Doc/faq/general.rst
@@ -135,7 +135,7 @@ Python versions are numbered "A.B.C" or
 
 See :pep:`6` for more information about bugfix releases.
 
-Not all releases are bugfix releases.  In the run-up to a new major release, a
+Not all releases are bugfix releases.  In the run-up to a new feature release, a
 series of development releases are made, denoted as alpha, beta, or release
 candidate.  Alphas are early releases in which interfaces aren't yet finalized;
 it's not unexpected to see an interface change between two alpha releases.
@@ -297,9 +297,9 @@ How stable is Python?
 
 Very stable.  New, stable releases have been coming out roughly every 6 to 18
 months since 1991, and this seems likely to continue.  As of version 3.9,
-Python will have a major new release every 12 months (:pep:`602`).
+Python will have a new feature release every 12 months (:pep:`602`).
 
-The developers issue "bugfix" releases of older versions, so the stability of
+The developers issue bugfix releases of older versions, so the stability of
 existing releases gradually improves.  Bugfix releases, indicated by a third
 component of the version number (e.g. 3.5.3, 3.6.2), are managed for stability;
 only fixes for known problems are included in a bugfix release, and it's
--- a/Doc/faq/library.rst
+++ b/Doc/faq/library.rst
@@ -566,7 +566,7 @@ use ``p.read(n)``.
    Note on a bug in popen2: unless your program calls ``wait()`` or
    ``waitpid()``, finished child processes are never removed, and eventually
    calls to popen2 will fail because of a limit on the number of child
-   processes.  Calling :func:`os.waitpid` with the :data:`os.WNOHANG` option can
+   processes.  Calling :func:`os.waitpid` with the :const:`os.WNOHANG` option can
    prevent this; a good place to insert such a call would be before calling
    ``popen2`` again.
 
--- a/Doc/glossary.rst
+++ b/Doc/glossary.rst
@@ -92,8 +92,8 @@ Glossary
 
    asynchronous context manager
       An object which controls the environment seen in an
-      :keyword:`async with` statement by defining :meth:`__aenter__` and
-      :meth:`__aexit__` methods.  Introduced by :pep:`492`.
+      :keyword:`async with` statement by defining :meth:`~object.__aenter__` and
+      :meth:`~object.__aexit__` methods.  Introduced by :pep:`492`.
 
    asynchronous generator
       A function which returns an :term:`asynchronous generator iterator`.  It
@@ -113,26 +113,26 @@ Glossary
       An object created by a :term:`asynchronous generator` function.
 
       This is an :term:`asynchronous iterator` which when called using the
-      :meth:`__anext__` method returns an awaitable object which will execute
+      :meth:`~object.__anext__` method returns an awaitable object which will execute
       the body of the asynchronous generator function until the next
       :keyword:`yield` expression.
 
       Each :keyword:`yield` temporarily suspends processing, remembering the
       location execution state (including local variables and pending
       try-statements).  When the *asynchronous generator iterator* effectively
-      resumes with another awaitable returned by :meth:`__anext__`, it
+      resumes with another awaitable returned by :meth:`~object.__anext__`, it
       picks up where it left off.  See :pep:`492` and :pep:`525`.
 
    asynchronous iterable
       An object, that can be used in an :keyword:`async for` statement.
       Must return an :term:`asynchronous iterator` from its
-      :meth:`__aiter__` method.  Introduced by :pep:`492`.
+      :meth:`~object.__aiter__` method.  Introduced by :pep:`492`.
 
    asynchronous iterator
-      An object that implements the :meth:`__aiter__` and :meth:`__anext__`
-      methods.  ``__anext__`` must return an :term:`awaitable` object.
+      An object that implements the :meth:`~object.__aiter__` and :meth:`~object.__anext__`
+      methods.  :meth:`~object.__anext__` must return an :term:`awaitable` object.
       :keyword:`async for` resolves the awaitables returned by an asynchronous
-      iterator's :meth:`__anext__` method until it raises a
+      iterator's :meth:`~object.__anext__` method until it raises a
       :exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`.
 
    attribute
@@ -149,7 +149,7 @@ Glossary
 
    awaitable
       An object that can be used in an :keyword:`await` expression.  Can be
-      a :term:`coroutine` or an object with an :meth:`__await__` method.
+      a :term:`coroutine` or an object with an :meth:`~object.__await__` method.
       See also :pep:`492`.
 
    BDFL
@@ -168,8 +168,9 @@ Glossary
       :class:`str` objects.
 
    borrowed reference
-      In Python's C API, a borrowed reference is a reference to an object.
-      It does not modify the object reference count. It becomes a dangling
+      In Python's C API, a borrowed reference is a reference to an object,
+      where the code using the object does not own the reference.
+      It becomes a dangling
       pointer if the object is destroyed. For example, a garbage collection can
       remove the last :term:`strong reference` to the object and so destroy it.
 
@@ -1131,8 +1132,10 @@ Glossary
 
    strong reference
       In Python's C API, a strong reference is a reference to an object
-      which increments the object's reference count when it is created and
-      decrements the object's reference count when it is deleted.
+      which is owned by the code holding the reference.  The strong
+      reference is taken by calling :c:func:`Py_INCREF` when the
+      reference is created and released with :c:func:`Py_DECREF`
+      when the reference is deleted.
 
       The :c:func:`Py_NewRef` function can be used to create a strong reference
       to an object. Usually, the :c:func:`Py_DECREF` function must be called on
--- a/Doc/howto/annotations.rst
+++ b/Doc/howto/annotations.rst
@@ -32,201 +32,201 @@ Annotations Best Practices
 Accessing The Annotations Dict Of An Object In Python 3.10 And Newer
 ====================================================================
 
-  Python 3.10 adds a new function to the standard library:
-  :func:`inspect.get_annotations`.  In Python versions 3.10
-  and newer, calling this function is the best practice for
-  accessing the annotations dict of any object that supports
-  annotations.  This function can also "un-stringize"
-  stringized annotations for you.
-
-  If for some reason :func:`inspect.get_annotations` isn't
-  viable for your use case, you may access the
-  ``__annotations__`` data member manually.  Best practice
-  for this changed in Python 3.10 as well: as of Python 3.10,
-  ``o.__annotations__`` is guaranteed to *always* work
-  on Python functions, classes, and modules.  If you're
-  certain the object you're examining is one of these three
-  *specific* objects, you may simply use ``o.__annotations__``
-  to get at the object's annotations dict.
-
-  However, other types of callables--for example,
-  callables created by :func:`functools.partial`--may
-  not have an ``__annotations__`` attribute defined.  When
-  accessing the ``__annotations__`` of a possibly unknown
-  object,  best practice in Python versions 3.10 and
-  newer is to call :func:`getattr` with three arguments,
-  for example ``getattr(o, '__annotations__', None)``.
-
-  Before Python 3.10, accessing ``__annotations__`` on a class that
-  defines no annotations but that has a parent class with
-  annotations would return the parent's ``__annotations__``.
-  In Python 3.10 and newer, the child class's annotations
-  will be an empty dict instead.
+Python 3.10 adds a new function to the standard library:
+:func:`inspect.get_annotations`.  In Python versions 3.10
+and newer, calling this function is the best practice for
+accessing the annotations dict of any object that supports
+annotations.  This function can also "un-stringize"
+stringized annotations for you.
+
+If for some reason :func:`inspect.get_annotations` isn't
+viable for your use case, you may access the
+``__annotations__`` data member manually.  Best practice
+for this changed in Python 3.10 as well: as of Python 3.10,
+``o.__annotations__`` is guaranteed to *always* work
+on Python functions, classes, and modules.  If you're
+certain the object you're examining is one of these three
+*specific* objects, you may simply use ``o.__annotations__``
+to get at the object's annotations dict.
+
+However, other types of callables--for example,
+callables created by :func:`functools.partial`--may
+not have an ``__annotations__`` attribute defined.  When
+accessing the ``__annotations__`` of a possibly unknown
+object,  best practice in Python versions 3.10 and
+newer is to call :func:`getattr` with three arguments,
+for example ``getattr(o, '__annotations__', None)``.
+
+Before Python 3.10, accessing ``__annotations__`` on a class that
+defines no annotations but that has a parent class with
+annotations would return the parent's ``__annotations__``.
+In Python 3.10 and newer, the child class's annotations
+will be an empty dict instead.
 
 
 Accessing The Annotations Dict Of An Object In Python 3.9 And Older
 ===================================================================
 
-  In Python 3.9 and older, accessing the annotations dict
-  of an object is much more complicated than in newer versions.
-  The problem is a design flaw in these older versions of Python,
-  specifically to do with class annotations.
-
-  Best practice for accessing the annotations dict of other
-  objects--functions, other callables, and modules--is the same
-  as best practice for 3.10, assuming you aren't calling
-  :func:`inspect.get_annotations`: you should use three-argument
-  :func:`getattr` to access the object's ``__annotations__``
-  attribute.
-
-  Unfortunately, this isn't best practice for classes.  The problem
-  is that, since ``__annotations__`` is optional on classes, and
-  because classes can inherit attributes from their base classes,
-  accessing the ``__annotations__`` attribute of a class may
-  inadvertently return the annotations dict of a *base class.*
-  As an example::
-
-      class Base:
-          a: int = 3
-          b: str = 'abc'
-
-      class Derived(Base):
-          pass
-
-      print(Derived.__annotations__)
-
-  This will print the annotations dict from ``Base``, not
-  ``Derived``.
-
-  Your code will have to have a separate code path if the object
-  you're examining is a class (``isinstance(o, type)``).
-  In that case, best practice relies on an implementation detail
-  of Python 3.9 and before: if a class has annotations defined,
-  they are stored in the class's ``__dict__`` dictionary.  Since
-  the class may or may not have annotations defined, best practice
-  is to call the ``get`` method on the class dict.
-
-  To put it all together, here is some sample code that safely
-  accesses the ``__annotations__`` attribute on an arbitrary
-  object in Python 3.9 and before::
-
-      if isinstance(o, type):
-          ann = o.__dict__.get('__annotations__', None)
-      else:
-          ann = getattr(o, '__annotations__', None)
-
-  After running this code, ``ann`` should be either a
-  dictionary or ``None``.  You're encouraged to double-check
-  the type of ``ann`` using :func:`isinstance` before further
-  examination.
-
-  Note that some exotic or malformed type objects may not have
-  a ``__dict__`` attribute, so for extra safety you may also wish
-  to use :func:`getattr` to access ``__dict__``.
+In Python 3.9 and older, accessing the annotations dict
+of an object is much more complicated than in newer versions.
+The problem is a design flaw in these older versions of Python,
+specifically to do with class annotations.
+
+Best practice for accessing the annotations dict of other
+objects--functions, other callables, and modules--is the same
+as best practice for 3.10, assuming you aren't calling
+:func:`inspect.get_annotations`: you should use three-argument
+:func:`getattr` to access the object's ``__annotations__``
+attribute.
+
+Unfortunately, this isn't best practice for classes.  The problem
+is that, since ``__annotations__`` is optional on classes, and
+because classes can inherit attributes from their base classes,
+accessing the ``__annotations__`` attribute of a class may
+inadvertently return the annotations dict of a *base class.*
+As an example::
+
+    class Base:
+        a: int = 3
+        b: str = 'abc'
+
+    class Derived(Base):
+        pass
+
+    print(Derived.__annotations__)
+
+This will print the annotations dict from ``Base``, not
+``Derived``.
+
+Your code will have to have a separate code path if the object
+you're examining is a class (``isinstance(o, type)``).
+In that case, best practice relies on an implementation detail
+of Python 3.9 and before: if a class has annotations defined,
+they are stored in the class's ``__dict__`` dictionary.  Since
+the class may or may not have annotations defined, best practice
+is to call the ``get`` method on the class dict.
+
+To put it all together, here is some sample code that safely
+accesses the ``__annotations__`` attribute on an arbitrary
+object in Python 3.9 and before::
+
+    if isinstance(o, type):
+        ann = o.__dict__.get('__annotations__', None)
+    else:
+        ann = getattr(o, '__annotations__', None)
+
+After running this code, ``ann`` should be either a
+dictionary or ``None``.  You're encouraged to double-check
+the type of ``ann`` using :func:`isinstance` before further
+examination.
+
+Note that some exotic or malformed type objects may not have
+a ``__dict__`` attribute, so for extra safety you may also wish
+to use :func:`getattr` to access ``__dict__``.
 
 
 Manually Un-Stringizing Stringized Annotations
 ==============================================
 
-  In situations where some annotations may be "stringized",
-  and you wish to evaluate those strings to produce the
-  Python values they represent, it really is best to
-  call :func:`inspect.get_annotations` to do this work
-  for you.
-
-  If you're using Python 3.9 or older, or if for some reason
-  you can't use :func:`inspect.get_annotations`, you'll need
-  to duplicate its logic.  You're encouraged to examine the
-  implementation of :func:`inspect.get_annotations` in the
-  current Python version and follow a similar approach.
-
-  In a nutshell, if you wish to evaluate a stringized annotation
-  on an arbitrary object ``o``:
-
-  * If ``o`` is a module, use ``o.__dict__`` as the
-    ``globals`` when calling :func:`eval`.
-  * If ``o`` is a class, use ``sys.modules[o.__module__].__dict__``
-    as the ``globals``, and ``dict(vars(o))`` as the ``locals``,
-    when calling :func:`eval`.
-  * If ``o`` is a wrapped callable using :func:`functools.update_wrapper`,
-    :func:`functools.wraps`, or :func:`functools.partial`, iteratively
-    unwrap it by accessing either ``o.__wrapped__`` or ``o.func`` as
-    appropriate, until you have found the root unwrapped function.
-  * If ``o`` is a callable (but not a class), use
-    ``o.__globals__`` as the globals when calling :func:`eval`.
-
-  However, not all string values used as annotations can
-  be successfully turned into Python values by :func:`eval`.
-  String values could theoretically contain any valid string,
-  and in practice there are valid use cases for type hints that
-  require annotating with string values that specifically
-  *can't* be evaluated.  For example:
-
-  * :pep:`604` union types using ``|``, before support for this
-    was added to Python 3.10.
-  * Definitions that aren't needed at runtime, only imported
-    when :const:`typing.TYPE_CHECKING` is true.
-
-  If :func:`eval` attempts to evaluate such values, it will
-  fail and raise an exception.  So, when designing a library
-  API that works with annotations, it's recommended to only
-  attempt to evaluate string values when explicitly requested
-  to by the caller.
+In situations where some annotations may be "stringized",
+and you wish to evaluate those strings to produce the
+Python values they represent, it really is best to
+call :func:`inspect.get_annotations` to do this work
+for you.
+
+If you're using Python 3.9 or older, or if for some reason
+you can't use :func:`inspect.get_annotations`, you'll need
+to duplicate its logic.  You're encouraged to examine the
+implementation of :func:`inspect.get_annotations` in the
+current Python version and follow a similar approach.
+
+In a nutshell, if you wish to evaluate a stringized annotation
+on an arbitrary object ``o``:
+
+* If ``o`` is a module, use ``o.__dict__`` as the
+  ``globals`` when calling :func:`eval`.
+* If ``o`` is a class, use ``sys.modules[o.__module__].__dict__``
+  as the ``globals``, and ``dict(vars(o))`` as the ``locals``,
+  when calling :func:`eval`.
+* If ``o`` is a wrapped callable using :func:`functools.update_wrapper`,
+  :func:`functools.wraps`, or :func:`functools.partial`, iteratively
+  unwrap it by accessing either ``o.__wrapped__`` or ``o.func`` as
+  appropriate, until you have found the root unwrapped function.
+* If ``o`` is a callable (but not a class), use
+  ``o.__globals__`` as the globals when calling :func:`eval`.
+
+However, not all string values used as annotations can
+be successfully turned into Python values by :func:`eval`.
+String values could theoretically contain any valid string,
+and in practice there are valid use cases for type hints that
+require annotating with string values that specifically
+*can't* be evaluated.  For example:
+
+* :pep:`604` union types using ``|``, before support for this
+  was added to Python 3.10.
+* Definitions that aren't needed at runtime, only imported
+  when :const:`typing.TYPE_CHECKING` is true.
+
+If :func:`eval` attempts to evaluate such values, it will
+fail and raise an exception.  So, when designing a library
+API that works with annotations, it's recommended to only
+attempt to evaluate string values when explicitly requested
+to by the caller.
 
 
 Best Practices For ``__annotations__`` In Any Python Version
 ============================================================
 
-  * You should avoid assigning to the ``__annotations__`` member
-    of objects directly.  Let Python manage setting ``__annotations__``.
+* You should avoid assigning to the ``__annotations__`` member
+  of objects directly.  Let Python manage setting ``__annotations__``.
 
-  * If you do assign directly to the ``__annotations__`` member
-    of an object, you should always set it to a ``dict`` object.
+* If you do assign directly to the ``__annotations__`` member
+  of an object, you should always set it to a ``dict`` object.
 
-  * If you directly access the ``__annotations__`` member
-    of an object, you should ensure that it's a
-    dictionary before attempting to examine its contents.
+* If you directly access the ``__annotations__`` member
+  of an object, you should ensure that it's a
+  dictionary before attempting to examine its contents.
 
-  * You should avoid modifying ``__annotations__`` dicts.
+* You should avoid modifying ``__annotations__`` dicts.
 
-  * You should avoid deleting the ``__annotations__`` attribute
-    of an object.
+* You should avoid deleting the ``__annotations__`` attribute
+  of an object.
 
 
 ``__annotations__`` Quirks
 ==========================
 
-  In all versions of Python 3, function
-  objects lazy-create an annotations dict if no annotations
-  are defined on that object.  You can delete the ``__annotations__``
-  attribute using ``del fn.__annotations__``, but if you then
-  access ``fn.__annotations__`` the object will create a new empty dict
-  that it will store and return as its annotations.  Deleting the
-  annotations on a function before it has lazily created its annotations
-  dict will throw an ``AttributeError``; using ``del fn.__annotations__``
-  twice in a row is guaranteed to always throw an ``AttributeError``.
-
-  Everything in the above paragraph also applies to class and module
-  objects in Python 3.10 and newer.
-
-  In all versions of Python 3, you can set ``__annotations__``
-  on a function object to ``None``.  However, subsequently
-  accessing the annotations on that object using ``fn.__annotations__``
-  will lazy-create an empty dictionary as per the first paragraph of
-  this section.  This is *not* true of modules and classes, in any Python
-  version; those objects permit setting ``__annotations__`` to any
-  Python value, and will retain whatever value is set.
-
-  If Python stringizes your annotations for you
-  (using ``from __future__ import annotations``), and you
-  specify a string as an annotation, the string will
-  itself be quoted.  In effect the annotation is quoted
-  *twice.*  For example::
+In all versions of Python 3, function
+objects lazy-create an annotations dict if no annotations
+are defined on that object.  You can delete the ``__annotations__``
+attribute using ``del fn.__annotations__``, but if you then
+access ``fn.__annotations__`` the object will create a new empty dict
+that it will store and return as its annotations.  Deleting the
+annotations on a function before it has lazily created its annotations
+dict will throw an ``AttributeError``; using ``del fn.__annotations__``
+twice in a row is guaranteed to always throw an ``AttributeError``.
+
+Everything in the above paragraph also applies to class and module
+objects in Python 3.10 and newer.
+
+In all versions of Python 3, you can set ``__annotations__``
+on a function object to ``None``.  However, subsequently
+accessing the annotations on that object using ``fn.__annotations__``
+will lazy-create an empty dictionary as per the first paragraph of
+this section.  This is *not* true of modules and classes, in any Python
+version; those objects permit setting ``__annotations__`` to any
+Python value, and will retain whatever value is set.
+
+If Python stringizes your annotations for you
+(using ``from __future__ import annotations``), and you
+specify a string as an annotation, the string will
+itself be quoted.  In effect the annotation is quoted
+*twice.*  For example::
 
-       from __future__ import annotations
-       def foo(a: "str"): pass
+     from __future__ import annotations
+     def foo(a: "str"): pass
 
-       print(foo.__annotations__)
+     print(foo.__annotations__)
 
-  This prints ``{'a': "'str'"}``.  This shouldn't really be considered
-  a "quirk"; it's mentioned here simply because it might be surprising.
+This prints ``{'a': "'str'"}``.  This shouldn't really be considered
+a "quirk"; it's mentioned here simply because it might be surprising.
--- a/Doc/howto/argparse.rst
+++ b/Doc/howto/argparse.rst
@@ -759,6 +759,59 @@ but not both at the same time:
      -q, --quiet
 
 
+How to translate the argparse output
+====================================
+
+The output of the :mod:`argparse` module such as its help text and error
+messages are all made translatable using the :mod:`gettext` module. This
+allows applications to easily localize messages produced by
+:mod:`argparse`. See also :ref:`i18n-howto`.
+
+For instance, in this :mod:`argparse` output:
+
+.. code-block:: shell-session
+
+   $ python prog.py --help
+   usage: prog.py [-h] [-v | -q] x y
+
+   calculate X to the power of Y
+
+   positional arguments:
+     x              the base
+     y              the exponent
+
+   options:
+     -h, --help     show this help message and exit
+     -v, --verbose
+     -q, --quiet
+
+The strings ``usage:``, ``positional arguments:``, ``options:`` and
+``show this help message and exit`` are all translatable.
+
+In order to translate these strings, they must first be extracted
+into a ``.po`` file. For example, using `Babel <https://babel.pocoo.org/>`__,
+run this command:
+
+.. code-block:: shell-session
+
+  $ pybabel extract -o messages.po /usr/lib/python3.12/argparse.py
+
+This command will extract all translatable strings from the :mod:`argparse`
+module and output them into a file named ``messages.po``. This command assumes
+that your Python installation is in ``/usr/lib``.
+
+You can find out the location of the :mod:`argparse` module on your system
+using this script::
+
+   import argparse
+   print(argparse.__file__)
+
+Once the messages in the ``.po`` file are translated and the translations are
+installed using :mod:`gettext`, :mod:`argparse` will be able to display the
+translated messages.
+
+To translate your own strings in the :mod:`argparse` output, use :mod:`gettext`.
+
 Conclusion
 ==========
 
--- a/Doc/howto/clinic.rst
+++ b/Doc/howto/clinic.rst
@@ -8,17 +8,30 @@ Argument Clinic How-To
 
 :author: Larry Hastings
 
+**Source code:** :source:`Tools/clinic/clinic.py`.
 
 .. topic:: Abstract
 
   Argument Clinic is a preprocessor for CPython C files.
-  Its purpose is to automate all the boilerplate involved
-  with writing argument parsing code for "builtins".
-  This document shows you how to convert your first C
-  function to work with Argument Clinic, and then introduces
-  some advanced topics on Argument Clinic usage.
+  It was introduced in Python 3.4 with :pep:`436`,
+  in order to provide introspection signatures,
+  and to generate performant and tailor-made boilerplate code
+  for argument parsing in CPython builtins,
+  module level functions, and class methods.
+  This document is divided in four major sections:
+
+  * :ref:`clinic-background` talks about the basic concepts and goals of
+    Argument Clinic.
+  * :ref:`clinic-reference` describes the command-line interface and Argument
+    Clinic terminology.
+  * :ref:`clinic-tutorial` guides you through all the steps required to
+    adapt an existing C function to Argument Clinic.
+  * :ref:`clinic-howtos` details how to handle specific tasks.
 
-  Currently Argument Clinic is considered internal-only
+
+.. note::
+
+  Argument Clinic is considered internal-only
   for CPython.  Its use is not supported for files outside
   CPython, and no guarantees are made regarding backwards
   compatibility for future versions.  In other words: if you
@@ -27,89 +40,35 @@ Argument Clinic How-To
   version of Argument Clinic that ships with the next version
   of CPython *could* be totally incompatible and break all your code.
 
-The Goals Of Argument Clinic
-============================
-
-Argument Clinic's primary goal
-is to take over responsibility for all argument parsing code
-inside CPython.  This means that, when you convert a function
-to work with Argument Clinic, that function should no longer
-do any of its own argument parsingthe code generated by
-Argument Clinic should be a "black box" to you, where CPython
-calls in at the top, and your code gets called at the bottom,
-with ``PyObject *args`` (and maybe ``PyObject *kwargs``)
-magically converted into the C variables and types you need.
-
-In order for Argument Clinic to accomplish its primary goal,
-it must be easy to use.  Currently, working with CPython's
-argument parsing library is a chore, requiring maintaining
-redundant information in a surprising number of places.
-When you use Argument Clinic, you don't have to repeat yourself.
-
-Obviously, no one would want to use Argument Clinic unless
-it's solving their problemand without creating new problems of
-its own.
-So it's paramount that Argument Clinic generate correct code.
-It'd be nice if the code was faster, too, but at the very least
-it should not introduce a major speed regression.  (Eventually Argument
-Clinic *should* make a major speedup possiblewe could
-rewrite its code generator to produce tailor-made argument
-parsing code, rather than calling the general-purpose CPython
-argument parsing library.  That would make for the fastest
-argument parsing possible!)
-
-Additionally, Argument Clinic must be flexible enough to
-work with any approach to argument parsing.  Python has
-some functions with some very strange parsing behaviors;
-Argument Clinic's goal is to support all of them.
-
-Finally, the original motivation for Argument Clinic was
-to provide introspection "signatures" for CPython builtins.
-It used to be, the introspection query functions would throw
-an exception if you passed in a builtin.  With Argument
-Clinic, that's a thing of the past!
-
-One idea you should keep in mind, as you work with
-Argument Clinic: the more information you give it, the
-better job it'll be able to do.
-Argument Clinic is admittedly relatively simple right
-now.  But as it evolves it will get more sophisticated,
-and it should be able to do many interesting and smart
-things with all the information you give it.
 
+.. _clinic-background:
 
-Basic Concepts And Usage
-========================
-
-Argument Clinic ships with CPython; you'll find it in ``Tools/clinic/clinic.py``.
-If you run that script, specifying a C file as an argument:
-
-.. code-block:: shell-session
+Background
+==========
 
-    $ python3 Tools/clinic/clinic.py foo.c
+Basic concepts
+--------------
 
-Argument Clinic will scan over the file looking for lines that
-look exactly like this:
+When Argument Clinic is run on a file, either via the :ref:`clinic-cli`
+or via ``make clinic``, it will scan over the input files looking for
+:term:`start lines <start line>`:
 
 .. code-block:: none
 
     /*[clinic input]
 
-When it finds one, it reads everything up to a line that looks
-exactly like this:
+When it finds one, it reads everything up to the :term:`end line`:
 
 .. code-block:: none
 
     [clinic start generated code]*/
 
-Everything in between these two lines is input for Argument Clinic.
-All of these lines, including the beginning and ending comment
-lines, are collectively called an Argument Clinic "block".
-
-When Argument Clinic parses one of these blocks, it
-generates output.  This output is rewritten into the C file
-immediately after the block, followed by a comment containing a checksum.
-The Argument Clinic block now looks like this:
+Everything in between these two lines is Argument Clinic :term:`input`.
+When Argument Clinic parses input, it generates :term:`output`.
+The output is rewritten into the C file immediately after the input,
+followed by a :term:`checksum line`.
+All of these lines, including the :term:`start line` and :term:`checksum line`,
+are collectively called an Argument Clinic :term:`block`:
 
 .. code-block:: none
 
@@ -117,464 +76,599 @@ The Argument Clinic block now looks like
     ... clinic input goes here ...
     [clinic start generated code]*/
     ... clinic output goes here ...
-    /*[clinic end generated code: checksum=...]*/
+    /*[clinic end generated code: ...]*/
 
 If you run Argument Clinic on the same file a second time, Argument Clinic
-will discard the old output and write out the new output with a fresh checksum
-line.  However, if the input hasn't changed, the output won't change either.
+will discard the old :term:`output` and write out the new output with a fresh
+:term:`checksum line`.
+If the :term:`input` hasn't changed, the output won't change either.
 
-You should never modify the output portion of an Argument Clinic block.  Instead,
-change the input until it produces the output you want.  (That's the purpose of the
-checksumto detect if someone changed the output, as these edits would be lost
-the next time Argument Clinic writes out fresh output.)
-
-For the sake of clarity, here's the terminology we'll use with Argument Clinic:
-
-* The first line of the comment (``/*[clinic input]``) is the *start line*.
-* The last line of the initial comment (``[clinic start generated code]*/``) is the *end line*.
-* The last line (``/*[clinic end generated code: checksum=...]*/``) is the *checksum line*.
-* In between the start line and the end line is the *input*.
-* In between the end line and the checksum line is the *output*.
-* All the text collectively, from the start line to the checksum line inclusively,
-  is the *block*.  (A block that hasn't been successfully processed by Argument
-  Clinic yet doesn't have output or a checksum line, but it's still considered
-  a block.)
+.. note::
 
+   You should never modify the output of an Argument Clinic block,
+   as any change will be lost in future Argument Clinic runs;
+   Argument Clinic will detect an output checksum mismatch and regenerate the
+   correct output.
+   If you are not happy with the generated output,
+   you should instead change the input until it produces the output you want.
 
-Converting Your First Function
-==============================
 
-The best way to get a sense of how Argument Clinic works is to
-convert a function to work with it.  Here, then, are the bare
-minimum steps you'd need to follow to convert a function to
-work with Argument Clinic.  Note that for code you plan to
-check in to CPython, you really should take the conversion farther,
-using some of the advanced concepts you'll see later on in
-the document (like "return converters" and "self converters").
-But we'll keep it simple for this walkthrough so you can learn.
+.. _clinic-reference:
 
-Let's dive in!
+Reference
+=========
 
-0. Make sure you're working with a freshly updated checkout
-   of the CPython trunk.
 
-1. Find a Python builtin that calls either :c:func:`PyArg_ParseTuple`
-   or :c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted
-   to work with Argument Clinic yet.
-   For my example I'm using ``_pickle.Pickler.dump()``.
+.. _clinic-terminology:
 
-2. If the call to the ``PyArg_Parse`` function uses any of the
-   following format units:
+Terminology
+-----------
 
-   .. code-block:: none
+.. glossary::
 
-       O&
-       O!
-       es
-       es#
-       et
-       et#
+   start line
+      The line ``/*[clinic input]``.
+      This line marks the beginning of Argument Clinic input.
+      Note that the *start line* opens a C block comment.
 
-   or if it has multiple calls to :c:func:`PyArg_ParseTuple`,
-   you should choose a different function.  Argument Clinic *does*
-   support all of these scenarios.  But these are advanced
-   topicslet's do something simpler for your first function.
-
-   Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple`
-   or :c:func:`PyArg_ParseTupleAndKeywords` where it supports different
-   types for the same argument, or if the function uses something besides
-   PyArg_Parse functions to parse its arguments, it probably
-   isn't suitable for conversion to Argument Clinic.  Argument Clinic
-   doesn't support generic functions or polymorphic parameters.
+   end line
+      The line ``[clinic start generated code]*/``.
+      The *end line* marks the _end_ of Argument Clinic :term:`input`,
+      but at the same time marks the _start_ of Argument Clinic :term:`output`,
+      thus the text *"clinic start start generated code"*
+      Note that the *end line* closes the C block comment opened
+      by the *start line*.
 
-3. Add the following boilerplate above the function, creating our block::
+   checksum
+      A hash to distinguish unique :term:`inputs <input>`
+      and :term:`outputs <output>`.
 
-    /*[clinic input]
-    [clinic start generated code]*/
+   checksum line
+      A line that looks like ``/*[clinic end generated code: ...]*/``.
+      The three dots will be replaced by a :term:`checksum` generated from the
+      :term:`input`, and a :term:`checksum` generated from the :term:`output`.
+      The checksum line marks the end of Argument Clinic generated code,
+      and is used by Argument Clinic to determine if it needs to regenerate
+      output.
 
-4. Cut the docstring and paste it in between the ``[clinic]`` lines,
-   removing all the junk that makes it a properly quoted C string.
-   When you're done you should have just the text, based at the left
-   margin, with no line wider than 80 characters.
-   (Argument Clinic will preserve indents inside the docstring.)
-
-   If the old docstring had a first line that looked like a function
-   signature, throw that line away.  (The docstring doesn't need it
-   anymorewhen you use ``help()`` on your builtin in the future,
-   the first line will be built automatically based on the function's
-   signature.)
+   input
+      The text between the :term:`start line` and the :term:`end line`.
+      Note that the start and end lines open and close a C block comment;
+      the *input* is thus a part of that same C block comment.
 
-   Sample::
+   output
+      The text between the :term:`end line` and the :term:`checksum line`.
 
-    /*[clinic input]
-    Write a pickled representation of obj to the open file.
-    [clinic start generated code]*/
+   block
+      All text from the :term:`start line` to the :term:`checksum line` inclusively.
 
-5. If your docstring doesn't have a "summary" line, Argument Clinic will
-   complain.  So let's make sure it has one.  The "summary" line should
-   be a paragraph consisting of a single 80-column line
-   at the beginning of the docstring.
-
-   (Our example docstring consists solely of a summary line, so the sample
-   code doesn't have to change for this step.)
-
-6. Above the docstring, enter the name of the function, followed
-   by a blank line.  This should be the Python name of the function,
-   and should be the full dotted path
-   to the functionit should start with the name of the module,
-   include any sub-modules, and if the function is a method on
-   a class it should include the class name too.
 
-   Sample::
+.. _clinic-cli:
 
-    /*[clinic input]
-    _pickle.Pickler.dump
+Command-line interface
+----------------------
 
-    Write a pickled representation of obj to the open file.
-    [clinic start generated code]*/
+The Argument Clinic :abbr:`CLI (Command-Line Interface)` is typically used to
+process a single source file, like this:
 
-7. If this is the first time that module or class has been used with Argument
-   Clinic in this C file,
-   you must declare the module and/or class.  Proper Argument Clinic hygiene
-   prefers declaring these in a separate block somewhere near the
-   top of the C file, in the same way that include files and statics go at
-   the top.  (In our sample code we'll just show the two blocks next to
-   each other.)
+.. code-block:: shell-session
 
-   The name of the class and module should be the same as the one
-   seen by Python.  Check the name defined in the :c:type:`PyModuleDef`
-   or :c:type:`PyTypeObject` as appropriate.
+    $ python3 ./Tools/clinic/clinic.py foo.c
 
-   When you declare a class, you must also specify two aspects of its type
-   in C: the type declaration you'd use for a pointer to an instance of
-   this class, and a pointer to the :c:type:`PyTypeObject` for this class.
+The CLI supports the following options:
 
-   Sample::
+.. program:: ./Tools/clinic/clinic.py [-h] [-f] [-o OUTPUT] [-v] \
+             [--converters] [--make] [--srcdir SRCDIR] [FILE ...]
 
-       /*[clinic input]
-       module _pickle
-       class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
-       [clinic start generated code]*/
+.. option:: -h, --help
 
-       /*[clinic input]
-       _pickle.Pickler.dump
+   Print CLI usage.
 
-       Write a pickled representation of obj to the open file.
-       [clinic start generated code]*/
+.. option:: -f, --force
 
+   Force output regeneration.
 
+.. option:: -o, --output OUTPUT
 
+   Redirect file output to OUTPUT
 
-8. Declare each of the parameters to the function.  Each parameter
-   should get its own line.  All the parameter lines should be
-   indented from the function name and the docstring.
+.. option:: -v, --verbose
 
-   The general form of these parameter lines is as follows:
+   Enable verbose mode.
 
-   .. code-block:: none
+.. option:: --converters
 
-       name_of_parameter: converter
+   Print a list of all supported converters and return converters.
 
-   If the parameter has a default value, add that after the
-   converter:
+.. option:: --make
 
-   .. code-block:: none
+   Walk :option:`--srcdir` to run over all relevant files.
 
-       name_of_parameter: converter = default_value
+.. option:: --srcdir SRCDIR
 
-   Argument Clinic's support for "default values" is quite sophisticated;
-   please see :ref:`the section below on default values <default_values>`
-   for more information.
+   The directory tree to walk in :option:`--make` mode.
 
-   Add a blank line below the parameters.
+.. option:: FILE ...
 
-   What's a "converter"?  It establishes both the type
-   of the variable used in C, and the method to convert the Python
-   value into a C value at runtime.
-   For now you're going to use what's called a "legacy converter"a
-   convenience syntax intended to make porting old code into Argument
-   Clinic easier.
+   The list of files to process.
 
-   For each parameter, copy the "format unit" for that
-   parameter from the ``PyArg_Parse()`` format argument and
-   specify *that* as its converter, as a quoted
-   string.  ("format unit" is the formal name for the one-to-three
-   character substring of the ``format`` parameter that tells
-   the argument parsing function what the type of the variable
-   is and how to convert it.  For more on format units please
-   see :ref:`arg-parsing`.)
 
-   For multicharacter format units like ``z#``, use the
-   entire two-or-three character string.
+.. _clinic-classes:
 
-   Sample::
+Classes for extending Argument Clinic
+-------------------------------------
 
-        /*[clinic input]
-        module _pickle
-        class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
-        [clinic start generated code]*/
+.. module:: clinic
 
-        /*[clinic input]
-        _pickle.Pickler.dump
+.. class:: CConverter
 
-           obj: 'O'
+   The base class for all converters.
+   See :ref:`clinic-howto-custom-converter` for how to subclass this class.
 
-       Write a pickled representation of obj to the open file.
-       [clinic start generated code]*/
+   .. attribute:: type
 
-9. If your function has ``|`` in the format string, meaning some
-   parameters have default values, you can ignore it.  Argument
-   Clinic infers which parameters are optional based on whether
-   or not they have default values.
+      The C type to use for this variable.
+      :attr:`!type` should be a Python string specifying the type,
+      e.g. ``'int'``.
+      If this is a pointer type, the type string should end with ``' *'``.
 
-   If your function has ``$`` in the format string, meaning it
-   takes keyword-only arguments, specify ``*`` on a line by
-   itself before the first keyword-only argument, indented the
-   same as the parameter lines.
+   .. attribute:: default
 
-   (``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)
+      The Python default value for this parameter, as a Python value.
+      Or the magic value ``unspecified`` if there is no default.
 
+   .. attribute:: py_default
 
-10. If the existing C function calls :c:func:`PyArg_ParseTuple`
-    (as opposed to :c:func:`PyArg_ParseTupleAndKeywords`), then all its
-    arguments are positional-only.
+      :attr:`!default` as it should appear in Python code,
+      as a string.
+      Or ``None`` if there is no default.
 
-    To mark all parameters as positional-only in Argument Clinic,
-    add a ``/`` on a line by itself after the last parameter,
-    indented the same as the parameter lines.
+   .. attribute:: c_default
 
-    Currently this is all-or-nothing; either all parameters are
-    positional-only, or none of them are.  (In the future Argument
-    Clinic may relax this restriction.)
+      :attr:`!default` as it should appear in C code,
+      as a string.
+      Or ``None`` if there is no default.
 
-    Sample::
+   .. attribute:: c_ignored_default
 
-        /*[clinic input]
-        module _pickle
-        class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
-        [clinic start generated code]*/
+      The default value used to initialize the C variable when
+      there is no default, but not specifying a default may
+      result in an "uninitialized variable" warning.  This can
+      easily happen when using option groupsalthough
+      properly written code will never actually use this value,
+      the variable does get passed in to the impl, and the
+      C compiler will complain about the "use" of the
+      uninitialized value.  This value should always be a
+      non-empty string.
 
-        /*[clinic input]
-        _pickle.Pickler.dump
+   .. attribute:: converter
 
-            obj: 'O'
-            /
+      The name of the C converter function, as a string.
 
-        Write a pickled representation of obj to the open file.
-        [clinic start generated code]*/
+   .. attribute:: impl_by_reference
 
-11. It's helpful to write a per-parameter docstring for each parameter.
-    But per-parameter docstrings are optional; you can skip this step
-    if you prefer.
+      A boolean value.  If true,
+      Argument Clinic will add a ``&`` in front of the name of
+      the variable when passing it into the impl function.
+
+   .. attribute:: parse_by_reference
+
+      A boolean value.  If true,
+      Argument Clinic will add a ``&`` in front of the name of
+      the variable when passing it into :c:func:`PyArg_ParseTuple`.
+
+
+.. _clinic-tutorial:
+
+Tutorial
+========
+
+The best way to get a sense of how Argument Clinic works is to
+convert a function to work with it.  Here, then, are the bare
+minimum steps you'd need to follow to convert a function to
+work with Argument Clinic.  Note that for code you plan to
+check in to CPython, you really should take the conversion farther,
+using some of the :ref:`advanced concepts <clinic-howtos>`
+you'll see later on in the document,
+like :ref:`clinic-howto-return-converters`
+and :ref:`clinic-howto-self-converter`.
+But we'll keep it simple for this walkthrough so you can learn.
 
-    Here's how to add a per-parameter docstring.  The first line
-    of the per-parameter docstring must be indented further than the
-    parameter definition.  The left margin of this first line establishes
-    the left margin for the whole per-parameter docstring; all the text
-    you write will be outdented by this amount.  You can write as much
-    text as you like, across multiple lines if you wish.
+First, make sure you're working with a freshly updated checkout
+of the CPython trunk.
 
-    Sample::
+Next, find a Python builtin that calls either :c:func:`PyArg_ParseTuple`
+or :c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted
+to work with Argument Clinic yet.
+For this tutorial, we'll be using
+:py:meth:`_pickle.Pickler.dump <pickle.Pickler.dump>`.
 
-        /*[clinic input]
-        module _pickle
-        class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
-        [clinic start generated code]*/
+If the call to the :c:func:`!PyArg_Parse*` function uses any of the
+following format units...:
 
-        /*[clinic input]
-        _pickle.Pickler.dump
+   .. code-block:: none
 
-            obj: 'O'
-                The object to be pickled.
-            /
+       O&
+       O!
+       es
+       es#
+       et
+       et#
 
-        Write a pickled representation of obj to the open file.
-        [clinic start generated code]*/
+... or if it has multiple calls to :c:func:`PyArg_ParseTuple`,
+you should choose a different function.
+(See :ref:`clinic-howto-advanced-converters` for those scenarios.)
+
+Also, if the function has multiple calls to :c:func:`!PyArg_ParseTuple`
+or :c:func:`PyArg_ParseTupleAndKeywords` where it supports different
+types for the same argument, or if the function uses something besides
+:c:func:`!PyArg_Parse*` functions to parse its arguments, it probably
+isn't suitable for conversion to Argument Clinic.  Argument Clinic
+doesn't support generic functions or polymorphic parameters.
 
-12. Save and close the file, then run ``Tools/clinic/clinic.py`` on
-    it.  With luck everything worked---your block now has output, and
-    a ``.c.h`` file has been generated! Reopen the file in your
-    text editor to see::
+Next, add the following boilerplate above the function,
+creating our input block::
 
-       /*[clinic input]
-       _pickle.Pickler.dump
+    /*[clinic input]
+    [clinic start generated code]*/
 
-           obj: 'O'
-               The object to be pickled.
-           /
+Cut the docstring and paste it in between the ``[clinic]`` lines,
+removing all the junk that makes it a properly quoted C string.
+When you're done you should have just the text, based at the left
+margin, with no line wider than 80 characters.
+Argument Clinic will preserve indents inside the docstring.
+
+If the old docstring had a first line that looked like a function
+signature, throw that line away; The docstring doesn't need it anymore ---
+when you use :py:func:`help` on your builtin in the future,
+the first line will be built automatically based on the function's signature.
 
-       Write a pickled representation of obj to the open file.
-       [clinic start generated code]*/
+Example docstring summary line::
 
-       static PyObject *
-       _pickle_Pickler_dump(PicklerObject *self, PyObject *obj)
-       /*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/
+   /*[clinic input]
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
 
-    Obviously, if Argument Clinic didn't produce any output, it's because
-    it found an error in your input.  Keep fixing your errors and retrying
-    until Argument Clinic processes your file without complaint.
+If your docstring doesn't have a "summary" line, Argument Clinic will
+complain, so let's make sure it has one.  The "summary" line should
+be a paragraph consisting of a single 80-column line
+at the beginning of the docstring.
+(See :pep:`257` regarding docstring conventions.)
+
+Our example docstring consists solely of a summary line, so the sample
+code doesn't have to change for this step.
+
+Now, above the docstring, enter the name of the function, followed
+by a blank line.  This should be the Python name of the function,
+and should be the full dotted path to the function ---
+it should start with the name of the module,
+include any sub-modules, and if the function is a method on
+a class it should include the class name too.
+
+In our example, :mod:`!_pickle` is the module, :py:class:`!Pickler` is the class,
+and :py:meth:`!dump` is the method, so the name becomes
+:py:meth:`!_pickle.Pickler.dump`::
 
-    For readability, most of the glue code has been generated to a ``.c.h``
-    file.  You'll need to include that in your original ``.c`` file,
-    typically right after the clinic module block::
+   /*[clinic input]
+   _pickle.Pickler.dump
 
-       #include "clinic/_pickle.c.h"
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
 
-13. Double-check that the argument-parsing code Argument Clinic generated
-    looks basically the same as the existing code.
+If this is the first time that module or class has been used with Argument
+Clinic in this C file,
+you must declare the module and/or class.  Proper Argument Clinic hygiene
+prefers declaring these in a separate block somewhere near the
+top of the C file, in the same way that include files and statics go at
+the top.
+In our sample code we'll just show the two blocks next to each other.
+
+The name of the class and module should be the same as the one
+seen by Python.  Check the name defined in the :c:type:`PyModuleDef`
+or :c:type:`PyTypeObject` as appropriate.
+
+When you declare a class, you must also specify two aspects of its type
+in C: the type declaration you'd use for a pointer to an instance of
+this class, and a pointer to the :c:type:`!PyTypeObject` for this class::
 
-    First, ensure both places use the same argument-parsing function.
-    The existing code must call either
-    :c:func:`PyArg_ParseTuple` or :c:func:`PyArg_ParseTupleAndKeywords`;
-    ensure that the code generated by Argument Clinic calls the
-    *exact* same function.
+   /*[clinic input]
+   module _pickle
+   class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
+   [clinic start generated code]*/
 
-    Second, the format string passed in to :c:func:`PyArg_ParseTuple` or
-    :c:func:`PyArg_ParseTupleAndKeywords` should be *exactly* the same
-    as the hand-written one in the existing function, up to the colon
-    or semi-colon.
+   /*[clinic input]
+   _pickle.Pickler.dump
 
-    (Argument Clinic always generates its format strings
-    with a ``:`` followed by the name of the function.  If the
-    existing code's format string ends with ``;``, to provide
-    usage help, this change is harmlessdon't worry about it.)
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
 
-    Third, for parameters whose format units require two arguments
-    (like a length variable, or an encoding string, or a pointer
-    to a conversion function), ensure that the second argument is
-    *exactly* the same between the two invocations.
+Declare each of the parameters to the function.  Each parameter
+should get its own line.  All the parameter lines should be
+indented from the function name and the docstring.
+The general form of these parameter lines is as follows:
 
-    Fourth, inside the output portion of the block you'll find a preprocessor
-    macro defining the appropriate static :c:type:`PyMethodDef` structure for
-    this builtin::
+.. code-block:: none
 
-        #define __PICKLE_PICKLER_DUMP_METHODDEF    \
-        {"dump", (PyCFunction)__pickle_Pickler_dump, METH_O, __pickle_Pickler_dump__doc__},
+    name_of_parameter: converter
 
-    This static structure should be *exactly* the same as the existing static
-    :c:type:`PyMethodDef` structure for this builtin.
+If the parameter has a default value, add that after the
+converter:
 
-    If any of these items differ in *any way*,
-    adjust your Argument Clinic function specification and rerun
-    ``Tools/clinic/clinic.py`` until they *are* the same.
+.. code-block:: none
 
+    name_of_parameter: converter = default_value
 
-14. Notice that the last line of its output is the declaration
-    of your "impl" function.  This is where the builtin's implementation goes.
-    Delete the existing prototype of the function you're modifying, but leave
-    the opening curly brace.  Now delete its argument parsing code and the
-    declarations of all the variables it dumps the arguments into.
-    Notice how the Python arguments are now arguments to this impl function;
-    if the implementation used different names for these variables, fix it.
+Argument Clinic's support for "default values" is quite sophisticated;
+see :ref:`clinic-howto-default-values` for more information.
 
-    Let's reiterate, just because it's kind of weird.  Your code should now
-    look like this::
+Next, add a blank line below the parameters.
 
-        static return_type
-        your_function_impl(...)
-        /*[clinic end generated code: checksum=...]*/
-        {
-        ...
+What's a "converter"?
+It establishes both the type of the variable used in C,
+and the method to convert the Python value into a C value at runtime.
+For now you're going to use what's called a "legacy converter" ---
+a convenience syntax intended to make porting old code into Argument
+Clinic easier.
+
+For each parameter, copy the "format unit" for that
+parameter from the :c:func:`PyArg_Parse` format argument and
+specify *that* as its converter, as a quoted string.
+The "format unit" is the formal name for the one-to-three
+character substring of the *format* parameter that tells
+the argument parsing function what the type of the variable
+is and how to convert it.
+For more on format units please see :ref:`arg-parsing`.
 
-    Argument Clinic generated the checksum line and the function prototype just
-    above it.  You should write the opening (and closing) curly braces for the
-    function, and the implementation inside.
-
-    Sample::
-
-        /*[clinic input]
-        module _pickle
-        class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
-        [clinic start generated code]*/
-        /*[clinic end generated code: checksum=da39a3ee5e6b4b0d3255bfef95601890afd80709]*/
-
-        /*[clinic input]
-        _pickle.Pickler.dump
-
-            obj: 'O'
-                The object to be pickled.
-            /
-
-        Write a pickled representation of obj to the open file.
-        [clinic start generated code]*/
-
-        PyDoc_STRVAR(__pickle_Pickler_dump__doc__,
-        "Write a pickled representation of obj to the open file.\n"
-        "\n"
-        ...
-        static PyObject *
-        _pickle_Pickler_dump_impl(PicklerObject *self, PyObject *obj)
-        /*[clinic end generated code: checksum=3bd30745bf206a48f8b576a1da3d90f55a0a4187]*/
-        {
-            /* Check whether the Pickler was initialized correctly (issue3664).
-               Developers often forget to call __init__() in their subclasses, which
-               would trigger a segfault without this check. */
-            if (self->write == NULL) {
-                PyErr_Format(PicklingError,
-                             "Pickler.__init__() was not called by %s.__init__()",
-                             Py_TYPE(self)->tp_name);
-                return NULL;
-            }
-
-            if (_Pickler_ClearBuffer(self) < 0)
-                return NULL;
-
-            ...
-
-15. Remember the macro with the :c:type:`PyMethodDef` structure for this
-    function?  Find the existing :c:type:`PyMethodDef` structure for this
-    function and replace it with a reference to the macro.  (If the builtin
-    is at module scope, this will probably be very near the end of the file;
-    if the builtin is a class method, this will probably be below but relatively
-    near to the implementation.)
-
-    Note that the body of the macro contains a trailing comma.  So when you
-    replace the existing static :c:type:`PyMethodDef` structure with the macro,
-    *don't* add a comma to the end.
-
-    Sample::
-
-        static struct PyMethodDef Pickler_methods[] = {
-            __PICKLE_PICKLER_DUMP_METHODDEF
-            __PICKLE_PICKLER_CLEAR_MEMO_METHODDEF
-            {NULL, NULL}                /* sentinel */
-        };
-
-
-16. Compile, then run the relevant portions of the regression-test suite.
-    This change should not introduce any new compile-time warnings or errors,
-    and there should be no externally visible change to Python's behavior.
-
-    Well, except for one difference: ``inspect.signature()`` run on your function
-    should now provide a valid signature!
+For multicharacter format units like ``z#``,
+use the entire two-or-three character string.
 
-    Congratulations, you've ported your first function to work with Argument Clinic!
+Sample::
 
-Advanced Topics
-===============
+   /*[clinic input]
+   module _pickle
+   class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
+   [clinic start generated code]*/
 
-Now that you've had some experience working with Argument Clinic, it's time
-for some advanced topics.
+   /*[clinic input]
+   _pickle.Pickler.dump
 
+       obj: 'O'
 
-Symbolic default values
------------------------
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
 
-The default value you provide for a parameter can't be any arbitrary
-expression.  Currently the following are explicitly supported:
+If your function has ``|`` in the format string,
+meaning some parameters have default values, you can ignore it.
+Argument Clinic infers which parameters are optional
+based on whether or not they have default values.
+
+If your function has ``$`` in the format string,
+meaning it takes keyword-only arguments,
+specify ``*`` on a line by itself before the first keyword-only argument,
+indented the same as the parameter lines.
+
+:py:meth:`!_pickle.Pickler.dump` has neither, so our sample is unchanged.
+
+Next, if the existing C function calls :c:func:`PyArg_ParseTuple`
+(as opposed to :c:func:`PyArg_ParseTupleAndKeywords`), then all its
+arguments are positional-only.
+
+To mark parameters as positional-only in Argument Clinic,
+add a ``/`` on a line by itself after the last positional-only parameter,
+indented the same as the parameter lines.
 
-* Numeric constants (integer and float)
-* String constants
-* ``True``, ``False``, and ``None``
-* Simple symbolic constants like ``sys.maxsize``, which must
-  start with the name of the module
+Sample::
 
-(In the future, this may need to get even more elaborate,
-to allow full expressions like ``CONSTANT - 1``.)
+   /*[clinic input]
+   module _pickle
+   class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
+   [clinic start generated code]*/
 
+   /*[clinic input]
+   _pickle.Pickler.dump
 
-Renaming the C functions and variables generated by Argument Clinic
--------------------------------------------------------------------
+       obj: 'O'
+       /
+
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
+
+It can be helpful to write a per-parameter docstring for each parameter.
+Since per-parameter docstrings are optional,
+you can skip this step if you prefer.
+
+Nevertheless, here's how to add a per-parameter docstring.
+The first line of the per-parameter docstring
+must be indented further than the parameter definition.
+The left margin of this first line establishes
+the left margin for the whole per-parameter docstring;
+all the text you write will be outdented by this amount.
+You can write as much text as you like, across multiple lines if you wish.
+
+Sample::
+
+   /*[clinic input]
+   module _pickle
+   class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
+   [clinic start generated code]*/
+
+   /*[clinic input]
+   _pickle.Pickler.dump
+
+       obj: 'O'
+           The object to be pickled.
+       /
+
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
+
+Save and close the file, then run ``Tools/clinic/clinic.py`` on it.
+With luck everything worked---your block now has output,
+and a :file:`.c.h` file has been generated!
+Reload the file in your text editor to see the generated code::
+
+   /*[clinic input]
+   _pickle.Pickler.dump
+
+       obj: 'O'
+           The object to be pickled.
+       /
+
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
+
+   static PyObject *
+   _pickle_Pickler_dump(PicklerObject *self, PyObject *obj)
+   /*[clinic end generated code: output=87ecad1261e02ac7 input=552eb1c0f52260d9]*/
+
+Obviously, if Argument Clinic didn't produce any output,
+it's because it found an error in your input.
+Keep fixing your errors and retrying until Argument Clinic processes your file
+without complaint.
+
+For readability, most of the glue code has been generated to a :file:`.c.h`
+file.  You'll need to include that in your original :file:`.c` file,
+typically right after the clinic module block::
+
+   #include "clinic/_pickle.c.h"
+
+Double-check that the argument-parsing code Argument Clinic generated
+looks basically the same as the existing code.
+
+First, ensure both places use the same argument-parsing function.
+The existing code must call either
+:c:func:`PyArg_ParseTuple` or :c:func:`PyArg_ParseTupleAndKeywords`;
+ensure that the code generated by Argument Clinic calls the
+*exact* same function.
+
+Second, the format string passed in to :c:func:`!PyArg_ParseTuple` or
+:c:func:`!PyArg_ParseTupleAndKeywords` should be *exactly* the same
+as the hand-written one in the existing function,
+up to the colon or semi-colon.
+
+Argument Clinic always generates its format strings
+with a ``:`` followed by the name of the function.
+If the existing code's format string ends with ``;``,
+to provide usage help, this change is harmless --- don't worry about it.
+
+Third, for parameters whose format units require two arguments,
+like a length variable, an encoding string, or a pointer
+to a conversion function, ensure that the second argument is
+*exactly* the same between the two invocations.
+
+Fourth, inside the output portion of the block,
+you'll find a preprocessor macro defining the appropriate static
+:c:type:`PyMethodDef` structure for this builtin::
+
+   #define __PICKLE_PICKLER_DUMP_METHODDEF    \
+   {"dump", (PyCFunction)__pickle_Pickler_dump, METH_O, __pickle_Pickler_dump__doc__},
+
+This static structure should be *exactly* the same as the existing static
+:c:type:`!PyMethodDef` structure for this builtin.
+
+If any of these items differ in *any way*,
+adjust your Argument Clinic function specification and rerun
+``Tools/clinic/clinic.py`` until they *are* the same.
+
+Notice that the last line of its output is the declaration
+of your "impl" function.  This is where the builtin's implementation goes.
+Delete the existing prototype of the function you're modifying, but leave
+the opening curly brace.  Now delete its argument parsing code and the
+declarations of all the variables it dumps the arguments into.
+Notice how the Python arguments are now arguments to this impl function;
+if the implementation used different names for these variables, fix it.
+
+Let's reiterate, just because it's kind of weird.
+Your code should now look like this::
+
+   static return_type
+   your_function_impl(...)
+   /*[clinic end generated code: input=..., output=...]*/
+   {
+   ...
+
+Argument Clinic generated the checksum line and the function prototype just
+above it.  You should write the opening and closing curly braces for the
+function, and the implementation inside.
+
+Sample::
+
+   /*[clinic input]
+   module _pickle
+   class _pickle.Pickler "PicklerObject *" "&Pickler_Type"
+   [clinic start generated code]*/
+   /*[clinic end generated code: checksum=da39a3ee5e6b4b0d3255bfef95601890afd80709]*/
+
+   /*[clinic input]
+   _pickle.Pickler.dump
+
+       obj: 'O'
+           The object to be pickled.
+       /
+
+   Write a pickled representation of obj to the open file.
+   [clinic start generated code]*/
+
+   PyDoc_STRVAR(__pickle_Pickler_dump__doc__,
+   "Write a pickled representation of obj to the open file.\n"
+   "\n"
+   ...
+   static PyObject *
+   _pickle_Pickler_dump_impl(PicklerObject *self, PyObject *obj)
+   /*[clinic end generated code: checksum=3bd30745bf206a48f8b576a1da3d90f55a0a4187]*/
+   {
+       /* Check whether the Pickler was initialized correctly (issue3664).
+          Developers often forget to call __init__() in their subclasses, which
+          would trigger a segfault without this check. */
+       if (self->write == NULL) {
+           PyErr_Format(PicklingError,
+                        "Pickler.__init__() was not called by %s.__init__()",
+                        Py_TYPE(self)->tp_name);
+           return NULL;
+       }
+
+       if (_Pickler_ClearBuffer(self) < 0) {
+           return NULL;
+       }
+
+       ...
+
+Remember the macro with the :c:type:`PyMethodDef` structure for this function?
+Find the existing :c:type:`!PyMethodDef` structure for this
+function and replace it with a reference to the macro.  If the builtin
+is at module scope, this will probably be very near the end of the file;
+if the builtin is a class method, this will probably be below but relatively
+near to the implementation.
+
+Note that the body of the macro contains a trailing comma; when you
+replace the existing static :c:type:`!PyMethodDef` structure with the macro,
+*don't* add a comma to the end.
+
+Sample::
+
+   static struct PyMethodDef Pickler_methods[] = {
+       __PICKLE_PICKLER_DUMP_METHODDEF
+       __PICKLE_PICKLER_CLEAR_MEMO_METHODDEF
+       {NULL, NULL}                /* sentinel */
+   };
+
+Finally, compile, then run the relevant portions of the regression-test suite.
+This change should not introduce any new compile-time warnings or errors,
+and there should be no externally visible change to Python's behavior,
+except for one difference: :py:func:`inspect.signature` run on your function
+should now provide a valid signature!
+
+Congratulations, you've ported your first function to work with Argument Clinic!
+
+
+.. _clinic-howtos:
+
+How-to guides
+=============
+
+
+How to rename C functions and variables generated by Argument Clinic
+--------------------------------------------------------------------
 
 Argument Clinic automatically names the functions it generates for you.
 Occasionally this may cause a problem, if the generated name collides with
@@ -585,15 +679,15 @@ Argument Clinic will use that function n
 then add ``"_impl"`` to the end and use that for the name of the impl function.
 
 For example, if we wanted to rename the C function names generated for
-``pickle.Pickler.dump``, it'd look like this::
+:py:meth:`pickle.Pickler.dump`, it'd look like this::
 
     /*[clinic input]
     pickle.Pickler.dump as pickler_dumper
 
     ...
 
-The base function would now be named ``pickler_dumper()``,
-and the impl function would now be named ``pickler_dumper_impl()``.
+The base function would now be named :c:func:`!pickler_dumper`,
+and the impl function would now be named :c:func:`!pickler_dumper_impl`.
 
 
 Similarly, you may have a problem where you want to give a parameter
@@ -611,25 +705,26 @@ using the same ``"as"`` syntax::
         fix_imports: bool = True
 
 Here, the name used in Python (in the signature and the ``keywords``
-array) would be ``file``, but the C variable would be named ``file_obj``.
+array) would be *file*, but the C variable would be named ``file_obj``.
 
-You can use this to rename the ``self`` parameter too!
+You can use this to rename the *self* parameter too!
 
 
-Converting functions using PyArg_UnpackTuple
---------------------------------------------
+How to convert functions using ``PyArg_UnpackTuple``
+----------------------------------------------------
 
 To convert a function parsing its arguments with :c:func:`PyArg_UnpackTuple`,
 simply write out all the arguments, specifying each as an ``object``.  You
-may specify the ``type`` argument to cast the type as appropriate.  All
+may specify the *type* argument to cast the type as appropriate.  All
 arguments should be marked positional-only (add a ``/`` on a line by itself
 after the last argument).
 
 Currently the generated code will use :c:func:`PyArg_ParseTuple`, but this
 will change soon.
 
-Optional Groups
----------------
+
+How to use optional groups
+--------------------------
 
 Some legacy functions have a tricky approach to parsing their arguments:
 they count the number of positional arguments, then use a ``switch`` statement
@@ -639,16 +734,16 @@ keyword-only arguments.)  This approach
 arguments back before :c:func:`PyArg_ParseTupleAndKeywords` was created.
 
 While functions using this approach can often be converted to
-use :c:func:`PyArg_ParseTupleAndKeywords`, optional arguments, and default values,
+use :c:func:`!PyArg_ParseTupleAndKeywords`, optional arguments, and default values,
 it's not always possible.  Some of these legacy functions have
-behaviors :c:func:`PyArg_ParseTupleAndKeywords` doesn't directly support.
-The most obvious example is the builtin function ``range()``, which has
+behaviors :c:func:`!PyArg_ParseTupleAndKeywords` doesn't directly support.
+The most obvious example is the builtin function :py:func:`range`, which has
 an optional argument on the *left* side of its required argument!
-Another example is ``curses.window.addch()``, which has a group of two
+Another example is :py:meth:`curses.window.addch`, which has a group of two
 arguments that must always be specified together.  (The arguments are
-called ``x`` and ``y``; if you call the function passing in ``x``,
-you must also pass in ``y``and if you don't pass in ``x`` you may not
-pass in ``y`` either.)
+called *x* and *y*; if you call the function passing in *x*,
+you must also pass in *y*  and if you don't pass in *x* you may not
+pass in *y* either.)
 
 In any case, the goal of Argument Clinic is to support argument parsing
 for all existing CPython builtins without changing their semantics.
@@ -669,7 +764,7 @@ can *only* be used with positional-only
 
 To specify an optional group, add a ``[`` on a line by itself before
 the parameters you wish to group together, and a ``]`` on a line by itself
-after these parameters.  As an example, here's how ``curses.window.addch``
+after these parameters.  As an example, here's how :py:meth:`curses.window.addch`
 uses optional groups to make the first two parameters and the last
 parameter optional::
 
@@ -721,8 +816,8 @@ Notes:
   use optional groups for new code.
 
 
-Using real Argument Clinic converters, instead of "legacy converters"
----------------------------------------------------------------------
+How to use real Argument Clinic converters, instead of "legacy converters"
+--------------------------------------------------------------------------
 
 To save time, and to minimize how much you need to learn
 to achieve your first port to Argument Clinic, the walkthrough above tells
@@ -755,14 +850,14 @@ the same converters.
 All arguments to Argument Clinic converters are keyword-only.
 All Argument Clinic converters accept the following arguments:
 
-  ``c_default``
+  *c_default*
     The default value for this parameter when defined in C.
     Specifically, this will be the initializer for the variable declared
     in the "parse function".  See :ref:`the section on default values <default_values>`
     for how to use this.
     Specified as a string.
 
-  ``annotation``
+  *annotation*
     The annotation value for this parameter.  Not currently supported,
     because :pep:`8` mandates that the Python library may not use
     annotations.
@@ -770,7 +865,7 @@ All Argument Clinic converters accept th
 In addition, some converters accept additional arguments.  Here is a list
 of these arguments, along with their meanings:
 
-  ``accept``
+  *accept*
     A set of Python types (and possibly pseudo-types);
     this restricts the allowable Python argument to values of these types.
     (This is not a general-purpose facility; as a rule it only supports
@@ -778,38 +873,38 @@ of these arguments, along with their mea
 
     To accept ``None``, add ``NoneType`` to this set.
 
-  ``bitwise``
+  *bitwise*
     Only supported for unsigned integers.  The native integer value of this
     Python argument will be written to the parameter without any range checking,
     even for negative values.
 
-  ``converter``
+  *converter*
     Only supported by the ``object`` converter.  Specifies the name of a
     :ref:`C "converter function" <o_ampersand>`
     to use to convert this object to a native type.
 
-  ``encoding``
+  *encoding*
     Only supported for strings.  Specifies the encoding to use when converting
     this string from a Python str (Unicode) value into a C ``char *`` value.
 
 
-  ``subclass_of``
+  *subclass_of*
     Only supported for the ``object`` converter.  Requires that the Python
     value be a subclass of a Python type, as expressed in C.
 
-  ``type``
+  *type*
     Only supported for the ``object`` and ``self`` converters.  Specifies
     the C type that will be used to declare the variable.  Default value is
     ``"PyObject *"``.
 
-  ``zeroes``
+  *zeroes*
     Only supported for strings.  If true, embedded NUL bytes (``'\\0'``) are
     permitted inside the value.  The length of the string will be passed in
     to the impl function, just after the string parameter, as a parameter named
     ``<parameter_name>_length``.
 
 Please note, not every possible combination of arguments will work.
-Usually these arguments are implemented by specific ``PyArg_ParseTuple``
+Usually these arguments are implemented by specific :c:func:`PyArg_ParseTuple`
 *format units*, with specific behavior.  For example, currently you cannot
 call ``unsigned_short`` without also specifying ``bitwise=True``.
 Although it's perfectly reasonable to think this would work, these semantics don't
@@ -888,8 +983,9 @@ available.  For each converter it'll sho
 it accepts, along with the default value for each parameter.
 Just run ``Tools/clinic/clinic.py --converters`` to see the full list.
 
-Py_buffer
----------
+
+How to use the ``Py_buffer`` converter
+--------------------------------------
 
 When using the ``Py_buffer`` converter
 (or the ``'s*'``, ``'w*'``, ``'*y'``, or ``'z*'`` legacy converters),
@@ -897,9 +993,10 @@ you *must* not call :c:func:`PyBuffer_Re
 Argument Clinic generates code that does it for you (in the parsing function).
 
 
+.. _clinic-howto-advanced-converters:
 
-Advanced converters
--------------------
+How to use advanced converters
+------------------------------
 
 Remember those format units you skipped for your first
 time because they were advanced?  Here's how to handle those too.
@@ -909,29 +1006,30 @@ conversion functions, or types, or strin
 (But "legacy converters" don't support arguments.  That's why we
 skipped them for your first function.)  The argument you specified
 to the format unit is now an argument to the converter; this
-argument is either ``converter`` (for ``O&``), ``subclass_of`` (for ``O!``),
-or ``encoding`` (for all the format units that start with ``e``).
+argument is either *converter* (for ``O&``), *subclass_of* (for ``O!``),
+or *encoding* (for all the format units that start with ``e``).
 
-When using ``subclass_of``, you may also want to use the other
-custom argument for ``object()``: ``type``, which lets you set the type
+When using *subclass_of*, you may also want to use the other
+custom argument for ``object()``: *type*, which lets you set the type
 actually used for the parameter.  For example, if you want to ensure
-that the object is a subclass of ``PyUnicode_Type``, you probably want
+that the object is a subclass of :c:var:`PyUnicode_Type`, you probably want
 to use the converter ``object(type='PyUnicodeObject *', subclass_of='&PyUnicode_Type')``.
 
 One possible problem with using Argument Clinic: it takes away some possible
 flexibility for the format units starting with ``e``.  When writing a
-``PyArg_Parse`` call by hand, you could theoretically decide at runtime what
-encoding string to pass in to :c:func:`PyArg_ParseTuple`.   But now this string must
+:c:func:`!PyArg_Parse*` call by hand, you could theoretically decide at runtime what
+encoding string to pass to that call.   But now this string must
 be hard-coded at Argument-Clinic-preprocessing-time.  This limitation is deliberate;
 it made supporting this format unit much easier, and may allow for future optimizations.
 This restriction doesn't seem unreasonable; CPython itself always passes in static
 hard-coded encoding strings for parameters whose format units start with ``e``.
 
 
+.. _clinic-howto-default-values:
 .. _default_values:
 
-Parameter default values
-------------------------
+How to assign default values to parameter
+-----------------------------------------
 
 Default values for parameters can be any of a number of values.
 At their simplest, they can be string, int, or float literals:
@@ -955,7 +1053,7 @@ for simple expressions, documented in th
 
 
 The ``NULL`` default value
---------------------------
+^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 For string and object parameters, you can set them to ``None`` to indicate
 that there's no default.  However, that means the C variable will be
@@ -964,8 +1062,25 @@ value called ``NULL`` for just this reas
 behaves like a default value of ``None``, but the C variable is initialized
 with ``NULL``.
 
-Expressions specified as default values
----------------------------------------
+
+Symbolic default values
+^^^^^^^^^^^^^^^^^^^^^^^
+
+The default value you provide for a parameter can't be any arbitrary
+expression.  Currently the following are explicitly supported:
+
+* Numeric constants (integer and float)
+* String constants
+* ``True``, ``False``, and ``None``
+* Simple symbolic constants like :py:data:`sys.maxsize`, which must
+  start with the name of the module
+
+(In the future, this may need to get even more elaborate,
+to allow full expressions like ``CONSTANT - 1``.)
+
+
+Expressions as default values
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 The default value for a parameter can be more than just a literal value.
 It can be an entire expression, using math operators and looking up attributes
@@ -978,28 +1093,28 @@ Consider the following example:
 
     foo: Py_ssize_t = sys.maxsize - 1
 
-``sys.maxsize`` can have different values on different platforms.  Therefore
+:py:data:`sys.maxsize` can have different values on different platforms.  Therefore
 Argument Clinic can't simply evaluate that expression locally and hard-code it
 in C.  So it stores the default in such a way that it will get evaluated at
 runtime, when the user asks for the function's signature.
 
 What namespace is available when the expression is evaluated?  It's evaluated
 in the context of the module the builtin came from.  So, if your module has an
-attribute called "``max_widgets``", you may simply use it:
+attribute called :py:attr:`!max_widgets`, you may simply use it:
 
 .. code-block:: none
 
     foo: Py_ssize_t = max_widgets
 
 If the symbol isn't found in the current module, it fails over to looking in
-``sys.modules``.  That's how it can find ``sys.maxsize`` for example.  (Since you
-don't know in advance what modules the user will load into their interpreter,
+:py:data:`sys.modules`.  That's how it can find :py:data:`sys.maxsize` for example.
+(Since you don't know in advance what modules the user will load into their interpreter,
 it's best to restrict yourself to modules that are preloaded by Python itself.)
 
 Evaluating default values only at runtime means Argument Clinic can't compute
 the correct equivalent C default value.  So you need to tell it explicitly.
 When you use an expression, you must also specify the equivalent expression
-in C, using the ``c_default`` parameter to the converter:
+in C, using the *c_default* parameter to the converter:
 
 .. code-block:: none
 
@@ -1021,9 +1136,10 @@ you're not permitted to use:
 * Tuple/list/set/dict literals.
 
 
+.. _clinic-howto-return-converters:
 
-Using a return converter
-------------------------
+How to use return converters
+----------------------------
 
 By default, the impl function Argument Clinic generates for you returns
 :c:type:`PyObject * <PyObject>`.
@@ -1066,7 +1182,7 @@ indicate an error has occurred?  Normall
 pointer for success, and ``NULL`` for failure.  But if you use an integer return converter,
 all integers are valid.  How can Argument Clinic detect an error?  Its solution: each return
 converter implicitly looks for a special value that indicates an error.  If you return
-that value, and an error has been set (``PyErr_Occurred()`` returns a true
+that value, and an error has been set (c:func:`PyErr_Occurred` returns a true
 value), then the generated code will propagate the error.  Otherwise it will
 encode the value you return like normal.
 
@@ -1097,8 +1213,8 @@ their parameters (if any),
 just run ``Tools/clinic/clinic.py --converters`` for the full list.
 
 
-Cloning existing functions
---------------------------
+How to clone existing functions
+-------------------------------
 
 If you have a number of functions that look similar, you may be able to
 use Clinic's "clone" feature.  When you clone an existing function,
@@ -1140,8 +1256,9 @@ then modifying it.  Cloning is an all-or
 Also, the function you are cloning from must have been previously defined
 in the current file.
 
-Calling Python code
--------------------
+
+How to call Python code
+-----------------------
 
 The rest of the advanced topics require you to write Python code
 which lives inside your C file and modifies Argument Clinic's
@@ -1168,17 +1285,19 @@ variable to the C code::
     /*[python checksum:...]*/
 
 
-Using a "self converter"
-------------------------
+.. _clinic-howto-self-converter:
+
+How to use the "self converter"
+-------------------------------
 
 Argument Clinic automatically adds a "self" parameter for you
 using a default converter.  It automatically sets the ``type``
 of this parameter to the "pointer to an instance" you specified
 when you declared the type.  However, you can override
 Argument Clinic's converter and specify one yourself.
-Just add your own ``self`` parameter as the first parameter in a
+Just add your own *self* parameter as the first parameter in a
 block, and ensure that its converter is an instance of
-``self_converter`` or a subclass thereof.
+:class:`!self_converter` or a subclass thereof.
 
 What's the point?  This lets you override the type of ``self``,
 or give it a different default name.
@@ -1186,7 +1305,7 @@ or give it a different default name.
 How do you specify the custom type you want to cast ``self`` to?
 If you only have one or two functions with the same type for ``self``,
 you can directly use Argument Clinic's existing ``self`` converter,
-passing in the type you want to use as the ``type`` parameter::
+passing in the type you want to use as the *type* parameter::
 
     /*[clinic input]
 
@@ -1201,7 +1320,7 @@ passing in the type you want to use as t
 
 On the other hand, if you have a lot of functions that will use the same
 type for ``self``, it's best to create your own converter, subclassing
-``self_converter`` but overwriting the ``type`` member::
+:class:`!self_converter` but overwriting the :py:attr:`!type` member::
 
     /*[python input]
     class PicklerObject_converter(self_converter):
@@ -1220,8 +1339,8 @@ type for ``self``, it's best to create y
     [clinic start generated code]*/
 
 
-Using a "defining class" converter
-----------------------------------
+How to use the "defining class" converter
+-----------------------------------------
 
 Argument Clinic facilitates gaining access to the defining class of a method.
 This is useful for :ref:`heap type <heap-types>` methods that need to fetch
@@ -1229,8 +1348,8 @@ module level state.  Use :c:func:`PyType
 heap type with a module.  You can now use :c:func:`PyType_GetModuleState` on
 the defining class to fetch the module state, for example from a module method.
 
-Example from ``Modules/zlibmodule.c``.  First, ``defining_class`` is added to
-the clinic input::
+Example from :source:`Modules/zlibmodule.c`.
+First, ``defining_class`` is added to the clinic input::
 
     /*[clinic input]
     zlib.Compress.compress
@@ -1260,16 +1379,17 @@ module state::
 Each method may only have one argument using this converter, and it must appear
 after ``self``, or, if ``self`` is not used, as the first argument.  The argument
 will be of type ``PyTypeObject *``.  The argument will not appear in the
-``__text_signature__``.
+:py:attr:`!__text_signature__`.
 
-The ``defining_class`` converter is not compatible with ``__init__`` and ``__new__``
-methods, which cannot use the ``METH_METHOD`` convention.
+The ``defining_class`` converter is not compatible with :py:meth:`!__init__`
+and :py:meth:`!__new__` methods, which cannot use the :c:macro:`METH_METHOD`
+convention.
 
 It is not possible to use ``defining_class`` with slot methods.  In order to
 fetch the module state from such methods, use :c:func:`PyType_GetModuleByDef`
 to look up the module and then :c:func:`PyModule_GetState` to fetch the module
 state.  Example from the ``setattro`` slot method in
-``Modules/_threadmodule.c``::
+:source:`Modules/_threadmodule.c`::
 
     static int
     local_setattro(localobject *self, PyObject *name, PyObject *v)
@@ -1283,76 +1403,31 @@ state.  Example from the ``setattro`` sl
 See also :pep:`573`.
 
 
-Writing a custom converter
---------------------------
+.. _clinic-howto-custom-converter:
 
-As we hinted at in the previous section... you can write your own converters!
-A converter is simply a Python class that inherits from ``CConverter``.
-The main purpose of a custom converter is if you have a parameter using
-the ``O&`` format unitparsing this parameter means calling
-a :c:func:`PyArg_ParseTuple` "converter function".
+How to write a custom converter
+-------------------------------
 
-Your converter class should be named ``*something*_converter``.
-If the name follows this convention, then your converter class
-will be automatically registered with Argument Clinic; its name
-will be the name of your class with the ``_converter`` suffix
-stripped off.  (This is accomplished with a metaclass.)
-
-You shouldn't subclass ``CConverter.__init__``.  Instead, you should
-write a ``converter_init()`` function.  ``converter_init()``
-always accepts a ``self`` parameter; after that, all additional
-parameters *must* be keyword-only.  Any arguments passed in to
-the converter in Argument Clinic will be passed along to your
-``converter_init()``.
-
-There are some additional members of ``CConverter`` you may wish
-to specify in your subclass.  Here's the current list:
-
-``type``
-    The C type to use for this variable.
-    ``type`` should be a Python string specifying the type, e.g. ``int``.
-    If this is a pointer type, the type string should end with ``' *'``.
-
-``default``
-    The Python default value for this parameter, as a Python value.
-    Or the magic value ``unspecified`` if there is no default.
-
-``py_default``
-    ``default`` as it should appear in Python code,
-    as a string.
-    Or ``None`` if there is no default.
-
-``c_default``
-    ``default`` as it should appear in C code,
-    as a string.
-    Or ``None`` if there is no default.
-
-``c_ignored_default``
-    The default value used to initialize the C variable when
-    there is no default, but not specifying a default may
-    result in an "uninitialized variable" warning.  This can
-    easily happen when using option groupsalthough
-    properly written code will never actually use this value,
-    the variable does get passed in to the impl, and the
-    C compiler will complain about the "use" of the
-    uninitialized value.  This value should always be a
-    non-empty string.
-
-``converter``
-    The name of the C converter function, as a string.
-
-``impl_by_reference``
-    A boolean value.  If true,
-    Argument Clinic will add a ``&`` in front of the name of
-    the variable when passing it into the impl function.
-
-``parse_by_reference``
-    A boolean value.  If true,
-    Argument Clinic will add a ``&`` in front of the name of
-    the variable when passing it into :c:func:`PyArg_ParseTuple`.
+A converter is a Python class that inherits from :py:class:`CConverter`.
+The main purpose of a custom converter, is for parameters parsed with
+the ``O&`` format unit --- parsing such a parameter means calling
+a :c:func:`PyArg_ParseTuple` "converter function".
 
+Your converter class should be named :samp:`{ConverterName}_converter`.
+By following this convention, your converter class will be automatically
+registered with Argument Clinic, with its *converter name* being the name of
+your converter class with the ``_converter`` suffix stripped off.
+
+Instead of subclassing :py:meth:`!CConverter.__init__`,
+write a :py:meth:`!converter_init` method.
+:py:meth:`!converter_init` always accepts a *self* parameter.
+After *self*, all additional parameters **must** be keyword-only.
+Any arguments passed to the converter in Argument Clinic
+will be passed along to your :py:meth:`!converter_init` method.
+See :py:class:`CConverter` for a list of members you may wish to specify in
+your subclass.
 
-Here's the simplest example of a custom converter, from ``Modules/zlibmodule.c``::
+Here's the simplest example of a custom converter, from :source:`Modules/zlibmodule.c`::
 
     /*[python input]
 
@@ -1363,35 +1438,37 @@ Here's the simplest example of a custom
     [python start generated code]*/
     /*[python end generated code: output=da39a3ee5e6b4b0d input=35521e4e733823c7]*/
 
-This block adds a converter to Argument Clinic named ``ssize_t``.  Parameters
-declared as ``ssize_t`` will be declared as type :c:type:`Py_ssize_t`, and will
-be parsed by the ``'O&'`` format unit, which will call the
-``ssize_t_converter`` converter function.  ``ssize_t`` variables
-automatically support default values.
+This block adds a converter named ``ssize_t`` to Argument Clinic.
+Parameters declared as ``ssize_t`` will be declared with type :c:type:`Py_ssize_t`,
+and will be parsed by the ``'O&'`` format unit,
+which will call the :c:func:`!ssize_t_converter` converter C function.
+``ssize_t`` variables automatically support default values.
 
 More sophisticated custom converters can insert custom C code to
 handle initialization and cleanup.
 You can see more examples of custom converters in the CPython
 source tree; grep the C files for the string ``CConverter``.
 
-Writing a custom return converter
----------------------------------
+
+How to write a custom return converter
+--------------------------------------
 
 Writing a custom return converter is much like writing
 a custom converter.  Except it's somewhat simpler, because return
 converters are themselves much simpler.
 
-Return converters must subclass ``CReturnConverter``.
+Return converters must subclass :py:class:`!CReturnConverter`.
 There are no examples yet of custom return converters,
 because they are not widely used yet.  If you wish to
-write your own return converter, please read ``Tools/clinic/clinic.py``,
-specifically the implementation of ``CReturnConverter`` and
+write your own return converter, please read :source:`Tools/clinic/clinic.py`,
+specifically the implementation of :py:class:`!CReturnConverter` and
 all its subclasses.
 
-METH_O and METH_NOARGS
-----------------------------------------------
 
-To convert a function using ``METH_O``, make sure the function's
+How to convert ``METH_O`` and ``METH_NOARGS`` functions
+-------------------------------------------------------
+
+To convert a function using :c:macro:`METH_O`, make sure the function's
 single argument is using the ``object`` converter, and mark the
 arguments as positional-only::
 
@@ -1403,23 +1480,25 @@ arguments as positional-only::
     [clinic start generated code]*/
 
 
-To convert a function using ``METH_NOARGS``, just don't specify
+To convert a function using :c:macro:`METH_NOARGS`, just don't specify
 any arguments.
 
 You can still use a self converter, a return converter, and specify
-a ``type`` argument to the object converter for ``METH_O``.
+a *type* argument to the object converter for :c:macro:`METH_O`.
+
 
-tp_new and tp_init functions
-----------------------------------------------
+How to convert ``tp_new`` and ``tp_init`` functions
+---------------------------------------------------
 
-You can convert ``tp_new`` and ``tp_init`` functions.  Just name
-them ``__new__`` or ``__init__`` as appropriate.  Notes:
+You can convert :c:member:`~PyTypeObject.tp_new` and
+:c:member:`~PyTypeObject.tp_init` functions.
+Just name them ``__new__`` or ``__init__`` as appropriate.  Notes:
 
 * The function name generated for ``__new__`` doesn't end in ``__new__``
   like it would by default.  It's just the name of the class, converted
   into a valid C identifier.
 
-* No ``PyMethodDef`` ``#define`` is generated for these functions.
+* No :c:type:`PyMethodDef` ``#define`` is generated for these functions.
 
 * ``__init__`` functions return ``int``, not ``PyObject *``.
 
@@ -1431,8 +1510,9 @@ them ``__new__`` or ``__init__`` as appr
   (If your function doesn't support keywords, the parsing function
   generated will throw an exception if it receives any.)
 
-Changing and redirecting Clinic's output
-----------------------------------------
+
+How to change and redirect Clinic's output
+------------------------------------------
 
 It can be inconvenient to have Clinic's output interspersed with
 your conventional hand-edited C code.  Luckily, Clinic is configurable:
@@ -1453,7 +1533,7 @@ Let's start with defining some terminolo
 
 *field*
   A field, in this context, is a subsection of Clinic's output.
-  For example, the ``#define`` for the ``PyMethodDef`` structure
+  For example, the ``#define`` for the :c:type:`PyMethodDef` structure
   is a field, called ``methoddef_define``.  Clinic has seven
   different fields it can output per function definition:
 
@@ -1497,8 +1577,8 @@ Let's start with defining some terminolo
     The filename chosen for the file is ``{basename}.clinic{extension}``,
     where ``basename`` and ``extension`` were assigned the output
     from ``os.path.splitext()`` run on the current file.  (Example:
-    the ``file`` destination for ``_pickle.c`` would be written to
-    ``_pickle.clinic.c``.)
+    the ``file`` destination for :file:`_pickle.c` would be written to
+    :file:`_pickle.clinic.c`.)
 
     **Important: When using a** ``file`` **destination, you**
     *must check in* **the generated file!**
@@ -1714,8 +1794,8 @@ it in a Clinic block lets Clinic use its
 the file was not modified by hand before it gets overwritten.
 
 
-The #ifdef trick
-----------------------------------------------
+How to use the ``#ifdef`` trick
+-------------------------------
 
 If you're converting a function that isn't available on all platforms,
 there's a trick you can use to make life a little easier.  The existing
@@ -1751,7 +1831,7 @@ like so::
     }
     #endif /* HAVE_FUNCTIONNAME */
 
-Then, remove those three lines from the ``PyMethodDef`` structure,
+Then, remove those three lines from the :c:type:`PyMethodDef` structure,
 replacing them with the macro Argument Clinic generated:
 
 .. code-block:: none
@@ -1792,12 +1872,11 @@ This may mean that you get a complaint f
 
 When this happens, just open your file, find the ``dump buffer`` block that
 Argument Clinic added to your file (it'll be at the very bottom), then
-move it above the ``PyMethodDef`` structure where that macro is used.
-
+move it above the :c:type:`PyMethodDef` structure where that macro is used.
 
 
-Using Argument Clinic in Python files
--------------------------------------
+How to use Argument Clinic in Python files
+------------------------------------------
 
 It's actually possible to use Argument Clinic to preprocess Python files.
 There's no point to using Argument Clinic blocks, of course, as the output
@@ -1814,3 +1893,38 @@ blocks embedded in Python files look sli
     #[python start generated code]*/
     def foo(): pass
     #/*[python checksum:...]*/
+
+
+.. _clinic-howto-override-signature:
+
+How to override the generated signature
+---------------------------------------
+
+You can use the ``@text_signature`` directive to override the default generated
+signature in the docstring.
+This can be useful for complex signatures that Argument Clinic cannot handle.
+The ``@text_signature`` directive takes one argument:
+the custom signature as a string.
+The provided signature is copied verbatim to the generated docstring.
+
+Example from :source:`Objects/codeobject.c`::
+
+   /*[clinic input]
+   @text_signature "($self, /, **changes)"
+   code.replace
+       *
+       co_argcount: int(c_default="self->co_argcount") = unchanged
+       co_posonlyargcount: int(c_default="self->co_posonlyargcount") = unchanged
+       # etc ...
+
+       Return a copy of the code object with new values for the specified fields.
+   [clinic start generated output]*/
+
+The generated docstring ends up looking like this:
+
+.. code-block:: none
+
+   replace($self, /, **changes)
+   --
+
+   Return a copy of the code object with new values for the specified fields.
--- a/Doc/howto/curses.rst
+++ b/Doc/howto/curses.rst
@@ -527,7 +527,7 @@ If you're in doubt about the detailed be
 functions, consult the manual pages for your curses implementation,
 whether it's ncurses or a proprietary Unix vendor's.  The manual pages
 will document any quirks, and provide complete lists of all the
-functions, attributes, and :const:`ACS_\*` characters available to
+functions, attributes, and :ref:`ACS_\* <curses-acs-codes>` characters available to
 you.
 
 Because the curses API is so large, some functions aren't supported in
--- a/Doc/howto/descriptor.rst
+++ b/Doc/howto/descriptor.rst
@@ -779,8 +779,8 @@ by a search through the class's :term:`m
 
 If a descriptor is found, it is invoked with ``desc.__get__(None, A)``.
 
-The full C implementation can be found in :c:func:`type_getattro()` and
-:c:func:`_PyType_Lookup()` in :source:`Objects/typeobject.c`.
+The full C implementation can be found in :c:func:`!type_getattro` and
+:c:func:`!_PyType_Lookup` in :source:`Objects/typeobject.c`.
 
 
 Invocation from super
@@ -794,7 +794,7 @@ for the base class ``B`` immediately fol
 ``B.__dict__['m'].__get__(obj, A)``.  If not a descriptor, ``m`` is returned
 unchanged.
 
-The full C implementation can be found in :c:func:`super_getattro()` in
+The full C implementation can be found in :c:func:`!super_getattro` in
 :source:`Objects/typeobject.c`.  A pure Python equivalent can be found in
 `Guido's Tutorial
 <https://www.python.org/download/releases/2.2.3/descrintro/#cooperation>`_.
@@ -836,8 +836,8 @@ and if they define :meth:`__set_name__`,
 arguments.  The *owner* is the class where the descriptor is used, and the
 *name* is the class variable the descriptor was assigned to.
 
-The implementation details are in :c:func:`type_new()` and
-:c:func:`set_names()` in :source:`Objects/typeobject.c`.
+The implementation details are in :c:func:`!type_new` and
+:c:func:`!set_names` in :source:`Objects/typeobject.c`.
 
 Since the update logic is in :meth:`type.__new__`, notifications only take
 place at the time of class creation.  If descriptors are added to the class
--- a/Doc/howto/enum.rst
+++ b/Doc/howto/enum.rst
@@ -484,7 +484,16 @@ from that module.
     nested in other classes.
 
 It is possible to modify how enum members are pickled/unpickled by defining
-:meth:`__reduce_ex__` in the enumeration class.
+:meth:`__reduce_ex__` in the enumeration class.  The default method is by-value,
+but enums with complicated values may want to use by-name::
+
+    >>> class MyEnum(Enum):
+    ...     __reduce_ex__ = enum.pickle_by_enum_name
+
+.. note::
+
+    Using by-name for flags is not recommended, as unnamed aliases will
+    not unpickle.
 
 
 Functional API
--- a/Doc/howto/functional.rst
+++ b/Doc/howto/functional.rst
@@ -1072,8 +1072,8 @@ write the obvious :keyword:`for` loop::
 
 A related function is :func:`itertools.accumulate(iterable, func=operator.add)
 <itertools.accumulate>`.  It performs the same calculation, but instead of
-returning only the final result, :func:`accumulate` returns an iterator that
-also yields each partial result::
+returning only the final result, :func:`~itertools.accumulate` returns an iterator
+that also yields each partial result::
 
     itertools.accumulate([1, 2, 3, 4, 5]) =>
       1, 3, 6, 10, 15
--- a/Doc/howto/instrumentation.rst
+++ b/Doc/howto/instrumentation.rst
@@ -292,11 +292,11 @@ Available static markers
 
 .. object:: function__return(str filename, str funcname, int lineno)
 
-   This marker is the converse of :c:func:`function__entry`, and indicates that
+   This marker is the converse of :c:func:`!function__entry`, and indicates that
    execution of a Python function has ended (either via ``return``, or via an
    exception).  It is only triggered for pure-Python (bytecode) functions.
 
-   The arguments are the same as for :c:func:`function__entry`
+   The arguments are the same as for :c:func:`!function__entry`
 
 .. object:: line(str filename, str funcname, int lineno)
 
@@ -304,7 +304,7 @@ Available static markers
    the equivalent of line-by-line tracing with a Python profiler.  It is
    not triggered within C functions.
 
-   The arguments are the same as for :c:func:`function__entry`.
+   The arguments are the same as for :c:func:`!function__entry`.
 
 .. object:: gc__start(int generation)
 
--- a/Doc/howto/isolating-extensions.rst
+++ b/Doc/howto/isolating-extensions.rst
@@ -298,10 +298,10 @@ Watch out for the following two points i
 a comprehensive list):
 
 * Unlike static types, heap type objects are mutable by default.
-  Use the :c:data:`Py_TPFLAGS_IMMUTABLETYPE` flag to prevent mutability.
+  Use the :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag to prevent mutability.
 * Heap types inherit :c:member:`~PyTypeObject.tp_new` by default,
   so it may become possible to instantiate them from Python code.
-  You can prevent this with the :c:data:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag.
+  You can prevent this with the :c:macro:`Py_TPFLAGS_DISALLOW_INSTANTIATION` flag.
 
 
 Defining Heap Types
@@ -333,12 +333,12 @@ To avoid memory leaks, instances of heap
 garbage collection protocol.
 That is, heap types should:
 
-- Have the :c:data:`Py_TPFLAGS_HAVE_GC` flag.
+- Have the :c:macro:`Py_TPFLAGS_HAVE_GC` flag.
 - Define a traverse function using ``Py_tp_traverse``, which
   visits the type (e.g. using :c:expr:`Py_VISIT(Py_TYPE(self))`).
 
 Please refer to the :ref:`the documentation <type-structs>` of
-:c:data:`Py_TPFLAGS_HAVE_GC` and :c:member:`~PyTypeObject.tp_traverse`
+:c:macro:`Py_TPFLAGS_HAVE_GC` and :c:member:`~PyTypeObject.tp_traverse`
 for additional considerations.
 
 If your traverse function delegates to the ``tp_traverse`` of its base class
@@ -411,7 +411,7 @@ that subclass, which may be defined in d
           pass
 
 For a method to get its "defining class", it must use the
-:data:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS`
+:ref:`METH_METHOD | METH_FASTCALL | METH_KEYWORDS <METH_METHOD-METH_FASTCALL-METH_KEYWORDS>`
 :c:type:`calling convention <PyMethodDef>`
 and the corresponding :c:type:`PyCMethod` signature::
 
@@ -467,7 +467,7 @@ Module State Access from Slot Methods, G
 
 Slot methodsthe fast C equivalents for special methods, such as
 :c:member:`~PyNumberMethods.nb_add` for :py:attr:`~object.__add__` or
-:c:member:`~PyType.tp_new` for initializationhave a very simple API that
+:c:member:`~PyTypeObject.tp_new` for initializationhave a very simple API that
 doesn't allow passing in the defining class, unlike with :c:type:`PyCMethod`.
 The same goes for getters and setters defined with
 :c:type:`PyGetSetDef`.
@@ -483,14 +483,14 @@ to get the state::
         return NULL;
     }
 
-``PyType_GetModuleByDef`` works by searching the
+:c:func:`!PyType_GetModuleByDef` works by searching the
 :term:`method resolution order` (i.e. all superclasses) for the first
 superclass that has a corresponding module.
 
 .. note::
 
    In very exotic cases (inheritance chains spanning multiple modules
-   created from the same definition), ``PyType_GetModuleByDef`` might not
+   created from the same definition), :c:func:`!PyType_GetModuleByDef` might not
    return the module of the true defining class. However, it will always
    return a module with the same definition, ensuring a compatible
    C memory layout.
--- a/Doc/howto/regex.rst
+++ b/Doc/howto/regex.rst
@@ -522,6 +522,8 @@ cache.
 Compilation Flags
 -----------------
 
+.. currentmodule:: re
+
 Compilation flags let you modify some aspects of how regular expressions work.
 Flags are available in the :mod:`re` module under two names, a long name such as
 :const:`IGNORECASE` and a short, one-letter form such as :const:`I`.  (If you're
--- a/Doc/howto/sorting.rst
+++ b/Doc/howto/sorting.rst
@@ -273,7 +273,7 @@ Odds and Ends
 
 * The sort routines use ``<`` when making comparisons
   between two objects. So, it is easy to add a standard sort order to a class by
-  defining an :meth:`__lt__` method:
+  defining an :meth:`~object.__lt__` method:
 
   .. doctest::
 
@@ -281,8 +281,8 @@ Odds and Ends
     >>> sorted(student_objects)
     [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]
 
-  However, note that ``<`` can fall back to using :meth:`__gt__` if
-  :meth:`__lt__` is not implemented (see :func:`object.__lt__`).
+  However, note that ``<`` can fall back to using :meth:`~object.__gt__` if
+  :meth:`~object.__lt__` is not implemented (see :func:`object.__lt__`).
 
 * Key functions need not depend directly on the objects being sorted. A key
   function can also access external resources. For instance, if the student grades
--- a/Doc/howto/unicode.rst
+++ b/Doc/howto/unicode.rst
@@ -424,8 +424,8 @@ lowercase letters 'ss'.
 
 A second tool is the :mod:`unicodedata` module's
 :func:`~unicodedata.normalize` function that converts strings to one
-of several normal forms, where letters followed by a combining
-character are replaced with single characters.  :func:`normalize` can
+of several normal forms, where letters followed by a combining character are
+replaced with single characters.  :func:`~unicodedata.normalize` can
 be used to perform string comparisons that won't falsely report
 inequality if two strings use combining characters differently:
 
@@ -474,8 +474,8 @@ The Unicode Standard also specifies how
 
     print(compare_caseless(single_char, multiple_chars))
 
-This will print ``True``.  (Why is :func:`NFD` invoked twice?  Because
-there are a few characters that make :meth:`casefold` return a
+This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because
+there are a few characters that make :meth:`~str.casefold` return a
 non-normalized string, so the result needs to be normalized again. See
 section 3.13 of the Unicode Standard for a discussion and an example.)
 
--- a/Doc/includes/turtle-star.py
+++ /dev/null
@@ -1,10 +0,0 @@
-from turtle import *
-color('red', 'yellow')
-begin_fill()
-while True:
-    forward(200)
-    left(170)
-    if abs(pos()) < 1:
-        break
-end_fill()
-done()
--- a/Doc/install/index.rst
+++ b/Doc/install/index.rst
@@ -309,9 +309,9 @@ install into it.  It is enabled with a s
 
    python setup.py install --user
 
-Files will be installed into subdirectories of :data:`site.USER_BASE` (written
+Files will be installed into subdirectories of :const:`site.USER_BASE` (written
 as :file:`{userbase}` hereafter).  This scheme installs pure Python modules and
-extension modules in the same location (also known as :data:`site.USER_SITE`).
+extension modules in the same location (also known as :const:`site.USER_SITE`).
 Here are the values for UNIX, including macOS:
 
 =============== ===========================================================
@@ -370,7 +370,7 @@ will expand this to your home directory:
 
 To make Python find the distributions installed with this scheme, you may have
 to :ref:`modify Python's search path <inst-search-path>` or edit
-:mod:`sitecustomize` (see :mod:`site`) to call :func:`site.addsitedir` or edit
+:mod:`!sitecustomize` (see :mod:`site`) to call :func:`site.addsitedir` or edit
 :data:`sys.path`.
 
 The :option:`!--home` option defines the installation base directory.  Files are
@@ -692,7 +692,7 @@ is supplied to suppress this behaviour.
    import sys
    sys.path.append('/www/python/')
 
-However, if you reinstall the same major version of Python (perhaps when
+However, if you reinstall the same minor version of Python (perhaps when
 upgrading from 2.2 to 2.2.2, for example) :file:`site.py` will be overwritten by
 the stock version.  You'd have to remember that it was modified and save a copy
 before doing the installation.
@@ -774,7 +774,7 @@ Notes:
 
 (2)
    On Unix, if the :envvar:`HOME` environment variable is not defined, the user's
-   home directory will be determined with the :func:`getpwuid` function from the
+   home directory will be determined with the :func:`~pwd.getpwuid` function from the
    standard :mod:`pwd` module. This is done by the :func:`os.path.expanduser`
    function used by Distutils.
 
--- a/Doc/library/__main__.rst
+++ b/Doc/library/__main__.rst
@@ -336,12 +336,12 @@ Note that importing ``__main__`` doesn't
 running top-level code meant for script use which is put in the
 ``if __name__ == "__main__"`` block of the ``start`` module. Why does this work?
 
-Python inserts an empty ``__main__`` module in :attr:`sys.modules` at
+Python inserts an empty ``__main__`` module in :data:`sys.modules` at
 interpreter startup, and populates it by running top-level code. In our example
 this is the ``start`` module which runs line by line and imports ``namely``.
 In turn, ``namely`` imports ``__main__`` (which is really ``start``). That's an
 import cycle! Fortunately, since the partially populated ``__main__``
-module is present in :attr:`sys.modules`, Python passes that to ``namely``.
+module is present in :data:`sys.modules`, Python passes that to ``namely``.
 See :ref:`Special considerations for __main__ <import-dunder-main>` in the
 import system's reference for details on how this works.
 
--- a/Doc/library/_thread.rst
+++ b/Doc/library/_thread.rst
@@ -68,10 +68,10 @@ This module defines the following consta
    there is no guarantee that the interruption will happen immediately.
 
    If given, *signum* is the number of the signal to simulate.
-   If *signum* is not given, :data:`signal.SIGINT` is simulated.
+   If *signum* is not given, :const:`signal.SIGINT` is simulated.
 
    If the given signal isn't handled by Python (it was set to
-   :data:`signal.SIG_DFL` or :data:`signal.SIG_IGN`), this function does
+   :const:`signal.SIG_DFL` or :const:`signal.SIG_IGN`), this function does
    nothing.
 
    .. versionchanged:: 3.10
@@ -148,8 +148,8 @@ This module defines the following consta
 .. data:: TIMEOUT_MAX
 
    The maximum value allowed for the *timeout* parameter of
-   :meth:`Lock.acquire`. Specifying a timeout greater than this value will
-   raise an :exc:`OverflowError`.
+   :meth:`Lock.acquire <threading.Lock.acquire>`. Specifying a timeout greater
+   than this value will raise an :exc:`OverflowError`.
 
    .. versionadded:: 3.2
 
@@ -215,8 +215,9 @@ In addition to these methods, lock objec
 * Calling :func:`sys.exit` or raising the :exc:`SystemExit` exception is
   equivalent to calling :func:`_thread.exit`.
 
-* It is not possible to interrupt the :meth:`acquire` method on a lock --- the
-  :exc:`KeyboardInterrupt` exception will happen after the lock has been acquired.
+* It is not possible to interrupt the :meth:`~threading.Lock.acquire` method on
+  a lock --- the :exc:`KeyboardInterrupt` exception will happen after the lock
+  has been acquired.
 
 * When the main thread exits, it is system defined whether the other threads
   survive.  On most systems, they are killed without executing
--- a/Doc/library/array.rst
+++ b/Doc/library/array.rst
@@ -51,9 +51,9 @@ Notes:
    It can be 16 bits or 32 bits depending on the platform.
 
    .. versionchanged:: 3.9
-      ``array('u')`` now uses ``wchar_t`` as C type instead of deprecated
+      ``array('u')`` now uses :c:type:`wchar_t` as C type instead of deprecated
       ``Py_UNICODE``. This change doesn't affect its behavior because
-      ``Py_UNICODE`` is alias of ``wchar_t`` since Python 3.3.
+      ``Py_UNICODE`` is alias of :c:type:`wchar_t` since Python 3.3.
 
    .. deprecated-removed:: 3.3 4.0
 
--- a/Doc/library/ast.rst
+++ b/Doc/library/ast.rst
@@ -146,6 +146,102 @@ Node classes
     Snakes <https://greentreesnakes.readthedocs.io/en/latest/>`__ project and
     all its contributors.
 
+
+.. _ast-root-nodes:
+
+Root nodes
+^^^^^^^^^^
+
+.. class:: Module(body, type_ignores)
+
+   A Python module, as with :ref:`file input <file-input>`.
+   Node type generated by :func:`ast.parse` in the default ``"exec"`` *mode*.
+
+   *body* is a :class:`list` of the module's :ref:`ast-statements`.
+
+   *type_ignores* is a :class:`list` of the module's type ignore comments;
+   see :func:`ast.parse` for more details.
+
+   .. doctest::
+
+        >>> print(ast.dump(ast.parse('x = 1'), indent=4))
+        Module(
+            body=[
+                Assign(
+                    targets=[
+                        Name(id='x', ctx=Store())],
+                    value=Constant(value=1))],
+            type_ignores=[])
+
+
+.. class:: Expression(body)
+
+   A single Python :ref:`expression input <expression-input>`.
+   Node type generated by :func:`ast.parse` when *mode* is ``"eval"``.
+
+   *body* is a single node,
+   one of the :ref:`expression types <ast-expressions>`.
+
+   .. doctest::
+
+        >>> print(ast.dump(ast.parse('123', mode='eval'), indent=4))
+        Expression(
+            body=Constant(value=123))
+
+
+.. class:: Interactive(body)
+
+   A single :ref:`interactive input <interactive>`, like in :ref:`tut-interac`.
+   Node type generated by :func:`ast.parse` when *mode* is ``"single"``.
+
+   *body* is a :class:`list` of :ref:`statement nodes <ast-statements>`.
+
+   .. doctest::
+
+        >>> print(ast.dump(ast.parse('x = 1; y = 2', mode='single'), indent=4))
+        Interactive(
+            body=[
+                Assign(
+                    targets=[
+                        Name(id='x', ctx=Store())],
+                    value=Constant(value=1)),
+                Assign(
+                    targets=[
+                        Name(id='y', ctx=Store())],
+                    value=Constant(value=2))])
+
+
+.. class:: FunctionType(argtypes, returns)
+
+   A representation of an old-style type comments for functions,
+   as Python versions prior to 3.5 didn't support :pep:`484` annotations.
+   Node type generated by :func:`ast.parse` when *mode* is ``"func_type"``.
+
+   Such type comments would look like this::
+
+       def sum_two_number(a, b):
+           # type: (int, int) -> int
+           return a + b
+
+   *argtypes* is a :class:`list` of :ref:`expression nodes <ast-expressions>`.
+
+   *returns* is a single :ref:`expression node <ast-expressions>`.
+
+   .. doctest::
+
+        >>> print(ast.dump(ast.parse('(int, str) -> List[int]', mode='func_type'), indent=4))
+        FunctionType(
+            argtypes=[
+                Name(id='int', ctx=Load()),
+                Name(id='str', ctx=Load())],
+            returns=Subscript(
+                value=Name(id='List', ctx=Load()),
+                slice=Name(id='int', ctx=Load()),
+                ctx=Load()))
+
+   .. versionadded:: 3.8
+
+
 Literals
 ^^^^^^^^
 
@@ -344,6 +440,8 @@ Variables
             type_ignores=[])
 
 
+.. _ast-expressions:
+
 Expressions
 ^^^^^^^^^^^
 
@@ -735,6 +833,9 @@ Comprehensions
                         ifs=[],
                         is_async=1)]))
 
+
+.. _ast-statements:
+
 Statements
 ^^^^^^^^^^
 
--- a/Doc/library/asyncio-dev.rst
+++ b/Doc/library/asyncio-dev.rst
@@ -34,7 +34,7 @@ There are several ways to enable asyncio
 In addition to enabling the debug mode, consider also:
 
 * setting the log level of the :ref:`asyncio logger <asyncio-logger>` to
-  :py:data:`logging.DEBUG`, for example the following snippet of code
+  :py:const:`logging.DEBUG`, for example the following snippet of code
   can be run at startup of the application::
 
     logging.basicConfig(level=logging.DEBUG)
@@ -142,7 +142,7 @@ Logging
 asyncio uses the :mod:`logging` module and all logging is performed
 via the ``"asyncio"`` logger.
 
-The default log level is :py:data:`logging.INFO`, which can be easily
+The default log level is :py:const:`logging.INFO`, which can be easily
 adjusted::
 
    logging.getLogger("asyncio").setLevel(logging.WARNING)
--- a/Doc/library/asyncio-eventloop.rst
+++ b/Doc/library/asyncio-eventloop.rst
@@ -397,11 +397,11 @@ Opening network connections
    Open a streaming transport connection to a given
    address specified by *host* and *port*.
 
-   The socket family can be either :py:data:`~socket.AF_INET` or
-   :py:data:`~socket.AF_INET6` depending on *host* (or the *family*
+   The socket family can be either :py:const:`~socket.AF_INET` or
+   :py:const:`~socket.AF_INET6` depending on *host* (or the *family*
    argument, if provided).
 
-   The socket type will be :py:data:`~socket.SOCK_STREAM`.
+   The socket type will be :py:const:`~socket.SOCK_STREAM`.
 
    *protocol_factory* must be a callable returning an
    :ref:`asyncio protocol <asyncio-protocol>` implementation.
@@ -495,7 +495,7 @@ Opening network connections
 
    .. versionchanged:: 3.6
 
-      The socket option :py:data:`~socket.TCP_NODELAY` is set by default
+      The socket option :py:const:`~socket.TCP_NODELAY` is set by default
       for all TCP connections.
 
    .. versionchanged:: 3.7
@@ -535,11 +535,11 @@ Opening network connections
 
    Create a datagram connection.
 
-   The socket family can be either :py:data:`~socket.AF_INET`,
-   :py:data:`~socket.AF_INET6`, or :py:data:`~socket.AF_UNIX`,
+   The socket family can be either :py:const:`~socket.AF_INET`,
+   :py:const:`~socket.AF_INET6`, or :py:const:`~socket.AF_UNIX`,
    depending on *host* (or the *family* argument, if provided).
 
-   The socket type will be :py:data:`~socket.SOCK_DGRAM`.
+   The socket type will be :py:const:`~socket.SOCK_DGRAM`.
 
    *protocol_factory* must be a callable returning a
    :ref:`protocol <asyncio-protocol>` implementation.
@@ -564,7 +564,7 @@ Opening network connections
    * *reuse_port* tells the kernel to allow this endpoint to be bound to the
      same port as other existing endpoints are bound to, so long as they all
      set this flag when being created. This option is not supported on Windows
-     and some Unixes. If the :py:data:`~socket.SO_REUSEPORT` constant is not
+     and some Unixes. If the :py:const:`~socket.SO_REUSEPORT` constant is not
      defined then this capability is unsupported.
 
    * *allow_broadcast* tells the kernel to allow this endpoint to send
@@ -590,7 +590,7 @@ Opening network connections
 
    .. versionchanged:: 3.8.1
       The *reuse_address* parameter is no longer supported, as using
-      :py:data:`~sockets.SO_REUSEADDR` poses a significant security concern for
+      :py:const:`~sockets.SO_REUSEADDR` poses a significant security concern for
       UDP. Explicitly passing ``reuse_address=True`` will raise an exception.
 
       When multiple processes with differing UIDs assign sockets to an
@@ -599,7 +599,7 @@ Opening network connections
 
       For supported platforms, *reuse_port* can be used as a replacement for
       similar functionality. With *reuse_port*,
-      :py:data:`~sockets.SO_REUSEPORT` is used instead, which specifically
+      :py:const:`~sockets.SO_REUSEPORT` is used instead, which specifically
       prevents processes with differing UIDs from assigning sockets to the same
       socket address.
 
@@ -617,8 +617,8 @@ Opening network connections
 
    Create a Unix connection.
 
-   The socket family will be :py:data:`~socket.AF_UNIX`; socket
-   type will be :py:data:`~socket.SOCK_STREAM`.
+   The socket family will be :py:const:`~socket.AF_UNIX`; socket
+   type will be :py:const:`~socket.SOCK_STREAM`.
 
    A tuple of ``(transport, protocol)`` is returned on success.
 
@@ -654,7 +654,7 @@ Creating network servers
                         ssl_shutdown_timeout=None, \
                         start_serving=True)
 
-   Create a TCP server (socket type :data:`~socket.SOCK_STREAM`) listening
+   Create a TCP server (socket type :const:`~socket.SOCK_STREAM`) listening
    on *port* of the *host* address.
 
    Returns a :class:`Server` object.
@@ -682,10 +682,10 @@ Creating network servers
      be selected (note that if *host* resolves to multiple network interfaces,
      a different random port will be selected for each interface).
 
-   * *family* can be set to either :data:`socket.AF_INET` or
-     :data:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6.
+   * *family* can be set to either :const:`socket.AF_INET` or
+     :const:`~socket.AF_INET6` to force the socket to use IPv4 or IPv6.
      If not set, the *family* will be determined from host name
-     (defaults to :data:`~socket.AF_UNSPEC`).
+     (defaults to :const:`~socket.AF_UNSPEC`).
 
    * *flags* is a bitmask for :meth:`getaddrinfo`.
 
@@ -739,7 +739,7 @@ Creating network servers
    .. versionchanged:: 3.6
 
       Added *ssl_handshake_timeout* and *start_serving* parameters.
-      The socket option :py:data:`~socket.TCP_NODELAY` is set by default
+      The socket option :py:const:`~socket.TCP_NODELAY` is set by default
       for all TCP connections.
 
    .. versionchanged:: 3.11
@@ -760,7 +760,7 @@ Creating network servers
                           start_serving=True)
 
    Similar to :meth:`loop.create_server` but works with the
-   :py:data:`~socket.AF_UNIX` socket family.
+   :py:const:`~socket.AF_UNIX` socket family.
 
    *path* is the name of a Unix domain socket, and is required,
    unless a *sock* argument is provided.  Abstract Unix sockets,
@@ -878,6 +878,9 @@ TLS Upgrade
    object only because the coder caches *protocol*-side data and sporadically
    exchanges extra TLS session packets with *transport*.
 
+   In some situations (e.g. when the passed transport is already closing) this
+   may return ``None``.
+
    Parameters:
 
    * *transport* and *protocol* instances that methods like
@@ -1558,6 +1561,9 @@ Do not instantiate the :class:`Server` c
    .. versionchanged:: 3.7
       Server object is an asynchronous context manager since Python 3.7.
 
+   .. versionchanged:: 3.11
+      This class was exposed publicly as ``asyncio.Server`` in Python 3.9.11, 3.10.3 and 3.11.
+
    .. method:: close()
 
       Stop serving: close listening sockets and set the :attr:`sockets`
--- a/Doc/library/asyncio-exceptions.rst
+++ b/Doc/library/asyncio-exceptions.rst
@@ -31,7 +31,7 @@ Exceptions
 
    .. versionchanged:: 3.8
 
-      :exc:`CancelledError` is now a subclass of :class:`BaseException`.
+      :exc:`CancelledError` is now a subclass of :class:`BaseException` rather than :class:`Exception`.
 
 
 .. exception:: InvalidStateError
--- a/Doc/library/asyncio-extending.rst
+++ b/Doc/library/asyncio-extending.rst
@@ -69,7 +69,7 @@ Task lifetime support
 =====================
 
 A third party task implementation should call the following functions to keep a task
-visible by :func:`asyncio.get_tasks` and :func:`asyncio.current_task`:
+visible by :func:`asyncio.all_tasks` and :func:`asyncio.current_task`:
 
 .. function:: _register_task(task)
 
--- a/Doc/library/asyncio-future.rst
+++ b/Doc/library/asyncio-future.rst
@@ -276,4 +276,4 @@ the Future has a result::
      :func:`concurrent.futures.as_completed` functions.
 
    - :meth:`asyncio.Future.cancel` accepts an optional ``msg`` argument,
-     but :func:`concurrent.futures.cancel` does not.
+     but :meth:`concurrent.futures.Future.cancel` does not.
--- a/Doc/library/asyncio-platforms.rst
+++ b/Doc/library/asyncio-platforms.rst
@@ -37,7 +37,7 @@ All event loops on Windows do not suppor
 
 * :meth:`loop.create_unix_connection` and
   :meth:`loop.create_unix_server` are not supported.
-  The :data:`socket.AF_UNIX` socket family is specific to Unix.
+  The :const:`socket.AF_UNIX` socket family is specific to Unix.
 
 * :meth:`loop.add_signal_handler` and
   :meth:`loop.remove_signal_handler` are not supported.
--- a/Doc/library/asyncio-subprocess.rst
+++ b/Doc/library/asyncio-subprocess.rst
@@ -68,7 +68,7 @@ Creating Subprocesses
 
    The *limit* argument sets the buffer limit for :class:`StreamReader`
    wrappers for :attr:`Process.stdout` and :attr:`Process.stderr`
-   (if :attr:`subprocess.PIPE` is passed to *stdout* and *stderr* arguments).
+   (if :const:`subprocess.PIPE` is passed to *stdout* and *stderr* arguments).
 
    Return a :class:`~asyncio.subprocess.Process` instance.
 
@@ -86,7 +86,7 @@ Creating Subprocesses
 
    The *limit* argument sets the buffer limit for :class:`StreamReader`
    wrappers for :attr:`Process.stdout` and :attr:`Process.stderr`
-   (if :attr:`subprocess.PIPE` is passed to *stdout* and *stderr* arguments).
+   (if :const:`subprocess.PIPE` is passed to *stdout* and *stderr* arguments).
 
    Return a :class:`~asyncio.subprocess.Process` instance.
 
@@ -244,7 +244,7 @@ their completion.
 
       Stop the child process.
 
-      On POSIX systems this method sends :py:data:`signal.SIGTERM` to the
+      On POSIX systems this method sends :py:const:`signal.SIGTERM` to the
       child process.
 
       On Windows the Win32 API function :c:func:`TerminateProcess` is
--- a/Doc/library/asyncio-task.rst
+++ b/Doc/library/asyncio-task.rst
@@ -601,16 +601,16 @@ Timeouts
     If ``long_running_task`` takes more than 10 seconds to complete,
     the context manager will cancel the current task and handle
     the resulting :exc:`asyncio.CancelledError` internally, transforming it
-    into an :exc:`asyncio.TimeoutError` which can be caught and handled.
+    into a :exc:`TimeoutError` which can be caught and handled.
 
     .. note::
 
       The :func:`asyncio.timeout` context manager is what transforms
-      the :exc:`asyncio.CancelledError` into an :exc:`asyncio.TimeoutError`,
-      which means the :exc:`asyncio.TimeoutError` can only be caught
+      the :exc:`asyncio.CancelledError` into a :exc:`TimeoutError`,
+      which means the :exc:`TimeoutError` can only be caught
       *outside* of the context manager.
 
-    Example of catching :exc:`asyncio.TimeoutError`::
+    Example of catching :exc:`TimeoutError`::
 
         async def main():
             try:
--- a/Doc/library/bz2.rst
+++ b/Doc/library/bz2.rst
@@ -87,7 +87,8 @@ The :mod:`bz2` module contains:
    compressed streams.
 
    :class:`BZ2File` provides all of the members specified by the
-   :class:`io.BufferedIOBase`, except for :meth:`detach` and :meth:`truncate`.
+   :class:`io.BufferedIOBase`, except for :meth:`~io.BufferedIOBase.detach`
+   and :meth:`~io.IOBase.truncate`.
    Iteration and the :keyword:`with` statement are supported.
 
    :class:`BZ2File` also provides the following method:
--- a/Doc/library/cmath.rst
+++ b/Doc/library/cmath.rst
@@ -9,7 +9,7 @@
 This module provides access to mathematical functions for complex numbers.  The
 functions in this module accept integers, floating-point numbers or complex
 numbers as arguments. They will also accept any Python object that has either a
-:meth:`__complex__` or a :meth:`__float__` method: these methods are used to
+:meth:`~object.__complex__` or a :meth:`~object.__float__` method: these methods are used to
 convert the object to a complex or floating-point number, respectively, and
 the function is then applied to the result of the conversion.
 
--- a/Doc/library/code.rst
+++ b/Doc/library/code.rst
@@ -163,12 +163,12 @@ interpreter objects as well as the follo
 
    Push a line of source text to the interpreter. The line should not have a
    trailing newline; it may have internal newlines.  The line is appended to a
-   buffer and the interpreter's :meth:`runsource` method is called with the
+   buffer and the interpreter's :meth:`~InteractiveInterpreter.runsource` method is called with the
    concatenated contents of the buffer as source.  If this indicates that the
    command was executed or invalid, the buffer is reset; otherwise, the command is
    incomplete, and the buffer is left as it was after the line was appended.  The
    return value is ``True`` if more input is required, ``False`` if the line was
-   dealt with in some way (this is the same as :meth:`runsource`).
+   dealt with in some way (this is the same as :meth:`!runsource`).
 
 
 .. method:: InteractiveConsole.resetbuffer()
--- a/Doc/library/codeop.rst
+++ b/Doc/library/codeop.rst
@@ -58,7 +58,7 @@ To do just the former:
 
 .. class:: Compile()
 
-   Instances of this class have :meth:`__call__` methods identical in signature to
+   Instances of this class have :meth:`~object.__call__` methods identical in signature to
    the built-in function :func:`compile`, but with the difference that if the
    instance compiles program text containing a :mod:`__future__` statement, the
    instance 'remembers' and compiles all subsequent program texts with the
@@ -67,7 +67,7 @@ To do just the former:
 
 .. class:: CommandCompiler()
 
-   Instances of this class have :meth:`__call__` methods identical in signature to
+   Instances of this class have :meth:`~object.__call__` methods identical in signature to
    :func:`compile_command`; the difference is that if the instance compiles program
    text containing a :mod:`__future__` statement, the instance 'remembers' and
    compiles all subsequent program texts with the statement in force.
--- a/Doc/library/compileall.rst
+++ b/Doc/library/compileall.rst
@@ -141,9 +141,9 @@ There is no command-line option to contr
 :func:`compile` function, because the Python interpreter itself already
 provides the option: :program:`python -O -m compileall`.
 
-Similarly, the :func:`compile` function respects the :attr:`sys.pycache_prefix`
+Similarly, the :func:`compile` function respects the :data:`sys.pycache_prefix`
 setting. The generated bytecode cache will only be useful if :func:`compile` is
-run with the same :attr:`sys.pycache_prefix` (if any) that will be used at
+run with the same :data:`sys.pycache_prefix` (if any) that will be used at
 runtime.
 
 Public functions
--- a/Doc/library/concurrent.rst
+++ b/Doc/library/concurrent.rst
@@ -1,5 +1,5 @@
-The :mod:`concurrent` package
-=============================
+The :mod:`!concurrent` package
+==============================
 
 Currently, there is only one module in this package:
 
--- a/Doc/library/constants.rst
+++ b/Doc/library/constants.rst
@@ -22,16 +22,16 @@ A small number of constants live in the
    An object frequently used to represent the absence of a value, as when
    default arguments are not passed to a function. Assignments to ``None``
    are illegal and raise a :exc:`SyntaxError`.
-   ``None`` is the sole instance of the :data:`NoneType` type.
+   ``None`` is the sole instance of the :data:`~types.NoneType` type.
 
 
 .. data:: NotImplemented
 
    A special value which should be returned by the binary special methods
-   (e.g. :meth:`__eq__`, :meth:`__lt__`, :meth:`__add__`, :meth:`__rsub__`,
+   (e.g. :meth:`~object.__eq__`, :meth:`~object.__lt__`, :meth:`~object.__add__`, :meth:`~object.__rsub__`,
    etc.) to indicate that the operation is not implemented with respect to
    the other type; may be returned by the in-place binary special methods
-   (e.g. :meth:`__imul__`, :meth:`__iand__`, etc.) for the same purpose.
+   (e.g. :meth:`~object.__imul__`, :meth:`~object.__iand__`, etc.) for the same purpose.
    It should not be evaluated in a boolean context.
    ``NotImplemented`` is the sole instance of the :data:`types.NotImplementedType` type.
 
--- a/Doc/library/crypt.rst
+++ b/Doc/library/crypt.rst
@@ -20,6 +20,7 @@
    The :mod:`crypt` module is deprecated
    (see :pep:`PEP 594 <594#crypt>` for details and alternatives).
    The :mod:`hashlib` module is a potential replacement for certain use cases.
+   The `passlib <https://pypi.org/project/passlib/>`_ package can replace all use cases of this module.
 
 --------------
 
--- a/Doc/library/ctypes.rst
+++ b/Doc/library/ctypes.rst
@@ -221,7 +221,7 @@ Fundamental data types
 +----------------------+------------------------------------------+----------------------------+
 | :class:`c_char`      | :c:expr:`char`                           | 1-character bytes object   |
 +----------------------+------------------------------------------+----------------------------+
-| :class:`c_wchar`     | :c:expr:`wchar_t`                        | 1-character string         |
+| :class:`c_wchar`     | :c:type:`wchar_t`                        | 1-character string         |
 +----------------------+------------------------------------------+----------------------------+
 | :class:`c_byte`      | :c:expr:`char`                           | int                        |
 +----------------------+------------------------------------------+----------------------------+
@@ -244,9 +244,9 @@ Fundamental data types
 | :class:`c_ulonglong` | :c:expr:`unsigned __int64` or            | int                        |
 |                      | :c:expr:`unsigned long long`             |                            |
 +----------------------+------------------------------------------+----------------------------+
-| :class:`c_size_t`    | :c:expr:`size_t`                         | int                        |
+| :class:`c_size_t`    | :c:type:`size_t`                         | int                        |
 +----------------------+------------------------------------------+----------------------------+
-| :class:`c_ssize_t`   | :c:expr:`ssize_t` or                     | int                        |
+| :class:`c_ssize_t`   | :c:type:`ssize_t` or                     | int                        |
 |                      | :c:expr:`Py_ssize_t`                     |                            |
 +----------------------+------------------------------------------+----------------------------+
 | :class:`c_float`     | :c:expr:`float`                          | float                      |
@@ -334,7 +334,7 @@ property::
 
 The :func:`create_string_buffer` function replaces the old :func:`c_buffer`
 function (which is still available as an alias).  To create a mutable memory
-block containing unicode characters of the C type :c:expr:`wchar_t`, use the
+block containing unicode characters of the C type :c:type:`wchar_t`, use the
 :func:`create_unicode_buffer` function.
 
 
@@ -399,9 +399,10 @@ Calling functions with your own custom d
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 
 You can also customize :mod:`ctypes` argument conversion to allow instances of
-your own classes be used as function arguments.  :mod:`ctypes` looks for an
-:attr:`_as_parameter_` attribute and uses this as the function argument.  Of
-course, it must be one of integer, string, or bytes::
+your own classes be used as function arguments. :mod:`ctypes` looks for an
+:attr:`!_as_parameter_` attribute and uses this as the function argument. The
+attribute must be an integer, string, bytes, a :mod:`ctypes` instance, or an
+object with an :attr:`!_as_parameter_` attribute::
 
    >>> class Bottles:
    ...     def __init__(self, number):
@@ -2361,7 +2362,7 @@ These are the fundamental ctypes data ty
 
 .. class:: c_wchar
 
-   Represents the C :c:expr:`wchar_t` datatype, and interprets the value as a
+   Represents the C :c:type:`wchar_t` datatype, and interprets the value as a
    single character unicode string.  The constructor accepts an optional string
    initializer, the length of the string must be exactly one character.
 
--- a/Doc/library/curses.rst
+++ b/Doc/library/curses.rst
@@ -644,7 +644,8 @@ The module :mod:`curses` defines the fol
 
 .. function:: update_lines_cols()
 
-   Update :envvar:`LINES` and :envvar:`COLS`. Useful for detecting manual screen resize.
+   Update the :const:`LINES` and :const:`COLS` module variables.
+   Useful for detecting manual screen resize.
 
    .. versionadded:: 3.5
 
@@ -1345,10 +1346,27 @@ The :mod:`curses` module defines the fol
 .. data:: COLORS
 
    The maximum number of colors the terminal can support.
+   It is defined only after the call to :func:`start_color`.
 
 .. data:: COLOR_PAIRS
 
    The maximum number of color pairs the terminal can support.
+   It is defined only after the call to :func:`start_color`.
+
+.. data:: COLS
+
+   The width of the screen, i.e., the number of columns.
+   It is defined only after the call to :func:`initscr`.
+   Updated by :func:`update_lines_cols`, :func:`resizeterm` and
+   :func:`resize_term`.
+
+.. data:: LINES
+
+   The height of the screen, i.e., the number of lines.
+   It is defined only after the call to :func:`initscr`.
+   Updated by :func:`update_lines_cols`, :func:`resizeterm` and
+   :func:`resize_term`.
+
 
 Some constants are available to specify character cell attributes.
 The exact constants available are system dependent.
@@ -1633,6 +1651,8 @@ keys); also, the following keypad mappin
 | :kbd:`Page Down` | KEY_NPAGE |
 +------------------+-----------+
 
+.. _curses-acs-codes:
+
 The following table lists characters from the alternate character set. These are
 inherited from the VT100 terminal, and will generally be  available on software
 emulations such as X terminals.  When there is no graphic available, curses
--- a/Doc/library/dataclasses.rst
+++ b/Doc/library/dataclasses.rst
@@ -733,7 +733,7 @@ for ``x`` when creating a class instance
 of ``x``.  Because dataclasses just use normal Python class
 creation they also share this behavior.  There is no general way
 for Data Classes to detect this condition.  Instead, the
-:func:`dataclass` decorator will raise a :exc:`TypeError` if it
+:func:`dataclass` decorator will raise a :exc:`ValueError` if it
 detects an unhashable default parameter.  The assumption is that if
 a value is unhashable, it is mutable.  This is a partial solution,
 but it does protect against many common errors.
--- a/Doc/library/decimal.rst
+++ b/Doc/library/decimal.rst
@@ -743,12 +743,23 @@ Decimal objects
 
    .. method:: normalize(context=None)
 
-      Normalize the number by stripping the rightmost trailing zeros and
-      converting any result equal to ``Decimal('0')`` to
-      ``Decimal('0e0')``. Used for producing canonical values for attributes
-      of an equivalence class. For example, ``Decimal('32.100')`` and
-      ``Decimal('0.321000e+2')`` both normalize to the equivalent value
-      ``Decimal('32.1')``.
+      Used for producing canonical values of an equivalence
+      class within either the current context or the specified context.
+
+      This has the same semantics as the unary plus operation, except that if
+      the final result is finite it is reduced to its simplest form, with all
+      trailing zeros removed and its sign preserved. That is, while the
+      coefficient is non-zero and a multiple of ten the coefficient is divided
+      by ten and the exponent is incremented by 1. Otherwise (the coefficient is
+      zero) the exponent is set to 0. In all cases the sign is unchanged.
+
+      For example, ``Decimal('32.100')`` and ``Decimal('0.321000e+2')`` both
+      normalize to the equivalent value ``Decimal('32.1')``.
+
+      Note that rounding is applied *before* reducing to simplest form.
+
+      In the latest versions of the specification, this operation is also known
+      as ``reduce``.
 
    .. method:: number_class(context=None)
 
@@ -2077,6 +2088,26 @@ representative:
    >>> [v.normalize() for v in values]
    [Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2'), Decimal('2E+2')]
 
+Q. When does rounding occur in a computation?
+
+A. It occurs *after* the computation.  The philosophy of the decimal
+specification is that numbers are considered exact and are created
+independent of the current context.  They can even have greater
+precision than current context.  Computations process with those
+exact inputs and then rounding (or other context operations) is
+applied to the *result* of the computation::
+
+   >>> getcontext().prec = 5
+   >>> pi = Decimal('3.1415926535')   # More than 5 digits
+   >>> pi                             # All digits are retained
+   Decimal('3.1415926535')
+   >>> pi + 0                         # Rounded after an addition
+   Decimal('3.1416')
+   >>> pi - Decimal('0.00005')        # Subtract unrounded numbers, then round
+   Decimal('3.1415')
+   >>> pi + 0 - Decimal('0.00005').   # Intermediate values are rounded
+   Decimal('3.1416')
+
 Q. Some decimal values always print with exponential notation.  Is there a way
 to get a non-exponential representation?
 
--- a/Doc/library/devmode.rst
+++ b/Doc/library/devmode.rst
@@ -16,7 +16,7 @@ setting the :envvar:`PYTHONDEVMODE` envi
 See also :ref:`Python debug build <debug-build>`.
 
 Effects of the Python Development Mode
-======================================
+--------------------------------------
 
 Enabling the Python Development Mode is similar to the following command, but
 with additional effects described below::
@@ -81,7 +81,7 @@ Effects of the Python Development Mode:
   ignored for empty strings.
 
 * The :class:`io.IOBase` destructor logs ``close()`` exceptions.
-* Set the :attr:`~sys.flags.dev_mode` attribute of :attr:`sys.flags` to
+* Set the :attr:`~sys.flags.dev_mode` attribute of :data:`sys.flags` to
   ``True``.
 
 The Python Development Mode does not enable the :mod:`tracemalloc` module by
@@ -107,7 +107,7 @@ value can be read from :data:`sys.flags.
 
 
 ResourceWarning Example
-=======================
+-----------------------
 
 Example of a script counting the number of lines of the text file specified in
 the command line::
@@ -171,7 +171,7 @@ application more deterministic and more
 
 
 Bad file descriptor error example
-=================================
+---------------------------------
 
 Script displaying the first line of itself::
 
@@ -198,7 +198,7 @@ descriptor" error when finalizing the fi
 
 .. code-block:: shell-session
 
-    $ python3 script.py
+    $ python3 -X dev script.py
     import os
     script.py:10: ResourceWarning: unclosed file <_io.TextIOWrapper name='script.py' mode='r' encoding='UTF-8'>
       main()
--- a/Doc/library/dis.rst
+++ b/Doc/library/dis.rst
@@ -747,7 +747,7 @@ iterations of the loop.
 .. opcode:: MATCH_MAPPING
 
    If TOS is an instance of :class:`collections.abc.Mapping` (or, more technically: if
-   it has the :const:`Py_TPFLAGS_MAPPING` flag set in its
+   it has the :c:macro:`Py_TPFLAGS_MAPPING` flag set in its
    :c:member:`~PyTypeObject.tp_flags`), push ``True`` onto the stack.  Otherwise, push
    ``False``.
 
@@ -758,7 +758,7 @@ iterations of the loop.
 
    If TOS is an instance of :class:`collections.abc.Sequence` and is *not* an instance
    of :class:`str`/:class:`bytes`/:class:`bytearray` (or, more technically: if it has
-   the :const:`Py_TPFLAGS_SEQUENCE` flag set in its :c:member:`~PyTypeObject.tp_flags`),
+   the :c:macro:`Py_TPFLAGS_SEQUENCE` flag set in its :c:member:`~PyTypeObject.tp_flags`),
    push ``True`` onto the stack.  Otherwise, push ``False``.
 
    .. versionadded:: 3.10
@@ -1260,12 +1260,15 @@ iterations of the loop.
    * ``0x02`` a dictionary of keyword-only parameters' default values
    * ``0x04`` a tuple of strings containing parameters' annotations
    * ``0x08`` a tuple containing cells for free variables, making a closure
-   * the code associated with the function (at TOS1)
-   * the :term:`qualified name` of the function (at TOS)
+   * the code associated with the function (at TOS)
 
    .. versionchanged:: 3.10
       Flag value ``0x04`` is a tuple of strings instead of dictionary
 
+   .. versionchanged:: 3.11
+      Qualified name at TOS was removed.
+
+
 .. opcode:: BUILD_SLICE (argc)
 
    .. index:: pair: built-in function; slice
--- a/Doc/library/email.charset.rst
+++ b/Doc/library/email.charset.rst
@@ -150,7 +150,7 @@ Import this class from the :mod:`email.c
    .. method:: __str__()
 
       Returns *input_charset* as a string coerced to lower
-      case. :meth:`__repr__` is an alias for :meth:`__str__`.
+      case. :meth:`!__repr__` is an alias for :meth:`!__str__`.
 
 
    .. method:: __eq__(other)
--- a/Doc/library/email.encoders.rst
+++ b/Doc/library/email.encoders.rst
@@ -25,7 +25,7 @@ is especially true for :mimetype:`image/
 containing binary data.
 
 The :mod:`email` package provides some convenient encoders in its
-:mod:`encoders` module.  These encoders are actually used by the
+:mod:`~email.encoders` module.  These encoders are actually used by the
 :class:`~email.mime.audio.MIMEAudio` and :class:`~email.mime.image.MIMEImage`
 class constructors to provide default encodings.  All encoder functions take
 exactly one argument, the message object to encode.  They usually extract the
--- a/Doc/library/email.generator.rst
+++ b/Doc/library/email.generator.rst
@@ -274,9 +274,9 @@ in with information about the part.
 .. rubric:: Footnotes
 
 .. [#] This statement assumes that you use the appropriate setting for
-       ``unixfrom``, and that there are no :mod:`policy` settings calling for
+       ``unixfrom``, and that there are no :mod:`email.policy` settings calling for
        automatic adjustments (for example,
-       :attr:`~email.policy.Policy.refold_source` must be ``none``, which is
+       :attr:`~email.policy.EmailPolicy.refold_source` must be ``none``, which is
        *not* the default).  It is also not 100% true, since if the message
        does not conform to the RFC standards occasionally information about the
        exact original text is lost during parsing error recovery.  It is a goal
--- a/Doc/library/email.message.rst
+++ b/Doc/library/email.message.rst
@@ -67,7 +67,7 @@ message objects.
       with the base :class:`~email.message.Message` class *maxheaderlen* is
       accepted, but defaults to ``None``, which means that by default the line
       length is controlled by the
-      :attr:`~email.policy.EmailPolicy.max_line_length` of the policy.  The
+      :attr:`~email.policy.Policy.max_line_length` of the policy.  The
       *policy* argument may be used to override the default policy obtained
       from the message instance.  This can be used to control some of the
       formatting produced by the method, since the specified *policy* will be
@@ -213,7 +213,7 @@ message objects.
          del msg['subject']
          msg['subject'] = 'Python roolz!'
 
-      If the :mod:`policy` defines certain headers to be unique (as the standard
+      If the :mod:`policy <email.policy>` defines certain headers to be unique (as the standard
       policies do), this method may raise a :exc:`ValueError` when an attempt
       is made to assign a value to such a header when one already exists.  This
       behavior is intentional for consistency's sake, but do not depend on it
@@ -378,7 +378,7 @@ message objects.
       deprecated.
 
       Note that existing parameter values of headers may be accessed through
-      the :attr:`~email.headerregistry.BaseHeader.params` attribute of the
+      the :attr:`~email.headerregistry.ParameterizedMIMEHeader.params` attribute of the
       header value (for example, ``msg['Content-Type'].params['charset']``).
 
       .. versionchanged:: 3.4 ``replace`` keyword was added.
@@ -691,7 +691,7 @@ message objects.
 
    .. method:: clear_content()
 
-      Remove the payload and all of the :exc:`Content-` headers, leaving
+      Remove the payload and all of the :mailheader:`!Content-` headers, leaving
       all other headers intact and in their original order.
 
 
--- a/Doc/library/email.parser.rst
+++ b/Doc/library/email.parser.rst
@@ -39,9 +39,9 @@ returns the root object when you close t
 Note that the parser can be extended in limited ways, and of course you can
 implement your own parser completely from scratch.  All of the logic that
 connects the :mod:`email` package's bundled parser and the
-:class:`~email.message.EmailMessage` class is embodied in the :mod:`policy`
+:class:`~email.message.EmailMessage` class is embodied in the :class:`~email.policy.Policy`
 class, so a custom parser can create message object trees any way it finds
-necessary by implementing custom versions of the appropriate :mod:`policy`
+necessary by implementing custom versions of the appropriate :class:`!Policy`
 methods.
 
 
--- a/Doc/library/exceptions.rst
+++ b/Doc/library/exceptions.rst
@@ -450,7 +450,7 @@ The following exceptions are the excepti
 
 .. exception:: StopAsyncIteration
 
-   Must be raised by :meth:`__anext__` method of an
+   Must be raised by :meth:`~object.__anext__` method of an
    :term:`asynchronous iterator` object to stop the iteration.
 
    .. versionadded:: 3.5
@@ -659,8 +659,8 @@ depending on the system error code.
 
    Raised when an operation would block on an object (e.g. socket) set
    for non-blocking operation.
-   Corresponds to :c:data:`errno` :py:data:`~errno.EAGAIN`, :py:data:`~errno.EALREADY`,
-   :py:data:`~errno.EWOULDBLOCK` and :py:data:`~errno.EINPROGRESS`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.EAGAIN`, :py:const:`~errno.EALREADY`,
+   :py:const:`~errno.EWOULDBLOCK` and :py:const:`~errno.EINPROGRESS`.
 
    In addition to those of :exc:`OSError`, :exc:`BlockingIOError` can have
    one more attribute:
@@ -674,7 +674,7 @@ depending on the system error code.
 .. exception:: ChildProcessError
 
    Raised when an operation on a child process failed.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ECHILD`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ECHILD`.
 
 .. exception:: ConnectionError
 
@@ -688,40 +688,40 @@ depending on the system error code.
    A subclass of :exc:`ConnectionError`, raised when trying to write on a
    pipe while the other end has been closed, or trying to write on a socket
    which has been shutdown for writing.
-   Corresponds to :c:data:`errno` :py:data:`~errno.EPIPE` and :py:data:`~errno.ESHUTDOWN`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.EPIPE` and :py:const:`~errno.ESHUTDOWN`.
 
 .. exception:: ConnectionAbortedError
 
    A subclass of :exc:`ConnectionError`, raised when a connection attempt
    is aborted by the peer.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ECONNABORTED`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ECONNABORTED`.
 
 .. exception:: ConnectionRefusedError
 
    A subclass of :exc:`ConnectionError`, raised when a connection attempt
    is refused by the peer.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ECONNREFUSED`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ECONNREFUSED`.
 
 .. exception:: ConnectionResetError
 
    A subclass of :exc:`ConnectionError`, raised when a connection is
    reset by the peer.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ECONNRESET`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ECONNRESET`.
 
 .. exception:: FileExistsError
 
    Raised when trying to create a file or directory which already exists.
-   Corresponds to :c:data:`errno` :py:data:`~errno.EEXIST`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.EEXIST`.
 
 .. exception:: FileNotFoundError
 
    Raised when a file or directory is requested but doesn't exist.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ENOENT`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ENOENT`.
 
 .. exception:: InterruptedError
 
    Raised when a system call is interrupted by an incoming signal.
-   Corresponds to :c:data:`errno` :py:data:`~errno.EINTR`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.EINTR`.
 
    .. versionchanged:: 3.5
       Python now retries system calls when a syscall is interrupted by a
@@ -732,7 +732,7 @@ depending on the system error code.
 
    Raised when a file operation (such as :func:`os.remove`) is requested
    on a directory.
-   Corresponds to :c:data:`errno` :py:data:`~errno.EISDIR`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.EISDIR`.
 
 .. exception:: NotADirectoryError
 
@@ -740,28 +740,28 @@ depending on the system error code.
    something which is not a directory.  On most POSIX platforms, it may also be
    raised if an operation attempts to open or traverse a non-directory file as if
    it were a directory.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ENOTDIR`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ENOTDIR`.
 
 .. exception:: PermissionError
 
    Raised when trying to run an operation without the adequate access
    rights - for example filesystem permissions.
-   Corresponds to :c:data:`errno` :py:data:`~errno.EACCES`,
-   :py:data:`~errno.EPERM`, and :py:data:`~errno.ENOTCAPABLE`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.EACCES`,
+   :py:const:`~errno.EPERM`, and :py:const:`~errno.ENOTCAPABLE`.
 
    .. versionchanged:: 3.11.1
-      WASI's :py:data:`~errno.ENOTCAPABLE` is now mapped to
+      WASI's :py:const:`~errno.ENOTCAPABLE` is now mapped to
       :exc:`PermissionError`.
 
 .. exception:: ProcessLookupError
 
    Raised when a given process doesn't exist.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ESRCH`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ESRCH`.
 
 .. exception:: TimeoutError
 
    Raised when a system function timed out at the system level.
-   Corresponds to :c:data:`errno` :py:data:`~errno.ETIMEDOUT`.
+   Corresponds to :c:data:`errno` :py:const:`~errno.ETIMEDOUT`.
 
 .. versionadded:: 3.3
    All the above :exc:`OSError` subclasses were added.
@@ -871,6 +871,8 @@ The following exceptions are used as war
    .. versionadded:: 3.2
 
 
+.. _lib-exception-groups:
+
 Exception groups
 ----------------
 
--- a/Doc/library/fcntl.rst
+++ b/Doc/library/fcntl.rst
@@ -166,9 +166,9 @@ The module defines the following functio
    which the lock starts, relative to *whence*, and *whence* is as with
    :func:`io.IOBase.seek`, specifically:
 
-   * :const:`0` -- relative to the start of the file (:data:`os.SEEK_SET`)
-   * :const:`1` -- relative to the current buffer position (:data:`os.SEEK_CUR`)
-   * :const:`2` -- relative to the end of the file (:data:`os.SEEK_END`)
+   * ``0`` -- relative to the start of the file (:const:`os.SEEK_SET`)
+   * ``1`` -- relative to the current buffer position (:const:`os.SEEK_CUR`)
+   * ``2`` -- relative to the end of the file (:const:`os.SEEK_END`)
 
    The default for *start* is 0, which means to start at the beginning of the file.
    The default for *len* is 0 which means to lock to the end of the file.  The
@@ -195,7 +195,7 @@ using the :func:`flock` call may be bett
 .. seealso::
 
    Module :mod:`os`
-      If the locking flags :data:`~os.O_SHLOCK` and :data:`~os.O_EXLOCK` are
+      If the locking flags :const:`~os.O_SHLOCK` and :const:`~os.O_EXLOCK` are
       present in the :mod:`os` module (on BSD only), the :func:`os.open`
       function provides an alternative to the :func:`lockf` and :func:`flock`
       functions.
--- a/Doc/library/filecmp.rst
+++ b/Doc/library/filecmp.rst
@@ -74,7 +74,7 @@ The :class:`dircmp` class
 
    Construct a new directory comparison object, to compare the directories *a*
    and *b*.  *ignore* is a list of names to ignore, and defaults to
-   :attr:`filecmp.DEFAULT_IGNORES`.  *hide* is a list of names to hide, and
+   :const:`filecmp.DEFAULT_IGNORES`.  *hide* is a list of names to hide, and
    defaults to ``[os.curdir, os.pardir]``.
 
    The :class:`dircmp` class compares files by doing *shallow* comparisons
@@ -100,7 +100,7 @@ The :class:`dircmp` class
    used to get various bits of information about the directory trees being
    compared.
 
-   Note that via :meth:`__getattr__` hooks, all attributes are computed lazily,
+   Note that via :meth:`~object.__getattr__` hooks, all attributes are computed lazily,
    so there is no speed penalty if only those attributes which are lightweight
    to compute are used.
 
--- a/Doc/library/fileinput.rst
+++ b/Doc/library/fileinput.rst
@@ -177,7 +177,7 @@ available for subclassing as well:
       The keyword-only parameter *encoding* and *errors* are added.
 
    .. versionchanged:: 3.11
-      The ``'rU'`` and ``'U'`` modes and the :meth:`__getitem__` method have
+      The ``'rU'`` and ``'U'`` modes and the :meth:`!__getitem__` method have
       been removed.
 
 
--- a/Doc/library/fractions.rst
+++ b/Doc/library/fractions.rst
@@ -25,7 +25,7 @@ another rational number, or from a strin
 
    The first version requires that *numerator* and *denominator* are instances
    of :class:`numbers.Rational` and returns a new :class:`Fraction` instance
-   with value ``numerator/denominator``. If *denominator* is :const:`0`, it
+   with value ``numerator/denominator``. If *denominator* is ``0``, it
    raises a :exc:`ZeroDivisionError`. The second version requires that
    *other_fraction* is an instance of :class:`numbers.Rational` and returns a
    :class:`Fraction` instance with the same value.  The next two versions accept
--- a/Doc/library/ftplib.rst
+++ b/Doc/library/ftplib.rst
@@ -108,7 +108,7 @@ The module defines the following items:
    .. versionchanged:: 3.4
       The class now supports hostname check with
       :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-      :data:`ssl.HAS_SNI`).
+      :const:`ssl.HAS_SNI`).
 
    .. deprecated:: 3.6
 
@@ -438,7 +438,7 @@ FTP_TLS Objects
 
 .. attribute:: FTP_TLS.ssl_version
 
-   The SSL version to use (defaults to :attr:`ssl.PROTOCOL_SSLv23`).
+   The SSL version to use (defaults to :data:`ssl.PROTOCOL_SSLv23`).
 
 .. method:: FTP_TLS.auth()
 
@@ -448,7 +448,7 @@ FTP_TLS Objects
    .. versionchanged:: 3.4
       The method now supports hostname check with
       :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-      :data:`ssl.HAS_SNI`).
+      :const:`ssl.HAS_SNI`).
 
 .. method:: FTP_TLS.ccc()
 
--- a/Doc/library/functions.rst
+++ b/Doc/library/functions.rst
@@ -14,8 +14,8 @@ are always available.  They are listed h
 | |  :func:`abs`          | |  :func:`enumerate`  | |  :func:`len`        | |  |func-range|_        |
 | |  :func:`aiter`        | |  :func:`eval`       | |  |func-list|_       | |  :func:`repr`         |
 | |  :func:`all`          | |  :func:`exec`       | |  :func:`locals`     | |  :func:`reversed`     |
-| |  :func:`any`          | |                     | |                     | |  :func:`round`        |
-| |  :func:`anext`        | |  **F**              | |  **M**              | |                       |
+| |  :func:`anext`        | |                     | |                     | |  :func:`round`        |
+| |  :func:`any`          | |  **F**              | |  **M**              | |                       |
 | |  :func:`ascii`        | |  :func:`filter`     | |  :func:`map`        | |  **S**                |
 | |                       | |  :func:`float`      | |  :func:`max`        | |  |func-set|_          |
 | |  **B**                | |  :func:`format`     | |  |func-memoryview|_ | |  :func:`setattr`      |
@@ -122,7 +122,7 @@ are always available.  They are listed h
 
    Convert an integer number to a binary string prefixed with "0b". The result
    is a valid Python expression. If *x* is not a Python :class:`int` object, it
-   has to define an :meth:`__index__` method that returns an integer. Some
+   has to define an :meth:`~object.__index__` method that returns an integer. Some
    examples:
 
       >>> bin(3)
@@ -383,9 +383,9 @@ are always available.  They are listed h
    ``0j``.
 
    For a general Python object ``x``, ``complex(x)`` delegates to
-   ``x.__complex__()``.  If ``__complex__()`` is not defined then it falls back
-   to :meth:`__float__`.  If ``__float__()`` is not defined then it falls back
-   to :meth:`__index__`.
+   ``x.__complex__()``.  If :meth:`~object.__complex__` is not defined then it falls back
+   to :meth:`~object.__float__`.  If :meth:`!__float__` is not defined then it falls back
+   to :meth:`~object.__index__`.
 
    .. note::
 
@@ -400,8 +400,8 @@ are always available.  They are listed h
       Grouping digits with underscores as in code literals is allowed.
 
    .. versionchanged:: 3.8
-      Falls back to :meth:`__index__` if :meth:`__complex__` and
-      :meth:`__float__` are not defined.
+      Falls back to :meth:`~object.__index__` if :meth:`~object.__complex__` and
+      :meth:`~object.__float__` are not defined.
 
 
 .. function:: delattr(object, name)
@@ -680,8 +680,8 @@ are always available.  They are listed h
    float, an :exc:`OverflowError` will be raised.
 
    For a general Python object ``x``, ``float(x)`` delegates to
-   ``x.__float__()``.  If ``__float__()`` is not defined then it falls back
-   to :meth:`__index__`.
+   ``x.__float__()``.  If :meth:`~object.__float__` is not defined then it falls back
+   to :meth:`~object.__index__`.
 
    If no argument is given, ``0.0`` is returned.
 
@@ -707,7 +707,7 @@ are always available.  They are listed h
       *x* is now a positional-only parameter.
 
    .. versionchanged:: 3.8
-      Falls back to :meth:`__index__` if :meth:`__float__` is not defined.
+      Falls back to :meth:`~object.__index__` if :meth:`~object.__float__` is not defined.
 
 
 .. index::
@@ -793,7 +793,7 @@ are always available.  They are listed h
 
       For objects with custom :meth:`__hash__` methods, note that :func:`hash`
       truncates the return value based on the bit width of the host machine.
-      See :meth:`__hash__` for details.
+      See :meth:`__hash__ <object.__hash__>` for details.
 
 .. function:: help()
               help(request)
@@ -821,7 +821,7 @@ are always available.  They are listed h
 
    Convert an integer number to a lowercase hexadecimal string prefixed with
    "0x". If *x* is not a Python :class:`int` object, it has to define an
-   :meth:`__index__` method that returns an integer. Some examples:
+   :meth:`~object.__index__` method that returns an integer. Some examples:
 
       >>> hex(255)
       '0xff'
@@ -892,9 +892,9 @@ are always available.  They are listed h
            int(x, base=10)
 
    Return an integer object constructed from a number or string *x*, or return
-   ``0`` if no arguments are given.  If *x* defines :meth:`__int__`,
-   ``int(x)`` returns ``x.__int__()``.  If *x* defines :meth:`__index__`,
-   it returns ``x.__index__()``.  If *x* defines :meth:`__trunc__`,
+   ``0`` if no arguments are given.  If *x* defines :meth:`~object.__int__`,
+   ``int(x)`` returns ``x.__int__()``.  If *x* defines :meth:`~object.__index__`,
+   it returns ``x.__index__()``.  If *x* defines :meth:`~object.__trunc__`,
    it returns ``x.__trunc__()``.
    For floating point numbers, this truncates towards zero.
 
@@ -931,10 +931,10 @@ are always available.  They are listed h
       *x* is now a positional-only parameter.
 
    .. versionchanged:: 3.8
-      Falls back to :meth:`__index__` if :meth:`__int__` is not defined.
+      Falls back to :meth:`~object.__index__` if :meth:`~object.__int__` is not defined.
 
    .. versionchanged:: 3.11
-      The delegation to :meth:`__trunc__` is deprecated.
+      The delegation to :meth:`~object.__trunc__` is deprecated.
 
    .. versionchanged:: 3.11
       :class:`int` string inputs and string representations can be limited to
@@ -1137,7 +1137,7 @@ are always available.  They are listed h
 
   Convert an integer number to an octal string prefixed with "0o".  The result
   is a valid Python expression. If *x* is not a Python :class:`int` object, it
-  has to define an :meth:`__index__` method that returns an integer. For
+  has to define an :meth:`~object.__index__` method that returns an integer. For
   example:
 
       >>> oct(8)
@@ -1230,7 +1230,7 @@ are always available.  They are listed h
 
    * Binary files are buffered in fixed-size chunks; the size of the buffer is
      chosen using a heuristic trying to determine the underlying device's "block
-     size" and falling back on :attr:`io.DEFAULT_BUFFER_SIZE`.  On many systems,
+     size" and falling back on :const:`io.DEFAULT_BUFFER_SIZE`.  On many systems,
      the buffer will typically be 4096 or 8192 bytes long.
 
    * "Interactive" text files (files for which :meth:`~io.IOBase.isatty`
--- a/Doc/library/gc.rst
+++ b/Doc/library/gc.rst
@@ -260,7 +260,7 @@ values but should not rebind them):
 
    .. versionchanged:: 3.4
       Following :pep:`442`, objects with a :meth:`__del__` method don't end
-      up in :attr:`gc.garbage` anymore.
+      up in :data:`gc.garbage` anymore.
 
 .. data:: callbacks
 
--- a/Doc/library/gettext.rst
+++ b/Doc/library/gettext.rst
@@ -411,6 +411,7 @@ One difference between this module and H
 supported access through a mapping API, but this appears to be unused and so is
 not currently supported.
 
+.. _i18n-howto:
 
 Internationalizing your programs and modules
 --------------------------------------------
--- a/Doc/library/graphlib.rst
+++ b/Doc/library/graphlib.rst
@@ -115,7 +115,7 @@
       :meth:`TopologicalSorter.done` is less than the number that have been
       returned by :meth:`TopologicalSorter.get_ready`.
 
-      The :meth:`~TopologicalSorter.__bool__` method of this class defers to
+      The :meth:`~object.__bool__` method of this class defers to
       this function, so instead of::
 
           if ts.is_active():
@@ -204,7 +204,7 @@ The :mod:`graphlib` module defines the f
    in the working graph. If multiple cycles exist, only one undefined choice among them will
    be reported and included in the exception.
 
-   The detected cycle can be accessed via the second element in the :attr:`~CycleError.args`
+   The detected cycle can be accessed via the second element in the :attr:`~BaseException.args`
    attribute of the exception instance and consists in a list of nodes, such that each node is,
    in the graph, an immediate predecessor of the next node in the list. In the reported list,
    the first and the last node will be the same, to make it clear that it is cyclic.
--- a/Doc/library/gzip.rst
+++ b/Doc/library/gzip.rst
@@ -70,7 +70,7 @@ The module defines the following items:
 .. class:: GzipFile(filename=None, mode=None, compresslevel=9, fileobj=None, mtime=None)
 
    Constructor for the :class:`GzipFile` class, which simulates most of the
-   methods of a :term:`file object`, with the exception of the :meth:`truncate`
+   methods of a :term:`file object`, with the exception of the :meth:`~io.IOBase.truncate`
    method.  At least one of *fileobj* and *filename* must be given a non-trivial
    value.
 
@@ -113,7 +113,7 @@ The module defines the following items:
 
    :class:`GzipFile` supports the :class:`io.BufferedIOBase` interface,
    including iteration and the :keyword:`with` statement.  Only the
-   :meth:`truncate` method isn't implemented.
+   :meth:`~io.IOBase.truncate` method isn't implemented.
 
    :class:`GzipFile` also provides the following method and attribute:
 
@@ -264,7 +264,7 @@ Command line options
 
 .. cmdoption:: file
 
-   If *file* is not specified, read from :attr:`sys.stdin`.
+   If *file* is not specified, read from :data:`sys.stdin`.
 
 .. cmdoption:: --fast
 
--- a/Doc/library/hashlib.rst
+++ b/Doc/library/hashlib.rst
@@ -11,7 +11,7 @@
 
 .. index::
    single: message digest, MD5
-   single: secure hash algorithm, SHA1, SHA224, SHA256, SHA384, SHA512
+   single: secure hash algorithm, SHA1, SHA2, SHA224, SHA256, SHA384, SHA512, SHA3, Shake, Blake2
 
 .. testsetup::
 
@@ -22,7 +22,8 @@
 
 This module implements a common interface to many different secure hash and
 message digest algorithms.  Included are the FIPS secure hash algorithms SHA1,
-SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as RSA's MD5
+SHA224, SHA256, SHA384, SHA512, (defined in `the FIPS 180-4 standard`_),
+the SHA-3 series (defined in `the FIPS 202 standard`_) as well as RSA's MD5
 algorithm (defined in internet :rfc:`1321`).  The terms "secure hash" and
 "message digest" are interchangeable.  Older algorithms were called message
 digests.  The modern term is secure hash.
@@ -32,11 +33,6 @@ digests.  The modern term is secure hash
    If you want the adler32 or crc32 hash functions, they are available in
    the :mod:`zlib` module.
 
-.. warning::
-
-   Some algorithms have known hash collision weaknesses, refer to the "See
-   also" section at the end.
-
 
 .. _hash-algorithms:
 
@@ -44,38 +40,43 @@ Hash algorithms
 ---------------
 
 There is one constructor method named for each type of :dfn:`hash`.  All return
-a hash object with the same simple interface. For example: use :func:`sha256` to
-create a SHA-256 hash object. You can now feed this object with :term:`bytes-like
-objects <bytes-like object>` (normally :class:`bytes`) using the :meth:`update` method.
-At any point you can ask it for the :dfn:`digest` of the
-concatenation of the data fed to it so far using the :meth:`digest` or
-:meth:`hexdigest` methods.
-
-.. note::
-
-   For better multithreading performance, the Python :term:`GIL` is released for
-   data larger than 2047 bytes at object creation or on update.
-
-.. note::
+a hash object with the same simple interface. For example: use :func:`sha256`
+to create a SHA-256 hash object. You can now feed this object with
+:term:`bytes-like objects <bytes-like object>` (normally :class:`bytes`) using
+the :meth:`update<hash.update>` method.  At any point you can ask it for the
+:dfn:`digest` of the concatenation of the data fed to it so far using the
+:meth:`digest()<hash.digest>` or :meth:`hexdigest()<hash.hexdigest>` methods.
+
+To allow multithreading, the Python :term:`GIL` is released while computing a
+hash supplied more than 2047 bytes of data at once in its constructor or
+:meth:`.update<hash.update>` method.
 
-   Feeding string objects into :meth:`update` is not supported, as hashes work
-   on bytes, not on characters.
 
 .. index:: single: OpenSSL; (use in module hashlib)
 
 Constructors for hash algorithms that are always present in this module are
-:func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`,
-:func:`sha512`, :func:`blake2b`, and :func:`blake2s`.
-:func:`md5` is normally available as well, though it
-may be missing or blocked if you are using a rare "FIPS compliant" build of Python.
-Additional algorithms may also be available depending upon the OpenSSL
-library that Python uses on your platform. On most platforms the
+:func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:`sha512`,
 :func:`sha3_224`, :func:`sha3_256`, :func:`sha3_384`, :func:`sha3_512`,
-:func:`shake_128`, :func:`shake_256` are also available.
+:func:`shake_128`, :func:`shake_256`, :func:`blake2b`, and :func:`blake2s`.
+:func:`md5` is normally available as well, though it may be missing or blocked
+if you are using a rare "FIPS compliant" build of Python.
+These correspond to :data:`algorithms_guaranteed`.
+
+Additional algorithms may also be available if your Python distribution's
+:mod:`hashlib` was linked against a build of OpenSSL that provides others.
+Others *are not guaranteed available* on all installations and will only be
+accessible by name via :func:`new`.  See :data:`algorithms_available`.
+
+.. warning::
+
+   Some algorithms have known hash collision weaknesses (including MD5 and
+   SHA1). Refer to `Attacks on cryptographic hash algorithms`_ and the
+   `hashlib-seealso`_ section at the end of this document.
 
 .. versionadded:: 3.6
    SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`,
-   :func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`.
+   :func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`
+   were added.
 
 .. versionadded:: 3.6
    :func:`blake2b` and :func:`blake2s` were added.
@@ -89,10 +90,14 @@ library that Python uses on your platfor
    that the hashing algorithm is not used in a security context, e.g. as a
    non-cryptographic one-way compression function.
 
-   Hashlib now uses SHA3 and SHAKE from OpenSSL 1.1.1 and newer.
+.. versionchanged:: 3.9
+   Hashlib now uses SHA3 and SHAKE from OpenSSL if it provides it.
 
-For example, to obtain the digest of the byte string ``b"Nobody inspects the
-spammish repetition"``::
+Usage
+-----
+
+To obtain the digest of the byte string ``b"Nobody inspects the spammish
+repetition"``::
 
    >>> import hashlib
    >>> m = hashlib.sha256()
@@ -108,22 +113,42 @@ More condensed:
    >>> hashlib.sha256(b"Nobody inspects the spammish repetition").hexdigest()
    '031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'
 
-.. function:: new(name[, data], *, usedforsecurity=True)
+Constructors
+------------
+
+.. function:: new(name[, data], \*, usedforsecurity=True)
 
    Is a generic constructor that takes the string *name* of the desired
    algorithm as its first parameter.  It also exists to allow access to the
    above listed hashes as well as any other algorithms that your OpenSSL
-   library may offer.  The named constructors are much faster than :func:`new`
-   and should be preferred.
+   library may offer.
 
-Using :func:`new` with an algorithm provided by OpenSSL:
+Using :func:`new` with an algorithm name:
 
    >>> h = hashlib.new('sha256')
    >>> h.update(b"Nobody inspects the spammish repetition")
    >>> h.hexdigest()
    '031edd7d41651593c5fe5c006fa5752b37fddff7bc4e843aa6af0c950f4b9406'
 
-Hashlib provides the following constant attributes:
+
+.. function:: md5([, data], \*, usedforsecurity=True)
+.. function:: sha1([, data], \*, usedforsecurity=True)
+.. function:: sha224([, data], \*, usedforsecurity=True)
+.. function:: sha256([, data], \*, usedforsecurity=True)
+.. function:: sha384([, data], \*, usedforsecurity=True)
+.. function:: sha512([, data], \*, usedforsecurity=True)
+.. function:: sha3_224([, data], \*, usedforsecurity=True)
+.. function:: sha3_256([, data], \*, usedforsecurity=True)
+.. function:: sha3_384([, data], \*, usedforsecurity=True)
+.. function:: sha3_512([, data], \*, usedforsecurity=True)
+
+Named constructors such as these are faster than passing an algorithm name to
+:func:`new`.
+
+Attributes
+----------
+
+Hashlib provides the following constant module attributes:
 
 .. data:: algorithms_guaranteed
 
@@ -144,10 +169,12 @@ Hashlib provides the following constant
 
    .. versionadded:: 3.2
 
+Hash Objects
+------------
+
 The following values are provided as constant attributes of the hash objects
 returned by the constructors:
 
-
 .. data:: hash.digest_size
 
    The size of the resulting hash in bytes.
@@ -207,6 +234,9 @@ A hash object has the following methods:
 SHAKE variable length digests
 -----------------------------
 
+.. function:: shake_128([, data], \*, usedforsecurity=True)
+.. function:: shake_256([, data], \*, usedforsecurity=True)
+
 The :func:`shake_128` and :func:`shake_256` algorithms provide variable
 length digests with length_in_bits//2 up to 128 or 256 bits of security.
 As such, their digest methods require a length. Maximum length is not limited
@@ -214,7 +244,7 @@ by the SHAKE algorithm.
 
 .. method:: shake.digest(length)
 
-   Return the digest of the data passed to the :meth:`update` method so far.
+   Return the digest of the data passed to the :meth:`~hash.update` method so far.
    This is a bytes object of size *length* which may contain bytes in
    the whole range from 0 to 255.
 
@@ -223,8 +253,13 @@ by the SHAKE algorithm.
 
    Like :meth:`digest` except the digest is returned as a string object of
    double length, containing only hexadecimal digits.  This may be used to
-   exchange the value safely in email or other non-binary environments.
+   exchange the value in email or other non-binary environments.
 
+Example use:
+
+   >>> h = hashlib.shake_256(b'Nobody inspects the spammish repetition')
+   >>> h.hexdigest(20)
+   '44709d6fcb83d92a76dcb0b668c98e1b1d3dafe7'
 
 File hashing
 ------------
@@ -478,9 +513,9 @@ Simple hashing
 
 To calculate hash of some data, you should first construct a hash object by
 calling the appropriate constructor function (:func:`blake2b` or
-:func:`blake2s`), then update it with the data by calling :meth:`update` on the
+:func:`blake2s`), then update it with the data by calling :meth:`~hash.update` on the
 object, and, finally, get the digest out of the object by calling
-:meth:`digest` (or :meth:`hexdigest` for hex-encoded string).
+:meth:`~hash.digest` (or :meth:`~hash.hexdigest` for hex-encoded string).
 
     >>> from hashlib import blake2b
     >>> h = blake2b()
@@ -773,12 +808,17 @@ Domain Dedication 1.0 Universal:
 .. _BLAKE2: https://www.blake2.net
 .. _HMAC: https://en.wikipedia.org/wiki/Hash-based_message_authentication_code
 .. _BLAKE: https://web.archive.org/web/20200918190133/https://131002.net/blake/
-.. _SHA-3: https://en.wikipedia.org/wiki/NIST_hash_function_competition
+.. _SHA-3: https://en.wikipedia.org/wiki/Secure_Hash_Algorithms
 .. _ChaCha: https://cr.yp.to/chacha.html
 .. _pyblake2: https://pythonhosted.org/pyblake2/
 .. _NIST-SP-800-132: https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 .. _stackexchange pbkdf2 iterations question: https://security.stackexchange.com/questions/3959/recommended-of-iterations-when-using-pbkdf2-sha256/
+.. _Attacks on cryptographic hash algorithms: https://en.wikipedia.org/wiki/Cryptographic_hash_function#Attacks_on_cryptographic_hash_algorithms
+.. _the FIPS 180-4 standard: https://csrc.nist.gov/publications/detail/fips/180/4/final
+.. _the FIPS 202 standard: https://csrc.nist.gov/publications/detail/fips/202/final
+
 
+.. _hashlib-seealso:
 
 .. seealso::
 
@@ -788,15 +828,18 @@ Domain Dedication 1.0 Universal:
    Module :mod:`base64`
       Another way to encode binary hashes for non-binary environments.
 
-   https://www.blake2.net
-      Official BLAKE2 website.
+   https://nvlpubs.nist.gov/nistpubs/fips/nist.fips.180-4.pdf
+      The FIPS 180-4 publication on Secure Hash Algorithms.
+
+   https://csrc.nist.gov/publications/detail/fips/202/final
+      The FIPS 202 publication on the SHA-3 Standard.
 
-   https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/documents/fips180-2.pdf
-      The FIPS 180-2 publication on Secure Hash Algorithms.
+   https://www.blake2.net/
+      Official BLAKE2 website.
 
-   https://en.wikipedia.org/wiki/Cryptographic_hash_function#Cryptographic_hash_algorithms
-      Wikipedia article with information on which algorithms have known issues and
-      what that means regarding their use.
+   https://en.wikipedia.org/wiki/Cryptographic_hash_function
+      Wikipedia article with information on which algorithms have known issues
+      and what that means regarding their use.
 
    https://www.ietf.org/rfc/rfc8018.txt
       PKCS #5: Password-Based Cryptography Specification Version 2.1
--- a/Doc/library/http.client.rst
+++ b/Doc/library/http.client.rst
@@ -84,7 +84,7 @@ The module provides the following classe
 
    .. versionchanged:: 3.2
       This class now supports HTTPS virtual hosts if possible (that is,
-      if :data:`ssl.HAS_SNI` is true).
+      if :const:`ssl.HAS_SNI` is true).
 
    .. versionchanged:: 3.4
       The *strict* parameter was removed. HTTP 0.9-style "Simple Responses" are
--- a/Doc/library/imaplib.rst
+++ b/Doc/library/imaplib.rst
@@ -112,7 +112,7 @@ There's also a subclass for secure conne
    .. versionchanged:: 3.4
       The class now supports hostname check with
       :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-      :data:`ssl.HAS_SNI`).
+      :const:`ssl.HAS_SNI`).
 
    .. deprecated:: 3.6
 
@@ -513,7 +513,7 @@ An :class:`IMAP4` instance has the follo
    .. versionchanged:: 3.4
       The method now supports hostname check with
       :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-      :data:`ssl.HAS_SNI`).
+      :const:`ssl.HAS_SNI`).
 
 
 .. method:: IMAP4.status(mailbox, names)
--- a/Doc/library/imp.rst
+++ b/Doc/library/imp.rst
@@ -10,7 +10,7 @@
 .. deprecated-removed:: 3.4 3.12
    The :mod:`imp` module is deprecated in favor of :mod:`importlib`.
 
-.. index:: statement: import
+.. index:: pair: statement; import
 
 --------------
 
--- a/Doc/library/importlib.resources.abc.rst
+++ b/Doc/library/importlib.resources.abc.rst
@@ -124,7 +124,7 @@
        suitable for reading (same as :attr:`pathlib.Path.open`).
 
        When opening as text, accepts encoding parameters such as those
-       accepted by :attr:`io.TextIOWrapper`.
+       accepted by :class:`io.TextIOWrapper`.
 
     .. method:: read_bytes()
 
@@ -139,10 +139,10 @@
 
     An abstract base class for resource readers capable of serving
     the :meth:`importlib.resources.files` interface. Subclasses
-    :class:`importlib.resources.abc.ResourceReader` and provides
-    concrete implementations of the :class:`importlib.resources.abc.ResourceReader`'s
+    :class:`ResourceReader` and provides
+    concrete implementations of the :class:`!ResourceReader`'s
     abstract methods. Therefore, any loader supplying
-    :class:`importlib.abc.TraversableResources` also supplies ResourceReader.
+    :class:`!TraversableResources` also supplies :class:`!ResourceReader`.
 
     Loaders that wish to support resource reading are expected to
     implement this interface.
--- a/Doc/library/importlib.rst
+++ b/Doc/library/importlib.rst
@@ -466,7 +466,7 @@ ABC hierarchy::
             The list of locations where the package's submodules will be found.
             Most of the time this is a single directory.
             The import system passes this attribute to ``__import__()`` and to finders
-            in the same way as :attr:`sys.path` but just for the package.
+            in the same way as :data:`sys.path` but just for the package.
             It is not set on non-package modules so it can be used
             as an indicator that the module is a package.
 
@@ -717,7 +717,7 @@ ABC hierarchy::
         automatically.
 
         When writing to the path fails because the path is read-only
-        (:attr:`errno.EACCES`/:exc:`PermissionError`), do not propagate the
+        (:const:`errno.EACCES`/:exc:`PermissionError`), do not propagate the
         exception.
 
         .. versionchanged:: 3.4
@@ -965,7 +965,7 @@ find and load modules.
 
    .. classmethod:: path_hook(*loader_details)
 
-      A class method which returns a closure for use on :attr:`sys.path_hooks`.
+      A class method which returns a closure for use on :data:`sys.path_hooks`.
       An instance of :class:`FileFinder` is returned by the closure using the
       path argument given to the closure directly and *loader_details*
       indirectly.
@@ -1306,10 +1306,10 @@ an :term:`importer`.
 .. function:: find_spec(name, package=None)
 
    Find the :term:`spec <module spec>` for a module, optionally relative to
-   the specified **package** name. If the module is in :attr:`sys.modules`,
+   the specified **package** name. If the module is in :data:`sys.modules`,
    then ``sys.modules[name].__spec__`` is returned (unless the spec would be
    ``None`` or is not set, in which case :exc:`ValueError` is raised).
-   Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is
+   Otherwise a search using :data:`sys.meta_path` is done. ``None`` is
    returned if no spec is found.
 
    If **name** is for a submodule (contains a dot), the parent module is
@@ -1442,7 +1442,7 @@ an :term:`importer`.
    :meth:`~importlib.abc.Loader.create_module` method must return ``None`` or a
    type for which its ``__class__`` attribute can be mutated along with not
    using :term:`slots <__slots__>`. Finally, modules which substitute the object
-   placed into :attr:`sys.modules` will not work as there is no way to properly
+   placed into :data:`sys.modules` will not work as there is no way to properly
    replace the module references throughout the interpreter safely;
    :exc:`ValueError` is raised if such a substitution is detected.
 
@@ -1566,9 +1566,9 @@ For deep customizations of import, you t
 :term:`importer`. This means managing both the :term:`finder` and :term:`loader`
 side of things. For finders there are two flavours to choose from depending on
 your needs: a :term:`meta path finder` or a :term:`path entry finder`. The
-former is what you would put on :attr:`sys.meta_path` while the latter is what
-you create using a :term:`path entry hook` on :attr:`sys.path_hooks` which works
-with :attr:`sys.path` entries to potentially create a finder. This example will
+former is what you would put on :data:`sys.meta_path` while the latter is what
+you create using a :term:`path entry hook` on :data:`sys.path_hooks` which works
+with :data:`sys.path` entries to potentially create a finder. This example will
 show you how to register your own importers so that import will use them (for
 creating an importer for yourself, read the documentation for the appropriate
 classes defined within this package)::
--- a/Doc/library/io.rst
+++ b/Doc/library/io.rst
@@ -423,7 +423,7 @@ I/O Base Classes
 
       .. versionadded:: 3.3
          Some operating systems could support additional values, like
-         :data:`os.SEEK_HOLE` or :data:`os.SEEK_DATA`. The valid values
+         :const:`os.SEEK_HOLE` or :const:`os.SEEK_DATA`. The valid values
          for a file could depend on it being open in text or binary mode.
 
    .. method:: seekable()
--- a/Doc/library/json.rst
+++ b/Doc/library/json.rst
@@ -192,7 +192,7 @@ Basic Usage
    dictionaries will be sorted by key.
 
    To use a custom :class:`JSONEncoder` subclass (e.g. one that overrides the
-   :meth:`default` method to serialize additional types), specify it with the
+   :meth:`~JSONEncoder.default` method to serialize additional types), specify it with the
    *cls* kwarg; otherwise :class:`JSONEncoder` is used.
 
    .. versionchanged:: 3.6
@@ -422,7 +422,7 @@ Encoders and Decoders
       Added support for int- and float-derived Enum classes.
 
    To extend this to recognize other objects, subclass and implement a
-   :meth:`default` method with another method that returns a serializable object
+   :meth:`~JSONEncoder.default` method with another method that returns a serializable object
    for ``o`` if possible, otherwise it should call the superclass implementation
    (to raise :exc:`TypeError`).
 
@@ -483,7 +483,7 @@ Encoders and Decoders
       :exc:`TypeError`).
 
       For example, to support arbitrary iterators, you could implement
-      :meth:`default` like this::
+      :meth:`~JSONEncoder.default` like this::
 
          def default(self, o):
             try:
@@ -683,7 +683,7 @@ The :mod:`json.tool` module provides a s
 and pretty-print JSON objects.
 
 If the optional ``infile`` and ``outfile`` arguments are not
-specified, :attr:`sys.stdin` and :attr:`sys.stdout` will be used respectively:
+specified, :data:`sys.stdin` and :data:`sys.stdout` will be used respectively:
 
 .. code-block:: shell-session
 
@@ -721,12 +721,12 @@ Command line options
           }
       ]
 
-   If *infile* is not specified, read from :attr:`sys.stdin`.
+   If *infile* is not specified, read from :data:`sys.stdin`.
 
 .. cmdoption:: outfile
 
    Write the output of the *infile* to the given *outfile*. Otherwise, write it
-   to :attr:`sys.stdout`.
+   to :data:`sys.stdout`.
 
 .. cmdoption:: --sort-keys
 
--- a/Doc/library/logging.handlers.rst
+++ b/Doc/library/logging.handlers.rst
@@ -97,7 +97,7 @@ sends logging output to a disk file.  It
 
    Returns a new instance of the :class:`FileHandler` class. The specified file is
    opened and used as the stream for logging. If *mode* is not specified,
-   :const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the file
+   ``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file
    with that encoding.  If *delay* is true, then file opening is deferred until the
    first call to :meth:`emit`. By default, the file grows indefinitely. If
    *errors* is specified, it's used to determine how encoding errors are handled.
@@ -182,7 +182,7 @@ for this value.
 
    Returns a new instance of the :class:`WatchedFileHandler` class. The specified
    file is opened and used as the stream for logging. If *mode* is not specified,
-   :const:`'a'` is used.  If *encoding* is not ``None``, it is used to open the file
+   ``'a'`` is used.  If *encoding* is not ``None``, it is used to open the file
    with that encoding.  If *delay* is true, then file opening is deferred until the
    first call to :meth:`emit`.  By default, the file grows indefinitely. If
    *errors* is provided, it determines how encoding errors are handled.
@@ -917,8 +917,9 @@ should, then :meth:`flush` is expected t
 
    .. method:: flush()
 
-      You can override this to implement custom flushing behavior. This version
-      just zaps the buffer to empty.
+      For a :class:`BufferingHandler` instance, flushing means that it sets the
+      buffer to an empty list. This method can be overwritten to implement more useful
+      flushing behavior.
 
 
    .. method:: shouldFlush(record)
@@ -950,9 +951,9 @@ should, then :meth:`flush` is expected t
 
    .. method:: flush()
 
-      For a :class:`MemoryHandler`, flushing means just sending the buffered
+      For a :class:`MemoryHandler` instance, flushing means just sending the buffered
       records to the target, if there is one. The buffer is also cleared when
-      this happens. Override if you want different behavior.
+      buffered records are sent to the target. Override if you want different behavior.
 
 
    .. method:: setTarget(target)
@@ -1051,8 +1052,8 @@ possible, while any potentially slow ope
       occur (e.g. because a bounded queue has filled up), the
       :meth:`~logging.Handler.handleError` method is called to handle the
       error. This can result in the record silently being dropped (if
-      :attr:`logging.raiseExceptions` is ``False``) or a message printed to
-      ``sys.stderr`` (if :attr:`logging.raiseExceptions` is ``True``).
+      :data:`logging.raiseExceptions` is ``False``) or a message printed to
+      ``sys.stderr`` (if :data:`logging.raiseExceptions` is ``True``).
 
    .. method:: prepare(record)
 
--- a/Doc/library/logging.rst
+++ b/Doc/library/logging.rst
@@ -385,21 +385,21 @@ have specific values relative to the pre
 with the same numeric value, it overwrites the predefined value; the predefined
 name is lost.
 
-+--------------+---------------+
-| Level        | Numeric value |
-+==============+===============+
-| ``CRITICAL`` | 50            |
-+--------------+---------------+
-| ``ERROR``    | 40            |
-+--------------+---------------+
-| ``WARNING``  | 30            |
-+--------------+---------------+
-| ``INFO``     | 20            |
-+--------------+---------------+
-| ``DEBUG``    | 10            |
-+--------------+---------------+
-| ``NOTSET``   | 0             |
-+--------------+---------------+
++-----------------------+---------------+
+| Level                 | Numeric value |
++=======================+===============+
+| .. py:data:: CRITICAL | 50            |
++-----------------------+---------------+
+| .. py:data:: ERROR    | 40            |
++-----------------------+---------------+
+| .. py:data:: WARNING  | 30            |
++-----------------------+---------------+
+| .. py:data:: INFO     | 20            |
++-----------------------+---------------+
+| .. py:data:: DEBUG    | 10            |
++-----------------------+---------------+
+| .. py:data:: NOTSET   | 0             |
++-----------------------+---------------+
 
 
 .. _handler:
--- a/Doc/library/lzma.rst
+++ b/Doc/library/lzma.rst
@@ -100,7 +100,8 @@ Reading and writing compressed files
    *filters* arguments have the same meanings as for :class:`LZMACompressor`.
 
    :class:`LZMAFile` supports all the members specified by
-   :class:`io.BufferedIOBase`, except for :meth:`detach` and :meth:`truncate`.
+   :class:`io.BufferedIOBase`, except for :meth:`~io.BufferedIOBase.detach`
+   and :meth:`~io.IOBase.truncate`.
    Iteration and the :keyword:`with` statement are supported.
 
    The following method is also provided:
--- a/Doc/library/mailbox.rst
+++ b/Doc/library/mailbox.rst
@@ -477,7 +477,7 @@ Supported mailbox formats are Maildir, m
                unlock()
 
       Three locking mechanisms are used---dot locking and, if available, the
-      :c:func:`flock` and :c:func:`lockf` system calls.
+      :c:func:`!flock` and :c:func:`!lockf` system calls.
 
 
 .. seealso::
@@ -588,7 +588,7 @@ Supported mailbox formats are Maildir, m
                unlock()
 
       Three locking mechanisms are used---dot locking and, if available, the
-      :c:func:`flock` and :c:func:`lockf` system calls. For MH mailboxes, locking
+      :c:func:`!flock` and :c:func:`!lockf` system calls. For MH mailboxes, locking
       the mailbox means locking the :file:`.mh_sequences` file and, only for the
       duration of any operations that affect them, locking individual message
       files.
@@ -686,7 +686,7 @@ Supported mailbox formats are Maildir, m
                unlock()
 
       Three locking mechanisms are used---dot locking and, if available, the
-      :c:func:`flock` and :c:func:`lockf` system calls.
+      :c:func:`!flock` and :c:func:`!lockf` system calls.
 
 
 .. seealso::
@@ -737,7 +737,7 @@ Supported mailbox formats are Maildir, m
                unlock()
 
       Three locking mechanisms are used---dot locking and, if available, the
-      :c:func:`flock` and :c:func:`lockf` system calls.
+      :c:func:`!flock` and :c:func:`!lockf` system calls.
 
 
 .. seealso::
--- a/Doc/library/msvcrt.rst
+++ b/Doc/library/msvcrt.rst
@@ -38,7 +38,7 @@ File Operations
    Lock part of a file based on file descriptor *fd* from the C runtime.  Raises
    :exc:`OSError` on failure.  The locked region of the file extends from the
    current file position for *nbytes* bytes, and may continue beyond the end of the
-   file.  *mode* must be one of the :const:`LK_\*` constants listed below. Multiple
+   file.  *mode* must be one of the :const:`!LK_\*` constants listed below. Multiple
    regions in a file may be locked at the same time, but may not overlap.  Adjacent
    regions are not merged; they must be unlocked individually.
 
--- a/Doc/library/multiprocessing.rst
+++ b/Doc/library/multiprocessing.rst
@@ -453,16 +453,16 @@ process which created it.
       ...     return x*x
       ...
       >>> with p:
-      ...   p.map(f, [1,2,3])
+      ...     p.map(f, [1,2,3])
       Process PoolWorker-1:
       Process PoolWorker-2:
       Process PoolWorker-3:
       Traceback (most recent call last):
       Traceback (most recent call last):
       Traceback (most recent call last):
-      AttributeError: 'module' object has no attribute 'f'
-      AttributeError: 'module' object has no attribute 'f'
-      AttributeError: 'module' object has no attribute 'f'
+      AttributeError: Can't get attribute 'f' on <module '__main__' (built-in)>
+      AttributeError: Can't get attribute 'f' on <module '__main__' (built-in)>
+      AttributeError: Can't get attribute 'f' on <module '__main__' (built-in)>
 
    (If you try this it will actually output three full tracebacks
    interleaved in a semi-random fashion, and then you may have to
@@ -2682,7 +2682,7 @@ handler type) for messages from differen
    Returns the logger used by :mod:`multiprocessing`.  If necessary, a new one
    will be created.
 
-   When first created the logger has level :data:`logging.NOTSET` and no
+   When first created the logger has level :const:`logging.NOTSET` and no
    default handler. Messages sent to this logger will not by default propagate
    to the root logger.
 
--- a/Doc/library/multiprocessing.shared_memory.rst
+++ b/Doc/library/multiprocessing.shared_memory.rst
@@ -255,16 +255,17 @@ shared memory blocks created using that
 :keyword:`with` statement's code block finishes execution.
 
 
-.. class:: ShareableList(sequence=None, *, name=None)
+.. class:: ShareableList(sequence=None, \*, name=None)
 
    Provides a mutable list-like object where all values stored within are
    stored in a shared memory block.  This constrains storable values to
-   only the ``int``, ``float``, ``bool``, ``str`` (less than 10M bytes each),
-   ``bytes`` (less than 10M bytes each), and ``None`` built-in data types.
-   It also notably differs from the built-in ``list`` type in that these
-   lists can not change their overall length (i.e. no append, insert, etc.)
-   and do not support the dynamic creation of new :class:`ShareableList`
-   instances via slicing.
+   only the ``int`` (signed 64-bit), ``float``, ``bool``, ``str`` (less
+   than 10M bytes each when encoded as utf-8), ``bytes`` (less than 10M
+   bytes each), and ``None`` built-in data types.  It also notably
+   differs from the built-in ``list`` type in that these lists can not
+   change their overall length (i.e. no append, insert, etc.) and do not
+   support the dynamic creation of new :class:`ShareableList` instances
+   via slicing.
 
    *sequence* is used in populating a new ``ShareableList`` full of values.
    Set to ``None`` to instead attach to an already existing
@@ -275,6 +276,35 @@ shared memory blocks created using that
    existing ``ShareableList``, specify its shared memory block's unique
    name while leaving ``sequence`` set to ``None``.
 
+   .. note::
+
+      A known issue exists for :class:`bytes` and :class:`str` values.
+      If they end with ``\x00`` nul bytes or characters, those may be
+      *silently stripped* when fetching them by index from the
+      :class:`ShareableList`. This ``.rstrip(b'\x00')`` behavior is
+      considered a bug and may go away in the future. See :gh:`106939`.
+
+   For applications where rstripping of trailing nulls is a problem,
+   work around it by always unconditionally appending an extra non-0
+   byte to the end of such values when storing and unconditionally
+   removing it when fetching:
+
+   .. doctest::
+
+       >>> from multiprocessing import shared_memory
+       >>> nul_bug_demo = shared_memory.ShareableList(['?\x00', b'\x03\x02\x01\x00\x00\x00'])
+       >>> nul_bug_demo[0]
+       '?'
+       >>> nul_bug_demo[1]
+       b'\x03\x02\x01'
+       >>> nul_bug_demo.shm.unlink()
+       >>> padded = shared_memory.ShareableList(['?\x00\x07', b'\x03\x02\x01\x00\x00\x00\x07'])
+       >>> padded[0][:-1]
+       '?\x00'
+       >>> padded[1][:-1]
+       b'\x03\x02\x01\x00\x00\x00'
+       >>> padded.shm.unlink()
+
    .. method:: count(value)
 
       Returns the number of occurrences of ``value``.
--- a/Doc/library/netrc.rst
+++ b/Doc/library/netrc.rst
@@ -51,9 +51,19 @@ the Unix :program:`ftp` program and othe
 
    Exception raised by the :class:`~netrc.netrc` class when syntactical errors are
    encountered in source text.  Instances of this exception provide three
-   interesting attributes:  :attr:`msg` is a textual explanation of the error,
-   :attr:`filename` is the name of the source file, and :attr:`lineno` gives the
-   line number on which the error was found.
+   interesting attributes:
+
+   .. attribute:: msg
+
+      Textual explanation of the error.
+
+   .. attribute:: filename
+
+      The name of the source file.
+
+   .. attribute:: lineno
+
+      The line number on which the error was found.
 
 
 .. _netrc-objects:
--- a/Doc/library/operator.rst
+++ b/Doc/library/operator.rst
@@ -59,9 +59,9 @@ truth tests, identity tests, and boolean
               __not__(obj)
 
    Return the outcome of :keyword:`not` *obj*.  (Note that there is no
-   :meth:`__not__` method for object instances; only the interpreter core defines
-   this operation.  The result is affected by the :meth:`__bool__` and
-   :meth:`__len__` methods.)
+   :meth:`!__not__` method for object instances; only the interpreter core defines
+   this operation.  The result is affected by the :meth:`~object.__bool__` and
+   :meth:`~object.__len__` methods.)
 
 
 .. function:: truth(obj)
--- a/Doc/library/optparse.rst
+++ b/Doc/library/optparse.rst
@@ -42,8 +42,8 @@ on the command-line, for example::
    <yourscript> --file=outfile -q
 
 As it parses the command line, :mod:`optparse` sets attributes of the
-``options`` object returned by :meth:`parse_args` based on user-supplied
-command-line values.  When :meth:`parse_args` returns from parsing this command
+``options`` object returned by :meth:`~OptionParser.parse_args` based on user-supplied
+command-line values.  When :meth:`~OptionParser.parse_args` returns from parsing this command
 line, ``options.filename`` will be ``"outfile"`` and ``options.verbose`` will be
 ``False``.  :mod:`optparse` supports both long and short options, allows short
 options to be merged together, and allows options to be associated with their
@@ -285,10 +285,10 @@ program's command line::
 
    (options, args) = parser.parse_args()
 
-(If you like, you can pass a custom argument list to :meth:`parse_args`, but
+(If you like, you can pass a custom argument list to :meth:`~OptionParser.parse_args`, but
 that's rarely necessary: by default it uses ``sys.argv[1:]``.)
 
-:meth:`parse_args` returns two values:
+:meth:`~OptionParser.parse_args` returns two values:
 
 * ``options``, an object containing values for all of your options---e.g. if
   ``--file`` takes a single string argument, then ``options.file`` will be the
@@ -339,7 +339,7 @@ Now let's make up a fake command line an
 
 When :mod:`optparse` sees the option string ``-f``, it consumes the next
 argument, ``foo.txt``, and stores it in ``options.filename``.  So, after this
-call to :meth:`parse_args`, ``options.filename`` is ``"foo.txt"``.
+call to :meth:`~OptionParser.parse_args`, ``options.filename`` is ``"foo.txt"``.
 
 Some other option types supported by :mod:`optparse` are ``int`` and ``float``.
 Here's an option that expects an integer argument::
@@ -453,7 +453,8 @@ Again, the default value for ``verbose``
 value supplied for any particular destination is the one that counts.
 
 A clearer way to specify default values is the :meth:`set_defaults` method of
-OptionParser, which you can call at any time before calling :meth:`parse_args`::
+OptionParser, which you can call at any time before calling
+:meth:`~OptionParser.parse_args`::
 
    parser.set_defaults(verbose=True)
    parser.add_option(...)
@@ -811,7 +812,7 @@ The first step in using :mod:`optparse`
       help option.  When :mod:`optparse` prints the usage string, it expands
       ``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you
       passed that keyword argument).  To suppress a usage message, pass the
-      special value :data:`optparse.SUPPRESS_USAGE`.
+      special value :const:`optparse.SUPPRESS_USAGE`.
 
    ``option_list`` (default: ``[]``)
       A list of Option objects to populate the parser with.  The options in
@@ -1077,7 +1078,7 @@ relevant to a particular option, or fail
    Help text to print for this option when listing all available options after
    the user supplies a :attr:`~Option.help` option (such as ``--help``).  If
    no help text is supplied, the option will be listed without help text.  To
-   hide this option, use the special value :data:`optparse.SUPPRESS_HELP`.
+   hide this option, use the special value :const:`optparse.SUPPRESS_HELP`.
 
 .. attribute:: Option.metavar
 
@@ -1249,7 +1250,7 @@ must specify for any option using that a
 
   If no :attr:`~Option.help` string is supplied for an option, it will still be
   listed in the help message.  To omit an option entirely, use the special value
-  :data:`optparse.SUPPRESS_HELP`.
+  :const:`optparse.SUPPRESS_HELP`.
 
   :mod:`optparse` automatically adds a :attr:`~Option.help` option to all
   OptionParsers, so you do not normally need to create one.
@@ -1338,35 +1339,37 @@ Parsing arguments
 ^^^^^^^^^^^^^^^^^
 
 The whole point of creating and populating an OptionParser is to call its
-:meth:`parse_args` method::
+:meth:`~OptionParser.parse_args` method.
 
-   (options, args) = parser.parse_args(args=None, values=None)
+.. method:: OptionParser.parse_args(args=None, values=None)
 
-where the input parameters are
+   Parse the command-line options found in *args*.
 
-``args``
-   the list of arguments to process (default: ``sys.argv[1:]``)
+   The input parameters are
 
-``values``
-   an :class:`optparse.Values` object to store option arguments in (default: a
-   new instance of :class:`Values`) -- if you give an existing object, the
-   option defaults will not be initialized on it
+   ``args``
+      the list of arguments to process (default: ``sys.argv[1:]``)
 
-and the return values are
+   ``values``
+      an :class:`Values` object to store option arguments in (default: a
+      new instance of :class:`Values`) -- if you give an existing object, the
+      option defaults will not be initialized on it
 
-``options``
-   the same object that was passed in as ``values``, or the optparse.Values
-   instance created by :mod:`optparse`
+   and the return value is a pair ``(options, args)`` where
 
-``args``
-   the leftover positional arguments after all options have been processed
+   ``options``
+      the same object that was passed in as *values*, or the ``optparse.Values``
+      instance created by :mod:`optparse`
+
+   ``args``
+      the leftover positional arguments after all options have been processed
 
 The most common usage is to supply neither keyword argument.  If you supply
 ``values``, it will be modified with repeated :func:`setattr` calls (roughly one
 for every option argument stored to an option destination) and returned by
-:meth:`parse_args`.
+:meth:`~OptionParser.parse_args`.
 
-If :meth:`parse_args` encounters any errors in the argument list, it calls the
+If :meth:`~OptionParser.parse_args` encounters any errors in the argument list, it calls the
 OptionParser's :meth:`error` method with an appropriate end-user error message.
 This ultimately terminates your process with an exit status of 2 (the
 traditional Unix exit status for command-line errors).
@@ -1518,7 +1521,7 @@ OptionParser supports several other publ
 
    Set the usage string according to the rules described above for the ``usage``
    constructor keyword argument.  Passing ``None`` sets the default usage
-   string; use :data:`optparse.SUPPRESS_USAGE` to suppress a usage message.
+   string; use :const:`optparse.SUPPRESS_USAGE` to suppress a usage message.
 
 .. method:: OptionParser.print_usage(file=None)
 
@@ -1661,7 +1664,7 @@ where
       the current list of leftover arguments, ie. arguments that have been
       consumed but are neither options nor option arguments. Feel free to modify
       ``parser.largs``, e.g. by adding more arguments to it.  (This list will
-      become ``args``, the second return value of :meth:`parse_args`.)
+      become ``args``, the second return value of :meth:`~OptionParser.parse_args`.)
 
    ``parser.rargs``
       the current list of remaining arguments, ie. with ``opt_str`` and
--- a/Doc/library/os.path.rst
+++ b/Doc/library/os.path.rst
@@ -383,7 +383,7 @@ the :mod:`glob` module.)
    *start*.  On Windows, :exc:`ValueError` is raised when *path* and *start*
    are on different drives.
 
-   *start* defaults to :attr:`os.curdir`.
+   *start* defaults to :data:`os.curdir`.
 
    .. availability:: Unix, Windows.
 
--- a/Doc/library/os.rst
+++ b/Doc/library/os.rst
@@ -60,7 +60,7 @@ Notes on the availability of these funct
    ``'java'``.
 
    .. seealso::
-      :attr:`sys.platform` has a finer granularity.  :func:`os.uname` gives
+      :data:`sys.platform` has a finer granularity.  :func:`os.uname` gives
       system-dependent version information.
 
       The :mod:`platform` module provides detailed checks for the
@@ -233,7 +233,7 @@ process and user.
    :data:`environ` and :data:`environb` are synchronized (modifying
    :data:`environb` updates :data:`environ`, and vice versa).
 
-   :data:`environb` is only available if :data:`supports_bytes_environ` is
+   :data:`environb` is only available if :const:`supports_bytes_environ` is
    ``True``.
 
    .. versionadded:: 3.2
@@ -331,7 +331,7 @@ process and user.
    future environment changes.
 
 
-   :func:`getenvb` is only available if :data:`supports_bytes_environ`
+   :func:`getenvb` is only available if :const:`supports_bytes_environ`
    is ``True``.
 
    .. availability:: Unix.
@@ -401,11 +401,11 @@ process and user.
 
       On macOS, :func:`getgroups` behavior differs somewhat from
       other Unix platforms. If the Python interpreter was built with a
-      deployment target of :const:`10.5` or earlier, :func:`getgroups` returns
+      deployment target of ``10.5`` or earlier, :func:`getgroups` returns
       the list of effective group ids associated with the current user process;
       this list is limited to a system-defined number of entries, typically 16,
       and may be modified by calls to :func:`setgroups` if suitably privileged.
-      If built with a deployment target greater than :const:`10.5`,
+      If built with a deployment target greater than ``10.5``,
       :func:`getgroups` returns the current group access list for the user
       associated with the effective user id of the process; the group access
       list may change over the lifetime of the process, it is not affected by
@@ -665,14 +665,14 @@ process and user.
 
 .. function:: getsid(pid, /)
 
-   Call the system call :c:func:`getsid`.  See the Unix manual for the semantics.
+   Call the system call :c:func:`!getsid`.  See the Unix manual for the semantics.
 
    .. availability:: Unix, not Emscripten, not WASI.
 
 
 .. function:: setsid()
 
-   Call the system call :c:func:`setsid`.  See the Unix manual for the semantics.
+   Call the system call :c:func:`!setsid`.  See the Unix manual for the semantics.
 
    .. availability:: Unix, not Emscripten, not WASI.
 
@@ -690,7 +690,7 @@ process and user.
 .. function:: strerror(code, /)
 
    Return the error message corresponding to the error code in *code*.
-   On platforms where :c:func:`strerror` returns ``NULL`` when given an unknown
+   On platforms where :c:func:`!strerror` returns ``NULL`` when given an unknown
    error number, :exc:`ValueError` is raised.
 
 
@@ -829,7 +829,7 @@ as internal buffering of data.
    If *offset_src* is None, then *src* is read from the current position;
    respectively for *offset_dst*. The files pointed by *src* and *dst*
    must reside in the same filesystem, otherwise an :exc:`OSError` is
-   raised with :attr:`~OSError.errno` set to :data:`errno.EXDEV`.
+   raised with :attr:`~OSError.errno` set to :const:`errno.EXDEV`.
 
    This copy is done without the additional cost of transferring data
    from the kernel to user space and then back into the kernel. Additionally,
@@ -1071,7 +1071,7 @@ as internal buffering of data.
 
    .. versionadded:: 3.3
       Some operating systems could support additional values, like
-      :data:`os.SEEK_HOLE` or :data:`os.SEEK_DATA`.
+      :const:`os.SEEK_HOLE` or :const:`os.SEEK_DATA`.
 
 
 .. function:: open(path, flags, mode=0o777, *, dir_fd=None)
@@ -1312,7 +1312,7 @@ or `the MSDN <https://msdn.microsoft.com
 
    If some data was successfully read, it will return the number of bytes read.
    If no bytes were read, it will return ``-1`` and set errno to
-   :data:`errno.EAGAIN`.
+   :const:`errno.EAGAIN`.
 
    .. availability:: Linux >= 4.14.
 
@@ -1513,7 +1513,7 @@ or `the MSDN <https://msdn.microsoft.com
    *offset_dst*. The offset associated to the file descriptor that refers to a
    pipe must be ``None``. The files pointed by *src* and *dst* must reside in
    the same filesystem, otherwise an :exc:`OSError` is raised with
-   :attr:`~OSError.errno` set to :data:`errno.EXDEV`.
+   :attr:`~OSError.errno` set to :const:`errno.EXDEV`.
 
    This copy is done without the additional cost of transferring data
    from the kernel to user space and then back into the kernel. Additionally,
@@ -1846,18 +1846,18 @@ features:
    Set the flags of *path* to the numeric *flags*. *flags* may take a combination
    (bitwise OR) of the following values (as defined in the :mod:`stat` module):
 
-   * :data:`stat.UF_NODUMP`
-   * :data:`stat.UF_IMMUTABLE`
-   * :data:`stat.UF_APPEND`
-   * :data:`stat.UF_OPAQUE`
-   * :data:`stat.UF_NOUNLINK`
-   * :data:`stat.UF_COMPRESSED`
-   * :data:`stat.UF_HIDDEN`
-   * :data:`stat.SF_ARCHIVED`
-   * :data:`stat.SF_IMMUTABLE`
-   * :data:`stat.SF_APPEND`
-   * :data:`stat.SF_NOUNLINK`
-   * :data:`stat.SF_SNAPSHOT`
+   * :const:`stat.UF_NODUMP`
+   * :const:`stat.UF_IMMUTABLE`
+   * :const:`stat.UF_APPEND`
+   * :const:`stat.UF_OPAQUE`
+   * :const:`stat.UF_NOUNLINK`
+   * :const:`stat.UF_COMPRESSED`
+   * :const:`stat.UF_HIDDEN`
+   * :const:`stat.SF_ARCHIVED`
+   * :const:`stat.SF_IMMUTABLE`
+   * :const:`stat.SF_APPEND`
+   * :const:`stat.SF_NOUNLINK`
+   * :const:`stat.SF_SNAPSHOT`
 
    This function can support :ref:`not following symlinks <follow_symlinks>`.
 
@@ -1878,25 +1878,25 @@ features:
    following values (as defined in the :mod:`stat` module) or bitwise ORed
    combinations of them:
 
-   * :data:`stat.S_ISUID`
-   * :data:`stat.S_ISGID`
-   * :data:`stat.S_ENFMT`
-   * :data:`stat.S_ISVTX`
-   * :data:`stat.S_IREAD`
-   * :data:`stat.S_IWRITE`
-   * :data:`stat.S_IEXEC`
-   * :data:`stat.S_IRWXU`
-   * :data:`stat.S_IRUSR`
-   * :data:`stat.S_IWUSR`
-   * :data:`stat.S_IXUSR`
-   * :data:`stat.S_IRWXG`
-   * :data:`stat.S_IRGRP`
-   * :data:`stat.S_IWGRP`
-   * :data:`stat.S_IXGRP`
-   * :data:`stat.S_IRWXO`
-   * :data:`stat.S_IROTH`
-   * :data:`stat.S_IWOTH`
-   * :data:`stat.S_IXOTH`
+   * :const:`stat.S_ISUID`
+   * :const:`stat.S_ISGID`
+   * :const:`stat.S_ENFMT`
+   * :const:`stat.S_ISVTX`
+   * :const:`stat.S_IREAD`
+   * :const:`stat.S_IWRITE`
+   * :const:`stat.S_IEXEC`
+   * :const:`stat.S_IRWXU`
+   * :const:`stat.S_IRUSR`
+   * :const:`stat.S_IWUSR`
+   * :const:`stat.S_IXUSR`
+   * :const:`stat.S_IRWXG`
+   * :const:`stat.S_IRGRP`
+   * :const:`stat.S_IWGRP`
+   * :const:`stat.S_IXGRP`
+   * :const:`stat.S_IRWXO`
+   * :const:`stat.S_IROTH`
+   * :const:`stat.S_IWOTH`
+   * :const:`stat.S_IXOTH`
 
    This function can support :ref:`specifying a file descriptor <path_fd>`,
    :ref:`paths relative to directory descriptors <dir_fd>` and :ref:`not
@@ -2036,7 +2036,7 @@ features:
 
    .. audit-event:: os.link src,dst,src_dir_fd,dst_dir_fd os.link
 
-   .. availability:: Unix, Windows.
+   .. availability:: Unix, Windows, not Emscripten.
 
    .. versionchanged:: 3.2
       Added Windows support.
@@ -2243,13 +2243,13 @@ features:
 .. function:: major(device, /)
 
    Extract the device major number from a raw device number (usually the
-   :attr:`st_dev` or :attr:`st_rdev` field from :c:type:`stat`).
+   :attr:`st_dev` or :attr:`st_rdev` field from :c:struct:`stat`).
 
 
 .. function:: minor(device, /)
 
    Extract the device minor number from a raw device number (usually the
-   :attr:`st_dev` or :attr:`st_rdev` field from :c:type:`stat`).
+   :attr:`st_dev` or :attr:`st_rdev` field from :c:struct:`stat`).
 
 
 .. function:: makedev(major, minor, /)
@@ -2743,7 +2743,7 @@ features:
 .. class:: stat_result
 
    Object whose attributes correspond roughly to the members of the
-   :c:type:`stat` structure. It is used for the result of :func:`os.stat`,
+   :c:struct:`stat` structure. It is used for the result of :func:`os.stat`,
    :func:`os.fstat` and :func:`os.lstat`.
 
    Attributes:
@@ -2906,12 +2906,12 @@ features:
       See the ``IO_REPARSE_TAG_*`` constants in the :mod:`stat` module.
 
    The standard module :mod:`stat` defines functions and constants that are
-   useful for extracting information from a :c:type:`stat` structure. (On
+   useful for extracting information from a :c:struct:`stat` structure. (On
    Windows, some items are filled with dummy values.)
 
    For backward compatibility, a :class:`stat_result` instance is also
    accessible as a tuple of at least 10 integers giving the most important (and
-   portable) members of the :c:type:`stat` structure, in the order
+   portable) members of the :c:struct:`stat` structure, in the order
    :attr:`st_mode`, :attr:`st_ino`, :attr:`st_dev`, :attr:`st_nlink`,
    :attr:`st_uid`, :attr:`st_gid`, :attr:`st_size`, :attr:`st_atime`,
    :attr:`st_mtime`, :attr:`st_ctime`. More items may be added at the end by
@@ -2944,7 +2944,7 @@ features:
 
    Perform a :c:func:`statvfs` system call on the given path.  The return value is
    an object whose attributes describe the filesystem on the given path, and
-   correspond to the members of the :c:type:`statvfs` structure, namely:
+   correspond to the members of the :c:struct:`statvfs` structure, namely:
    :attr:`f_bsize`, :attr:`f_frsize`, :attr:`f_blocks`, :attr:`f_bfree`,
    :attr:`f_bavail`, :attr:`f_files`, :attr:`f_ffree`, :attr:`f_favail`,
    :attr:`f_flag`, :attr:`f_namemax`, :attr:`f_fsid`.
@@ -3920,8 +3920,8 @@ written in Python, such as a mail server
    Send signal *sig* to the process *pid*.  Constants for the specific signals
    available on the host platform are defined in the :mod:`signal` module.
 
-   Windows: The :data:`signal.CTRL_C_EVENT` and
-   :data:`signal.CTRL_BREAK_EVENT` signals are special signals which can
+   Windows: The :const:`signal.CTRL_C_EVENT` and
+   :const:`signal.CTRL_BREAK_EVENT` signals are special signals which can
    only be sent to console processes which share a common console window,
    e.g., some subprocesses. Any other value for *sig* will cause the process
    to be unconditionally killed by the TerminateProcess API, and the exit code
@@ -4068,7 +4068,7 @@ written in Python, such as a mail server
    specified. If the value specified is 0, the child's process group ID will be
    made the same as its process ID. If the value of *setpgroup* is not set, the
    child will inherit the parent's process group ID. This argument corresponds
-   to the C library :c:data:`POSIX_SPAWN_SETPGROUP` flag.
+   to the C library :c:macro:`POSIX_SPAWN_SETPGROUP` flag.
 
    If the *resetids* argument is ``True`` it will reset the effective UID and
    GID of the child to the real UID and GID of the parent process. If the
@@ -4076,27 +4076,27 @@ written in Python, such as a mail server
    the parent. In either case, if the set-user-ID and set-group-ID permission
    bits are enabled on the executable file, their effect will override the
    setting of the effective UID and GID. This argument corresponds to the C
-   library :c:data:`POSIX_SPAWN_RESETIDS` flag.
+   library :c:macro:`POSIX_SPAWN_RESETIDS` flag.
 
    If the *setsid* argument is ``True``, it will create a new session ID
-   for ``posix_spawn``. *setsid* requires :c:data:`POSIX_SPAWN_SETSID`
-   or :c:data:`POSIX_SPAWN_SETSID_NP` flag. Otherwise, :exc:`NotImplementedError`
+   for ``posix_spawn``. *setsid* requires :c:macro:`POSIX_SPAWN_SETSID`
+   or :c:macro:`POSIX_SPAWN_SETSID_NP` flag. Otherwise, :exc:`NotImplementedError`
    is raised.
 
    The *setsigmask* argument will set the signal mask to the signal set
    specified. If the parameter is not used, then the child inherits the
    parent's signal mask. This argument corresponds to the C library
-   :c:data:`POSIX_SPAWN_SETSIGMASK` flag.
+   :c:macro:`POSIX_SPAWN_SETSIGMASK` flag.
 
    The *sigdef* argument will reset the disposition of all signals in the set
    specified. This argument corresponds to the C library
-   :c:data:`POSIX_SPAWN_SETSIGDEF` flag.
+   :c:macro:`POSIX_SPAWN_SETSIGDEF` flag.
 
    The *scheduler* argument must be a tuple containing the (optional) scheduler
    policy and an instance of :class:`sched_param` with the scheduler parameters.
    A value of ``None`` in the place of the scheduler policy indicates that is
    not being provided. This argument is a combination of the C library
-   :c:data:`POSIX_SPAWN_SETSCHEDPARAM` and :c:data:`POSIX_SPAWN_SETSCHEDULER`
+   :c:macro:`POSIX_SPAWN_SETSCHEDPARAM` and :c:macro:`POSIX_SPAWN_SETSCHEDULER`
    flags.
 
    .. audit-event:: os.posix_spawn path,argv,env os.posix_spawn
@@ -4410,11 +4410,11 @@ written in Python, such as a mail server
    :data:`WNOHANG` and :data:`WNOWAIT` are additional optional flags.
 
    The return value is an object representing the data contained in the
-   :c:type:`!siginfo_t` structure with the following attributes:
+   :c:type:`siginfo_t` structure with the following attributes:
 
    * :attr:`!si_pid` (process ID)
    * :attr:`!si_uid` (real user ID of the child)
-   * :attr:`!si_signo` (always :data:`~signal.SIGCHLD`)
+   * :attr:`!si_signo` (always :const:`~signal.SIGCHLD`)
    * :attr:`!si_status` (the exit status or signal number, depending on :attr:`!si_code`)
    * :attr:`!si_code` (see :data:`CLD_EXITED` for possible values)
 
@@ -4652,7 +4652,7 @@ used to determine the disposition of a p
 .. function:: WIFCONTINUED(status)
 
    Return ``True`` if a stopped child has been resumed by delivery of
-   :data:`~signal.SIGCONT` (if the process has been continued from a job
+   :const:`~signal.SIGCONT` (if the process has been continued from a job
    control stop), otherwise return ``False``.
 
    See :data:`WCONTINUED` option.
@@ -5024,7 +5024,7 @@ Random numbers
    ``/dev/urandom`` devices.
 
    The flags argument is a bit mask that can contain zero or more of the
-   following values ORed together: :py:data:`os.GRND_RANDOM` and
+   following values ORed together: :py:const:`os.GRND_RANDOM` and
    :py:data:`GRND_NONBLOCK`.
 
    See also the `Linux getrandom() manual page
--- a/Doc/library/platform.rst
+++ b/Doc/library/platform.rst
@@ -46,7 +46,7 @@ Cross Platform
       universal files containing multiple architectures.
 
       To get at the "64-bitness" of the current interpreter, it is more
-      reliable to query the :attr:`sys.maxsize` attribute::
+      reliable to query the :data:`sys.maxsize` attribute::
 
          is_64bits = sys.maxsize > 2**32
 
--- a/Doc/library/poplib.rst
+++ b/Doc/library/poplib.rst
@@ -81,7 +81,7 @@ The :mod:`poplib` module provides two cl
    .. versionchanged:: 3.4
       The class now supports hostname check with
       :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-      :data:`ssl.HAS_SNI`).
+      :const:`ssl.HAS_SNI`).
 
    .. deprecated:: 3.6
 
@@ -156,7 +156,7 @@ A :class:`POP3` instance has the followi
 .. method:: POP3.pass_(password)
 
    Send password, response includes message count and mailbox size. Note: the
-   mailbox on the server is locked until :meth:`~poplib.quit` is called.
+   mailbox on the server is locked until :meth:`~POP3.quit` is called.
 
 
 .. method:: POP3.apop(user, secret)
@@ -248,7 +248,7 @@ A :class:`POP3` instance has the followi
 
    This method supports hostname checking via
    :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-   :data:`ssl.HAS_SNI`).
+   :const:`ssl.HAS_SNI`).
 
    .. versionadded:: 3.4
 
--- a/Doc/library/pprint.rst
+++ b/Doc/library/pprint.rst
@@ -45,7 +45,7 @@ The :mod:`pprint` module defines one cla
    several keyword parameters.
 
    *stream* (default ``sys.stdout``) is a :term:`file-like object` to
-   which the output will be written by calling its :meth:`write` method.
+   which the output will be written by calling its :meth:`!write` method.
    If both *stream* and ``sys.stdout`` are ``None``, then
    :meth:`~PrettyPrinter.pprint` silently returns.
 
--- a/Doc/library/pty.rst
+++ b/Doc/library/pty.rst
@@ -71,7 +71,7 @@ The :mod:`pty` module defines the follow
 
    Return the exit status value from :func:`os.waitpid` on the child process.
 
-   :func:`waitstatus_to_exitcode` can be used to convert the exit status into
+   :func:`os.waitstatus_to_exitcode` can be used to convert the exit status into
    an exit code.
 
    .. audit-event:: pty.spawn argv pty.spawn
--- a/Doc/library/random.rst
+++ b/Doc/library/random.rst
@@ -141,7 +141,7 @@ Functions for integers
       ``randrange(10)``.  In the future, this will raise a :exc:`TypeError`.
 
    .. deprecated:: 3.10
-      The exception raised for non-integral values such as ``randrange(10.5)``
+      The exception raised for non-integer values such as ``randrange(10.5)``
       or ``randrange('10')`` will be changed from :exc:`ValueError` to
       :exc:`TypeError`.
 
--- a/Doc/library/re.rst
+++ b/Doc/library/re.rst
@@ -500,6 +500,8 @@ The special characters are:
       (``b'\x00'``-``b'\x7f'``) in :class:`bytes` replacement strings.
 
 
+.. _re-special-sequences:
+
 The special sequences consist of ``'\'`` and a character from the list below.
 If the ordinary character is not an ASCII digit or an ASCII letter, then the
 resulting RE will match the second character.  For example, ``\$`` matches the
@@ -778,6 +780,17 @@ Flags
    Corresponds to the inline flag ``(?s)``.
 
 
+.. data:: U
+          UNICODE
+
+   In Python 2, this flag made :ref:`special sequences <re-special-sequences>`
+   include Unicode characters in matches. Since Python 3, Unicode characters
+   are matched by default.
+
+   See :const:`A` for restricting matching on ASCII characters instead.
+
+   This flag is only kept for backward compatibility.
+
 .. data:: X
           VERBOSE
 
@@ -1518,14 +1531,14 @@ Simulating scanf()
 
 .. index:: single: scanf()
 
-Python does not currently have an equivalent to :c:func:`scanf`.  Regular
+Python does not currently have an equivalent to :c:func:`!scanf`.  Regular
 expressions are generally more powerful, though also more verbose, than
-:c:func:`scanf` format strings.  The table below offers some more-or-less
-equivalent mappings between :c:func:`scanf` format tokens and regular
+:c:func:`!scanf` format strings.  The table below offers some more-or-less
+equivalent mappings between :c:func:`!scanf` format tokens and regular
 expressions.
 
 +--------------------------------+---------------------------------------------+
-| :c:func:`scanf` Token          | Regular Expression                          |
+| :c:func:`!scanf` Token         | Regular Expression                          |
 +================================+=============================================+
 | ``%c``                         | ``.``                                       |
 +--------------------------------+---------------------------------------------+
@@ -1550,7 +1563,7 @@ To extract the filename and numbers from
 
    /usr/sbin/sendmail - 0 errors, 4 warnings
 
-you would use a :c:func:`scanf` format like ::
+you would use a :c:func:`!scanf` format like ::
 
    %s - %d errors, %d warnings
 
--- a/Doc/library/runpy.rst
+++ b/Doc/library/runpy.rst
@@ -39,7 +39,7 @@ The :mod:`runpy` module provides two fun
 
    The *mod_name* argument should be an absolute module name.
    If the module name refers to a package rather than a normal
-   module, then that package is imported and the ``__main__`` submodule within
+   module, then that package is imported and the :mod:`__main__` submodule within
    that package is then executed and the resulting module globals dictionary
    returned.
 
@@ -74,7 +74,7 @@ The :mod:`runpy` module provides two fun
 
    Note that this manipulation of :mod:`sys` is not thread-safe. Other threads
    may see the partially initialised module, as well as the altered list of
-   arguments. It is recommended that the :mod:`sys` module be left alone when
+   arguments. It is recommended that the ``sys`` module be left alone when
    invoking this function from threaded code.
 
    .. seealso::
@@ -82,7 +82,7 @@ The :mod:`runpy` module provides two fun
       command line.
 
    .. versionchanged:: 3.1
-      Added ability to execute packages by looking for a ``__main__`` submodule.
+      Added ability to execute packages by looking for a :mod:`__main__` submodule.
 
    .. versionchanged:: 3.2
       Added ``__cached__`` global variable (see :pep:`3147`).
@@ -101,15 +101,16 @@ The :mod:`runpy` module provides two fun
    Execute the code at the named filesystem location and return the resulting
    module globals dictionary. As with a script name supplied to the CPython
    command line, the supplied path may refer to a Python source file, a
-   compiled bytecode file or a valid sys.path entry containing a ``__main__``
-   module (e.g. a zipfile containing a top-level ``__main__.py`` file).
+   compiled bytecode file or a valid :data:`sys.path` entry containing a
+   :mod:`__main__` module
+   (e.g. a zipfile containing a top-level ``__main__.py`` file).
 
    For a simple script, the specified code is simply executed in a fresh
-   module namespace. For a valid sys.path entry (typically a zipfile or
+   module namespace. For a valid :data:`sys.path` entry (typically a zipfile or
    directory), the entry is first added to the beginning of ``sys.path``. The
    function then looks for and executes a :mod:`__main__` module using the
    updated path. Note that there is no special protection against invoking
-   an existing :mod:`__main__` entry located elsewhere on ``sys.path`` if
+   an existing ``__main__`` entry located elsewhere on ``sys.path`` if
    there is no such module at the specified location.
 
    The optional dictionary argument *init_globals* may be used to pre-populate
@@ -132,14 +133,14 @@ The :mod:`runpy` module provides two fun
    supplied path, and ``__spec__``, ``__cached__``, ``__loader__`` and
    ``__package__`` will all be set to :const:`None`.
 
-   If the supplied path is a reference to a valid sys.path entry, then
-   ``__spec__`` will be set appropriately for the imported ``__main__``
+   If the supplied path is a reference to a valid :data:`sys.path` entry, then
+   ``__spec__`` will be set appropriately for the imported :mod:`__main__`
    module (that is, ``__spec__.name`` will always be ``__main__``).
    ``__file__``, ``__cached__``, ``__loader__`` and ``__package__`` will be
    :ref:`set as normal <import-mod-attrs>` based on the module spec.
 
    A number of alterations are also made to the :mod:`sys` module. Firstly,
-   ``sys.path`` may be altered as described above. ``sys.argv[0]`` is updated
+   :data:`sys.path` may be altered as described above. ``sys.argv[0]`` is updated
    with the value of ``path_name`` and ``sys.modules[__name__]`` is updated
    with a temporary module object for the module being executed. All
    modifications to items in :mod:`sys` are reverted before the function
@@ -147,7 +148,7 @@ The :mod:`runpy` module provides two fun
 
    Note that, unlike :func:`run_module`, the alterations made to :mod:`sys`
    are not optional in this function as these adjustments are essential to
-   allowing the execution of sys.path entries. As the thread-safety
+   allowing the execution of :data:`sys.path` entries. As the thread-safety
    limitations still apply, use of this function in threaded code should be
    either serialised with the import lock or delegated to a separate process.
 
@@ -160,7 +161,7 @@ The :mod:`runpy` module provides two fun
    .. versionchanged:: 3.4
       Updated to take advantage of the module spec feature added by
       :pep:`451`. This allows ``__cached__`` to be set correctly in the
-      case where ``__main__`` is imported from a valid sys.path entry rather
+      case where ``__main__`` is imported from a valid :data:`sys.path` entry rather
       than being executed directly.
 
 .. seealso::
--- a/Doc/library/sched.rst
+++ b/Doc/library/sched.rst
@@ -115,7 +115,7 @@ Scheduler Objects
 
 .. method:: scheduler.run(blocking=True)
 
-   Run all scheduled events. This method will wait  (using the :func:`delayfunc`
+   Run all scheduled events. This method will wait  (using the *delayfunc*
    function passed to the constructor) for the next event, then execute it and so
    on until there are no more scheduled events.
 
--- a/Doc/library/select.rst
+++ b/Doc/library/select.rst
@@ -6,10 +6,10 @@
 
 --------------
 
-This module provides access to the :c:func:`select` and :c:func:`poll` functions
-available in most operating systems, :c:func:`devpoll` available on
-Solaris and derivatives, :c:func:`epoll` available on Linux 2.5+ and
-:c:func:`kqueue` available on most BSD.
+This module provides access to the :c:func:`!select` and :c:func:`!poll` functions
+available in most operating systems, :c:func:`!devpoll` available on
+Solaris and derivatives, :c:func:`!epoll` available on Linux 2.5+ and
+:c:func:`!kqueue` available on most BSD.
 Note that on Windows, it only works for sockets; on other operating systems,
 it also works for other file types (in particular, on Unix, it works on pipes).
 It cannot be used on regular files to determine whether a file has grown since
@@ -41,10 +41,10 @@ The module defines the following:
    polling object; see section :ref:`devpoll-objects` below for the
    methods supported by devpoll objects.
 
-   :c:func:`devpoll` objects are linked to the number of file
+   :c:func:`!devpoll` objects are linked to the number of file
    descriptors allowed at the time of instantiation. If your program
-   reduces this value, :c:func:`devpoll` will fail. If your program
-   increases this value, :c:func:`devpoll` may return an
+   reduces this value, :c:func:`!devpoll` will fail. If your program
+   increases this value, :c:func:`!devpoll` may return an
    incomplete list of active file descriptors.
 
    The new file descriptor is :ref:`non-inheritable <fd_inheritance>`.
@@ -62,7 +62,7 @@ The module defines the following:
 
    *sizehint* informs epoll about the expected number of events to be
    registered.  It must be positive, or ``-1`` to use the default. It is only
-   used on older systems where :c:func:`epoll_create1` is not available;
+   used on older systems where :c:func:`!epoll_create1` is not available;
    otherwise it has no effect (though its value is still checked).
 
    *flags* is deprecated and completely ignored.  However, when supplied, its
@@ -117,7 +117,7 @@ The module defines the following:
 
 .. function:: select(rlist, wlist, xlist[, timeout])
 
-   This is a straightforward interface to the Unix :c:func:`select` system call.
+   This is a straightforward interface to the Unix :c:func:`!select` system call.
    The first three arguments are iterables of 'waitable objects': either
    integers representing file descriptors or objects with a parameterless method
    named :meth:`~io.IOBase.fileno` returning such an integer:
@@ -154,7 +154,7 @@ The module defines the following:
       .. index:: single: WinSock
 
       File objects on Windows are not acceptable, but sockets are.  On Windows,
-      the underlying :c:func:`select` function is provided by the WinSock
+      the underlying :c:func:`!select` function is provided by the WinSock
       library, and does not handle file descriptors that don't originate from
       WinSock.
 
@@ -169,7 +169,7 @@ The module defines the following:
 
    The minimum number of bytes which can be written without blocking to a pipe
    when the pipe has been reported as ready for writing by :func:`~select.select`,
-   :func:`poll` or another interface in this module.  This doesn't apply
+   :func:`!poll` or another interface in this module.  This doesn't apply
    to other kind of file-like objects such as sockets.
 
    This value is guaranteed by POSIX to be at least 512.
@@ -184,11 +184,11 @@ The module defines the following:
 ``/dev/poll`` Polling Objects
 -----------------------------
 
-Solaris and derivatives have ``/dev/poll``. While :c:func:`select` is
-O(highest file descriptor) and :c:func:`poll` is O(number of file
+Solaris and derivatives have ``/dev/poll``. While :c:func:`!select` is
+O(highest file descriptor) and :c:func:`!poll` is O(number of file
 descriptors), ``/dev/poll`` is O(active file descriptors).
 
-``/dev/poll`` behaviour is very close to the standard :c:func:`poll`
+``/dev/poll`` behaviour is very close to the standard :c:func:`!poll`
 object.
 
 
@@ -222,7 +222,7 @@ object.
    implement :meth:`!fileno`, so they can also be used as the argument.
 
    *eventmask* is an optional bitmask describing the type of events you want to
-   check for. The constants are the same that with :c:func:`poll`
+   check for. The constants are the same that with :c:func:`!poll`
    object. The default value is a combination of the constants :const:`POLLIN`,
    :const:`POLLPRI`, and :const:`POLLOUT`.
 
@@ -231,7 +231,7 @@ object.
       Registering a file descriptor that's already registered is not an
       error, but the result is undefined. The appropriate action is to
       unregister or modify it first. This is an important difference
-      compared with :c:func:`poll`.
+      compared with :c:func:`!poll`.
 
 
 .. method:: devpoll.modify(fd[, eventmask])
@@ -376,13 +376,13 @@ Edge and Level Trigger Polling (epoll) O
 Polling Objects
 ---------------
 
-The :c:func:`poll` system call, supported on most Unix systems, provides better
+The :c:func:`!poll` system call, supported on most Unix systems, provides better
 scalability for network servers that service many, many clients at the same
-time. :c:func:`poll` scales better because the system call only requires listing
-the file descriptors of interest, while :c:func:`select` builds a bitmap, turns
+time. :c:func:`!poll` scales better because the system call only requires listing
+the file descriptors of interest, while :c:func:`!select` builds a bitmap, turns
 on bits for the fds of interest, and then afterward the whole bitmap has to be
-linearly scanned again. :c:func:`select` is O(highest file descriptor), while
-:c:func:`poll` is O(number of file descriptors).
+linearly scanned again. :c:func:`!select` is O(highest file descriptor), while
+:c:func:`!poll` is O(number of file descriptors).
 
 
 .. method:: poll.register(fd[, eventmask])
--- a/Doc/library/selectors.rst
+++ b/Doc/library/selectors.rst
@@ -60,9 +60,9 @@ constants below:
    +-----------------------+-----------------------------------------------+
    | Constant              | Meaning                                       |
    +=======================+===============================================+
-   | :const:`EVENT_READ`   | Available for read                            |
+   | .. data:: EVENT_READ  | Available for read                            |
    +-----------------------+-----------------------------------------------+
-   | :const:`EVENT_WRITE`  | Available for write                           |
+   | .. data:: EVENT_WRITE | Available for write                           |
    +-----------------------+-----------------------------------------------+
 
 
@@ -132,8 +132,8 @@ constants below:
 
       Change a registered file object's monitored events or attached data.
 
-      This is equivalent to :meth:`BaseSelector.unregister(fileobj)` followed
-      by :meth:`BaseSelector.register(fileobj, events, data)`, except that it
+      This is equivalent to ``BaseSelector.unregister(fileobj)`` followed
+      by ``BaseSelector.register(fileobj, events, data)``, except that it
       can be implemented more efficiently.
 
       This returns a new :class:`SelectorKey` instance, or raises a
--- a/Doc/library/shelve.rst
+++ b/Doc/library/shelve.rst
@@ -25,7 +25,7 @@ lots of shared  sub-objects.  The keys a
    database file is opened for reading and writing.  The optional *flag* parameter
    has the same interpretation as the *flag* parameter of :func:`dbm.open`.
 
-   By default, pickles created with :data:`pickle.DEFAULT_PROTOCOL` are used
+   By default, pickles created with :const:`pickle.DEFAULT_PROTOCOL` are used
    to serialize values.  The version of the pickle protocol can be specified
    with the *protocol* parameter.
 
@@ -42,7 +42,7 @@ lots of shared  sub-objects.  The keys a
    mutated).
 
    .. versionchanged:: 3.10
-      :data:`pickle.DEFAULT_PROTOCOL` is now used as the default pickle
+      :const:`pickle.DEFAULT_PROTOCOL` is now used as the default pickle
       protocol.
 
    .. versionchanged:: 3.11
@@ -119,7 +119,7 @@ Restrictions
    A subclass of :class:`collections.abc.MutableMapping` which stores pickled
    values in the *dict* object.
 
-   By default, pickles created with :data:`pickle.DEFAULT_PROTOCOL` are used
+   By default, pickles created with :const:`pickle.DEFAULT_PROTOCOL` are used
    to serialize values.  The version of the pickle protocol can be specified
    with the *protocol* parameter.  See the :mod:`pickle` documentation for a
    discussion of the pickle protocols.
@@ -143,7 +143,7 @@ Restrictions
       Added context manager support.
 
    .. versionchanged:: 3.10
-      :data:`pickle.DEFAULT_PROTOCOL` is now used as the default pickle
+      :const:`pickle.DEFAULT_PROTOCOL` is now used as the default pickle
       protocol.
 
 
--- a/Doc/library/shutil.rst
+++ b/Doc/library/shutil.rst
@@ -363,7 +363,7 @@ Directory and files operations
    If *copy_function* is given, it must be a callable that takes two arguments
    *src* and *dst*, and will be used to copy *src* to *dst* if
    :func:`os.rename` cannot be used.  If the source is a directory,
-   :func:`copytree` is called, passing it the :func:`copy_function`. The
+   :func:`copytree` is called, passing it the *copy_function*. The
    default *copy_function* is :func:`copy2`.  Using :func:`~shutil.copy` as the
    *copy_function* allows the move to succeed when it is not possible to also
    copy the metadata, at the expense of not copying any of the metadata.
@@ -393,6 +393,12 @@ Directory and files operations
    total, used and free space, in bytes. *path* may be a file or a
    directory.
 
+   .. note::
+
+      On Unix filesystems, *path* must point to a path within a **mounted**
+      filesystem partition. On those platforms, CPython doesn't attempt to
+      retrieve disk usage information from non-mounted filesystems.
+
    .. versionadded:: 3.3
 
    .. versionchanged:: 3.8
@@ -425,7 +431,7 @@ Directory and files operations
    determining if the file exists and executable.
 
    When no *path* is specified, the results of :func:`os.environ` are used,
-   returning either the "PATH" value or a fallback of :attr:`os.defpath`.
+   returning either the "PATH" value or a fallback of :data:`os.defpath`.
 
    On Windows, the current directory is always prepended to the *path* whether
    or not you use the default or provide your own, which is the behavior the
--- a/Doc/library/signal.rst
+++ b/Doc/library/signal.rst
@@ -562,7 +562,7 @@ The :mod:`signal` module defines the fol
 
    Note that installing a signal handler with :func:`signal` will reset the
    restart behaviour to interruptible by implicitly calling
-   :c:func:`siginterrupt` with a true *flag* value for the given signal.
+   :c:func:`!siginterrupt` with a true *flag* value for the given signal.
 
 
 .. function:: signal(signalnum, handler)
@@ -656,7 +656,7 @@ The :mod:`signal` module defines the fol
 .. function:: sigtimedwait(sigset, timeout)
 
    Like :func:`sigwaitinfo`, but takes an additional *timeout* argument
-   specifying a timeout. If *timeout* is specified as :const:`0`, a poll is
+   specifying a timeout. If *timeout* is specified as ``0``, a poll is
    performed. Returns :const:`None` if a timeout occurs.
 
    .. availability:: Unix.
--- a/Doc/library/smtplib.rst
+++ b/Doc/library/smtplib.rst
@@ -103,7 +103,7 @@ Protocol) and :rfc:`1869` (SMTP Service
    .. versionchanged:: 3.4
       The class now supports hostname check with
       :attr:`ssl.SSLContext.check_hostname` and *Server Name Indication* (see
-      :data:`ssl.HAS_SNI`).
+      :const:`ssl.HAS_SNI`).
 
    .. deprecated:: 3.6
 
@@ -431,7 +431,7 @@ An :class:`SMTP` instance has the follow
    .. versionchanged:: 3.4
       The method now supports hostname check with
       :attr:`SSLContext.check_hostname` and *Server Name Indicator* (see
-      :data:`~ssl.HAS_SNI`).
+      :const:`~ssl.HAS_SNI`).
 
    .. versionchanged:: 3.5
       The error raised for lack of STARTTLS support is now the
--- a/Doc/library/socket.rst
+++ b/Doc/library/socket.rst
@@ -2153,7 +2153,7 @@ This is because the previous execution h
 state, and can't be immediately reused.
 
 There is a :mod:`socket` flag to set, in order to prevent this,
-:data:`socket.SO_REUSEADDR`::
+:const:`socket.SO_REUSEADDR`::
 
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
--- a/Doc/library/sqlite3.rst
+++ b/Doc/library/sqlite3.rst
@@ -265,8 +265,9 @@ Module functions
 
    :param database:
        The path to the database file to be opened.
-       Pass ``":memory:"`` to open a connection to a database that is
-       in RAM instead of on disk.
+       You can pass ``":memory:"`` to create an `SQLite database existing only
+       in memory <https://sqlite.org/inmemorydb.html>`_, and open a connection
+       to it.
    :type database: :term:`path-like object`
 
    :param float timeout:
@@ -394,15 +395,15 @@ Module functions
 
 .. function:: register_adapter(type, adapter, /)
 
-   Register an *adapter* callable to adapt the Python type *type* into an
-   SQLite type.
+   Register an *adapter* :term:`callable` to adapt the Python type *type*
+   into an SQLite type.
    The adapter is called with a Python object of type *type* as its sole
    argument, and must return a value of a
    :ref:`type that SQLite natively understands <sqlite3-types>`.
 
 .. function:: register_converter(typename, converter, /)
 
-   Register the *converter* callable to convert SQLite objects of type
+   Register the *converter* :term:`callable` to convert SQLite objects of type
    *typename* into a Python object of a specific type.
    The converter is invoked for all SQLite values of type *typename*;
    it is passed a :class:`bytes` object and should return an object of the
@@ -459,7 +460,7 @@ Module constants
           SQLITE_DENY
           SQLITE_IGNORE
 
-   Flags that should be returned by the *authorizer_callback* callable
+   Flags that should be returned by the *authorizer_callback* :term:`callable`
    passed to :meth:`Connection.set_authorizer`, to indicate whether:
 
    * Access is allowed (:const:`!SQLITE_OK`),
@@ -562,8 +563,8 @@ Connection objects
 
       Create and return a :class:`Cursor` object.
       The cursor method accepts a single optional parameter *factory*. If
-      supplied, this must be a callable returning an instance of :class:`Cursor`
-      or its subclasses.
+      supplied, this must be a :term:`callable` returning
+      an instance of :class:`Cursor` or its subclasses.
 
    .. method:: blobopen(table, column, row, /, *, readonly=False, name="main")
 
@@ -647,7 +648,7 @@ Connection objects
           If ``-1``, it may take any number of arguments.
 
       :param func:
-          A callable that is called when the SQL function is invoked.
+          A :term:`callable` that is called when the SQL function is invoked.
           The callable must return :ref:`a type natively supported by SQLite
           <sqlite3-types>`.
           Set to ``None`` to remove an existing SQL function.
@@ -872,9 +873,10 @@ Connection objects
 
    .. method:: set_authorizer(authorizer_callback)
 
-      Register callable *authorizer_callback* to be invoked for each attempt to
-      access a column of a table in the database. The callback should return
-      one of :const:`SQLITE_OK`, :const:`SQLITE_DENY`, or :const:`SQLITE_IGNORE`
+      Register :term:`callable` *authorizer_callback* to be invoked
+      for each attempt to access a column of a table in the database.
+      The callback should return one of :const:`SQLITE_OK`,
+      :const:`SQLITE_DENY`, or :const:`SQLITE_IGNORE`
       to signal how access to the column should be handled
       by the underlying SQLite library.
 
@@ -897,7 +899,7 @@ Connection objects
 
    .. method:: set_progress_handler(progress_handler, n)
 
-      Register callable *progress_handler* to be invoked for every *n*
+      Register :term:`callable` *progress_handler* to be invoked for every *n*
       instructions of the SQLite virtual machine. This is useful if you want to
       get called from SQLite during long-running operations, for example to update
       a GUI.
@@ -912,8 +914,8 @@ Connection objects
 
    .. method:: set_trace_callback(trace_callback)
 
-      Register callable *trace_callback* to be invoked for each SQL statement
-      that is actually executed by the SQLite backend.
+      Register :term:`callable` *trace_callback* to be invoked
+      for each SQL statement that is actually executed by the SQLite backend.
 
       The only argument passed to the callback is the statement (as
       :class:`str`) that is being executed. The return value of the callback is
@@ -1045,8 +1047,8 @@ Connection objects
           Defaults to ``-1``.
 
       :param progress:
-          If set to a callable, it is invoked with three integer arguments for
-          every backup iteration:
+          If set to a :term:`callable`,
+          it is invoked with three integer arguments for every backup iteration:
           the *status* of the last iteration,
           the *remaining* number of pages still to be copied,
           and the *total* number of pages.
@@ -1247,8 +1249,8 @@ Connection objects
 
    .. attribute:: text_factory
 
-      A callable that accepts a :class:`bytes` parameter and returns a text
-      representation of it.
+      A :term:`callable` that accepts a :class:`bytes` parameter
+      and returns a text representation of it.
       The callable is invoked for SQLite values with the ``TEXT`` data type.
       By default, this attribute is set to :class:`str`.
       If you want to return ``bytes`` instead, set *text_factory* to ``bytes``.
@@ -1641,9 +1643,9 @@ Blob objects
    .. method:: seek(offset, origin=os.SEEK_SET, /)
 
       Set the current access position of the blob to *offset*.  The *origin*
-      argument defaults to :data:`os.SEEK_SET` (absolute blob positioning).
-      Other values for *origin* are :data:`os.SEEK_CUR` (seek relative to the
-      current position) and :data:`os.SEEK_END` (seek relative to the blobs
+      argument defaults to :const:`os.SEEK_SET` (absolute blob positioning).
+      Other values for *origin* are :const:`os.SEEK_CUR` (seek relative to the
+      current position) and :const:`os.SEEK_END` (seek relative to the blobs
       end).
 
 
@@ -2310,6 +2312,13 @@ Queries now return :class:`!Row` objects
    >>> row["RADIUS"]  # Column names are case-insensitive.
    6378
 
+.. note::
+
+    The ``FROM`` clause can be omitted in the ``SELECT`` statement, as in the
+    above example. In such cases, SQLite returns a single row with columns
+    defined by expressions, e.g. literals, with the given aliases
+    ``expr AS alias``.
+
 You can create a custom :attr:`~Cursor.row_factory`
 that returns each row as a :class:`dict`, with column names mapped to values:
 
--- a/Doc/library/ssl.rst
+++ b/Doc/library/ssl.rst
@@ -142,7 +142,7 @@ purposes.
    The settings are: :data:`PROTOCOL_TLS_CLIENT` or
    :data:`PROTOCOL_TLS_SERVER`, :data:`OP_NO_SSLv2`, and :data:`OP_NO_SSLv3`
    with high encryption cipher suites without RC4 and
-   without unauthenticated cipher suites. Passing :data:`~Purpose.SERVER_AUTH`
+   without unauthenticated cipher suites. Passing :const:`~Purpose.SERVER_AUTH`
    as *purpose* sets :data:`~SSLContext.verify_mode` to :data:`CERT_REQUIRED`
    and either loads CA certificates (when at least one of *cafile*, *capath* or
    *cadata* is given) or uses :meth:`SSLContext.load_default_certs` to load
@@ -344,7 +344,7 @@ Random generation
 
    Mix the given *bytes* into the SSL pseudo-random number generator.  The
    parameter *entropy* (a float) is a lower bound on the entropy contained in
-   string (so you can always use :const:`0.0`).  See :rfc:`1750` for more
+   string (so you can always use ``0.0``).  See :rfc:`1750` for more
    information on sources of entropy.
 
    .. versionchanged:: 3.5
@@ -1579,9 +1579,9 @@ to speed up repeated connections from th
    load CA certificates from other locations, too.
 
    The *purpose* flag specifies what kind of CA certificates are loaded. The
-   default settings :data:`Purpose.SERVER_AUTH` loads certificates, that are
+   default settings :const:`Purpose.SERVER_AUTH` loads certificates, that are
    flagged and trusted for TLS web server authentication (client side
-   sockets). :data:`Purpose.CLIENT_AUTH` loads CA certificates for client
+   sockets). :const:`Purpose.CLIENT_AUTH` loads CA certificates for client
    certificate verification on the server side.
 
    .. versionadded:: 3.4
@@ -1824,7 +1824,7 @@ to speed up repeated connections from th
    Wrap an existing Python socket *sock* and return an instance of
    :attr:`SSLContext.sslsocket_class` (default :class:`SSLSocket`). The
    returned SSL socket is tied to the context, its settings and certificates.
-   *sock* must be a :data:`~socket.SOCK_STREAM` socket; other
+   *sock* must be a :const:`~socket.SOCK_STREAM` socket; other
    socket types are unsupported.
 
    The parameter ``server_side`` is a boolean which identifies whether
@@ -2688,7 +2688,7 @@ disabled by default.
    >>> client_context.maximum_version = ssl.TLSVersion.TLSv1_3
 
 
-The SSL context created above will only allow TLSv1.2 and later (if
+The SSL context created above will only allow TLSv1.3 and later (if
 supported by your system) connections to a server. :const:`PROTOCOL_TLS_CLIENT`
 implies certificate validation and hostname checks by default. You have to
 load certificates into the context.
--- a/Doc/library/stat.rst
+++ b/Doc/library/stat.rst
@@ -13,8 +13,8 @@
 
 The :mod:`stat` module defines constants and functions for interpreting the
 results of :func:`os.stat`, :func:`os.fstat` and :func:`os.lstat` (if they
-exist).  For complete details about the :c:func:`stat`, :c:func:`fstat` and
-:c:func:`lstat` calls, consult the documentation for your system.
+exist).  For complete details about the :c:func:`stat`, :c:func:`!fstat` and
+:c:func:`!lstat` calls, consult the documentation for your system.
 
 .. versionchanged:: 3.4
    The stat module is backed by a C implementation.
@@ -89,9 +89,9 @@ mode:
 .. function:: S_IFMT(mode)
 
    Return the portion of the file's mode that describes the file type (used by the
-   :func:`S_IS\*` functions above).
+   :func:`!S_IS\*` functions above).
 
-Normally, you would use the :func:`os.path.is\*` functions for testing the type
+Normally, you would use the :func:`!os.path.is\*` functions for testing the type
 of a file; the functions here are useful when you are doing multiple tests of
 the same file and wish to avoid the overhead of the :c:func:`stat` system call
 for each test.  These are also useful when checking for information about a file
--- a/Doc/library/stdtypes.rst
+++ b/Doc/library/stdtypes.rst
@@ -44,7 +44,7 @@ Any object can be tested for truth value
 .. index:: single: true
 
 By default, an object is considered true unless its class defines either a
-:meth:`__bool__` method that returns ``False`` or a :meth:`__len__` method that
+:meth:`~object.__bool__` method that returns ``False`` or a :meth:`__len__` method that
 returns zero, when called with the object. [1]_  Here are most of the built-in
 objects considered false:
 
@@ -52,7 +52,7 @@ objects considered false:
      single: None (Built-in object)
      single: False (Built-in object)
 
-* constants defined to be false: ``None`` and ``False``.
+* constants defined to be false: ``None`` and ``False``
 
 * zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``,
   ``Fraction(0, 1)``
@@ -3903,7 +3903,7 @@ copying.
          >>> m = memoryview(bytearray(b'abc'))
          >>> mm = m.toreadonly()
          >>> mm.tolist()
-         [89, 98, 99]
+         [97, 98, 99]
          >>> mm[0] = 42
          Traceback (most recent call last):
            File "<stdin>", line 1, in <module>
@@ -3959,6 +3959,7 @@ copying.
       :mod:`struct` syntax. One of the formats must be a byte format
       ('B', 'b' or 'c'). The byte length of the result must be the same
       as the original length.
+      Note that all byte lengths may depend on the operating system.
 
       Cast 1D/long to 1D/unsigned bytes::
 
@@ -3989,8 +3990,8 @@ copying.
          >>> x = memoryview(b)
          >>> x[0] = b'a'
          Traceback (most recent call last):
-           File "<stdin>", line 1, in <module>
-         ValueError: memoryview: invalid value for format "B"
+           ...
+         TypeError: memoryview: invalid type for format 'B'
          >>> y = x.cast('c')
          >>> y[0] = b'a'
          >>> b
@@ -4735,8 +4736,10 @@ An example of dictionary view usage::
    >>> # set operations
    >>> keys & {'eggs', 'bacon', 'salad'}
    {'bacon'}
-   >>> keys ^ {'sausage', 'juice'}
-   {'juice', 'sausage', 'bacon', 'spam'}
+   >>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}
+   True
+   >>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}
+   True
 
    >>> # get back a read-only proxy for the original dictionary
    >>> values.mapping
@@ -4943,8 +4946,8 @@ exception to disallow mistakes like ``di
 
    >>> dict[str][str]
    Traceback (most recent call last):
-     File "<stdin>", line 1, in <module>
-   TypeError: There are no type variables left in dict[str]
+     ...
+   TypeError: dict[str] is not a generic class
 
 However, such expressions are valid when :ref:`type variables <generics>` are
 used.  The index must have as many elements as there are type variable items
@@ -5109,6 +5112,14 @@ enables cleaner type hinting syntax comp
       def square(number: int | float) -> int | float:
           return number ** 2
 
+   .. note::
+
+      The ``|`` operand cannot be used at runtime to define unions where one or
+      more members is a forward reference. For example, ``int | "Foo"``, where
+      ``"Foo"`` is a reference to a class not yet defined, will fail at
+      runtime. For unions which include forward references, present the
+      whole expression as a string, e.g. ``"int | Foo"``.
+
 .. describe:: union_object == other
 
    Union objects can be tested for equality with other union objects.  Details:
@@ -5142,13 +5153,15 @@ enables cleaner type hinting syntax comp
       >>> isinstance("", int | str)
       True
 
-   However, union objects containing :ref:`parameterized generics
-   <types-genericalias>` cannot be used::
+   However, :ref:`parameterized generics <types-genericalias>` in
+   union objects cannot be checked::
 
-      >>> isinstance(1, int | list[int])
+      >>> isinstance(1, int | list[int])  # short-circuit evaluation
+      True
+      >>> isinstance([1], int | list[int])
       Traceback (most recent call last):
-        File "<stdin>", line 1, in <module>
-      TypeError: isinstance() argument 2 cannot contain a parameterized generic
+        ...
+      TypeError: isinstance() argument 2 cannot be a parameterized generic
 
 The user-exposed type for the union object can be accessed from
 :data:`types.UnionType` and used for :func:`isinstance` checks.  An object cannot be
@@ -5464,7 +5477,7 @@ types, where they are relevant.  Some of
    definition order.  Example::
 
       >>> int.__subclasses__()
-      [<class 'bool'>]
+      [<class 'bool'>, <enum 'IntEnum'>, <flag 'IntFlag'>, <class 're._constants._NamedIntConstant'>]
 
 
 .. _int_max_str_digits:
@@ -5500,7 +5513,7 @@ When an operation would exceed the limit
    >>> _ = int('2' * 5432)
    Traceback (most recent call last):
    ...
-   ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit.
+   ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit
    >>> i = int('2' * 4300)
    >>> len(str(i))
    4300
@@ -5508,7 +5521,7 @@ When an operation would exceed the limit
    >>> len(str(i_squared))
    Traceback (most recent call last):
    ...
-   ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 8599 digits; use sys.set_int_max_str_digits() to increase the limit.
+   ValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit
    >>> len(hex(i_squared))
    7144
    >>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited.
@@ -5578,7 +5591,7 @@ From code, you can inspect the current l
   a getter and setter for the interpreter-wide limit. Subinterpreters have
   their own limit.
 
-Information about the default and minimum can be found in :attr:`sys.int_info`:
+Information about the default and minimum can be found in :data:`sys.int_info`:
 
 * :data:`sys.int_info.default_max_str_digits <sys.int_info>` is the compiled-in
   default limit.
--- a/Doc/library/string.rst
+++ b/Doc/library/string.rst
@@ -227,7 +227,9 @@ See also the :ref:`formatspec` section.
 
 The *field_name* itself begins with an *arg_name* that is either a number or a
 keyword.  If it's a number, it refers to a positional argument, and if it's a keyword,
-it refers to a named keyword argument.  If the numerical arg_names in a format string
+it refers to a named keyword argument. An *arg_name* is treated as a number if
+a call to :meth:`str.isdecimal` on the string would return true.
+If the numerical arg_names in a format string
 are 0, 1, 2, ... in sequence, they can all be omitted (not just some)
 and the numbers 0, 1, 2, ... will be automatically inserted in that order.
 Because *arg_name* is not quote-delimited, it is not possible to specify arbitrary
--- a/Doc/library/struct.rst
+++ b/Doc/library/struct.rst
@@ -231,9 +231,9 @@ platform-dependent.
 | ``Q``  | :c:expr:`unsigned long   | integer            | 8              | \(2)       |
 |        | long`                    |                    |                |            |
 +--------+--------------------------+--------------------+----------------+------------+
-| ``n``  | :c:expr:`ssize_t`        | integer            |                | \(3)       |
+| ``n``  | :c:type:`ssize_t`        | integer            |                | \(3)       |
 +--------+--------------------------+--------------------+----------------+------------+
-| ``N``  | :c:expr:`size_t`         | integer            |                | \(3)       |
+| ``N``  | :c:type:`size_t`         | integer            |                | \(3)       |
 +--------+--------------------------+--------------------+----------------+------------+
 | ``e``  | \(6)                     | float              | 2              | \(4)       |
 +--------+--------------------------+--------------------+----------------+------------+
@@ -266,11 +266,11 @@ Notes:
 
 (2)
    When attempting to pack a non-integer using any of the integer conversion
-   codes, if the non-integer has a :meth:`__index__` method then that method is
+   codes, if the non-integer has a :meth:`~object.__index__` method then that method is
    called to convert the argument to an integer before packing.
 
    .. versionchanged:: 3.2
-      Added use of the :meth:`__index__` method for non-integers.
+      Added use of the :meth:`~object.__index__` method for non-integers.
 
 (3)
    The ``'n'`` and ``'N'`` conversion codes are only available for the native
--- a/Doc/library/subprocess.rst
+++ b/Doc/library/subprocess.rst
@@ -463,9 +463,9 @@ functions.
    :func:`open` function when creating the stdin/stdout/stderr pipe
    file objects:
 
-   - :const:`0` means unbuffered (read and write are one
+   - ``0`` means unbuffered (read and write are one
      system call and can return short)
-   - :const:`1` means line buffered
+   - ``1`` means line buffered
      (only usable if ``text=True`` or ``universal_newlines=True``)
    - any other positive value means use a buffer of approximately that
      size
@@ -475,7 +475,7 @@ functions.
    .. versionchanged:: 3.3.1
       *bufsize* now defaults to -1 to enable buffering by default to match the
       behavior that most code expects.  In versions prior to Python 3.2.4 and
-      3.3.1 it incorrectly defaulted to :const:`0` which was unbuffered
+      3.3.1 it incorrectly defaulted to ``0`` which was unbuffered
       and allowed short reads.  This was unintentional and did not match the
       behavior of Python 2 as most code expected.
 
@@ -540,8 +540,8 @@ functions.
       :exc:`RuntimeError`. The new restriction may affect applications that
       are deployed in mod_wsgi, uWSGI, and other embedded environments.
 
-   If *close_fds* is true, all file descriptors except :const:`0`, :const:`1` and
-   :const:`2` will be closed before the child process is executed.  Otherwise
+   If *close_fds* is true, all file descriptors except ``0``, ``1`` and
+   ``2`` will be closed before the child process is executed.  Otherwise
    when *close_fds* is false, file descriptors obey their inheritable flag
    as described in :ref:`fd_inheritance`.
 
@@ -1609,7 +1609,7 @@ improves performance.
 
 If you ever encounter a presumed highly unusual situation where you need to
 prevent ``vfork()`` from being used by Python, you can set the
-:attr:`subprocess._USE_VFORK` attribute to a false value.
+:const:`subprocess._USE_VFORK` attribute to a false value.
 
 ::
 
@@ -1617,7 +1617,7 @@ prevent ``vfork()`` from being used by P
 
 Setting this has no impact on use of ``posix_spawn()`` which could use
 ``vfork()`` internally within its libc implementation.  There is a similar
-:attr:`subprocess._USE_POSIX_SPAWN` attribute if you need to prevent use of
+:const:`subprocess._USE_POSIX_SPAWN` attribute if you need to prevent use of
 that.
 
 ::
--- a/Doc/library/sys.rst
+++ b/Doc/library/sys.rst
@@ -166,7 +166,7 @@ always available.
    Python interpreter.  (This information is not available in any other way ---
    ``modules.keys()`` only lists the imported modules.)
 
-   See also the :attr:`sys.stdlib_module_names` list.
+   See also the :data:`sys.stdlib_module_names` list.
 
 
 .. function:: call_tracing(func, args)
@@ -511,27 +511,28 @@ always available.
    The :term:`named tuple` *flags* exposes the status of command line
    flags. The attributes are read only.
 
-   ============================= ==============================================================================================================
-   attribute                     flag
-   ============================= ==============================================================================================================
-   :const:`debug`                :option:`-d`
-   :const:`inspect`              :option:`-i`
-   :const:`interactive`          :option:`-i`
-   :const:`isolated`             :option:`-I`
-   :const:`optimize`             :option:`-O` or :option:`-OO`
-   :const:`dont_write_bytecode`  :option:`-B`
-   :const:`no_user_site`         :option:`-s`
-   :const:`no_site`              :option:`-S`
-   :const:`ignore_environment`   :option:`-E`
-   :const:`verbose`              :option:`-v`
-   :const:`bytes_warning`        :option:`-b`
-   :const:`quiet`                :option:`-q`
-   :const:`hash_randomization`   :option:`-R`
-   :const:`dev_mode`             :option:`-X dev <-X>` (:ref:`Python Development Mode <devmode>`)
-   :const:`utf8_mode`            :option:`-X utf8 <-X>`
-   :const:`safe_path`            :option:`-P`
-   :const:`int_max_str_digits`   :option:`-X int_max_str_digits <-X>` (:ref:`integer string conversion length limitation <int_max_str_digits>`)
-   ============================= ==============================================================================================================
+   ==============================  ==============================================================================================================
+   attribute                       flag
+   ==============================  ==============================================================================================================
+   :const:`debug`                  :option:`-d`
+   :const:`inspect`                :option:`-i`
+   :const:`interactive`            :option:`-i`
+   :const:`isolated`               :option:`-I`
+   :const:`optimize`               :option:`-O` or :option:`-OO`
+   :const:`dont_write_bytecode`    :option:`-B`
+   :const:`no_user_site`           :option:`-s`
+   :const:`no_site`                :option:`-S`
+   :const:`ignore_environment`     :option:`-E`
+   :const:`verbose`                :option:`-v`
+   :const:`bytes_warning`          :option:`-b`
+   :const:`quiet`                  :option:`-q`
+   :const:`hash_randomization`     :option:`-R`
+   :const:`dev_mode`               :option:`-X dev <-X>` (:ref:`Python Development Mode <devmode>`)
+   :const:`utf8_mode`              :option:`-X utf8 <-X>`
+   :const:`safe_path`              :option:`-P`
+   :const:`int_max_str_digits`     :option:`-X int_max_str_digits <-X>` (:ref:`integer string conversion length limitation <int_max_str_digits>`)
+   :const:`warn_default_encoding`  :option:`-X warn_default_encoding <-X>`
+   ==============================  ==============================================================================================================
 
    .. versionchanged:: 3.2
       Added ``quiet`` attribute for the new :option:`-q` flag.
@@ -550,6 +551,9 @@ always available.
       Mode <devmode>` and the ``utf8_mode`` attribute for the new  :option:`-X`
       ``utf8`` flag.
 
+   .. versionchanged:: 3.10
+      Added ``warn_default_encoding`` attribute for :option:`-X` ``warn_default_encoding`` flag.
+
    .. versionchanged:: 3.11
       Added the ``safe_path`` attribute for :option:`-P` option.
 
@@ -686,7 +690,7 @@ always available.
    Return the current value of the flags that are used for
    :c:func:`dlopen` calls.  Symbolic names for the flag values can be
    found in the :mod:`os` module (``RTLD_xxx`` constants, e.g.
-   :data:`os.RTLD_LAZY`).
+   :const:`os.RTLD_LAZY`).
 
    .. availability:: Unix.
 
@@ -755,6 +759,9 @@ always available.
    higher than you might expect, because it includes the (temporary) reference as
    an argument to :func:`getrefcount`.
 
+   Note that the returned value may not actually reflect how many
+   references to the object are actually held.  Consequently, do not rely
+   on the returned value to be accurate, other than a value of 0 or 1.
 
 .. function:: getrecursionlimit()
 
@@ -846,19 +853,19 @@ always available.
    ``sys.getwindowsversion().major``. For compatibility with prior
    versions, only the first 5 elements are retrievable by indexing.
 
-   *platform* will be :const:`2 (VER_PLATFORM_WIN32_NT)`.
+   *platform* will be ``2`` (VER_PLATFORM_WIN32_NT).
 
    *product_type* may be one of the following values:
 
    +---------------------------------------+---------------------------------+
    | Constant                              | Meaning                         |
    +=======================================+=================================+
-   | :const:`1 (VER_NT_WORKSTATION)`       | The system is a workstation.    |
+   | ``1`` (VER_NT_WORKSTATION)            | The system is a workstation.    |
    +---------------------------------------+---------------------------------+
-   | :const:`2 (VER_NT_DOMAIN_CONTROLLER)` | The system is a domain          |
+   | ``2`` (VER_NT_DOMAIN_CONTROLLER)      | The system is a domain          |
    |                                       | controller.                     |
    +---------------------------------------+---------------------------------+
-   | :const:`3 (VER_NT_SERVER)`            | The system is a server, but not |
+   | ``3`` (VER_NT_SERVER)                 | The system is a server, but not |
    |                                       | a domain controller.            |
    +---------------------------------------+---------------------------------+
 
@@ -1261,20 +1268,20 @@ always available.
    ================ ===========================
 
    .. versionchanged:: 3.3
-      On Linux, :attr:`sys.platform` doesn't contain the major version anymore.
+      On Linux, :data:`sys.platform` doesn't contain the major version anymore.
       It is always ``'linux'``, instead of ``'linux2'`` or ``'linux3'``.  Since
       older Python versions include the version number, it is recommended to
       always use the ``startswith`` idiom presented above.
 
    .. versionchanged:: 3.8
-      On AIX, :attr:`sys.platform` doesn't contain the major version anymore.
+      On AIX, :data:`sys.platform` doesn't contain the major version anymore.
       It is always ``'aix'``, instead of ``'aix5'`` or ``'aix7'``.  Since
       older Python versions include the version number, it is recommended to
       always use the ``startswith`` idiom presented above.
 
    .. seealso::
 
-      :attr:`os.name` has a coarser granularity.  :func:`os.uname` gives
+      :data:`os.name` has a coarser granularity.  :func:`os.uname` gives
       system-dependent version information.
 
       The :mod:`platform` module provides detailed checks for the
@@ -1342,7 +1349,7 @@ always available.
    ``sys.setdlopenflags(0)``.  To share symbols across extension modules, call as
    ``sys.setdlopenflags(os.RTLD_GLOBAL)``.  Symbolic names for the flag values
    can be found in the :mod:`os` module (``RTLD_xxx`` constants, e.g.
-   :data:`os.RTLD_LAZY`).
+   :const:`os.RTLD_LAZY`).
 
    .. availability:: Unix.
 
@@ -1685,7 +1692,7 @@ always available.
    ``email.mime`` sub-package and the ``email.message`` sub-module are not
    listed.
 
-   See also the :attr:`sys.builtin_module_names` list.
+   See also the :data:`sys.builtin_module_names` list.
 
    .. versionadded:: 3.10
 
--- a/Doc/library/sysconfig.rst
+++ b/Doc/library/sysconfig.rst
@@ -69,7 +69,7 @@ Python uses an installation scheme that
 the installation options.  These schemes are stored in :mod:`sysconfig` under
 unique identifiers based on the value returned by :const:`os.name`.
 
-Every new component that is installed using :mod:`distutils` or a
+Every new component that is installed using :mod:`!distutils` or a
 Distutils-based system will follow the same scheme to copy its file in the right
 places.
 
--- a/Doc/library/tarfile.rst
+++ b/Doc/library/tarfile.rst
@@ -901,7 +901,7 @@ can be:
   path to where the archive is extracted (i.e. the same path is used for all
   members)::
 
-      filter(/, member: TarInfo, path: str) -> TarInfo | None
+      filter(member: TarInfo, path: str, /) -> TarInfo | None
 
   The callable is called just before each member is extracted, so it can
   take the current state of the disk into account.
@@ -921,17 +921,17 @@ Default named filters
 The pre-defined, named filters are available as functions, so they can be
 reused in custom filters:
 
-.. function:: fully_trusted_filter(/, member, path)
+.. function:: fully_trusted_filter(member, path)
 
    Return *member* unchanged.
 
    This implements the ``'fully_trusted'`` filter.
 
-.. function:: tar_filter(/, member, path)
+.. function:: tar_filter(member, path)
 
   Implements the ``'tar'`` filter.
 
-  - Strip leading slashes (``/`` and :attr:`os.sep`) from filenames.
+  - Strip leading slashes (``/`` and :data:`os.sep`) from filenames.
   - :ref:`Refuse <tarfile-extraction-refuse>` to extract files with absolute
     paths (in case the name is absolute
     even after stripping slashes, e.g. ``C:/foo`` on Windows).
@@ -940,11 +940,11 @@ reused in custom filters:
     path (after following symlinks) would end up outside the destination.
     This raises :class:`~tarfile.OutsideDestinationError`.
   - Clear high mode bits (setuid, setgid, sticky) and group/other write bits
-    (:attr:`~stat.S_IWGRP`|:attr:`~stat.S_IWOTH`).
+    (:const:`~stat.S_IWGRP`|:const:`~stat.S_IWOTH`).
 
   Return the modified ``TarInfo`` member.
 
-.. function:: data_filter(/, member, path)
+.. function:: data_filter(member, path)
 
   Implements the ``'data'`` filter.
   In addition to what ``tar_filter`` does:
@@ -965,10 +965,10 @@ reused in custom filters:
   - For regular files, including hard links:
 
     - Set the owner read and write permissions
-      (:attr:`~stat.S_IRUSR`|:attr:`~stat.S_IWUSR`).
+      (:const:`~stat.S_IRUSR`|:const:`~stat.S_IWUSR`).
     - Remove the group & other executable permission
-      (:attr:`~stat.S_IXGRP`|:attr:`~stat.S_IXOTH`)
-      if the owner doesnt have it (:attr:`~stat.S_IXUSR`).
+      (:const:`~stat.S_IXGRP`|:const:`~stat.S_IXOTH`)
+      if the owner doesnt have it (:const:`~stat.S_IXUSR`).
 
   - For other files (directories), set ``mode`` to ``None``, so
     that extraction methods skip applying permission bits.
--- a/Doc/library/tempfile.rst
+++ b/Doc/library/tempfile.rst
@@ -59,7 +59,7 @@ The module defines the following user-ca
    platforms, it is a file-like object whose :attr:`!file` attribute is the
    underlying true file object.
 
-   The :py:data:`os.O_TMPFILE` flag is used if it is available and works
+   The :py:const:`os.O_TMPFILE` flag is used if it is available and works
    (Linux-specific, requires Linux kernel 3.11 or later).
 
    On platforms that are neither Posix nor Cygwin, TemporaryFile is an alias
@@ -69,7 +69,7 @@ The module defines the following user-ca
 
    .. versionchanged:: 3.5
 
-      The :py:data:`os.O_TMPFILE` flag is now used if available.
+      The :py:const:`os.O_TMPFILE` flag is now used if available.
 
    .. versionchanged:: 3.8
       Added *errors* parameter.
--- a/Doc/library/test.rst
+++ b/Doc/library/test.rst
@@ -418,7 +418,7 @@ The :mod:`test.support` module defines t
 
 .. function:: with_pymalloc()
 
-   Return :data:`_testcapi.WITH_PYMALLOC`.
+   Return :const:`_testcapi.WITH_PYMALLOC`.
 
 
 .. function:: requires(resource, msg=None)
@@ -973,7 +973,7 @@ The :mod:`test.support` module defines t
    `SetErrorMode <https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx>`_.
 
    On UNIX, :func:`resource.setrlimit` is used to set
-   :attr:`resource.RLIMIT_CORE`'s soft limit to 0 to prevent coredump file
+   :const:`resource.RLIMIT_CORE`'s soft limit to 0 to prevent coredump file
    creation.
 
    On both platforms, the old value is restored by :meth:`__exit__`.
--- a/Doc/library/textwrap.rst
+++ b/Doc/library/textwrap.rst
@@ -60,7 +60,7 @@ functions should be good enough; otherwi
    First the whitespace in *text* is collapsed (all whitespace is replaced by
    single spaces).  If the result fits in the *width*, it is returned.
    Otherwise, enough words are dropped from the end so that the remaining words
-   plus the :attr:`placeholder` fit within :attr:`width`::
+   plus the :attr:`.placeholder` fit within :attr:`.width`::
 
       >>> textwrap.shorten("Hello  world!", width=12)
       'Hello world!'
@@ -173,7 +173,7 @@ hyphenated words; only then will long wo
    .. attribute:: expand_tabs
 
       (default: ``True``) If true, then all tab characters in *text* will be
-      expanded to spaces using the :meth:`expandtabs` method of *text*.
+      expanded to spaces using the :meth:`~str.expandtabs` method of *text*.
 
 
    .. attribute:: tabsize
--- a/Doc/library/tkinter.rst
+++ b/Doc/library/tkinter.rst
@@ -163,7 +163,7 @@ the modern themed widget set and API::
    interpreter and calls :func:`exec` on the contents of
    :file:`.{className}.py` and :file:`.{baseName}.py`.  The path for the
    profile files is the :envvar:`HOME` environment variable or, if that
-   isn't defined, then :attr:`os.curdir`.
+   isn't defined, then :data:`os.curdir`.
 
    .. attribute:: tk
 
--- a/Doc/library/tkinter.ttk.rst
+++ b/Doc/library/tkinter.ttk.rst
@@ -102,7 +102,7 @@ themed widgets and is not supposed to be
 Standard Options
 ^^^^^^^^^^^^^^^^
 
-All the :mod:`ttk` Widgets accepts the following options:
+All the :mod:`ttk` Widgets accept the following options:
 
    .. tabularcolumns:: |l|L|
 
--- a/Doc/library/tokenize.rst
+++ b/Doc/library/tokenize.rst
@@ -22,6 +22,15 @@ the generic :data:`~token.OP` token type
 type can be determined by checking the ``exact_type`` property on the
 :term:`named tuple` returned from :func:`tokenize.tokenize`.
 
+
+.. warning::
+
+   Note that the functions in this module are only designed to parse
+   syntactically valid Python code (code that does not raise when parsed
+   using :func:`ast.parse`).  The behavior of the functions in this module is
+   **undefined** when providing invalid Python code and it can change at any
+   point.
+
 Tokenizing Input
 ----------------
 
--- a/Doc/library/turtle.rst
+++ b/Doc/library/turtle.rst
@@ -19,14 +19,10 @@
 Introduction
 ============
 
-Turtle graphics is a popular way for introducing programming to kids.  It was
-part of the original Logo programming language developed by Wally Feurzeig,
-Seymour Papert and Cynthia Solomon in 1967.
-
-Imagine a robotic turtle starting at (0, 0) in the x-y plane.  After an ``import turtle``, give it the
-command ``turtle.forward(15)``, and it moves (on-screen!) 15 pixels in the
-direction it is facing, drawing a line as it moves.  Give it the command
-``turtle.right(25)``, and it rotates in-place 25 degrees clockwise.
+Turtle graphics is an implementation of `the popular geometric drawing tools
+introduced in Logo <https://en.wikipedia.org/wiki/Turtle_
+(robot)>`_, developed by Wally Feurzeig, Seymour Papert and Cynthia Solomon
+in 1967.
 
 .. sidebar:: Turtle star
 
@@ -36,67 +32,261 @@ direction it is facing, drawing a line a
    .. image:: turtle-star.*
       :align: center
 
-   .. literalinclude:: ../includes/turtle-star.py
+In Python, turtle graphics provides a representation of a physical "turtle"
+(a little robot with a pen) that draws on a sheet of paper on the floor.
 
-By combining together these and similar commands, intricate shapes and pictures
-can easily be drawn.
+It's an effective and well-proven way for learners to encounter
+programming concepts and interaction with software, as it provides instant,
+visible feedback. It also provides convenient access to graphical output
+in general.
 
-The :mod:`turtle` module is an extended reimplementation of the same-named
-module from the Python standard distribution up to version Python 2.5.
+Turtle drawing was originally created as an educational tool, to be used by
+teachers in the classroom. For the programmer who needs to produce some
+graphical output it can be a way to do that without the overhead of
+introducing more complex or external libraries into their work.
 
-It tries to keep the merits of the old turtle module and to be (nearly) 100%
-compatible with it.  This means in the first place to enable the learning
-programmer to use all the commands, classes and methods interactively when using
-the module from within IDLE run with the ``-n`` switch.
 
-The turtle module provides turtle graphics primitives, in both object-oriented
-and procedure-oriented ways.  Because it uses :mod:`tkinter` for the underlying
-graphics, it needs a version of Python installed with Tk support.
+.. _turtle-tutorial:
 
-The object-oriented interface uses essentially two+two classes:
+Tutorial
+========
 
-1. The :class:`TurtleScreen` class defines graphics windows as a playground for
-   the drawing turtles.  Its constructor needs a :class:`tkinter.Canvas` or a
-   :class:`ScrolledCanvas` as argument.  It should be used when :mod:`turtle` is
-   used as part of some application.
+New users should start here. In this tutorial we'll explore some of the
+basics of turtle drawing.
 
-   The function :func:`Screen` returns a singleton object of a
-   :class:`TurtleScreen` subclass. This function should be used when
-   :mod:`turtle` is used as a standalone tool for doing graphics.
-   As a singleton object, inheriting from its class is not possible.
 
-   All methods of TurtleScreen/Screen also exist as functions, i.e. as part of
-   the procedure-oriented interface.
+Starting a turtle environment
+-----------------------------
 
-2. :class:`RawTurtle` (alias: :class:`RawPen`) defines Turtle objects which draw
-   on a :class:`TurtleScreen`.  Its constructor needs a Canvas, ScrolledCanvas
-   or TurtleScreen as argument, so the RawTurtle objects know where to draw.
+In a Python shell, import all the objects of the ``turtle`` module::
 
-   Derived from RawTurtle is the subclass :class:`Turtle` (alias: :class:`Pen`),
-   which draws on "the" :class:`Screen` instance which is automatically
-   created, if not already present.
+    from turtle import *
 
-   All methods of RawTurtle/Turtle also exist as functions, i.e. part of the
-   procedure-oriented interface.
+If you run into a ``No module named '_tkinter'`` error, you'll have to
+install the :mod:`Tk interface package <tkinter>` on your system.
 
-The procedural interface provides functions which are derived from the methods
-of the classes :class:`Screen` and :class:`Turtle`.  They have the same names as
-the corresponding methods.  A screen object is automatically created whenever a
-function derived from a Screen method is called.  An (unnamed) turtle object is
-automatically created whenever any of the functions derived from a Turtle method
-is called.
 
-To use multiple turtles on a screen one has to use the object-oriented interface.
+Basic drawing
+-------------
+
+Send the turtle forward 100 steps::
+
+   forward(100)
+
+You should see (most likely, in a new window on your display) a line
+drawn by the turtle, heading East. Change the direction of the turtle,
+so that it turns 120 degrees left (anti-clockwise)::
+
+   left(120)
+
+Let's continue by drawing a triangle::
+
+   forward(100)
+   left(120)
+   forward(100)
+
+Notice how the turtle, represented by an arrow, points in different
+directions as you steer it.
+
+Experiment with those commands, and also with ``backward()`` and
+``right()``.
+
+
+Pen control
+~~~~~~~~~~~
+
+Try changing the color - for example, ``color('blue')`` - and
+width of the line - for example, ``width(3)`` - and then drawing again.
+
+You can also move the turtle around without drawing, by lifting up the pen:
+``up()`` before moving. To start drawing again, use ``down()``.
+
+
+The turtle's position
+~~~~~~~~~~~~~~~~~~~~~
+
+Send your turtle back to its starting-point (useful if it has disappeared
+off-screen)::
+
+   home()
+
+The home position is at the center of the turtle's screen. If you ever need to
+know them, get the turtle's x-y co-ordinates with::
+
+    pos()
+
+Home is at ``(0, 0)``.
+
+And after a while, it will probably help to clear the window so we can start
+anew::
+
+   clearscreen()
+
+
+Making algorithmic patterns
+---------------------------
+
+Using loops, it's possible to build up geometric patterns::
+
+    for steps in range(100):
+        for c in ('blue', 'red', 'green'):
+            color(c)
+            forward(steps)
+            right(30)
+
+
+\ - which of course, are limited only by the imagination!
+
+Let's draw the star shape at the top of this page. We want red lines,
+filled in with yellow::
+
+    color('red')
+    fillcolor('yellow')
+
+Just as ``up()`` and ``down()`` determine whether lines will be drawn,
+filling can be turned on and off::
+
+    begin_fill()
+
+Next we'll create a loop::
+
+    while True:
+        forward(200)
+        left(170)
+        if abs(pos()) < 1:
+            break
+
+``abs(pos()) < 1`` is a good way to know when the turtle is back at its
+home position.
+
+Finally, complete the filling::
+
+    end_fill()
+
+(Note that filling only actually takes place when you give the
+``end_fill()`` command.)
+
+
+.. _turtle-how-to:
+
+How to...
+=========
+
+This section covers some typical turtle use-cases and approaches.
+
+
+Get started as quickly as possible
+----------------------------------
+
+One of the joys of turtle graphics is the immediate, visual feedback that's
+available from simple commands - it's an excellent way to introduce children
+to programming ideas, with a minimum of overhead (not just children, of
+course).
+
+The turtle module makes this possible by exposing all its basic functionality
+as functions, available with ``from turtle import *``. The :ref:`turtle
+graphics tutorial <turtle-tutorial>` covers this approach.
+
+It's worth noting that many of the turtle commands also have even more terse
+equivalents, such as ``fd()`` for :func:`forward`. These are especially
+useful when working with learners for whom typing is not a skill.
+
+.. _note:
+
+    You'll need to have the :mod:`Tk interface package <tkinter>` installed on
+    your system for turtle graphics to work. Be warned that this is not
+    always straightforward, so check this in advance if you're planning to
+    use turtle graphics with a learner.
+
+
+Use the ``turtle`` module namespace
+-----------------------------------
+
+Using ``from turtle import *`` is convenient - but be warned that it imports a
+rather large collection of objects, and if you're doing anything but turtle
+graphics you run the risk of a name conflict (this becomes even more an issue
+if you're using turtle graphics in a script where other modules might be
+imported).
+
+The solution is to use ``import turtle`` - ``fd()`` becomes
+``turtle.fd()``, ``width()`` becomes ``turtle.width()`` and so on. (If typing
+"turtle" over and over again becomes tedious, use for example ``import turtle
+as t`` instead.)
+
+
+Use turtle graphics in a script
+-------------------------------
+
+It's recommended to use the ``turtle`` module namespace as described
+immediately above, for example::
+
+    import turtle as t
+    from random import random
+
+    for i in range(100):
+        steps = int(random() * 100)
+        angle = int(random() * 360)
+        t.right(angle)
+        t.fd(steps)
+
+Another step is also required though - as soon as the script ends, Python
+will also close the turtle's window. Add::
+
+    t.mainloop()
+
+to the end of the script. The script will now wait to be dismissed and
+will not exit until it is terminated, for example by closing the turtle
+graphics window.
+
+
+Use object-oriented turtle graphics
+-----------------------------------
+
+.. seealso:: :ref:`Explanation of the object-oriented interface <turtle-explanation>`
+
+Other than for very basic introductory purposes, or for trying things out
+as quickly as possible, it's more usual and much more powerful to use the
+object-oriented approach to turtle graphics. For example, this allows
+multiple turtles on screen at once.
+
+In this approach, the various turtle commands are methods of objects (mostly of
+``Turtle`` objects). You *can* use the object-oriented approach in the shell,
+but it would be more typical in a Python script.
+
+The example above then becomes::
+
+    from turtle import Turtle
+    from random import random
+
+    t = Turtle()
+    for i in range(100):
+        steps = int(random() * 100)
+        angle = int(random() * 360)
+        t.right(angle)
+        t.fd(steps)
+
+    t.screen.mainloop()
+
+Note the last line. ``t.screen`` is an instance of the :class:`Screen`
+that a Turtle instance exists on; it's created automatically along with
+the turtle.
+
+The turtle's screen can be customised, for example::
+
+    t.screen.title('Object-oriented turtle demo')
+    t.screen.bgcolor("orange")
+
+
+Turtle graphics reference
+=========================
 
 .. note::
+
    In the following documentation the argument list for functions is given.
    Methods, of course, have the additional first argument *self* which is
    omitted here.
 
 
-Overview of available Turtle and Screen methods
-=================================================
-
 Turtle methods
 --------------
 
@@ -2193,6 +2383,41 @@ Public classes
    * ``a.rotate(angle)`` rotation
 
 
+.. _turtle-explanation:
+
+Explanation
+===========
+
+A turtle object draws on a screen object, and there a number of key classes in
+the turtle object-oriented interface that can be used to create them and relate
+them to each other.
+
+A :class:`Turtle` instance will automatically create a :class:`Screen`
+instance if one is not already present.
+
+``Turtle`` is a subclass of :class:`RawTurtle`, which *doesn't* automatically
+create a drawing surface - a *canvas* will need to be provided or created for
+it. The *canvas* can be a :class:`tkinter.Canvas`, :class:`ScrolledCanvas`
+or :class:`TurtleScreen`.
+
+
+:class:`TurtleScreen` is the basic drawing surface for a
+turtle. :class:`Screen` is a subclass of ``TurtleScreen``, and
+includes :ref:`some additional methods <screenspecific>` for managing its
+appearance (including size and title) and behaviour. ``TurtleScreen``'s
+constructor needs a :class:`tkinter.Canvas` or a
+:class:`ScrolledCanvas` as an argument.
+
+The functional interface for turtle graphics uses the various methods of
+``Turtle`` and ``TurtleScreen``/``Screen``. Behind the scenes, a screen
+object is automatically created whenever a function derived from a ``Screen``
+method is called. Similarly, a turtle object is automatically created
+whenever any of the functions derived from a Turtle method is called.
+
+To use multiple turtles on a screen, the object-oriented interface must be
+used.
+
+
 Help and configuration
 ======================
 
--- a/Doc/library/typing.rst
+++ b/Doc/library/typing.rst
@@ -2,6 +2,12 @@
 :mod:`typing` --- Support for type hints
 ========================================
 
+.. testsetup:: *
+
+   import typing
+   from dataclasses import dataclass
+   from typing import *
+
 .. module:: typing
    :synopsis: Support for type hints (see :pep:`484`).
 
@@ -17,10 +23,9 @@
 
 --------------
 
-This module provides runtime support for type hints. The most fundamental
-support consists of the types :data:`Any`, :data:`Union`, :data:`Callable`,
-:class:`TypeVar`, and :class:`Generic`. For a specification, please see
-:pep:`484`. For a simplified introduction to type hints, see :pep:`483`.
+This module provides runtime support for type hints. For the original
+specification of the typing system, see :pep:`484`. For a simplified
+introduction to type hints, see :pep:`483`.
 
 
 The function below takes and returns a string and is annotated as follows::
@@ -41,16 +46,18 @@ For a summary of deprecated features and
 
 .. seealso::
 
-   For a quick overview of type hints, refer to
-   `this cheat sheet <https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html>`_.
-
-   The "Type System Reference" section of https://mypy.readthedocs.io/ -- since
-   the Python typing system is standardised via PEPs, this reference should
-   broadly apply to most Python type checkers, although some parts may still be
-   specific to mypy.
+   `"Typing cheat sheet" <https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html>`_
+       A quick overview of type hints (hosted at the mypy docs)
 
-   The documentation at https://typing.readthedocs.io/ serves as useful reference
-   for type system features, useful typing related tools and typing best practices.
+   "Type System Reference" section of `the mypy docs <https://mypy.readthedocs.io/en/stable/index.html>`_
+      The Python typing system is standardised via PEPs, so this reference
+      should broadly apply to most Python type checkers. (Some parts may still
+      be specific to mypy.)
+
+   `"Static Typing with Python" <https://typing.readthedocs.io/en/latest/>`_
+      Type-checker-agnostic documentation written by the community detailing
+      type system features, useful typing related tools and typing best
+      practices.
 
 .. _relevant-peps:
 
@@ -59,7 +66,12 @@ Relevant PEPs
 
 Since the initial introduction of type hints in :pep:`484` and :pep:`483`, a
 number of PEPs have modified and enhanced Python's framework for type
-annotations. These include:
+annotations:
+
+.. raw:: html
+
+   <details>
+   <summary><a style="cursor:pointer;">The full list of PEPs</a></summary>
 
 * :pep:`526`: Syntax for Variable Annotations
      *Introducing* syntax for annotating variables outside of function
@@ -99,6 +111,11 @@ annotations. These include:
 * :pep:`681`: Data Class Transforms
     *Introducing* the :func:`@dataclass_transform<dataclass_transform>` decorator
 
+.. raw:: html
+
+   </details>
+   <br>
+
 .. _type-aliases:
 
 Type aliases
@@ -133,9 +150,6 @@ Type aliases are useful for simplifying
            servers: Sequence[tuple[tuple[str, int], dict[str, str]]]) -> None:
        ...
 
-Note that ``None`` as a type hint is a special case and is replaced by
-``type(None)``.
-
 Type aliases may be marked with :data:`TypeAlias` to make it explicit that
 the statement is a type alias declaration, not a normal variable assignment::
 
@@ -222,35 +236,85 @@ See :pep:`484` for more details.
 .. versionadded:: 3.5.2
 
 .. versionchanged:: 3.10
-   ``NewType`` is now a class rather than a function.  There is some additional
-   runtime cost when calling ``NewType`` over a regular function.  However, this
-   cost will be reduced in 3.11.0.
+   ``NewType`` is now a class rather than a function.  As a result, there is
+   some additional runtime cost when calling ``NewType`` over a regular
+   function.
 
+.. versionchanged:: 3.11
+   The performance of calling ``NewType`` has been restored to its level in
+   Python 3.9.
 
-Callable
-========
+.. _annotating-callables:
 
-Frameworks expecting callback functions of specific signatures might be
-type hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``.
+Annotating callable objects
+===========================
 
-For example::
+Functions -- or other :term:`callable` objects -- can be annotated using
+:class:`collections.abc.Callable` or :data:`typing.Callable`.
+``Callable[[int], str]`` signifies a function that takes a single parameter
+of type :class:`int` and returns a :class:`str`.
+
+For example:
 
-   from collections.abc import Callable
+.. testcode::
+
+   from collections.abc import Callable, Awaitable
 
    def feeder(get_next_item: Callable[[], str]) -> None:
-       # Body
+       ...  # Body
 
    def async_query(on_success: Callable[[int], None],
                    on_error: Callable[[int, Exception], None]) -> None:
-       # Body
+       ...  # Body
 
    async def on_update(value: str) -> None:
-       # Body
+       ...  # Body
+
    callback: Callable[[str], Awaitable[None]] = on_update
 
-It is possible to declare the return type of a callable without specifying
-the call signature by substituting a literal ellipsis
-for the list of arguments in the type hint: ``Callable[..., ReturnType]``.
+The subscription syntax must always be used with exactly two values: the
+argument list and the return type.  The argument list must be a list of types,
+a :class:`ParamSpec`, :data:`Concatenate`, or an ellipsis. The return type must
+be a single type.
+
+If a literal ellipsis ``...`` is given as the argument list, it indicates that
+a callable with any arbitrary parameter list would be acceptable:
+
+.. testcode::
+
+   def concat(x: str, y: str) -> str:
+       return x + y
+
+   x: Callable[..., str]
+   x = str     # OK
+   x = concat  # Also OK
+
+``Callable`` cannot express complex signatures such as functions that take a
+variadic number of arguments, :func:`overloaded functions <overload>`, or
+functions that have keyword-only parameters. However, these signatures can be
+expressed by defining a :class:`Protocol` class with a
+:meth:`~object.__call__` method:
+
+.. testcode::
+
+   from collections.abc import Iterable
+   from typing import Protocol
+
+   class Combiner(Protocol):
+       def __call__(self, *vals: bytes, maxlen: int | None = None) -> list[bytes]: ...
+
+   def batch_proc(data: Iterable[bytes], cb_results: Combiner) -> bytes:
+       for item in data:
+           ...
+
+   def good_cb(*vals: bytes, maxlen: int | None = None) -> list[bytes]:
+       ...
+   def bad_cb(*vals: bytes, maxitems: int | None) -> list[bytes]:
+       ...
+
+   batch_proc([], good_cb)  # OK
+   batch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because of
+                            # different name and kind in the callback
 
 Callables which take other callables as arguments may indicate that their
 parameter types are dependent on each other using :class:`ParamSpec`.
@@ -274,13 +338,19 @@ Generics
 ========
 
 Since type information about objects kept in containers cannot be statically
-inferred in a generic way, abstract base classes have been extended to support
-subscription to denote expected types for container elements.
+inferred in a generic way, many container classes in the standard library support
+subscription to denote the expected types of container elements.
 
-::
+.. testcode::
 
    from collections.abc import Mapping, Sequence
 
+   class Employee: ...
+
+   # Sequence[Employee] indicates that all elements in the sequence
+   # must be instances of "Employee".
+   # Mapping[str, str] indicates that all keys and all values in the mapping
+   # must be strings.
    def notify_by_email(employees: Sequence[Employee],
                        overrides: Mapping[str, str]) -> None: ...
 
@@ -292,11 +362,119 @@ called :class:`TypeVar`.
    from collections.abc import Sequence
    from typing import TypeVar
 
-   T = TypeVar('T')      # Declare type variable
+   T = TypeVar('T')                  # Declare type variable "T"
 
-   def first(l: Sequence[T]) -> T:   # Generic function
+   def first(l: Sequence[T]) -> T:   # Function is generic over the TypeVar "T"
        return l[0]
 
+.. _annotating-tuples:
+
+Annotating tuples
+=================
+
+For most containers in Python, the typing system assumes that all elements in
+the container will be of the same type. For example::
+
+   from collections.abc import Mapping
+
+   # Type checker will infer that all elements in ``x`` are meant to be ints
+   x: list[int] = []
+
+   # Type checker error: ``list`` only accepts a single type argument:
+   y: list[int, str] = [1, 'foo']
+
+   # Type checker will infer that all keys in ``z`` are meant to be strings,
+   # and that all values in ``z`` are meant to be either strings or ints
+   z: Mapping[str, str | int] = {}
+
+:class:`list` only accepts one type argument, so a type checker would emit an
+error on the ``y`` assignment above. Similarly,
+:class:`~collections.abc.Mapping` only accepts two type arguments: the first
+indicates the type of the keys, and the second indicates the type of the
+values.
+
+Unlike most other Python containers, however, it is common in idiomatic Python
+code for tuples to have elements which are not all of the same type. For this
+reason, tuples are special-cased in Python's typing system. :class:`tuple`
+accepts *any number* of type arguments::
+
+   # OK: ``x`` is assigned to a tuple of length 1 where the sole element is an int
+   x: tuple[int] = (5,)
+
+   # OK: ``y`` is assigned to a tuple of length 2;
+   # element 1 is an int, element 2 is a str
+   y: tuple[int, str] = (5, "foo")
+
+   # Error: the type annotation indicates a tuple of length 1,
+   # but ``z`` has been assigned to a tuple of length 3
+   z: tuple[int] = (1, 2, 3)
+
+To denote a tuple which could be of *any* length, and in which all elements are
+of the same type ``T``, use ``tuple[T, ...]``. To denote an empty tuple, use
+``tuple[()]``. Using plain ``tuple`` as an annotation is equivalent to using
+``tuple[Any, ...]``::
+
+   x: tuple[int, ...] = (1, 2)
+   # These reassignments are OK: ``tuple[int, ...]`` indicates x can be of any length
+   x = (1, 2, 3)
+   x = ()
+   # This reassignment is an error: all elements in ``x`` must be ints
+   x = ("foo", "bar")
+
+   # ``y`` can only ever be assigned to an empty tuple
+   y: tuple[()] = ()
+
+   z: tuple = ("foo", "bar")
+   # These reassignments are OK: plain ``tuple`` is equivalent to ``tuple[Any, ...]``
+   z = (1, 2, 3)
+   z = ()
+
+.. _type-of-class-objects:
+
+The type of class objects
+=========================
+
+A variable annotated with ``C`` may accept a value of type ``C``. In
+contrast, a variable annotated with ``type[C]`` (or
+:class:`typing.Type[C] <Type>`) may accept values that are classes
+themselves -- specifically, it will accept the *class object* of ``C``. For
+example::
+
+   a = 3         # Has type ``int```
+   b = int       # Has type ``type[int]``
+   c = type(a)   # Also has type ``type[int]``
+
+Note that ``type[C]`` is covariant::
+
+   class User: ...
+   class ProUser(User): ...
+   class TeamUser(User): ...
+
+   def make_new_user(user_class: type[User]) -> User:
+       # ...
+       return user_class()
+
+   make_new_user(User)      # OK
+   make_new_user(ProUser)   # Also OK: ``type[ProUser]`` is a subtype of ``type[User]``
+   make_new_user(TeamUser)  # Still fine
+   make_new_user(User())    # Error: expected ``type[User]`` but got ``User``
+   make_new_user(int)       # Error: ``type[int]`` is not a subtype of ``type[User]``
+
+The only legal parameters for :class:`type` are classes, :data:`Any`,
+:ref:`type variables <generics>`, and unions of any of these types.
+For example::
+
+   def new_non_team_user(user_class: type[BasicUser | ProUser]): ...
+
+   new_non_team_user(BasicUser)  # OK
+   new_non_team_user(ProUser)    # OK
+   new_non_team_user(TeamUser)   # Error: ``type[TeamUser]`` is not a subtype
+                                 # of ``type[BasicUser | ProUser]``
+   new_non_team_user(User)       # Also an error
+
+``type[Any]`` is equivalent to :class:`type`, which is the root of Python's
+:ref:`metaclass hierarchy <metaclasses>`.
+
 .. _user-defined-generics:
 
 User-defined generic types
@@ -388,11 +566,14 @@ In this case ``MyDict`` has a single par
 
 Using a generic class without specifying type parameters assumes
 :data:`Any` for each position. In the following example, ``MyIterable`` is
-not generic but implicitly inherits from ``Iterable[Any]``::
+not generic but implicitly inherits from ``Iterable[Any]``:
+
+.. testcode::
 
    from collections.abc import Iterable
 
    class MyIterable(Iterable): # Same as Iterable[Any]
+       ...
 
 User-defined generic type aliases are also supported. Examples::
 
@@ -442,7 +623,7 @@ to the former, so the following are equi
    >>> X[[int, str]]
    __main__.X[(<class 'int'>, <class 'str'>)]
 
-Do note that generics with :class:`ParamSpec` may not have correct
+Note that generics with :class:`ParamSpec` may not have correct
 ``__parameters__`` after substitution in some cases because they
 are intended primarily for static type checking.
 
@@ -577,25 +758,7 @@ can define new custom protocols to fully
 Module contents
 ===============
 
-The module defines the following classes, functions and decorators.
-
-.. note::
-
-   This module defines several types that are subclasses of pre-existing
-   standard library classes which also extend :class:`Generic`
-   to support type variables inside ``[]``.
-   These types became redundant in Python 3.9 when the
-   corresponding pre-existing classes were enhanced to support ``[]``.
-
-   The redundant types are deprecated as of Python 3.9 but no
-   deprecation warnings will be issued by the interpreter.
-   It is expected that type checkers will flag the deprecated types
-   when the checked program targets Python 3.9 or newer.
-
-   The deprecated types will be removed from the :mod:`typing` module
-   no sooner than the first Python version released 5 years after the release of Python 3.9.0.
-   See details in :pep:`585`*Type Hinting Generics In Standard Collections*.
-
+The ``typing`` module defines the following classes, functions and decorators.
 
 Special typing primitives
 -------------------------
@@ -603,7 +766,8 @@ Special typing primitives
 Special types
 """""""""""""
 
-These can be used as types in annotations and do not support ``[]``.
+These can be used as types in annotations. They do not support subscription
+using ``[]``.
 
 .. data:: Any
 
@@ -619,42 +783,66 @@ These can be used as types in annotation
 
 .. data:: AnyStr
 
-   ``AnyStr`` is a :ref:`constrained type variable <typing-constrained-typevar>` defined as
-   ``AnyStr = TypeVar('AnyStr', str, bytes)``.
+   A :ref:`constrained type variable <typing-constrained-typevar>`.
+
+   Definition::
+
+      AnyStr = TypeVar('AnyStr', str, bytes)
 
-   It is meant to be used for functions that may accept any kind of string
-   without allowing different kinds of strings to mix. For example::
+   ``AnyStr`` is meant to be used for functions that may accept :class:`str` or
+   :class:`bytes` arguments but cannot allow the two to mix.
+
+   For example::
 
       def concat(a: AnyStr, b: AnyStr) -> AnyStr:
           return a + b
 
-      concat(u"foo", u"bar")  # Ok, output has type 'unicode'
-      concat(b"foo", b"bar")  # Ok, output has type 'bytes'
-      concat(u"foo", b"bar")  # Error, cannot mix unicode and bytes
+      concat("foo", "bar")    # OK, output has type 'str'
+      concat(b"foo", b"bar")  # OK, output has type 'bytes'
+      concat("foo", b"bar")   # Error, cannot mix str and bytes
+
+   Note that, despite its name, ``AnyStr`` has nothing to do with the
+   :class:`Any` type, nor does it mean "any string". In particular, ``AnyStr``
+   and ``str | bytes`` are different from each other and have different use
+   cases::
+
+      # Invalid use of AnyStr:
+      # The type variable is used only once in the function signature,
+      # so cannot be "solved" by the type checker
+      def greet_bad(cond: bool) -> AnyStr:
+          return "hi there!" if cond else b"greetings!"
+
+      # The better way of annotating this function:
+      def greet_proper(cond: bool) -> str | bytes:
+          return "hi there!" if cond else b"greetings!"
 
 .. data:: LiteralString
 
-   Special type that includes only literal strings. A string
+   Special type that includes only literal strings.
+
+   Any string
    literal is compatible with ``LiteralString``, as is another
-   ``LiteralString``, but an object typed as just ``str`` is not.
+   ``LiteralString``. However, an object typed as just ``str`` is not.
    A string created by composing ``LiteralString``-typed objects
    is also acceptable as a ``LiteralString``.
 
-   Example::
+   Example:
 
-      def run_query(sql: LiteralString) -> ...
+   .. testcode::
+
+      def run_query(sql: LiteralString) -> None:
           ...
 
       def caller(arbitrary_string: str, literal_string: LiteralString) -> None:
-          run_query("SELECT * FROM students")  # ok
-          run_query(literal_string)  # ok
-          run_query("SELECT * FROM " + literal_string)  # ok
+          run_query("SELECT * FROM students")  # OK
+          run_query(literal_string)  # OK
+          run_query("SELECT * FROM " + literal_string)  # OK
           run_query(arbitrary_string)  # type checker error
           run_query(  # type checker error
               f"SELECT * FROM students WHERE name = {arbitrary_string}"
           )
 
-   This is useful for sensitive APIs where arbitrary user-generated
+   ``LiteralString`` is useful for sensitive APIs where arbitrary user-generated
    strings could generate problems. For example, the two cases above
    that generate type checker errors could be vulnerable to an SQL
    injection attack.
@@ -684,7 +872,7 @@ These can be used as types in annotation
               case str():
                   print("It's a str")
               case _:
-                  never_call_me(arg)  # ok, arg is of type Never
+                  never_call_me(arg)  # OK, arg is of type Never
 
    .. versionadded:: 3.11
 
@@ -694,6 +882,7 @@ These can be used as types in annotation
 .. data:: NoReturn
 
    Special type indicating that a function never returns.
+
    For example::
 
       from typing import NoReturn
@@ -713,15 +902,20 @@ These can be used as types in annotation
 .. data:: Self
 
    Special type to represent the current enclosed class.
+
    For example::
 
-      from typing import Self
+      from typing import Self, reveal_type
 
       class Foo:
           def return_self(self) -> Self:
               ...
               return self
 
+      class SubclassOfFoo(Foo): pass
+
+      reveal_type(Foo().return_self())  # Revealed type is "Foo"
+      reveal_type(SubclassOfFoo().return_self())  # Revealed type is "SubclassOfFoo"
 
    This annotation is semantically equivalent to the following,
    albeit in a more succinct fashion::
@@ -735,15 +929,11 @@ These can be used as types in annotation
               ...
               return self
 
-   In general if something currently follows the pattern of::
-
-      class Foo:
-          def return_self(self) -> "Foo":
-              ...
-              return self
-
-   You should use :data:`Self` as calls to ``SubclassOfFoo.return_self`` would have
-   ``Foo`` as the return type and not ``SubclassOfFoo``.
+   In general, if something returns ``self``, as in the above examples, you
+   should use ``Self`` as the return annotation. If ``Foo.return_self`` was
+   annotated as returning ``"Foo"``, then the type checker would infer the
+   object returned from ``SubclassOfFoo.return_self`` as being of type ``Foo``
+   rather than ``SubclassOfFoo``.
 
    Other common use cases include:
 
@@ -751,6 +941,17 @@ These can be used as types in annotation
      of the ``cls`` parameter.
    - Annotating an :meth:`~object.__enter__` method which returns self.
 
+   You should not use ``Self`` as the return annotation if the method is not
+   guaranteed to return an instance of a subclass when the class is
+   subclassed::
+
+      class Eggs:
+          # Self would be an incorrect return annotation here,
+          # as the object returned is always an instance of Eggs,
+          # even in subclasses
+          def returns_eggs(self) -> "Eggs":
+              return Eggs()
+
    See :pep:`673` for more details.
 
    .. versionadded:: 3.11
@@ -758,38 +959,42 @@ These can be used as types in annotation
 .. data:: TypeAlias
 
    Special annotation for explicitly declaring a :ref:`type alias <type-aliases>`.
+
    For example::
 
-    from typing import TypeAlias
+      from typing import TypeAlias
 
-    Factors: TypeAlias = list[int]
+      Factors: TypeAlias = list[int]
 
-   See :pep:`613` for more details about explicit type aliases.
+   ``TypeAlias`` is particularly useful for annotating
+   aliases that make use of forward references, as it can be hard for type
+   checkers to distinguish these from normal variable assignments:
 
-   .. versionadded:: 3.10
+   .. testcode::
 
-Special forms
-"""""""""""""
+      from typing import Generic, TypeAlias, TypeVar
 
-These can be used as types in annotations using ``[]``, each having a unique syntax.
+      T = TypeVar("T")
 
-.. data:: Tuple
+      # "Box" does not exist yet,
+      # so we have to use quotes for the forward reference.
+      # Using ``TypeAlias`` tells the type checker that this is a type alias declaration,
+      # not a variable assignment to a string.
+      BoxOfStrings: TypeAlias = "Box[str]"
+
+      class Box(Generic[T]):
+          @classmethod
+          def make_box_of_strings(cls) -> BoxOfStrings: ...
 
-   Tuple type; ``Tuple[X, Y]`` is the type of a tuple of two items
-   with the first item of type X and the second of type Y. The type of
-   the empty tuple can be written as ``Tuple[()]``.
-
-   Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding
-   to type variables T1 and T2.  ``Tuple[int, float, str]`` is a tuple
-   of an int, a float and a string.
-
-   To specify a variable-length tuple of homogeneous type,
-   use literal ellipsis, e.g. ``Tuple[int, ...]``. A plain :data:`Tuple`
-   is equivalent to ``Tuple[Any, ...]``, and in turn to :class:`tuple`.
+   See :pep:`613` for more details.
 
-   .. deprecated:: 3.9
-      :class:`builtins.tuple <tuple>` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
+   .. versionadded:: 3.10
+
+Special forms
+"""""""""""""
+
+These can be used as types in annotations. They all support subscription using
+``[]``, but each has a unique syntax.
 
 .. data:: Union
 
@@ -828,8 +1033,6 @@ These can be used as types in annotation
 
 .. data:: Optional
 
-   Optional type.
-
    ``Optional[X]`` is equivalent to ``X | None`` (or ``Union[X, None]``).
 
    Note that this is not the same concept as an optional argument,
@@ -851,50 +1054,16 @@ These can be used as types in annotation
       Optional can now be written as ``X | None``. See
       :ref:`union type expressions<types-union>`.
 
-.. data:: Callable
-
-   Callable type; ``Callable[[int], str]`` is a function of (int) -> str.
-
-   The subscription syntax must always be used with exactly two
-   values: the argument list and the return type.  The argument list
-   must be a list of types or an ellipsis; the return type must be
-   a single type.
-
-   There is no syntax to indicate optional or keyword arguments;
-   such function types are rarely used as callback types.
-   ``Callable[..., ReturnType]`` (literal ellipsis) can be used to
-   type hint a callable taking any number of arguments and returning
-   ``ReturnType``.  A plain :data:`Callable` is equivalent to
-   ``Callable[..., Any]``, and in turn to
-   :class:`collections.abc.Callable`.
-
-   Callables which take other callables as arguments may indicate that their
-   parameter types are dependent on each other using :class:`ParamSpec`.
-   Additionally, if that callable adds or removes arguments from other
-   callables, the :data:`Concatenate` operator may be used.  They
-   take the form ``Callable[ParamSpecVariable, ReturnType]`` and
-   ``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], ReturnType]``
-   respectively.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Callable` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-   .. versionchanged:: 3.10
-      ``Callable`` now supports :class:`ParamSpec` and :data:`Concatenate`.
-      See :pep:`612` for more details.
-
-   .. seealso::
-      The documentation for :class:`ParamSpec` and :class:`Concatenate` provide
-      examples of usage with ``Callable``.
-
 .. data:: Concatenate
 
-   Used with :data:`Callable` and :class:`ParamSpec` to type annotate a higher
-   order callable which adds, removes, or transforms parameters of another
+   Special form for annotating higher-order functions.
+
+   ``Concatenate`` can be used in conjunction with :ref:`Callable <annotating-callables>` and
+   :class:`ParamSpec` to annotate a higher-order callable which adds, removes,
+   or transforms parameters of another
    callable.  Usage is in the form
    ``Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable]``. ``Concatenate``
-   is currently only valid when used as the first argument to a :data:`Callable`.
+   is currently only valid when used as the first argument to a :ref:`Callable <annotating-callables>`.
    The last parameter to ``Concatenate`` must be a :class:`ParamSpec` or
    ellipsis (``...``).
 
@@ -938,70 +1107,28 @@ These can be used as types in annotation
    .. seealso::
 
       * :pep:`612` -- Parameter Specification Variables (the PEP which introduced
-        ``ParamSpec`` and ``Concatenate``).
-      * :class:`ParamSpec` and :class:`Callable`.
+        ``ParamSpec`` and ``Concatenate``)
+      * :class:`ParamSpec`
+      * :ref:`annotating-callables`
 
+.. data:: Literal
 
-.. class:: Type(Generic[CT_co])
+   Special typing form to define "literal types".
 
-   A variable annotated with ``C`` may accept a value of type ``C``. In
-   contrast, a variable annotated with ``Type[C]`` may accept values that are
-   classes themselves -- specifically, it will accept the *class object* of
-   ``C``. For example::
-
-      a = 3         # Has type 'int'
-      b = int       # Has type 'Type[int]'
-      c = type(a)   # Also has type 'Type[int]'
-
-   Note that ``Type[C]`` is covariant::
-
-      class User: ...
-      class BasicUser(User): ...
-      class ProUser(User): ...
-      class TeamUser(User): ...
-
-      # Accepts User, BasicUser, ProUser, TeamUser, ...
-      def make_new_user(user_class: Type[User]) -> User:
-          # ...
-          return user_class()
-
-   The fact that ``Type[C]`` is covariant implies that all subclasses of
-   ``C`` should implement the same constructor signature and class method
-   signatures as ``C``. The type checker should flag violations of this,
-   but should also allow constructor calls in subclasses that match the
-   constructor calls in the indicated base class. How the type checker is
-   required to handle this particular case may change in future revisions of
-   :pep:`484`.
+   ``Literal`` can be used to indicate to type checkers that the
+   annotated object has a value equivalent to one of the
+   provided literals.
 
-   The only legal parameters for :class:`Type` are classes, :data:`Any`,
-   :ref:`type variables <generics>`, and unions of any of these types.
    For example::
 
-      def new_non_team_user(user_class: Type[BasicUser | ProUser]): ...
-
-   ``Type[Any]`` is equivalent to ``Type`` which in turn is equivalent
-   to ``type``, which is the root of Python's metaclass hierarchy.
-
-   .. versionadded:: 3.5.2
-
-   .. deprecated:: 3.9
-      :class:`builtins.type <type>` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. data:: Literal
-
-   A type that can be used to indicate to type checkers that the
-   corresponding variable or function parameter has a value equivalent to
-   the provided literal (or one of several literals). For example::
-
       def validate_simple(data: Any) -> Literal[True]:  # always returns True
           ...
 
-      MODE = Literal['r', 'rb', 'w', 'wb']
-      def open_helper(file: str, mode: MODE) -> str:
+      Mode: TypeAlias = Literal['r', 'rb', 'w', 'wb']
+      def open_helper(file: str, mode: Mode) -> str:
           ...
 
-      open_helper('/some/path', 'r')  # Passes type check
+      open_helper('/some/path', 'r')      # Passes type check
       open_helper('/other/path', 'typo')  # Error in type checker
 
    ``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value
@@ -1044,8 +1171,12 @@ These can be used as types in annotation
 
 .. data:: Final
 
-   A special typing construct to indicate to type checkers that a name
-   cannot be re-assigned or overridden in a subclass. For example::
+   Special typing construct to indicate final names to type checkers.
+
+   Final names cannot be reassigned in any scope. Final names declared in class
+   scopes cannot be overridden in subclasses.
+
+   For example::
 
       MAX_SIZE: Final = 9000
       MAX_SIZE += 1  # Error reported by type checker
@@ -1063,10 +1194,17 @@ These can be used as types in annotation
 
 .. data:: Required
 
+   Special typing construct to mark a :class:`TypedDict` key as required.
+
+   This is mainly useful for ``total=False`` TypedDicts. See :class:`TypedDict`
+   and :pep:`655` for more details.
+
+   .. versionadded:: 3.11
+
 .. data:: NotRequired
 
-   Special typing constructs that mark individual keys of a :class:`TypedDict`
-   as either required or non-required respectively.
+   Special typing construct to mark a :class:`TypedDict` key as potentially
+   missing.
 
    See :class:`TypedDict` and :pep:`655` for more details.
 
@@ -1074,92 +1212,149 @@ These can be used as types in annotation
 
 .. data:: Annotated
 
-   A type, introduced in :pep:`593` (``Flexible function and variable
-   annotations``), to decorate existing types with context-specific metadata
-   (possibly multiple pieces of it, as ``Annotated`` is variadic).
-   Specifically, a type ``T`` can be annotated with metadata ``x`` via the
-   typehint ``Annotated[T, x]``. This metadata can be used for either static
-   analysis or at runtime. If a library (or tool) encounters a typehint
-   ``Annotated[T, x]`` and has no special logic for metadata ``x``, it
-   should ignore it and simply treat the type as ``T``. Unlike the
-   ``no_type_check`` functionality that currently exists in the ``typing``
-   module which completely disables typechecking annotations on a function
-   or a class, the ``Annotated`` type allows for both static typechecking
-   of ``T`` (which can safely ignore ``x``)
-   together with runtime access to ``x`` within a specific application.
-
-   Ultimately, the responsibility of how to interpret the annotations (if
-   at all) is the responsibility of the tool or library encountering the
-   ``Annotated`` type. A tool or library encountering an ``Annotated`` type
-   can scan through the annotations to determine if they are of interest
-   (e.g., using ``isinstance()``).
-
-   When a tool or a library does not support annotations or encounters an
-   unknown annotation it should just ignore it and treat annotated type as
-   the underlying type.
-
-   It's up to the tool consuming the annotations to decide whether the
-   client is allowed to have several annotations on one type and how to
-   merge those annotations.
-
-   Since the ``Annotated`` type allows you to put several annotations of
-   the same (or different) type(s) on any node, the tools or libraries
-   consuming those annotations are in charge of dealing with potential
-   duplicates. For example, if you are doing value range analysis you might
-   allow this::
+   Special typing form to add context-specific metadata to an annotation.
 
-       T1 = Annotated[int, ValueRange(-10, 5)]
-       T2 = Annotated[T1, ValueRange(-20, 3)]
+   Add metadata ``x`` to a given type ``T`` by using the annotation
+   ``Annotated[T, x]``. Metadata added using ``Annotated`` can be used by
+   static analysis tools or at runtime. At runtime, the metadata is stored
+   in a :attr:`!__metadata__` attribute.
+
+   If a library or tool encounters an annotation ``Annotated[T, x]`` and has
+   no special logic for the metadata, it should ignore the metadata and simply
+   treat the annotation as ``T``. As such, ``Annotated`` can be useful for code
+   that wants to use annotations for purposes outside Python's static typing
+   system.
+
+   Using ``Annotated[T, x]`` as an annotation still allows for static
+   typechecking of ``T``, as type checkers will simply ignore the metadata ``x``.
+   In this way, ``Annotated`` differs from the
+   :func:`@no_type_check <no_type_check>` decorator, which can also be used for
+   adding annotations outside the scope of the typing system, but
+   completely disables typechecking for a function or class.
+
+   The responsibility of how to interpret the metadata
+   lies with the the tool or library encountering an
+   ``Annotated`` annotation. A tool or library encountering an ``Annotated`` type
+   can scan through the metadata elements to determine if they are of interest
+   (e.g., using :func:`isinstance`).
+
+   .. describe:: Annotated[<type>, <metadata>]
+
+   Here is an example of how you might use ``Annotated`` to add metadata to
+   type annotations if you were doing range analysis:
+
+   .. testcode::
+
+      @dataclass
+      class ValueRange:
+          lo: int
+          hi: int
 
-   Passing ``include_extras=True`` to :func:`get_type_hints` lets one
-   access the extra annotations at runtime.
+      T1 = Annotated[int, ValueRange(-10, 5)]
+      T2 = Annotated[T1, ValueRange(-20, 3)]
 
-   The details of the syntax:
+   Details of the syntax:
 
    * The first argument to ``Annotated`` must be a valid type
 
-   * Multiple type annotations are supported (``Annotated`` supports variadic
+   * Multiple metadata elements can be supplied (``Annotated`` supports variadic
      arguments)::
 
-       Annotated[int, ValueRange(3, 10), ctype("char")]
+        @dataclass
+        class ctype:
+            kind: str
+
+        Annotated[int, ValueRange(3, 10), ctype("char")]
 
-   * ``Annotated`` must be called with at least two arguments (
+     It is up to the tool consuming the annotations to decide whether the
+     client is allowed to add multiple metadata elements to one annotation and how to
+     merge those annotations.
+
+   * ``Annotated`` must be subscripted with at least two arguments (
      ``Annotated[int]`` is not valid)
 
-   * The order of the annotations is preserved and matters for equality
+   * The order of the metadata elements is preserved and matters for equality
      checks::
 
-       Annotated[int, ValueRange(3, 10), ctype("char")] != Annotated[
-           int, ctype("char"), ValueRange(3, 10)
-       ]
+        assert Annotated[int, ValueRange(3, 10), ctype("char")] != Annotated[
+            int, ctype("char"), ValueRange(3, 10)
+        ]
+
+   * Nested ``Annotated`` types are flattened. The order of the metadata elements
+     starts with the innermost annotation::
+
+        assert Annotated[Annotated[int, ValueRange(3, 10)], ctype("char")] == Annotated[
+            int, ValueRange(3, 10), ctype("char")
+        ]
+
+   * Duplicated metadata elements are not removed::
 
-   * Nested ``Annotated`` types are flattened, with metadata ordered
-     starting with the innermost annotation::
+        assert Annotated[int, ValueRange(3, 10)] != Annotated[
+            int, ValueRange(3, 10), ValueRange(3, 10)
+        ]
 
-       Annotated[Annotated[int, ValueRange(3, 10)], ctype("char")] == Annotated[
-           int, ValueRange(3, 10), ctype("char")
-       ]
+   * ``Annotated`` can be used with nested and generic aliases:
 
-   * Duplicated annotations are not removed::
+     .. testcode::
 
-       Annotated[int, ValueRange(3, 10)] != Annotated[
-           int, ValueRange(3, 10), ValueRange(3, 10)
-       ]
+        @dataclass
+        class MaxLen:
+            value: int
 
-   * ``Annotated`` can be used with nested and generic aliases::
+        T = TypeVar("T")
+        Vec: TypeAlias = Annotated[list[tuple[T, T]], MaxLen(10)]
 
-       T = TypeVar('T')
-       Vec = Annotated[list[tuple[T, T]], MaxLen(10)]
-       V = Vec[int]
+        assert Vec[int] == Annotated[list[tuple[int, int]], MaxLen(10)]
 
-       V == Annotated[list[tuple[int, int]], MaxLen(10)]
+   * ``Annotated`` cannot be used with an unpacked :class:`TypeVarTuple`::
+
+        Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid
+
+     This would be equivalent to::
+
+        Annotated[T1, T2, T3, ..., Ann1]
+
+     where ``T1``, ``T2``, etc. are :class:`TypeVars <TypeVar>`. This would be
+     invalid: only one type should be passed to Annotated.
+
+   * By default, :func:`get_type_hints` strips the metadata from annotations.
+     Pass ``include_extras=True`` to have the metadata preserved:
+
+     .. doctest::
+
+        >>> from typing import Annotated, get_type_hints
+        >>> def func(x: Annotated[int, "metadata"]) -> None: pass
+        ...
+        >>> get_type_hints(func)
+        {'x': <class 'int'>, 'return': <class 'NoneType'>}
+        >>> get_type_hints(func, include_extras=True)
+        {'x': typing.Annotated[int, 'metadata'], 'return': <class 'NoneType'>}
+
+   * At runtime, the metadata associated with an ``Annotated`` type can be
+     retrieved via the :attr:`!__metadata__` attribute:
+
+     .. doctest::
+
+        >>> from typing import Annotated
+        >>> X = Annotated[int, "very", "important", "metadata"]
+        >>> X
+        typing.Annotated[int, 'very', 'important', 'metadata']
+        >>> X.__metadata__
+        ('very', 'important', 'metadata')
+
+   .. seealso::
+
+      :pep:`593` - Flexible function and variable annotations
+         The PEP introducing ``Annotated`` to the standard library.
 
    .. versionadded:: 3.9
 
 
 .. data:: TypeGuard
 
-   Special typing form used to annotate the return type of a user-defined
+   Special typing construct for marking user-defined type guard functions.
+
+   ``TypeGuard`` can be used to annotate the return type of a user-defined
    type guard function.  ``TypeGuard`` only accepts a single type argument.
    At runtime, functions marked this way should return a boolean.
 
@@ -1226,8 +1421,9 @@ These can be used as types in annotation
 
 .. data:: Unpack
 
-   A typing operator that conceptually marks an object as having been
-   unpacked. For example, using the unpack operator ``*`` on a
+   Typing operator to conceptually mark an object as having been unpacked.
+
+   For example, using the unpack operator ``*`` on a
    :class:`type variable tuple <TypeVarTuple>` is equivalent to using ``Unpack``
    to mark the type variable tuple as having been unpacked::
 
@@ -1255,7 +1451,8 @@ These can be used as types in annotation
 Building generic types
 """"""""""""""""""""""
 
-The following objects are not used directly in annotations. Instead, they are building blocks
+The following classes should not be used directly as annotations.
+Their intended purpose is to be building blocks
 for creating generic types.
 
 .. class:: Generic
@@ -1316,10 +1513,9 @@ for creating generic types.
    Note that type variables can be *bound*, *constrained*, or neither, but
    cannot be both bound *and* constrained.
 
-   Created type variables may be explicitly marked covariant or contravariant by passing
-   ``covariant=True`` or ``contravariant=True``.
-   By default, type variables are invariant.
-   See :pep:`484` and :pep:`695` for more details.
+   Type variables may be marked covariant or contravariant by passing
+   ``covariant=True`` or ``contravariant=True``.  See :pep:`484` for more
+   details.  By default, type variables are invariant.
 
    Bound type variables and constrained type variables have different
    semantics in several important ways. Using a *bound* type variable means
@@ -1436,9 +1632,12 @@ for creating generic types.
           def __abs__(self) -> "Array[*Shape]": ...
           def get_shape(self) -> tuple[*Shape]: ...
 
-   Type variable tuples can be happily combined with normal type variables::
+   Type variable tuples can be happily combined with normal type variables:
+
+   .. testcode::
 
       DType = TypeVar('DType')
+      Shape = TypeVarTuple('Shape')
 
       class Array(Generic[DType, *Shape]):  # This is fine
           pass
@@ -1446,6 +1645,9 @@ for creating generic types.
       class Array2(Generic[*Shape, DType]):  # This would also be fine
           pass
 
+      class Height: ...
+      class Width: ...
+
       float_array_1d: Array[float, Height] = Array()     # Totally fine
       int_array_2d: Array[int, Height, Width] = Array()  # Yup, fine too
 
@@ -1562,8 +1764,9 @@ for creating generic types.
 
    .. seealso::
       * :pep:`612` -- Parameter Specification Variables (the PEP which introduced
-        ``ParamSpec`` and ``Concatenate``).
-      * :class:`Callable` and :class:`Concatenate`.
+        ``ParamSpec`` and ``Concatenate``)
+      * :data:`Concatenate`
+      * :ref:`annotating-callables`
 
 .. data:: ParamSpecArgs
 .. data:: ParamSpecKwargs
@@ -1574,11 +1777,16 @@ for creating generic types.
    for runtime introspection and have no special meaning to static type checkers.
 
    Calling :func:`get_origin` on either of these objects will return the
-   original ``ParamSpec``::
+   original ``ParamSpec``:
+
+   .. doctest::
 
-      P = ParamSpec("P")
-      get_origin(P.args)  # returns P
-      get_origin(P.kwargs)  # returns P
+      >>> from typing import ParamSpec
+      >>> P = ParamSpec("P")
+      >>> get_origin(P.args) is P
+      True
+      >>> get_origin(P.kwargs) is P
+      True
 
    .. versionadded:: 3.10
 
@@ -1586,7 +1794,9 @@ for creating generic types.
 Other special directives
 """"""""""""""""""""""""
 
-These are not used in annotations. They are building blocks for declaring types.
+These functions and classes should not be used directly as annotations.
+Their intended purpose is to be building blocks for creating and declaring
+types.
 
 .. class:: NamedTuple
 
@@ -1658,13 +1868,15 @@ These are not used in annotations. They
 
 .. class:: NewType(name, tp)
 
-   A helper class to indicate a distinct type to a typechecker,
-   see :ref:`distinct`. At runtime it returns an object that returns
-   its argument when called.
+   Helper class to create low-overhead :ref:`distinct types <distinct>`.
+
+   A ``NewType`` is considered a distinct type by a typechecker. At runtime,
+   however, calling a ``NewType`` returns its argument unchanged.
+
    Usage::
 
-      UserId = NewType('UserId', int)
-      first_user = UserId(1)
+      UserId = NewType('UserId', int)  # Declare the NewType "UserId"
+      first_user = UserId(1)  # "UserId" returns the argument unchanged at runtime
 
    .. attribute:: __module__
 
@@ -1685,7 +1897,9 @@ These are not used in annotations. They
 
 .. class:: Protocol(Generic)
 
-   Base class for protocol classes. Protocol classes are defined like this::
+   Base class for protocol classes.
+
+   Protocol classes are defined like this::
 
       class Proto(Protocol):
           def meth(self) -> int:
@@ -1746,7 +1960,7 @@ These are not used in annotations. They
         methods or attributes, not their type signatures or types.
         For example, :class:`ssl.SSLObject`
         is a class, therefore it passes an :func:`issubclass`
-        check against :data:`Callable`.  However, the
+        check against :ref:`Callable <annotating-callables>`. However, the
         ``ssl.SSLObject.__init__`` method exists only to raise a
         :exc:`TypeError` with a more informative message, therefore making
         it impossible to call (instantiate) :class:`ssl.SSLObject`.
@@ -1885,10 +2099,11 @@ These are not used in annotations. They
 
       class XZ(X, Z): pass  # raises TypeError
 
-      T = TypeVar('T')
-      class XT(X, Generic[T]): pass  # raises TypeError
+   A ``TypedDict`` can be generic:
+
+   .. testcode::
 
-   A ``TypedDict`` can be generic::
+      T = TypeVar("T")
 
       class Group(TypedDict, Generic[T]):
           key: T
@@ -1901,7 +2116,9 @@ These are not used in annotations. They
    .. attribute:: __total__
 
       ``Point2D.__total__`` gives the value of the ``total`` argument.
-      Example::
+      Example:
+
+      .. doctest::
 
          >>> from typing import TypedDict
          >>> class Point2D(TypedDict): pass
@@ -1931,7 +2148,9 @@ These are not used in annotations. They
       non-required keys in the same ``TypedDict`` . This is done by declaring a
       ``TypedDict`` with one value for the ``total`` argument and then
       inheriting from it in another ``TypedDict`` with a different value for
-      ``total``::
+      ``total``:
+
+      .. doctest::
 
          >>> class Point2D(TypedDict, total=False):
          ...     x: int
@@ -1958,488 +2177,11 @@ These are not used in annotations. They
    .. versionchanged:: 3.11
       Added support for generic ``TypedDict``\ s.
 
-Generic concrete collections
-----------------------------
-
-Corresponding to built-in types
-"""""""""""""""""""""""""""""""
-
-.. class:: Dict(dict, MutableMapping[KT, VT])
-
-   A generic version of :class:`dict`.
-   Useful for annotating return types. To annotate arguments it is preferred
-   to use an abstract collection type such as :class:`Mapping`.
-
-   This type can be used as follows::
-
-      def count_words(text: str) -> Dict[str, int]:
-          ...
-
-   .. deprecated:: 3.9
-      :class:`builtins.dict <dict>` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: List(list, MutableSequence[T])
-
-   Generic version of :class:`list`.
-   Useful for annotating return types. To annotate arguments it is preferred
-   to use an abstract collection type such as :class:`Sequence` or
-   :class:`Iterable`.
-
-   This type may be used as follows::
-
-      T = TypeVar('T', int, float)
-
-      def vec2(x: T, y: T) -> List[T]:
-          return [x, y]
-
-      def keep_positives(vector: Sequence[T]) -> List[T]:
-          return [item for item in vector if item > 0]
-
-   .. deprecated:: 3.9
-      :class:`builtins.list <list>` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Set(set, MutableSet[T])
-
-   A generic version of :class:`builtins.set <set>`.
-   Useful for annotating return types. To annotate arguments it is preferred
-   to use an abstract collection type such as :class:`AbstractSet`.
-
-   .. deprecated:: 3.9
-      :class:`builtins.set <set>` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: FrozenSet(frozenset, AbstractSet[T_co])
-
-   A generic version of :class:`builtins.frozenset <frozenset>`.
-
-   .. deprecated:: 3.9
-      :class:`builtins.frozenset <frozenset>`
-      now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. note:: :data:`Tuple` is a special form.
-
-Corresponding to types in :mod:`collections`
-""""""""""""""""""""""""""""""""""""""""""""
-
-.. class:: DefaultDict(collections.defaultdict, MutableMapping[KT, VT])
-
-   A generic version of :class:`collections.defaultdict`.
-
-   .. versionadded:: 3.5.2
-
-   .. deprecated:: 3.9
-      :class:`collections.defaultdict` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: OrderedDict(collections.OrderedDict, MutableMapping[KT, VT])
-
-   A generic version of :class:`collections.OrderedDict`.
-
-   .. versionadded:: 3.7.2
-
-   .. deprecated:: 3.9
-      :class:`collections.OrderedDict` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: ChainMap(collections.ChainMap, MutableMapping[KT, VT])
-
-   A generic version of :class:`collections.ChainMap`.
-
-   .. versionadded:: 3.5.4
-   .. versionadded:: 3.6.1
-
-   .. deprecated:: 3.9
-      :class:`collections.ChainMap` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Counter(collections.Counter, Dict[T, int])
-
-   A generic version of :class:`collections.Counter`.
-
-   .. versionadded:: 3.5.4
-   .. versionadded:: 3.6.1
-
-   .. deprecated:: 3.9
-      :class:`collections.Counter` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Deque(deque, MutableSequence[T])
-
-   A generic version of :class:`collections.deque`.
-
-   .. versionadded:: 3.5.4
-   .. versionadded:: 3.6.1
-
-   .. deprecated:: 3.9
-      :class:`collections.deque` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-Other concrete types
-""""""""""""""""""""
-
-.. class:: IO
-           TextIO
-           BinaryIO
-
-   Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])``
-   and ``BinaryIO(IO[bytes])``
-   represent the types of I/O streams such as returned by
-   :func:`open`.
-
-   .. deprecated-removed:: 3.8 3.13
-      The ``typing.io`` namespace is deprecated and will be removed.
-      These types should be directly imported from ``typing`` instead.
-
-.. class:: Pattern
-           Match
-
-   These type aliases
-   correspond to the return types from :func:`re.compile` and
-   :func:`re.match`.  These types (and the corresponding functions)
-   are generic in ``AnyStr`` and can be made specific by writing
-   ``Pattern[str]``, ``Pattern[bytes]``, ``Match[str]``, or
-   ``Match[bytes]``.
-
-   .. deprecated-removed:: 3.8 3.13
-      The ``typing.re`` namespace is deprecated and will be removed.
-      These types should be directly imported from ``typing`` instead.
-
-   .. deprecated:: 3.9
-      Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``.
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Text
-
-   ``Text`` is an alias for ``str``. It is provided to supply a forward
-   compatible path for Python 2 code: in Python 2, ``Text`` is an alias for
-   ``unicode``.
-
-   Use ``Text`` to indicate that a value must contain a unicode string in
-   a manner that is compatible with both Python 2 and Python 3::
-
-       def add_unicode_checkmark(text: Text) -> Text:
-           return text + u' \u2713'
-
-   .. versionadded:: 3.5.2
-
-   .. deprecated:: 3.11
-      Python 2 is no longer supported, and most type checkers also no longer
-      support type checking Python 2 code. Removal of the alias is not
-      currently planned, but users are encouraged to use
-      :class:`str` instead of ``Text``.
-
-Abstract Base Classes
----------------------
-
-Corresponding to collections in :mod:`collections.abc`
-""""""""""""""""""""""""""""""""""""""""""""""""""""""
-
-.. class:: AbstractSet(Collection[T_co])
-
-   A generic version of :class:`collections.abc.Set`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Set` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: ByteString(Sequence[int])
-
-   This type represents the types :class:`bytes`, :class:`bytearray`,
-   and :class:`memoryview` of byte sequences.
-
-   .. deprecated-removed:: 3.9 3.14
-      Prefer ``typing_extensions.Buffer``, or a union like ``bytes | bytearray | memoryview``.
-
-.. class:: Collection(Sized, Iterable[T_co], Container[T_co])
-
-   A generic version of :class:`collections.abc.Collection`
-
-   .. versionadded:: 3.6.0
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Collection` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Container(Generic[T_co])
-
-   A generic version of :class:`collections.abc.Container`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Container` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: ItemsView(MappingView, AbstractSet[tuple[KT_co, VT_co]])
-
-   A generic version of :class:`collections.abc.ItemsView`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.ItemsView` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: KeysView(MappingView, AbstractSet[KT_co])
-
-   A generic version of :class:`collections.abc.KeysView`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.KeysView` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Mapping(Collection[KT], Generic[KT, VT_co])
-
-   A generic version of :class:`collections.abc.Mapping`.
-   This type can be used as follows::
-
-      def get_position_in_index(word_list: Mapping[str, int], word: str) -> int:
-          return word_list[word]
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Mapping` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: MappingView(Sized)
-
-   A generic version of :class:`collections.abc.MappingView`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.MappingView` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: MutableMapping(Mapping[KT, VT])
-
-   A generic version of :class:`collections.abc.MutableMapping`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.MutableMapping`
-      now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: MutableSequence(Sequence[T])
-
-   A generic version of :class:`collections.abc.MutableSequence`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.MutableSequence`
-      now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: MutableSet(AbstractSet[T])
-
-   A generic version of :class:`collections.abc.MutableSet`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.MutableSet` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Sequence(Reversible[T_co], Collection[T_co])
-
-   A generic version of :class:`collections.abc.Sequence`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Sequence` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: ValuesView(MappingView, Collection[_VT_co])
-
-   A generic version of :class:`collections.abc.ValuesView`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.ValuesView` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-Corresponding to other types in :mod:`collections.abc`
-""""""""""""""""""""""""""""""""""""""""""""""""""""""
-
-.. class:: Iterable(Generic[T_co])
-
-   A generic version of :class:`collections.abc.Iterable`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Iterable` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Iterator(Iterable[T_co])
-
-   A generic version of :class:`collections.abc.Iterator`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Iterator` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Generator(Iterator[T_co], Generic[T_co, T_contra, V_co])
-
-   A generator can be annotated by the generic type
-   ``Generator[YieldType, SendType, ReturnType]``. For example::
-
-      def echo_round() -> Generator[int, float, str]:
-          sent = yield 0
-          while sent >= 0:
-              sent = yield round(sent)
-          return 'Done'
-
-   Note that unlike many other generics in the typing module, the ``SendType``
-   of :class:`Generator` behaves contravariantly, not covariantly or
-   invariantly.
-
-   If your generator will only yield values, set the ``SendType`` and
-   ``ReturnType`` to ``None``::
-
-      def infinite_stream(start: int) -> Generator[int, None, None]:
-          while True:
-              yield start
-              start += 1
-
-   Alternatively, annotate your generator as having a return type of
-   either ``Iterable[YieldType]`` or ``Iterator[YieldType]``::
-
-      def infinite_stream(start: int) -> Iterator[int]:
-          while True:
-              yield start
-              start += 1
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Generator` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Hashable
-
-   An alias to :class:`collections.abc.Hashable`.
-
-.. class:: Reversible(Iterable[T_co])
-
-   A generic version of :class:`collections.abc.Reversible`.
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Reversible` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Sized
-
-   An alias to :class:`collections.abc.Sized`.
-
-Asynchronous programming
-""""""""""""""""""""""""
-
-.. class:: Coroutine(Awaitable[V_co], Generic[T_co, T_contra, V_co])
-
-   A generic version of :class:`collections.abc.Coroutine`.
-   The variance and order of type variables
-   correspond to those of :class:`Generator`, for example::
-
-      from collections.abc import Coroutine
-      c: Coroutine[list[str], str, int]  # Some coroutine defined elsewhere
-      x = c.send('hi')                   # Inferred type of 'x' is list[str]
-      async def bar() -> None:
-          y = await c                    # Inferred type of 'y' is int
-
-   .. versionadded:: 3.5.3
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Coroutine` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: AsyncGenerator(AsyncIterator[T_co], Generic[T_co, T_contra])
-
-   An async generator can be annotated by the generic type
-   ``AsyncGenerator[YieldType, SendType]``. For example::
-
-      async def echo_round() -> AsyncGenerator[int, float]:
-          sent = yield 0
-          while sent >= 0.0:
-              rounded = await round(sent)
-              sent = yield rounded
-
-   Unlike normal generators, async generators cannot return a value, so there
-   is no ``ReturnType`` type parameter. As with :class:`Generator`, the
-   ``SendType`` behaves contravariantly.
-
-   If your generator will only yield values, set the ``SendType`` to
-   ``None``::
-
-      async def infinite_stream(start: int) -> AsyncGenerator[int, None]:
-          while True:
-              yield start
-              start = await increment(start)
-
-   Alternatively, annotate your generator as having a return type of
-   either ``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::
-
-      async def infinite_stream(start: int) -> AsyncIterator[int]:
-          while True:
-              yield start
-              start = await increment(start)
-
-   .. versionadded:: 3.6.1
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.AsyncGenerator`
-      now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: AsyncIterable(Generic[T_co])
-
-   A generic version of :class:`collections.abc.AsyncIterable`.
-
-   .. versionadded:: 3.5.2
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.AsyncIterable` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: AsyncIterator(AsyncIterable[T_co])
-
-   A generic version of :class:`collections.abc.AsyncIterator`.
-
-   .. versionadded:: 3.5.2
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.AsyncIterator` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: Awaitable(Generic[T_co])
-
-   A generic version of :class:`collections.abc.Awaitable`.
-
-   .. versionadded:: 3.5.2
-
-   .. deprecated:: 3.9
-      :class:`collections.abc.Awaitable` now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-
-Context manager types
-"""""""""""""""""""""
-
-.. class:: ContextManager(Generic[T_co])
-
-   A generic version of :class:`contextlib.AbstractContextManager`.
-
-   .. versionadded:: 3.5.4
-   .. versionadded:: 3.6.0
-
-   .. deprecated:: 3.9
-      :class:`contextlib.AbstractContextManager`
-      now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
-.. class:: AsyncContextManager(Generic[T_co])
-
-   A generic version of :class:`contextlib.AbstractAsyncContextManager`.
-
-   .. versionadded:: 3.5.4
-   .. versionadded:: 3.6.2
-
-   .. deprecated:: 3.9
-      :class:`contextlib.AbstractAsyncContextManager`
-      now supports subscripting (``[]``).
-      See :pep:`585` and :ref:`types-genericalias`.
-
 Protocols
 ---------
 
-These protocols are decorated with :func:`runtime_checkable`.
+The following protocols are provided by the typing module. All are decorated
+with :func:`@runtime_checkable <runtime_checkable>`.
 
 .. class:: SupportsAbs
 
@@ -2473,6 +2215,18 @@ These protocols are decorated with :func
     An ABC with one abstract method ``__round__``
     that is covariant in its return type.
 
+ABCs for working with IO
+------------------------
+
+.. class:: IO
+           TextIO
+           BinaryIO
+
+   Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])``
+   and ``BinaryIO(IO[bytes])``
+   represent the types of I/O streams such as returned by
+   :func:`open`.
+
 Functions and decorators
 ------------------------
 
@@ -2530,6 +2284,7 @@ Functions and decorators
    last case can never execute, because ``arg`` is either
    an :class:`int` or a :class:`str`, and both options are covered by
    earlier cases.
+
    If a type checker finds that a call to ``assert_never()`` is
    reachable, it will emit an error. For example, if the type annotation
    for ``arg`` was instead ``int | str | float``, the type checker would
@@ -2578,15 +2333,23 @@ Functions and decorators
 
    .. versionadded:: 3.11
 
-.. decorator:: dataclass_transform
+.. decorator:: dataclass_transform(*, eq_default=True, order_default=False, \
+                                   kw_only_default=False, \
+                                   field_specifiers=(), **kwargs)
+
+   Decorator to mark an object as providing
+   :func:`dataclass <dataclasses.dataclass>`-like behavior.
 
-   :data:`~typing.dataclass_transform` may be used to
+   ``dataclass_transform`` may be used to
    decorate a class, metaclass, or a function that is itself a decorator.
    The presence of ``@dataclass_transform()`` tells a static type checker that the
    decorated object performs runtime "magic" that
-   transforms a class, giving it :func:`dataclasses.dataclass`-like behaviors.
+   transforms a class in a similar way to
+   :func:`@dataclasses.dataclass <dataclasses.dataclass>`.
+
+   Example usage with a decorator function:
 
-   Example usage with a decorator function::
+   .. testcode::
 
       T = TypeVar("T")
 
@@ -2638,38 +2401,64 @@ Functions and decorators
    customize the default behaviors of the decorated class, metaclass, or
    function:
 
-   * ``eq_default`` indicates whether the ``eq`` parameter is assumed to be
-     ``True`` or ``False`` if it is omitted by the caller.
-   * ``order_default`` indicates whether the ``order`` parameter is
-     assumed to be True or False if it is omitted by the caller.
-   * ``kw_only_default`` indicates whether the ``kw_only`` parameter is
-     assumed to be True or False if it is omitted by the caller.
-   * ``field_specifiers`` specifies a static list of supported classes
-     or functions that describe fields, similar to ``dataclasses.field()``.
-   * Arbitrary other keyword arguments are accepted in order to allow for
-     possible future extensions.
+   :param bool eq_default:
+       Indicates whether the ``eq`` parameter is assumed to be
+       ``True`` or ``False`` if it is omitted by the caller.
+       Defaults to ``True``.
+
+   :param bool order_default:
+       Indicates whether the ``order`` parameter is
+       assumed to be ``True`` or ``False`` if it is omitted by the caller.
+       Defaults to ``False``.
+
+   :param bool kw_only_default:
+       Indicates whether the ``kw_only`` parameter is
+       assumed to be ``True`` or ``False`` if it is omitted by the caller.
+       Defaults to ``False``.
+
+   :param field_specifiers:
+       Specifies a static list of supported classes
+       or functions that describe fields, similar to :func:`dataclasses.field`.
+       Defaults to ``()``.
+   :type field_specifiers: tuple[Callable[..., Any], ...]
+
+   :param Any \**kwargs:
+       Arbitrary other keyword arguments are accepted in order to allow for
+       possible future extensions.
 
-   Type checkers recognize the following optional arguments on field
+   Type checkers recognize the following optional parameters on field
    specifiers:
 
-   * ``init`` indicates whether the field should be included in the
-     synthesized ``__init__`` method. If unspecified, ``init`` defaults to
-     ``True``.
-   * ``default`` provides the default value for the field.
-   * ``default_factory`` provides a runtime callback that returns the
-     default value for the field. If neither ``default`` nor
-     ``default_factory`` are specified, the field is assumed to have no
-     default value and must be provided a value when the class is
-     instantiated.
-   * ``factory`` is an alias for ``default_factory``.
-   * ``kw_only`` indicates whether the field should be marked as
-     keyword-only. If ``True``, the field will be keyword-only. If
-     ``False``, it will not be keyword-only. If unspecified, the value of
-     the ``kw_only`` parameter on the object decorated with
-     ``dataclass_transform`` will be used, or if that is unspecified, the
-     value of ``kw_only_default`` on ``dataclass_transform`` will be used.
-   * ``alias`` provides an alternative name for the field. This alternative
-     name is used in the synthesized ``__init__`` method.
+   .. list-table:: **Recognised parameters for field specifiers**
+      :header-rows: 1
+      :widths: 20 80
+
+      * - Parameter name
+        - Description
+      * - ``init``
+        - Indicates whether the field should be included in the
+          synthesized ``__init__`` method. If unspecified, ``init`` defaults to
+          ``True``.
+      * - ``default``
+        - Provides the default value for the field.
+      * - ``default_factory``
+        - Provides a runtime callback that returns the
+          default value for the field. If neither ``default`` nor
+          ``default_factory`` are specified, the field is assumed to have no
+          default value and must be provided a value when the class is
+          instantiated.
+      * - ``factory``
+        - An alias for the ``default_factory`` parameter on field specifiers.
+      * - ``kw_only``
+        - Indicates whether the field should be marked as
+          keyword-only. If ``True``, the field will be keyword-only. If
+          ``False``, it will not be keyword-only. If unspecified, the value of
+          the ``kw_only`` parameter on the object decorated with
+          ``dataclass_transform`` will be used, or if that is unspecified, the
+          value of ``kw_only_default`` on ``dataclass_transform`` will be used.
+      * - ``alias``
+        - Provides an alternative name for the field. This alternative
+          name is used in the synthesized ``__init__`` method.
 
    At runtime, this decorator records its arguments in the
    ``__dataclass_transform__`` attribute on the decorated object.
@@ -2681,17 +2470,25 @@ Functions and decorators
 
 .. decorator:: overload
 
+   Decorator for creating overloaded functions and methods.
+
    The ``@overload`` decorator allows describing functions and methods
    that support multiple different combinations of argument types. A series
    of ``@overload``-decorated definitions must be followed by exactly one
    non-``@overload``-decorated definition (for the same function/method).
-   The ``@overload``-decorated definitions are for the benefit of the
+
+   ``@overload``-decorated definitions are for the benefit of the
    type checker only, since they will be overwritten by the
-   non-``@overload``-decorated definition, while the latter is used at
+   non-``@overload``-decorated definition. The non-``@overload``-decorated
+   definition, meanwhile, will be used at
    runtime but should be ignored by a type checker.  At runtime, calling
-   a ``@overload``-decorated function directly will raise
-   :exc:`NotImplementedError`. An example of overload that gives a more
-   precise type than can be expressed using a union or a type variable::
+   an ``@overload``-decorated function directly will raise
+   :exc:`NotImplementedError`.
+
+   An example of overload that gives a more
+   precise type than can be expressed using a union or a type variable:
+
+   .. testcode::
 
       @overload
       def process(response: None) -> None:
@@ -2703,7 +2500,7 @@ Functions and decorators
       def process(response: bytes) -> str:
           ...
       def process(response):
-          <actual implementation>
+          ...  # actual implementation goes here
 
    See :pep:`484` for more details and comparison with other typing semantics.
 
@@ -2715,7 +2512,9 @@ Functions and decorators
 .. function:: get_overloads(func)
 
    Return a sequence of :func:`@overload <overload>`-decorated definitions for
-   *func*. *func* is the function object for the implementation of the
+   *func*.
+
+   *func* is the function object for the implementation of the
    overloaded function. For example, given the definition of ``process`` in
    the documentation for :func:`@overload <overload>`,
    ``get_overloads(process)`` will return a sequence of three function objects
@@ -2730,16 +2529,21 @@ Functions and decorators
 
 .. function:: clear_overloads()
 
-   Clear all registered overloads in the internal registry. This can be used
-   to reclaim the memory used by the registry.
+   Clear all registered overloads in the internal registry.
+
+   This can be used to reclaim the memory used by the registry.
 
    .. versionadded:: 3.11
 
 
 .. decorator:: final
 
-   A decorator to indicate to type checkers that the decorated method
-   cannot be overridden, and the decorated class cannot be subclassed.
+   Decorator to indicate final methods and final classes.
+
+   Decorating a method with ``@final`` indicates to a type checker that the
+   method cannot be overridden in a subclass. Decorating a class with ``@final``
+   indicates that it cannot be subclassed.
+
    For example::
 
       class Base:
@@ -2762,7 +2566,7 @@ Functions and decorators
    .. versionadded:: 3.8
 
    .. versionchanged:: 3.11
-      The decorator will now set the ``__final__`` attribute to ``True``
+      The decorator will now attempt to set a ``__final__`` attribute to ``True``
       on the decorated object. Thus, a check like
       ``if getattr(obj, "__final__", False)`` can be used at runtime
       to determine whether an object ``obj`` has been marked as final.
@@ -2774,11 +2578,13 @@ Functions and decorators
 
    Decorator to indicate that annotations are not type hints.
 
-   This works as class or function :term:`decorator`.  With a class, it
+   This works as a class or function :term:`decorator`.  With a class, it
    applies recursively to all methods and classes defined in that class
-   (but not to methods defined in its superclasses or subclasses).
+   (but not to methods defined in its superclasses or subclasses). Type
+   checkers will ignore all annotations in a function or class with this
+   decorator.
 
-   This mutates the function(s) in place.
+   ``@no_type_check`` mutates the decorated object in place.
 
 .. decorator:: no_type_check_decorator
 
@@ -2789,7 +2595,7 @@ Functions and decorators
 
 .. decorator:: type_check_only
 
-   Decorator to mark a class or function to be unavailable at runtime.
+   Decorator to mark a class or function as unavailable at runtime.
 
    This decorator is itself not available at runtime. It is mainly
    intended to mark classes that are defined in type stub files if
@@ -2821,14 +2627,16 @@ Introspection helpers
 
    The function recursively replaces all ``Annotated[T, ...]`` with ``T``,
    unless ``include_extras`` is set to ``True`` (see :class:`Annotated` for
-   more information). For example::
+   more information). For example:
+
+   .. testcode::
 
        class Student(NamedTuple):
            name: Annotated[str, 'some marker']
 
-       get_type_hints(Student) == {'name': str}
-       get_type_hints(Student, include_extras=False) == {'name': str}
-       get_type_hints(Student, include_extras=True) == {
+       assert get_type_hints(Student) == {'name': str}
+       assert get_type_hints(Student, include_extras=False) == {'name': str}
+       assert get_type_hints(Student, include_extras=True) == {
            'name': Annotated[str, 'some marker']
        }
 
@@ -2841,6 +2649,7 @@ Introspection helpers
 
    .. versionchanged:: 3.9
       Added ``include_extras`` parameter as part of :pep:`593`.
+      See the documentation on :data:`Annotated` for more information.
 
    .. versionchanged:: 3.11
       Previously, ``Optional[t]`` was added for function and method annotations
@@ -2850,12 +2659,17 @@ Introspection helpers
 .. function:: get_origin(tp)
 
    Get the unsubscripted version of a type: for a typing object of the form
-   ``X[Y, Z, ...]`` return ``X``. If ``X`` is a generic alias for a builtin or
-   :mod:`collections` class, it gets normalized to the original class.
+   ``X[Y, Z, ...]`` return ``X``.
+
+   If ``X`` is a typing-module alias for a builtin or
+   :mod:`collections` class, it will be normalized to the original class.
    If ``X`` is an instance of :class:`ParamSpecArgs` or :class:`ParamSpecKwargs`,
    return the underlying :class:`ParamSpec`.
    Return ``None`` for unsupported objects.
-   Examples::
+
+   Examples:
+
+   .. testcode::
 
       assert get_origin(str) is None
       assert get_origin(Dict[str, int]) is dict
@@ -2870,11 +2684,15 @@ Introspection helpers
 
    Get type arguments with all substitutions performed: for a typing object
    of the form ``X[Y, Z, ...]`` return ``(Y, Z, ...)``.
+
    If ``X`` is a union or :class:`Literal` contained in another
    generic type, the order of ``(Y, Z, ...)`` may be different from the order
    of the original arguments ``[Y, Z, ...]`` due to type caching.
    Return ``()`` for unsupported objects.
-   Examples::
+
+   Examples:
+
+   .. testcode::
 
       assert get_args(int) == ()
       assert get_args(Dict[int, str]) == (int, str)
@@ -2886,22 +2704,29 @@ Introspection helpers
 
    Check if a type is a :class:`TypedDict`.
 
-   For example::
+   For example:
+
+   .. testcode::
 
       class Film(TypedDict):
           title: str
           year: int
 
-      is_typeddict(Film)  # => True
-      is_typeddict(list | str)  # => False
+      assert is_typeddict(Film)
+      assert not is_typeddict(list | str)
+
+      # TypedDict is a factory for creating typed dicts,
+      # not a typed dict itself
+      assert not is_typeddict(TypedDict)
 
    .. versionadded:: 3.10
 
 .. class:: ForwardRef
 
-   A class used for internal typing representation of string forward references.
+   Class used for internal typing representation of string forward references.
+
    For example, ``List["SomeClass"]`` is implicitly transformed into
-   ``List[ForwardRef("SomeClass")]``.  This class should not be instantiated by
+   ``List[ForwardRef("SomeClass")]``.  ``ForwardRef`` should not be instantiated by
    a user, but may be used by introspection tools.
 
    .. note::
@@ -2917,7 +2742,9 @@ Constant
 .. data:: TYPE_CHECKING
 
    A special constant that is assumed to be ``True`` by 3rd party static
-   type checkers. It is ``False`` at runtime. Usage::
+   type checkers. It is ``False`` at runtime.
+
+   Usage::
 
       if TYPE_CHECKING:
           import expensive_mod
@@ -2940,6 +2767,556 @@ Constant
 
    .. versionadded:: 3.5.2
 
+.. _generic-concrete-collections:
+.. _deprecated-typing-aliases:
+
+Deprecated aliases
+------------------
+
+This module defines several deprecated aliases to pre-existing
+standard library classes. These were originally included in the typing
+module in order to support parameterizing these generic classes using ``[]``.
+However, the aliases became redundant in Python 3.9 when the
+corresponding pre-existing classes were enhanced to support ``[]`` (see
+:pep:`585`).
+
+The redundant types are deprecated as of Python 3.9. However, while the aliases
+may be removed at some point, removal of these aliases is not currently
+planned. As such, no deprecation warnings are currently issued by the
+interpreter for these aliases.
+
+If at some point it is decided to remove these deprecated aliases, a
+deprecation warning will be issued by the interpreter for at least two releases
+prior to removal. The aliases are guaranteed to remain in the typing module
+without deprecation warnings until at least Python 3.14.
+
+Type checkers are encouraged to flag uses of the deprecated types if the
+program they are checking targets a minimum Python version of 3.9 or newer.
+
+.. _corresponding-to-built-in-types:
+
+Aliases to built-in types
+"""""""""""""""""""""""""
+
+.. class:: Dict(dict, MutableMapping[KT, VT])
+
+   Deprecated alias to :class:`dict`.
+
+   Note that to annotate arguments, it is preferred
+   to use an abstract collection type such as :class:`Mapping`
+   rather than to use :class:`dict` or :class:`!typing.Dict`.
+
+   This type can be used as follows::
+
+      def count_words(text: str) -> Dict[str, int]:
+          ...
+
+   .. deprecated:: 3.9
+      :class:`builtins.dict <dict>` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: List(list, MutableSequence[T])
+
+   Deprecated alias to :class:`list`.
+
+   Note that to annotate arguments, it is preferred
+   to use an abstract collection type such as :class:`Sequence` or
+   :class:`Iterable` rather than to use :class:`list` or :class:`!typing.List`.
+
+   This type may be used as follows::
+
+      T = TypeVar('T', int, float)
+
+      def vec2(x: T, y: T) -> List[T]:
+          return [x, y]
+
+      def keep_positives(vector: Sequence[T]) -> List[T]:
+          return [item for item in vector if item > 0]
+
+   .. deprecated:: 3.9
+      :class:`builtins.list <list>` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Set(set, MutableSet[T])
+
+   Deprecated alias to :class:`builtins.set <set>`.
+
+   Note that to annotate arguments, it is preferred
+   to use an abstract collection type such as :class:`AbstractSet`
+   rather than to use :class:`set` or :class:`!typing.Set`.
+
+   .. deprecated:: 3.9
+      :class:`builtins.set <set>` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: FrozenSet(frozenset, AbstractSet[T_co])
+
+   Deprecated alias to :class:`builtins.frozenset <frozenset>`.
+
+   .. deprecated:: 3.9
+      :class:`builtins.frozenset <frozenset>`
+      now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. data:: Tuple
+
+   Deprecated alias for :class:`tuple`.
+
+   :class:`tuple` and ``Tuple`` are special-cased in the type system; see
+   :ref:`annotating-tuples` for more details.
+
+   .. deprecated:: 3.9
+      :class:`builtins.tuple <tuple>` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Type(Generic[CT_co])
+
+   Deprecated alias to :class:`type`.
+
+   See :ref:`type-of-class-objects` for details on using :class:`type` or
+   ``typing.Type`` in type annotations.
+
+   .. versionadded:: 3.5.2
+
+   .. deprecated:: 3.9
+      :class:`builtins.type <type>` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. _corresponding-to-types-in-collections:
+
+Aliases to types in :mod:`collections`
+""""""""""""""""""""""""""""""""""""""
+
+.. class:: DefaultDict(collections.defaultdict, MutableMapping[KT, VT])
+
+   Deprecated alias to :class:`collections.defaultdict`.
+
+   .. versionadded:: 3.5.2
+
+   .. deprecated:: 3.9
+      :class:`collections.defaultdict` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: OrderedDict(collections.OrderedDict, MutableMapping[KT, VT])
+
+   Deprecated alias to :class:`collections.OrderedDict`.
+
+   .. versionadded:: 3.7.2
+
+   .. deprecated:: 3.9
+      :class:`collections.OrderedDict` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: ChainMap(collections.ChainMap, MutableMapping[KT, VT])
+
+   Deprecated alias to :class:`collections.ChainMap`.
+
+   .. versionadded:: 3.5.4
+   .. versionadded:: 3.6.1
+
+   .. deprecated:: 3.9
+      :class:`collections.ChainMap` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Counter(collections.Counter, Dict[T, int])
+
+   Deprecated alias to :class:`collections.Counter`.
+
+   .. versionadded:: 3.5.4
+   .. versionadded:: 3.6.1
+
+   .. deprecated:: 3.9
+      :class:`collections.Counter` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Deque(deque, MutableSequence[T])
+
+   Deprecated alias to :class:`collections.deque`.
+
+   .. versionadded:: 3.5.4
+   .. versionadded:: 3.6.1
+
+   .. deprecated:: 3.9
+      :class:`collections.deque` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. _other-concrete-types:
+
+Aliases to other concrete types
+"""""""""""""""""""""""""""""""
+
+.. class:: Pattern
+           Match
+
+   Deprecated aliases corresponding to the return types from
+   :func:`re.compile` and :func:`re.match`.
+
+   These types (and the corresponding functions) are generic over
+   :data:`AnyStr`. ``Pattern`` can be specialised as ``Pattern[str]`` or
+   ``Pattern[bytes]``; ``Match`` can be specialised as ``Match[str]`` or
+   ``Match[bytes]``.
+
+   .. deprecated-removed:: 3.8 3.13
+      The ``typing.re`` namespace is deprecated and will be removed.
+      These types should be directly imported from ``typing`` instead.
+
+   .. deprecated:: 3.9
+      Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``.
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Text
+
+   Deprecated alias for :class:`str`.
+
+   ``Text`` is provided to supply a forward
+   compatible path for Python 2 code: in Python 2, ``Text`` is an alias for
+   ``unicode``.
+
+   Use ``Text`` to indicate that a value must contain a unicode string in
+   a manner that is compatible with both Python 2 and Python 3::
+
+       def add_unicode_checkmark(text: Text) -> Text:
+           return text + u' \u2713'
+
+   .. versionadded:: 3.5.2
+
+   .. deprecated:: 3.11
+      Python 2 is no longer supported, and most type checkers also no longer
+      support type checking Python 2 code. Removal of the alias is not
+      currently planned, but users are encouraged to use
+      :class:`str` instead of ``Text``.
+
+.. _abstract-base-classes:
+.. _corresponding-to-collections-in-collections-abc:
+
+Aliases to container ABCs in :mod:`collections.abc`
+"""""""""""""""""""""""""""""""""""""""""""""""""""
+
+.. class:: AbstractSet(Collection[T_co])
+
+   Deprecated alias to :class:`collections.abc.Set`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Set` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: ByteString(Sequence[int])
+
+   This type represents the types :class:`bytes`, :class:`bytearray`,
+   and :class:`memoryview` of byte sequences.
+
+   .. deprecated-removed:: 3.9 3.14
+      Prefer ``typing_extensions.Buffer``, or a union like ``bytes | bytearray | memoryview``.
+
+.. class:: Collection(Sized, Iterable[T_co], Container[T_co])
+
+   Deprecated alias to :class:`collections.abc.Collection`.
+
+   .. versionadded:: 3.6.0
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Collection` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Container(Generic[T_co])
+
+   Deprecated alias to :class:`collections.abc.Container`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Container` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: ItemsView(MappingView, AbstractSet[tuple[KT_co, VT_co]])
+
+   Deprecated alias to :class:`collections.abc.ItemsView`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.ItemsView` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: KeysView(MappingView, AbstractSet[KT_co])
+
+   Deprecated alias to :class:`collections.abc.KeysView`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.KeysView` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Mapping(Collection[KT], Generic[KT, VT_co])
+
+   Deprecated alias to :class:`collections.abc.Mapping`.
+
+   This type can be used as follows::
+
+      def get_position_in_index(word_list: Mapping[str, int], word: str) -> int:
+          return word_list[word]
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Mapping` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: MappingView(Sized)
+
+   Deprecated alias to :class:`collections.abc.MappingView`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.MappingView` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: MutableMapping(Mapping[KT, VT])
+
+   Deprecated alias to :class:`collections.abc.MutableMapping`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.MutableMapping`
+      now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: MutableSequence(Sequence[T])
+
+   Deprecated alias to :class:`collections.abc.MutableSequence`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.MutableSequence`
+      now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: MutableSet(AbstractSet[T])
+
+   Deprecated alias to :class:`collections.abc.MutableSet`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.MutableSet` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Sequence(Reversible[T_co], Collection[T_co])
+
+   Deprecated alias to :class:`collections.abc.Sequence`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Sequence` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: ValuesView(MappingView, Collection[_VT_co])
+
+   Deprecated alias to :class:`collections.abc.ValuesView`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.ValuesView` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. _asynchronous-programming:
+
+Aliases to asynchronous ABCs in :mod:`collections.abc`
+""""""""""""""""""""""""""""""""""""""""""""""""""""""
+
+.. class:: Coroutine(Awaitable[ReturnType], Generic[YieldType, SendType, ReturnType])
+
+   Deprecated alias to :class:`collections.abc.Coroutine`.
+
+   The variance and order of type variables
+   correspond to those of :class:`Generator`, for example::
+
+      from collections.abc import Coroutine
+      c: Coroutine[list[str], str, int]  # Some coroutine defined elsewhere
+      x = c.send('hi')                   # Inferred type of 'x' is list[str]
+      async def bar() -> None:
+          y = await c                    # Inferred type of 'y' is int
+
+   .. versionadded:: 3.5.3
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Coroutine` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: AsyncGenerator(AsyncIterator[YieldType], Generic[YieldType, SendType])
+
+   Deprecated alias to :class:`collections.abc.AsyncGenerator`.
+
+   An async generator can be annotated by the generic type
+   ``AsyncGenerator[YieldType, SendType]``. For example::
+
+      async def echo_round() -> AsyncGenerator[int, float]:
+          sent = yield 0
+          while sent >= 0.0:
+              rounded = await round(sent)
+              sent = yield rounded
+
+   Unlike normal generators, async generators cannot return a value, so there
+   is no ``ReturnType`` type parameter. As with :class:`Generator`, the
+   ``SendType`` behaves contravariantly.
+
+   If your generator will only yield values, set the ``SendType`` to
+   ``None``::
+
+      async def infinite_stream(start: int) -> AsyncGenerator[int, None]:
+          while True:
+              yield start
+              start = await increment(start)
+
+   Alternatively, annotate your generator as having a return type of
+   either ``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::
+
+      async def infinite_stream(start: int) -> AsyncIterator[int]:
+          while True:
+              yield start
+              start = await increment(start)
+
+   .. versionadded:: 3.6.1
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.AsyncGenerator`
+      now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: AsyncIterable(Generic[T_co])
+
+   Deprecated alias to :class:`collections.abc.AsyncIterable`.
+
+   .. versionadded:: 3.5.2
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.AsyncIterable` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: AsyncIterator(AsyncIterable[T_co])
+
+   Deprecated alias to :class:`collections.abc.AsyncIterator`.
+
+   .. versionadded:: 3.5.2
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.AsyncIterator` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Awaitable(Generic[T_co])
+
+   Deprecated alias to :class:`collections.abc.Awaitable`.
+
+   .. versionadded:: 3.5.2
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Awaitable` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. _corresponding-to-other-types-in-collections-abc:
+
+Aliases to other ABCs in :mod:`collections.abc`
+"""""""""""""""""""""""""""""""""""""""""""""""
+
+.. class:: Iterable(Generic[T_co])
+
+   Deprecated alias to :class:`collections.abc.Iterable`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Iterable` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Iterator(Iterable[T_co])
+
+   Deprecated alias to :class:`collections.abc.Iterator`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Iterator` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. data:: Callable
+
+   Deprecated alias to :class:`collections.abc.Callable`.
+
+   See :ref:`annotating-callables` for details on how to use
+   :class:`collections.abc.Callable` and ``typing.Callable`` in type annotations.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Callable` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+   .. versionchanged:: 3.10
+      ``Callable`` now supports :class:`ParamSpec` and :data:`Concatenate`.
+      See :pep:`612` for more details.
+
+.. class:: Generator(Iterator[YieldType], Generic[YieldType, SendType, ReturnType])
+
+   Deprecated alias to :class:`collections.abc.Generator`.
+
+   A generator can be annotated by the generic type
+   ``Generator[YieldType, SendType, ReturnType]``. For example::
+
+      def echo_round() -> Generator[int, float, str]:
+          sent = yield 0
+          while sent >= 0:
+              sent = yield round(sent)
+          return 'Done'
+
+   Note that unlike many other generics in the typing module, the ``SendType``
+   of :class:`Generator` behaves contravariantly, not covariantly or
+   invariantly.
+
+   If your generator will only yield values, set the ``SendType`` and
+   ``ReturnType`` to ``None``::
+
+      def infinite_stream(start: int) -> Generator[int, None, None]:
+          while True:
+              yield start
+              start += 1
+
+   Alternatively, annotate your generator as having a return type of
+   either ``Iterable[YieldType]`` or ``Iterator[YieldType]``::
+
+      def infinite_stream(start: int) -> Iterator[int]:
+          while True:
+              yield start
+              start += 1
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Generator` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Hashable
+
+   Alias to :class:`collections.abc.Hashable`.
+
+.. class:: Reversible(Iterable[T_co])
+
+   Deprecated alias to :class:`collections.abc.Reversible`.
+
+   .. deprecated:: 3.9
+      :class:`collections.abc.Reversible` now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: Sized
+
+   Alias to :class:`collections.abc.Sized`.
+
+.. _context-manager-types:
+
+Aliases to :mod:`contextlib` ABCs
+"""""""""""""""""""""""""""""""""
+
+.. class:: ContextManager(Generic[T_co])
+
+   Deprecated alias to :class:`contextlib.AbstractContextManager`.
+
+   .. versionadded:: 3.5.4
+   .. versionadded:: 3.6.0
+
+   .. deprecated:: 3.9
+      :class:`contextlib.AbstractContextManager`
+      now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
+.. class:: AsyncContextManager(Generic[T_co])
+
+   Deprecated alias to :class:`contextlib.AbstractAsyncContextManager`.
+
+   .. versionadded:: 3.5.4
+   .. versionadded:: 3.6.2
+
+   .. deprecated:: 3.9
+      :class:`contextlib.AbstractAsyncContextManager`
+      now supports subscripting (``[]``).
+      See :pep:`585` and :ref:`types-genericalias`.
+
 Deprecation Timeline of Major Features
 ======================================
 
@@ -2947,16 +3324,26 @@ Certain features in ``typing`` are depre
 version of Python. The following table summarizes major deprecations for your
 convenience. This is subject to change, and not all deprecations are listed.
 
-+----------------------------------+---------------+-------------------+----------------+
-|  Feature                         | Deprecated in | Projected removal | PEP/issue      |
-+==================================+===============+===================+================+
-|  ``typing.io`` and ``typing.re`` | 3.8           | 3.13              | :issue:`38291` |
-|  submodules                      |               |                   |                |
-+----------------------------------+---------------+-------------------+----------------+
-|  ``typing`` versions of standard | 3.9           | Undecided         | :pep:`585`     |
-|  collections                     |               |                   |                |
-+----------------------------------+---------------+-------------------+----------------+
-|  ``typing.ByteString``           | 3.9           | 3.14              | :gh:`91896`    |
-+----------------------------------+---------------+-------------------+----------------+
-|  ``typing.Text``                 | 3.11          | Undecided         | :gh:`92332`    |
-+----------------------------------+---------------+-------------------+----------------+
+.. list-table::
+   :header-rows: 1
+
+   * - Feature
+     - Deprecated in
+     - Projected removal
+     - PEP/issue
+   * - ``typing.io`` and ``typing.re`` submodules
+     - 3.8
+     - 3.13
+     - :issue:`38291`
+   * - ``typing`` versions of standard collections
+     - 3.9
+     - Undecided (see :ref:`deprecated-typing-aliases` for more information)
+     - :pep:`585`
+   * - :class:`typing.ByteString`
+     - 3.9
+     - 3.14
+     - :gh:`91896`
+   * - :data:`typing.Text`
+     - 3.11
+     - Undecided
+     - :gh:`92332`
--- a/Doc/library/unittest.mock.rst
+++ b/Doc/library/unittest.mock.rst
@@ -2436,7 +2436,7 @@ behaviour you can switch it off by setti
 
 Alternatively you can just use ``vars(my_mock)`` (instance members) and
 ``dir(type(my_mock))`` (type members) to bypass the filtering irrespective of
-:data:`mock.FILTER_DIR`.
+:const:`mock.FILTER_DIR`.
 
 
 mock_open
--- a/Doc/library/unittest.rst
+++ b/Doc/library/unittest.rst
@@ -1128,7 +1128,7 @@ Test cases
 
       If given, *level* should be either a numeric logging level or
       its string equivalent (for example either ``"ERROR"`` or
-      :attr:`logging.ERROR`).  The default is :attr:`logging.INFO`.
+      :const:`logging.ERROR`).  The default is :const:`logging.INFO`.
 
       The test passes if at least one message emitted inside the ``with``
       block matches the *logger* and *level* conditions, otherwise it fails.
@@ -1169,7 +1169,7 @@ Test cases
 
       If given, *level* should be either a numeric logging level or
       its string equivalent (for example either ``"ERROR"`` or
-      :attr:`logging.ERROR`).  The default is :attr:`logging.INFO`.
+      :const:`logging.ERROR`).  The default is :const:`logging.INFO`.
 
       Unlike :meth:`assertLogs`, nothing will be returned by the context
       manager.
--- a/Doc/library/urllib.error.rst
+++ b/Doc/library/urllib.error.rst
@@ -61,6 +61,8 @@ The following exceptions are raised by :
    This exception is raised when the :func:`~urllib.request.urlretrieve`
    function detects that
    the amount of the downloaded data is less than the expected amount (given by
-   the *Content-Length* header).  The :attr:`content` attribute stores the
-   downloaded (and supposedly truncated) data.
+   the *Content-Length* header).
 
+   .. attribute:: content
+
+      The downloaded (and supposedly truncated) data.
--- a/Doc/library/urllib.parse.rst
+++ b/Doc/library/urllib.parse.rst
@@ -23,9 +23,9 @@ to an absolute URL given a "base URL."
 The module has been designed to match the internet RFC on Relative Uniform
 Resource Locators. It supports the following URL schemes: ``file``, ``ftp``,
 ``gopher``, ``hdl``, ``http``, ``https``, ``imap``, ``mailto``, ``mms``,
-``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, ``rtspu``, ``sftp``,
-``shttp``, ``sip``, ``sips``, ``snews``, ``svn``, ``svn+ssh``, ``telnet``,
-``wais``, ``ws``, ``wss``.
+``news``, ``nntp``, ``prospero``, ``rsync``, ``rtsp``, ``rtsps``, ``rtspu``,
+``sftp``, ``shttp``, ``sip``, ``sips``, ``snews``, ``svn``, ``svn+ssh``,
+``telnet``, ``wais``, ``ws``, ``wss``.
 
 The :mod:`urllib.parse` module defines functions that fall into two broad
 categories: URL parsing and URL quoting. These are covered in detail in
--- a/Doc/library/urllib.request.rst
+++ b/Doc/library/urllib.request.rst
@@ -99,7 +99,7 @@ The :mod:`urllib.request` module defines
 
    .. versionchanged:: 3.2
       HTTPS virtual hosts are now supported if possible (that is, if
-      :data:`ssl.HAS_SNI` is true).
+      :const:`ssl.HAS_SNI` is true).
 
    .. versionadded:: 3.2
       *data* can be an iterable object.
--- a/Doc/library/venv.rst
+++ b/Doc/library/venv.rst
@@ -60,7 +60,7 @@ running from a virtual environment.
 
 A virtual environment may be "activated" using a script in its binary directory
 (``bin`` on POSIX; ``Scripts`` on Windows).
-This will prepend that directory to your :envvar:`!PATH`, so that running
+This will prepend that directory to your :envvar:`PATH`, so that running
 :program:`python` will invoke the environment's Python interpreter
 and you can run installed scripts without having to use their full path.
 The invocation of the activation script is platform-specific
@@ -100,10 +100,10 @@ In order to achieve this, scripts instal
 a "shebang" line which points to the environment's Python interpreter,
 i.e. :samp:`#!/{<path-to-venv>}/bin/python`.
 This means that the script will run with that interpreter regardless of the
-value of :envvar:`!PATH`. On Windows, "shebang" line processing is supported if
+value of :envvar:`PATH`. On Windows, "shebang" line processing is supported if
 you have the :ref:`launcher` installed. Thus, double-clicking an installed
 script in a Windows Explorer window should run it with the correct interpreter
-without the environment needing to be activated or on the :envvar:`!PATH`.
+without the environment needing to be activated or on the :envvar:`PATH`.
 
 When a virtual environment has been activated, the :envvar:`!VIRTUAL_ENV`
 environment variable is set to the path of the environment.
--- a/Doc/library/winreg.rst
+++ b/Doc/library/winreg.rst
@@ -288,7 +288,7 @@ This module offers the following functio
    table (FAT) file system, the filename may not have an extension.
 
    A call to :func:`LoadKey` fails if the calling process does not have the
-   :const:`SE_RESTORE_PRIVILEGE` privilege.  Note that privileges are different
+   :c:data:`!SE_RESTORE_PRIVILEGE` privilege.  Note that privileges are different
    from permissions -- see the `RegLoadKey documentation
    <https://msdn.microsoft.com/en-us/library/ms724889%28v=VS.85%29.aspx>`__ for
    more details.
@@ -414,7 +414,7 @@ This module offers the following functio
 
    If *key* represents a key on a remote computer, the path described by
    *file_name* is relative to the remote computer. The caller of this method must
-   possess the :const:`SeBackupPrivilege` security privilege.  Note that
+   possess the **SeBackupPrivilege** security privilege.  Note that
    privileges are different than permissions -- see the
    `Conflicts Between User Rights and Permissions documentation
    <https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx>`__
@@ -536,7 +536,7 @@ This module offers the following functio
 Constants
 ------------------
 
-The following constants are defined for use in many :mod:`_winreg` functions.
+The following constants are defined for use in many :mod:`winreg` functions.
 
 .. _hkey-constants:
 
@@ -745,7 +745,7 @@ All registry functions in this module re
 All registry functions in this module which accept a handle object also accept
 an integer, however, use of the handle object is encouraged.
 
-Handle objects provide semantics for :meth:`__bool__` -- thus ::
+Handle objects provide semantics for :meth:`~object.__bool__` -- thus ::
 
    if handle:
        print("Yes")
--- a/Doc/library/winsound.rst
+++ b/Doc/library/winsound.rst
@@ -24,7 +24,7 @@ provided by Windows platforms.  It inclu
 
 .. function:: PlaySound(sound, flags)
 
-   Call the underlying :c:func:`PlaySound` function from the Platform API.  The
+   Call the underlying :c:func:`!PlaySound` function from the Platform API.  The
    *sound* parameter may be a filename, a system sound alias, audio data as a
    :term:`bytes-like object`, or ``None``.  Its
    interpretation depends on the value of *flags*, which can be a bitwise ORed
@@ -35,7 +35,7 @@ provided by Windows platforms.  It inclu
 
 .. function:: MessageBeep(type=MB_OK)
 
-   Call the underlying :c:func:`MessageBeep` function from the Platform API.  This
+   Call the underlying :c:func:`!MessageBeep` function from the Platform API.  This
    plays a sound as specified in the registry.  The *type* argument specifies which
    sound to play; possible values are ``-1``, ``MB_ICONASTERISK``,
    ``MB_ICONEXCLAMATION``, ``MB_ICONHAND``, ``MB_ICONQUESTION``, and ``MB_OK``, all
--- a/Doc/library/xml.rst
+++ b/Doc/library/xml.rst
@@ -73,12 +73,12 @@ decompression bomb         Safe
 1. Expat 2.4.1 and newer is not vulnerable to the "billion laughs" and
    "quadratic blowup" vulnerabilities. Items still listed as vulnerable due to
    potential reliance on system-provided libraries. Check
-   :data:`pyexpat.EXPAT_VERSION`.
+   :const:`pyexpat.EXPAT_VERSION`.
 2. :mod:`xml.etree.ElementTree` doesn't expand external entities and raises a
-   :exc:`ParserError` when an entity occurs.
+   :exc:`~xml.etree.ElementTree.ParseError` when an entity occurs.
 3. :mod:`xml.dom.minidom` doesn't expand external entities and simply returns
    the unexpanded entity verbatim.
-4. :mod:`xmlrpclib` doesn't expand external entities and omits them.
+4. :mod:`xmlrpc.client` doesn't expand external entities and omits them.
 5. Since Python 3.7.1, external general entities are no longer processed by
    default.
 
@@ -119,8 +119,8 @@ all known attack vectors with examples a
 
 .. _defusedxml-package:
 
-The :mod:`defusedxml` Package
-------------------------------------------------------
+The :mod:`!defusedxml` Package
+------------------------------
 
 `defusedxml`_ is a pure Python package with modified subclasses of all stdlib
 XML parsers that prevent any potentially malicious operation. Use of this
--- a/Doc/library/xml.sax.handler.rst
+++ b/Doc/library/xml.sax.handler.rst
@@ -393,7 +393,7 @@ implements this interface, then register
 :class:`~xml.sax.xmlreader.XMLReader`, the parser
 will call the methods in your object to report all warnings and errors. There
 are three levels of errors available: warnings, (possibly) recoverable errors,
-and unrecoverable errors.  All methods take a :exc:`SAXParseException` as the
+and unrecoverable errors.  All methods take a :exc:`~xml.sax.SAXParseException` as the
 only parameter.  Errors and warnings may be converted to an exception by raising
 the passed-in exception object.
 
--- a/Doc/library/xml.sax.utils.rst
+++ b/Doc/library/xml.sax.utils.rst
@@ -87,5 +87,5 @@ or as base classes.
    reading.  The input source can be given as a string, a file-like object, or
    an :class:`~xml.sax.xmlreader.InputSource` object; parsers will use this
    function to implement the polymorphic *source* argument to their
-   :meth:`parse` method.
+   :meth:`~xml.sax.xmlreader.XMLReader.parse` method.
 
--- a/Doc/library/xmlrpc.rst
+++ b/Doc/library/xmlrpc.rst
@@ -1,5 +1,5 @@
-:mod:`xmlrpc` --- XMLRPC server and client modules
-==================================================
+:mod:`!xmlrpc` --- XMLRPC server and client modules
+===================================================
 
 XML-RPC is a Remote Procedure Call method that uses XML passed via HTTP as a
 transport.  With it, a client can call methods with parameters on a remote
--- a/Doc/license.rst
+++ b/Doc/license.rst
@@ -657,134 +657,186 @@ The modules :mod:`hashlib`, :mod:`posix`
 the OpenSSL library for added performance if made available by the
 operating system. Additionally, the Windows and macOS installers for
 Python may include a copy of the OpenSSL libraries, so we include a copy
-of the OpenSSL license here::
+of the OpenSSL license here. For the OpenSSL 3.0 release,
+and later releases derived from that, the Apache License v2 applies::
 
 
-  LICENSE ISSUES
-  ==============
+                                 Apache License
+                           Version 2.0, January 2004
+                        https://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
 
-  The OpenSSL toolkit stays under a dual license, i.e. both the conditions of
-  the OpenSSL License and the original SSLeay license apply to the toolkit.
-  See below for the actual license texts. Actually both licenses are BSD-style
-  Open Source licenses. In case of any license issues related to OpenSSL
-  please contact openssl-core@openssl.org.
-
-  OpenSSL License
-  ---------------
-
-    /* ====================================================================
-     * Copyright (c) 1998-2008 The OpenSSL Project.  All rights reserved.
-     *
-     * Redistribution and use in source and binary forms, with or without
-     * modification, are permitted provided that the following conditions
-     * are met:
-     *
-     * 1. Redistributions of source code must retain the above copyright
-     *    notice, this list of conditions and the following disclaimer.
-     *
-     * 2. Redistributions in binary form must reproduce the above copyright
-     *    notice, this list of conditions and the following disclaimer in
-     *    the documentation and/or other materials provided with the
-     *    distribution.
-     *
-     * 3. All advertising materials mentioning features or use of this
-     *    software must display the following acknowledgment:
-     *    "This product includes software developed by the OpenSSL Project
-     *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
-     *
-     * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
-     *    endorse or promote products derived from this software without
-     *    prior written permission. For written permission, please contact
-     *    openssl-core@openssl.org.
-     *
-     * 5. Products derived from this software may not be called "OpenSSL"
-     *    nor may "OpenSSL" appear in their names without prior written
-     *    permission of the OpenSSL Project.
-     *
-     * 6. Redistributions of any form whatsoever must retain the following
-     *    acknowledgment:
-     *    "This product includes software developed by the OpenSSL Project
-     *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
-     *
-     * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
-     * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-     * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
-     * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-     * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-     * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-     * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-     * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
-     * OF THE POSSIBILITY OF SUCH DAMAGE.
-     * ====================================================================
-     *
-     * This product includes cryptographic software written by Eric Young
-     * (eay@cryptsoft.com).  This product includes software written by Tim
-     * Hudson (tjh@cryptsoft.com).
-     *
-     */
-
- Original SSLeay License
- -----------------------
-
-    /* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
-     * All rights reserved.
-     *
-     * This package is an SSL implementation written
-     * by Eric Young (eay@cryptsoft.com).
-     * The implementation was written so as to conform with Netscapes SSL.
-     *
-     * This library is free for commercial and non-commercial use as long as
-     * the following conditions are aheared to.  The following conditions
-     * apply to all code found in this distribution, be it the RC4, RSA,
-     * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
-     * included with this distribution is covered by the same copyright terms
-     * except that the holder is Tim Hudson (tjh@cryptsoft.com).
-     *
-     * Copyright remains Eric Young's, and as such any Copyright notices in
-     * the code are not to be removed.
-     * If this package is used in a product, Eric Young should be given attribution
-     * as the author of the parts of the library used.
-     * This can be in the form of a textual message at program startup or
-     * in documentation (online or textual) provided with the package.
-     *
-     * Redistribution and use in source and binary forms, with or without
-     * modification, are permitted provided that the following conditions
-     * are met:
-     * 1. Redistributions of source code must retain the copyright
-     *    notice, this list of conditions and the following disclaimer.
-     * 2. Redistributions in binary form must reproduce the above copyright
-     *    notice, this list of conditions and the following disclaimer in the
-     *    documentation and/or other materials provided with the distribution.
-     * 3. All advertising materials mentioning features or use of this software
-     *    must display the following acknowledgement:
-     *    "This product includes cryptographic software written by
-     *     Eric Young (eay@cryptsoft.com)"
-     *    The word 'cryptographic' can be left out if the rouines from the library
-     *    being used are not cryptographic related :-).
-     * 4. If you include any Windows specific code (or a derivative thereof) from
-     *    the apps directory (application code) you must include an acknowledgement:
-     *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
-     *
-     * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
-     * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-     * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-     * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-     * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-     * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-     * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-     * SUCH DAMAGE.
-     *
-     * The licence and distribution terms for any publically available version or
-     * derivative of this code cannot be changed.  i.e. this code cannot simply be
-     * copied and put under another distribution licence
-     * [including the GNU Public Licence.]
-     */
+   END OF TERMS AND CONDITIONS
 
 
 expat
--- a/Doc/reference/compound_stmts.rst
+++ b/Doc/reference/compound_stmts.rst
@@ -1602,7 +1602,7 @@ body of a coroutine function.
 
       * a class that inherits from :class:`collections.abc.Sequence`
       * a Python class that has been registered as :class:`collections.abc.Sequence`
-      * a builtin class that has its (CPython) :data:`Py_TPFLAGS_SEQUENCE` bit set
+      * a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_SEQUENCE` bit set
       * a class that inherits from any of the above
 
    The following standard library classes are sequences:
@@ -1621,7 +1621,7 @@ body of a coroutine function.
 
       * a class that inherits from :class:`collections.abc.Mapping`
       * a Python class that has been registered as :class:`collections.abc.Mapping`
-      * a builtin class that has its (CPython) :data:`Py_TPFLAGS_MAPPING` bit set
+      * a builtin class that has its (CPython) :c:macro:`Py_TPFLAGS_MAPPING` bit set
       * a class that inherits from any of the above
 
    The standard library classes :class:`dict` and :class:`types.MappingProxyType`
--- a/Doc/reference/datamodel.rst
+++ b/Doc/reference/datamodel.rst
@@ -1581,9 +1581,9 @@ Basic customization
 
    Called to implement truth value testing and the built-in operation
    ``bool()``; should return ``False`` or ``True``.  When this method is not
-   defined, :meth:`__len__` is called, if it is defined, and the object is
+   defined, :meth:`~object.__len__` is called, if it is defined, and the object is
    considered true if its result is nonzero.  If a class defines neither
-   :meth:`__len__` nor :meth:`__bool__`, all its instances are considered
+   :meth:`!__len__` nor :meth:`!__bool__`, all its instances are considered
    true.
 
 
@@ -2477,16 +2477,16 @@ through the object's keys; for sequences
 
    Called to implement the built-in function :func:`len`.  Should return the length
    of the object, an integer ``>=`` 0.  Also, an object that doesn't define a
-   :meth:`__bool__` method and whose :meth:`__len__` method returns zero is
+   :meth:`~object.__bool__` method and whose :meth:`!__len__` method returns zero is
    considered to be false in a Boolean context.
 
    .. impl-detail::
 
-      In CPython, the length is required to be at most :attr:`sys.maxsize`.
-      If the length is larger than :attr:`!sys.maxsize` some features (such as
+      In CPython, the length is required to be at most :data:`sys.maxsize`.
+      If the length is larger than :data:`!sys.maxsize` some features (such as
       :func:`len`) may raise :exc:`OverflowError`.  To prevent raising
       :exc:`!OverflowError` by truth value testing, an object must define a
-      :meth:`__bool__` method.
+      :meth:`~object.__bool__` method.
 
 
 .. method:: object.__length_hint__(self)
--- a/Doc/reference/expressions.rst
+++ b/Doc/reference/expressions.rst
@@ -298,27 +298,27 @@ Dictionary displays
 .. index::
    pair: dictionary; display
    pair: dictionary; comprehensions
-   key, datum, key/datum pair
+   key, value, key/value pair
    pair: object; dictionary
    single: {} (curly brackets); dictionary expression
    single: : (colon); in dictionary expressions
    single: , (comma); in dictionary displays
 
-A dictionary display is a possibly empty series of key/datum pairs enclosed in
-curly braces:
+A dictionary display is a possibly empty series of dict items (key/value pairs)
+enclosed in curly braces:
 
 .. productionlist:: python-grammar
-   dict_display: "{" [`key_datum_list` | `dict_comprehension`] "}"
-   key_datum_list: `key_datum` ("," `key_datum`)* [","]
-   key_datum: `expression` ":" `expression` | "**" `or_expr`
+   dict_display: "{" [`dict_item_list` | `dict_comprehension`] "}"
+   dict_item_list: `dict_item` ("," `dict_item`)* [","]
+   dict_item: `expression` ":" `expression` | "**" `or_expr`
    dict_comprehension: `expression` ":" `expression` `comp_for`
 
 A dictionary display yields a new dictionary object.
 
-If a comma-separated sequence of key/datum pairs is given, they are evaluated
+If a comma-separated sequence of dict items is given, they are evaluated
 from left to right to define the entries of the dictionary: each key object is
-used as a key into the dictionary to store the corresponding datum.  This means
-that you can specify the same key multiple times in the key/datum list, and the
+used as a key into the dictionary to store the corresponding value.  This means
+that you can specify the same key multiple times in the dict item list, and the
 final dictionary's value for that key will be the last one given.
 
 .. index::
@@ -328,7 +328,7 @@ final dictionary's value for that key wi
 A double asterisk ``**`` denotes :dfn:`dictionary unpacking`.
 Its operand must be a :term:`mapping`.  Each mapping item is added
 to the new dictionary.  Later values replace values already set by
-earlier key/datum pairs and earlier dictionary unpackings.
+earlier dict items and earlier dictionary unpackings.
 
 .. versionadded:: 3.5
    Unpacking into dictionary displays, originally proposed by :pep:`448`.
@@ -344,7 +344,7 @@ in the new dictionary in the order they
 Restrictions on the types of the key values are listed earlier in section
 :ref:`types`.  (To summarize, the key type should be :term:`hashable`, which excludes
 all mutable objects.)  Clashes between duplicate keys are not detected; the last
-datum (textually rightmost in the display) stored for a given key value
+value (textually rightmost in the display) stored for a given key value
 prevails.
 
 .. versionchanged:: 3.8
@@ -740,7 +740,8 @@ which are used to control the execution
    because there is no yield expression that could receive the value.
 
 
-.. coroutinemethod:: agen.athrow(type[, value[, traceback]])
+.. coroutinemethod:: agen.athrow(value)
+                     agen.athrow(type[, value[, traceback]])
 
    Returns an awaitable that raises an exception of type ``type`` at the point
    where the asynchronous generator was paused, and returns the next value
@@ -1706,7 +1707,7 @@ control flow statements, the following v
 ``False``, ``None``, numeric zero of all types, and empty strings and containers
 (including strings, tuples, lists, dictionaries, sets and frozensets).  All
 other values are interpreted as true.  User-defined objects can customize their
-truth value by providing a :meth:`__bool__` method.
+truth value by providing a :meth:`~object.__bool__` method.
 
 .. index:: pair: operator; not
 
--- a/Doc/reference/lexical_analysis.rst
+++ b/Doc/reference/lexical_analysis.rst
@@ -757,7 +757,7 @@ is converted before formatting.  Convers
 the result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls :func:`ascii`.
 
 The result is then formatted using the :func:`format` protocol.  The
-format specifier is passed to the :meth:`__format__` method of the
+format specifier is passed to the :meth:`~object.__format__` method of the
 expression or conversion result.  An empty string is passed when the
 format specifier is omitted.  The formatted result is then included in
 the final value of the whole string.
--- a/Doc/reference/simple_stmts.rst
+++ b/Doc/reference/simple_stmts.rst
@@ -209,7 +209,7 @@ Assignment of an object to a single targ
 
   If the primary is a mapping object (such as a dictionary), the subscript must
   have a type compatible with the mapping's key type, and the mapping is then
-  asked to create a key/datum pair which maps the subscript to the assigned
+  asked to create a key/value pair which maps the subscript to the assigned
   object.  This can either replace an existing key/value pair with the same key
   value, or insert a new key/value pair (if no key with the same value existed).
 
--- a/Doc/requirements-oldest-sphinx.txt
+++ b/Doc/requirements-oldest-sphinx.txt
@@ -14,11 +14,10 @@ python-docs-theme>=2022.1
 # Docutils<0.17, Jinja2<3, and MarkupSafe<2 are additionally specified as
 # Sphinx 3.2 is incompatible with newer releases of these packages.
 
-Sphinx==3.2.1
 alabaster==0.7.13
 Babel==2.12.1
-certifi==2022.12.7
-charset-normalizer==3.1.0
+certifi==2023.7.22
+charset-normalizer==3.2.0
 colorama==0.4.6
 docutils==0.16
 idna==3.4
@@ -27,12 +26,13 @@ Jinja2==2.11.3
 MarkupSafe==1.1.1
 packaging==23.1
 Pygments==2.15.1
-requests==2.29.0
+requests==2.31.0
 snowballstemmer==2.2.0
+Sphinx==3.2.1
 sphinxcontrib-applehelp==1.0.4
 sphinxcontrib-devhelp==1.0.2
 sphinxcontrib-htmlhelp==2.0.1
 sphinxcontrib-jsmath==1.0.1
 sphinxcontrib-qthelp==1.0.3
 sphinxcontrib-serializinghtml==1.1.5
-urllib3==1.26.15
+urllib3==2.0.4
--- a/Doc/requirements.txt
+++ b/Doc/requirements.txt
@@ -15,6 +15,6 @@ sphinxext-opengraph>=0.7.1
 
 # The theme used by the documentation is stored separately, so we need
 # to install that as well.
-python-docs-theme>=2022.1
+python-docs-theme>=2023.3.1,!=2023.7
 
 -c constraints.txt
--- a/Doc/tools/extensions/pyspecific.py
+++ b/Doc/tools/extensions/pyspecific.py
@@ -14,30 +14,28 @@ import io
 from os import getenv, path
 from time import asctime
 from pprint import pformat
+
+from docutils import nodes, utils
 from docutils.io import StringOutput
 from docutils.parsers.rst import Directive
 from docutils.utils import new_document
-
-from docutils import nodes, utils
-
 from sphinx import addnodes
 from sphinx.builders import Builder
-try:
-    from sphinx.errors import NoUri
-except ImportError:
-    from sphinx.environment import NoUri
+from sphinx.domains.python import PyFunction, PyMethod
+from sphinx.errors import NoUri
 from sphinx.locale import _ as sphinx_gettext
-from sphinx.util import status_iterator, logging
+from sphinx.util import logging
 from sphinx.util.docutils import SphinxDirective
 from sphinx.util.nodes import split_explicit_title
 from sphinx.writers.text import TextWriter, TextTranslator
 from sphinx.writers.latex import LaTeXTranslator
 
 try:
-    from sphinx.domains.python import PyFunction, PyMethod
+    # Sphinx 6+
+    from sphinx.util.display import status_iterator
 except ImportError:
-    from sphinx.domains.python import PyClassmember as PyMethod
-    from sphinx.domains.python import PyModulelevel as PyFunction
+    # Deprecated in Sphinx 6.1, will be removed in Sphinx 8
+    from sphinx.util import status_iterator
 
 # Support for checking for suspicious markup
 
@@ -105,14 +103,13 @@ class ImplementationDetail(Directive):
     final_argument_whitespace = True
 
     # This text is copied to templates/dummy.html
-    label_text = 'CPython implementation detail:'
+    label_text = sphinx_gettext('CPython implementation detail:')
 
     def run(self):
         self.assert_has_content()
         pnode = nodes.compound(classes=['impl-detail'])
-        label = sphinx_gettext(self.label_text)
         content = self.content
-        add_text = nodes.strong(label, label)
+        add_text = nodes.strong(self.label_text, self.label_text)
         self.state.nested_parse(content, self.content_offset, pnode)
         content = nodes.inline(pnode[0].rawsource, translatable=True)
         content.source = pnode[0].source
@@ -187,7 +184,7 @@ class Availability(SphinxDirective):
         if unknown:
             cls = type(self)
             logger = logging.getLogger(cls.__qualname__)
-            logger.warn(
+            logger.warning(
                 f"Unknown platform(s) or syntax '{' '.join(sorted(unknown))}' "
                 f"in '.. availability:: {self.arguments[0]}', see "
                 f"{__file__}:{cls.__qualname__}.known_platforms for a set "
@@ -241,9 +238,9 @@ class AuditEvent(Directive):
     final_argument_whitespace = True
 
     _label = [
-        "Raises an :ref:`auditing event <auditing>` {name} with no arguments.",
-        "Raises an :ref:`auditing event <auditing>` {name} with argument {args}.",
-        "Raises an :ref:`auditing event <auditing>` {name} with arguments {args}.",
+        sphinx_gettext("Raises an :ref:`auditing event <auditing>` {name} with no arguments."),
+        sphinx_gettext("Raises an :ref:`auditing event <auditing>` {name} with argument {args}."),
+        sphinx_gettext("Raises an :ref:`auditing event <auditing>` {name} with arguments {args}."),
     ]
 
     @property
@@ -259,7 +256,7 @@ class AuditEvent(Directive):
         else:
             args = []
 
-        label = sphinx_gettext(self._label[min(2, len(args))])
+        label = self._label[min(2, len(args))]
         text = label.format(name="``{}``".format(name),
                             args=", ".join("``{}``".format(a) for a in args if a))
 
@@ -274,7 +271,7 @@ class AuditEvent(Directive):
         info = env.all_audit_events.setdefault(name, new_info)
         if info is not new_info:
             if not self._do_args_match(info['args'], new_info['args']):
-                self.logger.warn(
+                self.logger.warning(
                     "Mismatched arguments for audit-event {}: {!r} != {!r}"
                     .format(name, info['args'], new_info['args'])
                 )
@@ -421,8 +418,8 @@ class DeprecatedRemoved(Directive):
     final_argument_whitespace = True
     option_spec = {}
 
-    _deprecated_label = 'Deprecated since version {deprecated}, will be removed in version {removed}'
-    _removed_label = 'Deprecated since version {deprecated}, removed in version {removed}'
+    _deprecated_label = sphinx_gettext('Deprecated since version {deprecated}, will be removed in version {removed}')
+    _removed_label = sphinx_gettext('Deprecated since version {deprecated}, removed in version {removed}')
 
     def run(self):
         node = addnodes.versionmodified()
@@ -438,7 +435,6 @@ class DeprecatedRemoved(Directive):
         else:
             label = self._removed_label
 
-        label = sphinx_gettext(label)
         text = label.format(deprecated=self.arguments[0], removed=self.arguments[1])
         if len(self.arguments) == 3:
             inodes, messages = self.state.inline_text(self.arguments[2],
@@ -551,7 +547,7 @@ class PydocTopicsBuilder(Builder):
                                      'building topics... ',
                                      length=len(pydoc_topic_labels)):
             if label not in self.env.domaindata['std']['labels']:
-                self.env.logger.warn('label %r not in documentation' % label)
+                self.env.logger.warning(f'label {label!r} not in documentation')
                 continue
             docname, labelid, sectname = self.env.domaindata['std']['labels'][label]
             doctree = self.env.get_and_resolve_doctree(docname, self)
--- a/Doc/tools/templates/layout.html
+++ b/Doc/tools/templates/layout.html
@@ -4,16 +4,16 @@
 {%- if outdated %}
 <div id="outdated-warning" style="padding: .5em; text-align: center; background-color: #FFBABA; color: #6A0E0E;">
     {% trans %}This document is for an old version of Python that is no longer supported.
-    You should upgrade, and read the {% endtrans %}
-    <a href="/3/{{ pagename }}{{ file_suffix }}">{% trans %} Python documentation for the current stable release{% endtrans %}</a>.
+    You should upgrade, and read the{% endtrans %}
+    <a href="/3/{{ pagename }}{{ file_suffix }}">{% trans %}Python documentation for the current stable release{% endtrans %}</a>.
 </div>
 {%- endif %}
 
 {%- if is_deployment_preview %}
 <div id="deployment-preview-warning" style="padding: .5em; text-align: center; background-color: #fff2ba; color: #6a580e;">
   {% trans %}This is a deploy preview created from a <a href="{{ repository_url }}/pull/{{ pr_id }}">pull request</a>.
-  For authoritative documentation, see the {% endtrans %}
-  <a href="https://docs.python.org/3/{{ pagename }}{{ file_suffix }}">{% trans %} the current stable release{% endtrans %}</a>.
+  For authoritative documentation, see{% endtrans %}
+  <a href="https://docs.python.org/3/{{ pagename }}{{ file_suffix }}">{% trans %}the current stable release{% endtrans %}</a>.
 </div>
 {%- endif %}
 {% endblock %}
@@ -26,6 +26,9 @@
 {% endblock %}
 
 {% block extrahead %}
+    {% if builder == "html" %}
+      <script defer data-domain="docs.python.org" src="https://plausible.io/js/script.js"></script>
+    {% endif %}
     <link rel="canonical" href="https://docs.python.org/3/{{pagename}}.html" />
     {% if builder != "htmlhelp" %}
       {% if pagename == 'whatsnew/changelog' and not embedded %}
--- a/Doc/tools/templates/search.html
+++ b/Doc/tools/templates/search.html
@@ -1,48 +1,62 @@
 {% extends "!search.html" %}
 {% block extrahead %}
     {{ super() }}
+    <meta name="robots" content="noindex">
     <script type="text/javascript">
-        var GLOSSARY_PAGE = 'glossary.html';
+        const GLOSSARY_PAGE = 'glossary.html';
 
-        jQuery(function() {
-            $.getJSON("_static/glossary.json", function(glossary) {
-                var RESULT_TEMPLATE = '<div style="display: none" class="admonition seealso" id="glossary-result">' +
+        document.addEventListener('DOMContentLoaded', function() {
+          fetch('_static/glossary.json')
+            .then(function(response) {
+              if (response.ok) {
+                return response.json();
+              } else {
+                throw new Error('Failed to fetch glossary.json');
+              }
+            })
+            .then(function(glossary) {
+              const RESULT_TEMPLATE = '<div style="display: none" class="admonition seealso" id="glossary-result">' +
                                       '  <p class="topic-title">' +
                                       '    <a class="glossary-title" href="#"></a>' +
                                       '  </p>' +
                                       '  <div class="glossary-body"></div>' +
                                       '</div>';
-                $("#search-results").prepend(RESULT_TEMPLATE);
+              let searchResults = document.getElementById('search-results');
+              searchResults.insertAdjacentHTML('afterbegin', RESULT_TEMPLATE);
 
-                var params = $.getQueryParameters();
-                if (params.q) {
-                    var search_param = params.q[0].toLowerCase();
-                    var glossary_item = glossary[search_param];
-                    if (glossary_item) {
-                        var resultDiv = $("#glossary-result");
+              const params = new URLSearchParams(document.location.search).get("q");
+              if (params) {
+                const searchParam = params.toLowerCase();
+                const glossaryItem = glossary[searchParam];
+                if (glossaryItem) {
+                  let resultDiv = document.getElementById('glossary-result');
 
-                        // set up the title text with a link to the glossary page
-                        resultDiv.find(".glossary-title").text('Glossary: ' + glossary_item.title);
-                        var link_target = search_param.replace(/ /g, '-');
-                        resultDiv.find(".glossary-title").attr(
-                            'href', GLOSSARY_PAGE + '#term-' + link_target
-                        );
+                  // set up the title text with a link to the glossary page
+                  let glossaryTitle = resultDiv.querySelector('.glossary-title');
+                  glossaryTitle.textContent = 'Glossary: ' + glossaryItem.title;
+                  const linkTarget = searchParam.replace(/ /g, '-');
+                  glossaryTitle.href = GLOSSARY_PAGE + '#term-' + linkTarget;
 
-                        // rewrite any anchor links (to other glossary terms)
-                        // to have a full reference to the glossary page
-                        var body = $(glossary_item.body).children();
-                        body.find("a[href^='#']").each(function() {
-                            var current_url = $(this).attr('href');
-                            $(this).attr('href', GLOSSARY_PAGE + current_url);
-                        });
-                        resultDiv.find(".glossary-body").html(body);
+                  // rewrite any anchor links (to other glossary terms)
+                  // to have a full reference to the glossary page
+                  let body = document.createElement('div');
+                  body.innerHTML = glossaryItem.body;
+                  const anchorLinks = body.querySelectorAll('a[href^="#"]');
+                  anchorLinks.forEach(function(link) {
+                    const currentUrl = link.getAttribute('href');
+                    link.href = GLOSSARY_PAGE + currentUrl;
+                  });
+                  resultDiv.querySelector('.glossary-body').appendChild(body);
 
-                        resultDiv.show();
-                    } else {
-                        $("#glossary-result").hide('');
-                    }
+                  resultDiv.style.display = '';
+                } else {
+                  document.getElementById('glossary-result').style.display = 'none';
                 }
+              }
+            })
+            .catch(function(error) {
+              console.error(error);
             });
         });
     </script>
-{% endblock %}
\ No newline at end of file
+{% endblock %}
--- a/Doc/tutorial/controlflow.rst
+++ b/Doc/tutorial/controlflow.rst
@@ -4,8 +4,8 @@
 More Control Flow Tools
 ***********************
 
-Besides the :keyword:`while` statement just introduced, Python uses the usual
-flow control statements known from other languages, with some twists.
+As well as the :keyword:`while` statement just introduced, Python uses a few more
+that we will encounter in this chapter.
 
 
 .. _tut-if:
@@ -163,14 +163,21 @@ arguments.  In chapter :ref:`tut-structu
 :keyword:`!break` and :keyword:`!continue` Statements, and :keyword:`!else` Clauses on Loops
 ============================================================================================
 
-The :keyword:`break` statement, like in C, breaks out of the innermost enclosing
+The :keyword:`break` statement breaks out of the innermost enclosing
 :keyword:`for` or :keyword:`while` loop.
 
-Loop statements may have an :keyword:`!else` clause; it is executed when the loop
-terminates through exhaustion of the iterable (with :keyword:`for`) or when the
-condition becomes false (with :keyword:`while`), but not when the loop is
-terminated by a :keyword:`break` statement.  This is exemplified by the
-following loop, which searches for prime numbers::
+A :keyword:`!for` or :keyword:`!while` loop can include an :keyword:`!else` clause.
+
+In a :keyword:`for` loop, the :keyword:`!else` clause is executed
+after the loop reaches its final iteration.
+
+In a :keyword:`while` loop, it's executed after the loop's condition becomes false.
+
+In either kind of loop, the :keyword:`!else` clause is **not** executed
+if the loop was terminated by a :keyword:`break`.
+
+This is exemplified in the following :keyword:`!for` loop,
+which searches for prime numbers::
 
    >>> for n in range(2, 10):
    ...     for x in range(2, n):
@@ -307,8 +314,9 @@ you can use the class name followed by a
 constructor, but with the ability to capture attributes into variables::
 
     class Point:
-        x: int
-        y: int
+        def __init__(self, x, y):
+            self.x = x
+            self.y = y
 
     def where_is(point):
         match point:
@@ -342,7 +350,13 @@ Dotted names (like ``foo.bar``), attribu
 (recognized by the "(...)" next to them like ``Point`` above) are never assigned to.
 
 Patterns can be arbitrarily nested.  For example, if we have a short
-list of points, we could match it like this::
+list of Points, with ``__match_args__`` added, we could match it like this::
+
+    class Point:
+        __match_args__ = ('x', 'y')
+        def __init__(self, x, y):
+            self.x = x
+            self.y = y
 
     match points:
         case []:
--- a/Doc/tutorial/errors.rst
+++ b/Doc/tutorial/errors.rst
@@ -154,7 +154,7 @@ exception type.
 The *except clause* may specify a variable after the exception name.  The
 variable is bound to the exception instance which typically has an ``args``
 attribute that stores the arguments. For convenience, builtin exception
-types define :meth:`__str__` to print all the arguments without explicitly
+types define :meth:`~object.__str__` to print all the arguments without explicitly
 accessing ``.args``.  ::
 
    >>> try:
@@ -174,7 +174,7 @@ accessing ``.args``.  ::
    x = spam
    y = eggs
 
-The exception's :meth:`__str__` output is printed as the last part ('detail')
+The exception's :meth:`~object.__str__` output is printed as the last part ('detail')
 of the message for unhandled exceptions.
 
 :exc:`BaseException` is the common base class of all exceptions. One of its
@@ -535,11 +535,20 @@ of a certain type while letting all othe
 other clauses and eventually to be reraised. ::
 
    >>> def f():
-   ...     raise ExceptionGroup("group1",
-   ...                          [OSError(1),
-   ...                           SystemError(2),
-   ...                           ExceptionGroup("group2",
-   ...                                          [OSError(3), RecursionError(4)])])
+   ...     raise ExceptionGroup(
+   ...         "group1",
+   ...         [
+   ...             OSError(1),
+   ...             SystemError(2),
+   ...             ExceptionGroup(
+   ...                 "group2",
+   ...                 [
+   ...                     OSError(3),
+   ...                     RecursionError(4)
+   ...                 ]
+   ...             )
+   ...         ]
+   ...     )
    ...
    >>> try:
    ...     f()
@@ -578,6 +587,8 @@ the following pattern::
    ...
 
 
+.. _tut-exception-notes:
+
 Enriching Exceptions with Notes
 ===============================
 
--- a/Doc/tutorial/interactive.rst
+++ b/Doc/tutorial/interactive.rst
@@ -23,7 +23,7 @@ Python statement names, the current loca
 module names.  For dotted expressions such as ``string.a``, it will evaluate
 the expression up to the final ``'.'`` and then suggest completions from
 the attributes of the resulting object.  Note that this may execute
-application-defined code if an object with a :meth:`__getattr__` method
+application-defined code if an object with a :meth:`~object.__getattr__` method
 is part of the expression.  The default configuration also saves your
 history into a file named :file:`.python_history` in your user directory.
 The history will be available again during the next interactive interpreter
--- a/Doc/tutorial/introduction.rst
+++ b/Doc/tutorial/introduction.rst
@@ -52,8 +52,8 @@ Numbers
 
 The interpreter acts as a simple calculator: you can type an expression at it
 and it will write the value.  Expression syntax is straightforward: the
-operators ``+``, ``-``, ``*`` and ``/`` work just like in most other languages
-(for example, Pascal or C); parentheses (``()``) can be used for grouping.
+operators ``+``, ``-``, ``*`` and ``/`` can be used to perform
+arithmetic; parentheses (``()``) can be used for grouping.
 For example::
 
    >>> 2 + 2
@@ -138,16 +138,25 @@ and uses the ``j`` or ``J`` suffix to in
 
 .. _tut-strings:
 
-Strings
--------
+Text
+----
 
-Besides numbers, Python can also manipulate strings, which can be expressed
-in several ways.  They can be enclosed in single quotes (``'...'``) or
-double quotes (``"..."``) with the same result [#]_.  ``\`` can be used
-to escape quotes::
+Python can manipulate text (represented by type :class:`str`, so-called
+"strings") as well as numbers.  This includes characters "``!``", words
+"``rabbit``", names "``Paris``", sentences "``Got your back.``", etc.
+"``Yay! :)``". They can be enclosed in single quotes (``'...'``) or double
+quotes (``"..."``) with the same result [#]_.
 
    >>> 'spam eggs'  # single quotes
    'spam eggs'
+   >>> "Paris rabbit got your back :)! Yay!"  # double quotes
+   'Paris rabbit got your back :)! Yay!'
+   >>> '1975'  # digits and numerals enclosed in quotes are also strings
+   '1975'
+
+To quote a quote, we need to "escape" it, by preceding it with ``\``.
+Alternatively, we can use the other type of quotation marks::
+
    >>> 'doesn\'t'  # use \' to escape the single quote...
    "doesn't"
    >>> "doesn't"  # ...or use double quotes instead
@@ -159,23 +168,14 @@ to escape quotes::
    >>> '"Isn\'t," they said.'
    '"Isn\'t," they said.'
 
-In the interactive interpreter, the output string is enclosed in quotes and
-special characters are escaped with backslashes.  While this might sometimes
-look different from the input (the enclosing quotes could change), the two
-strings are equivalent.  The string is enclosed in double quotes if
-the string contains a single quote and no double quotes, otherwise it is
-enclosed in single quotes.  The :func:`print` function produces a more
-readable output, by omitting the enclosing quotes and by printing escaped
-and special characters::
+In the Python shell, the string definition and output string can look
+different.  The :func:`print` function produces a more readable output, by
+omitting the enclosing quotes and by printing escaped and special characters::
 
-   >>> '"Isn\'t," they said.'
-   '"Isn\'t," they said.'
-   >>> print('"Isn\'t," they said.')
-   "Isn't," they said.
    >>> s = 'First line.\nSecond line.'  # \n means newline
-   >>> s  # without print(), \n is included in the output
+   >>> s  # without print(), special characters are included in the string
    'First line.\nSecond line.'
-   >>> print(s)  # with print(), \n produces a new line
+   >>> print(s)  # with print(), special characters are interpreted, so \n produces new line
    First line.
    Second line.
 
--- a/Doc/tutorial/modules.rst
+++ b/Doc/tutorial/modules.rst
@@ -512,6 +512,22 @@ code::
 This would mean that ``from sound.effects import *`` would import the three
 named submodules of the :mod:`sound.effects` package.
 
+Be aware that submodules might become shadowed by locally defined names. For
+example, if you added a ``reverse`` function to the
+:file:`sound/effects/__init__.py` file, the ``from sound.effects import *``
+would only import the two submodules ``echo`` and ``surround``, but *not* the
+``reverse`` submodule, because it is shadowed by the locally defined
+``reverse`` function::
+
+    __all__ = [
+        "echo",      # refers to the 'echo.py' file
+        "surround",  # refers to the 'surround.py' file
+        "reverse",   # !!! refers to the 'reverse' function now !!!
+    ]
+
+    def reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule
+        return msg[::-1]    #     in the case of a 'from sound.effects import *'
+
 If ``__all__`` is not defined, the statement ``from sound.effects import *``
 does *not* import all submodules from the package :mod:`sound.effects` into the
 current namespace; it only ensures that the package :mod:`sound.effects` has
--- a/Doc/using/cmdline.rst
+++ b/Doc/using/cmdline.rst
@@ -883,11 +883,11 @@ conflict.
    * ``default``: use the :ref:`default memory allocators
      <default-memory-allocators>`.
    * ``malloc``: use the :c:func:`malloc` function of the C library
-     for all domains (:c:data:`PYMEM_DOMAIN_RAW`, :c:data:`PYMEM_DOMAIN_MEM`,
-     :c:data:`PYMEM_DOMAIN_OBJ`).
+     for all domains (:c:macro:`PYMEM_DOMAIN_RAW`, :c:macro:`PYMEM_DOMAIN_MEM`,
+     :c:macro:`PYMEM_DOMAIN_OBJ`).
    * ``pymalloc``: use the :ref:`pymalloc allocator <pymalloc>` for
-     :c:data:`PYMEM_DOMAIN_MEM` and :c:data:`PYMEM_DOMAIN_OBJ` domains and use
-     the :c:func:`malloc` function for the :c:data:`PYMEM_DOMAIN_RAW` domain.
+     :c:macro:`PYMEM_DOMAIN_MEM` and :c:macro:`PYMEM_DOMAIN_OBJ` domains and use
+     the :c:func:`malloc` function for the :c:macro:`PYMEM_DOMAIN_RAW` domain.
 
    Install :ref:`debug hooks <pymem-debug-hooks>`:
 
--- a/Doc/using/configure.rst
+++ b/Doc/using/configure.rst
@@ -62,7 +62,7 @@ General Options
 
 .. cmdoption:: --with-tzpath=<list of absolute paths separated by pathsep>
 
-   Select the default time zone search path for :data:`zoneinfo.TZPATH`.
+   Select the default time zone search path for :const:`zoneinfo.TZPATH`.
    See the :ref:`Compile-time configuration
    <zoneinfo_data_compile_time_config>` of the :mod:`zoneinfo` module.
 
@@ -77,7 +77,7 @@ General Options
    Build the ``_decimal`` extension module using a thread-local context rather
    than a coroutine-local context (default), see the :mod:`decimal` module.
 
-   See :data:`decimal.HAVE_CONTEXTVAR` and the :mod:`contextvars` module.
+   See :const:`decimal.HAVE_CONTEXTVAR` and the :mod:`contextvars` module.
 
    .. versionadded:: 3.9
 
--- a/Doc/using/windows.rst
+++ b/Doc/using/windows.rst
@@ -1188,7 +1188,7 @@ non-standard paths in the registry and u
       Modules specified in the registry under ``Modules`` (not ``PythonPath``)
       may be imported by :class:`importlib.machinery.WindowsRegistryFinder`.
       This finder is enabled on Windows in 3.6.0 and earlier, but may need to
-      be explicitly added to :attr:`sys.meta_path` in the future.
+      be explicitly added to :data:`sys.meta_path` in the future.
 
 Additional modules
 ==================
--- a/Include/cpython/modsupport.h
+++ b/Include/cpython/modsupport.h
@@ -103,5 +103,6 @@ PyAPI_FUNC(PyObject * const *) _PyArg_Un
                            (minpos), (maxpos), (minkw), (buf)))
 
 PyAPI_FUNC(PyObject *) _PyModule_CreateInitialized(PyModuleDef*, int apiver);
+PyAPI_FUNC(int) _PyModule_Add(PyObject *, const char *, PyObject *);
 
 PyAPI_DATA(const char *) _Py_PackageContext;
--- a/Include/modsupport.h
+++ b/Include/modsupport.h
@@ -41,10 +41,12 @@ PyAPI_FUNC(PyObject *) _Py_BuildValue_Si
 
 PyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);
 
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030a0000
 // Add an attribute with name 'name' and value 'obj' to the module 'mod.
 // On success, return 0 on success.
 // On error, raise an exception and return -1.
 PyAPI_FUNC(int) PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value);
+#endif   /* Py_LIMITED_API */
 
 // Similar to PyModule_AddObjectRef() but steal a reference to 'obj'
 // (Py_DECREF(obj)) on success (if it returns 0).
--- a/Include/patchlevel.h
+++ b/Include/patchlevel.h
@@ -23,7 +23,7 @@
 #define PY_RELEASE_SERIAL       0
 
 /* Version as a string */
-#define PY_VERSION              "3.11.4"
+#define PY_VERSION              "3.11.4+"
 /*--end constants--*/
 
 /* Version as a single 4-byte hex number, e.g. 0x010502B2 == 1.5.2b2.
--- a/Lib/asyncio/base_events.py
+++ b/Lib/asyncio/base_events.py
@@ -716,7 +716,7 @@ class BaseEventLoop(events.AbstractEvent
         always relative to the current time.
 
         Each callback will be called exactly once.  If two callbacks
-        are scheduled for exactly the same time, it undefined which
+        are scheduled for exactly the same time, it is undefined which
         will be called first.
 
         Any positional arguments after the callback will be passed to
--- a/Lib/asyncio/events.py
+++ b/Lib/asyncio/events.py
@@ -613,7 +613,7 @@ class AbstractEventLoopPolicy:
     def get_event_loop(self):
         """Get the event loop for the current context.
 
-        Returns an event loop object implementing the BaseEventLoop interface,
+        Returns an event loop object implementing the AbstractEventLoop interface,
         or raises an exception in case no event loop has been set for the
         current context and the current policy does not specify to create one.
 
--- a/Lib/colorsys.py
+++ b/Lib/colorsys.py
@@ -83,7 +83,7 @@ def rgb_to_hls(r, g, b):
     if l <= 0.5:
         s = rangec / sumc
     else:
-        s = rangec / (2.0-sumc)
+        s = rangec / (2.0-maxc-minc)  # Not always 2.0-sumc: gh-106498.
     rc = (maxc-r) / rangec
     gc = (maxc-g) / rangec
     bc = (maxc-b) / rangec
--- a/Lib/concurrent/futures/process.py
+++ b/Lib/concurrent/futures/process.py
@@ -497,6 +497,10 @@ class _ExecutorManagerThread(threading.T
         for p in self.processes.values():
             p.terminate()
 
+        # Prevent queue writing to a pipe which is no longer read.
+        # https://github.com/python/cpython/issues/94777
+        self.call_queue._reader.close()
+
         # clean up resources
         self.join_executor_internals()
 
--- a/Lib/configparser.py
+++ b/Lib/configparser.py
@@ -59,7 +59,7 @@ ConfigParser -- responsible for parsing
         instance. It will be used as the handler for option value
         pre-processing when using getters. RawConfigParser objects don't do
         any sort of interpolation, whereas ConfigParser uses an instance of
-        BasicInterpolation. The library also provides a ``zc.buildbot``
+        BasicInterpolation. The library also provides a ``zc.buildout``
         inspired ExtendedInterpolation implementation.
 
         When `converters` is given, it should be a dictionary where each key
--- a/Lib/ctypes/test/test_as_parameter.py
+++ b/Lib/ctypes/test/test_as_parameter.py
@@ -194,7 +194,7 @@ class BasicWrapTestCase(unittest.TestCas
     def test_recursive_as_param(self):
         from ctypes import c_int
 
-        class A(object):
+        class A:
             pass
 
         a = A()
@@ -205,7 +205,7 @@ class BasicWrapTestCase(unittest.TestCas
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-class AsParamWrapper(object):
+class AsParamWrapper:
     def __init__(self, param):
         self._as_parameter_ = param
 
@@ -214,7 +214,7 @@ class AsParamWrapperTestCase(BasicWrapTe
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-class AsParamPropertyWrapper(object):
+class AsParamPropertyWrapper:
     def __init__(self, param):
         self._param = param
 
--- a/Lib/ctypes/test/test_byteswap.py
+++ b/Lib/ctypes/test/test_byteswap.py
@@ -14,14 +14,6 @@ def bin(s):
 # For Structures and Unions, these types are created on demand.
 
 class Test(unittest.TestCase):
-    @unittest.skip('test disabled')
-    def test_X(self):
-        print(sys.byteorder, file=sys.stderr)
-        for i in range(32):
-            bits = BITS()
-            setattr(bits, "i%s" % i, 1)
-            dump(bits)
-
     def test_slots(self):
         class BigPoint(BigEndianStructure):
             __slots__ = ()
--- a/Lib/ctypes/test/test_callbacks.py
+++ b/Lib/ctypes/test/test_callbacks.py
@@ -93,14 +93,6 @@ class Callbacks(unittest.TestCase):
         self.check_type(c_char, b"x")
         self.check_type(c_char, b"a")
 
-    # disabled: would now (correctly) raise a RuntimeWarning about
-    # a memory leak.  A callback function cannot return a non-integral
-    # C type without causing a memory leak.
-    @unittest.skip('test disabled')
-    def test_char_p(self):
-        self.check_type(c_char_p, "abc")
-        self.check_type(c_char_p, "def")
-
     def test_pyobject(self):
         o = ()
         from sys import getrefcount as grc
@@ -130,7 +122,7 @@ class Callbacks(unittest.TestCase):
     def test_issue_7959(self):
         proto = self.functype.__func__(None)
 
-        class X(object):
+        class X:
             def func(self): pass
             def __init__(self):
                 self.v = proto(self.func)
--- a/Lib/ctypes/test/test_keeprefs.py
+++ b/Lib/ctypes/test/test_keeprefs.py
@@ -93,37 +93,33 @@ class PointerTestCase(unittest.TestCase)
         x = pointer(i)
         self.assertEqual(x._objects, {'1': i})
 
-class DeletePointerTestCase(unittest.TestCase):
-    @unittest.skip('test disabled')
-    def test_X(self):
-        class X(Structure):
-            _fields_ = [("p", POINTER(c_char_p))]
-        x = X()
-        i = c_char_p("abc def")
-        from sys import getrefcount as grc
-        print("2?", grc(i))
-        x.p = pointer(i)
-        print("3?", grc(i))
-        for i in range(320):
-            c_int(99)
-            x.p[0]
-        print(x.p[0])
-##        del x
-##        print "2?", grc(i)
-##        del i
-        import gc
-        gc.collect()
-        for i in range(320):
-            c_int(99)
-            x.p[0]
-        print(x.p[0])
-        print(x.p.contents)
-##        print x._objects
-
-        x.p[0] = "spam spam"
-##        print x.p[0]
-        print("+" * 42)
-        print(x._objects)
+    def test_pp_ownership(self):
+        d = c_int(123)
+        n = c_int(456)
+
+        p = pointer(d)
+        pp = pointer(p)
+
+        self.assertIs(pp._objects['1'], p)
+        self.assertIs(pp._objects['0']['1'], d)
+
+        pp.contents.contents = n
+
+        self.assertIs(pp._objects['1'], p)
+        self.assertIs(pp._objects['0']['1'], n)
+
+        self.assertIs(p._objects['1'], n)
+        self.assertEqual(len(p._objects), 1)
+
+        del d
+        del p
+
+        self.assertIs(pp._objects['0']['1'], n)
+        self.assertEqual(len(pp._objects), 2)
+
+        del n
+
+        self.assertEqual(len(pp._objects), 2)
 
 class PointerToStructure(unittest.TestCase):
     def test(self):
--- a/Lib/ctypes/test/test_numbers.py
+++ b/Lib/ctypes/test/test_numbers.py
@@ -82,14 +82,6 @@ class NumberTestCase(unittest.TestCase):
             self.assertRaises(TypeError, t, "")
             self.assertRaises(TypeError, t, None)
 
-    @unittest.skip('test disabled')
-    def test_valid_ranges(self):
-        # invalid values of the correct type
-        # raise ValueError (not OverflowError)
-        for t, (l, h) in zip(unsigned_types, unsigned_ranges):
-            self.assertRaises(ValueError, t, l-1)
-            self.assertRaises(ValueError, t, h+1)
-
     def test_from_param(self):
         # the from_param class method attribute always
         # returns PyCArgObject instances
@@ -106,7 +98,7 @@ class NumberTestCase(unittest.TestCase):
     def test_floats(self):
         # c_float and c_double can be created from
         # Python int and float
-        class FloatLike(object):
+        class FloatLike:
             def __float__(self):
                 return 2.0
         f = FloatLike()
@@ -117,15 +109,15 @@ class NumberTestCase(unittest.TestCase):
             self.assertEqual(t(f).value, 2.0)
 
     def test_integers(self):
-        class FloatLike(object):
+        class FloatLike:
             def __float__(self):
                 return 2.0
         f = FloatLike()
-        class IntLike(object):
+        class IntLike:
             def __int__(self):
                 return 2
         d = IntLike()
-        class IndexLike(object):
+        class IndexLike:
             def __index__(self):
                 return 2
         i = IndexLike()
@@ -205,19 +197,6 @@ class NumberTestCase(unittest.TestCase):
         a[0] = ord('?')
         self.assertEqual(v.value, b'?')
 
-    # array does not support c_bool / 't'
-    @unittest.skip('test disabled')
-    def test_bool_from_address(self):
-        from ctypes import c_bool
-        from array import array
-        a = array(c_bool._type_, [True])
-        v = t.from_address(a.buffer_info()[0])
-        self.assertEqual(v.value, a[0])
-        self.assertEqual(type(v) is t)
-        a[0] = False
-        self.assertEqual(v.value, a[0])
-        self.assertEqual(type(v) is t)
-
     def test_init(self):
         # c_int() can be initialized from Python's int, and c_int.
         # Not from c_long or so, which seems strange, abc should
@@ -234,62 +213,6 @@ class NumberTestCase(unittest.TestCase):
             if (hasattr(t, "__ctype_le__")):
                 self.assertRaises(OverflowError, t.__ctype_le__, big_int)
 
-    @unittest.skip('test disabled')
-    def test_perf(self):
-        check_perf()
-
-from ctypes import _SimpleCData
-class c_int_S(_SimpleCData):
-    _type_ = "i"
-    __slots__ = []
-
-def run_test(rep, msg, func, arg=None):
-##    items = [None] * rep
-    items = range(rep)
-    from time import perf_counter as clock
-    if arg is not None:
-        start = clock()
-        for i in items:
-            func(arg); func(arg); func(arg); func(arg); func(arg)
-        stop = clock()
-    else:
-        start = clock()
-        for i in items:
-            func(); func(); func(); func(); func()
-        stop = clock()
-    print("%15s: %.2f us" % (msg, ((stop-start)*1e6/5/rep)))
-
-def check_perf():
-    # Construct 5 objects
-    from ctypes import c_int
-
-    REP = 200000
-
-    run_test(REP, "int()", int)
-    run_test(REP, "int(999)", int)
-    run_test(REP, "c_int()", c_int)
-    run_test(REP, "c_int(999)", c_int)
-    run_test(REP, "c_int_S()", c_int_S)
-    run_test(REP, "c_int_S(999)", c_int_S)
-
-# Python 2.3 -OO, win2k, P4 700 MHz:
-#
-#          int(): 0.87 us
-#       int(999): 0.87 us
-#        c_int(): 3.35 us
-#     c_int(999): 3.34 us
-#      c_int_S(): 3.23 us
-#   c_int_S(999): 3.24 us
-
-# Python 2.2 -OO, win2k, P4 700 MHz:
-#
-#          int(): 0.89 us
-#       int(999): 0.89 us
-#        c_int(): 9.99 us
-#     c_int(999): 10.02 us
-#      c_int_S(): 9.87 us
-#   c_int_S(999): 9.85 us
 
 if __name__ == '__main__':
-##    check_perf()
     unittest.main()
--- a/Lib/ctypes/test/test_parameters.py
+++ b/Lib/ctypes/test/test_parameters.py
@@ -145,7 +145,7 @@ class SimpleTypesTestCase(unittest.TestC
         # TypeError: has no from_param method
         self.assertRaises(TypeError, setattr, func, "argtypes", (object,))
 
-        class Adapter(object):
+        class Adapter:
             def from_param(cls, obj):
                 return None
 
@@ -153,7 +153,7 @@ class SimpleTypesTestCase(unittest.TestC
         self.assertEqual(func(None), None)
         self.assertEqual(func(object()), None)
 
-        class Adapter(object):
+        class Adapter:
             def from_param(cls, obj):
                 return obj
 
@@ -162,7 +162,7 @@ class SimpleTypesTestCase(unittest.TestC
         self.assertRaises(ArgumentError, func, object())
         self.assertEqual(func(c_void_p(42)), 42)
 
-        class Adapter(object):
+        class Adapter:
             def from_param(cls, obj):
                 raise ValueError(obj)
 
--- a/Lib/ctypes/test/test_structures.py
+++ b/Lib/ctypes/test/test_structures.py
@@ -359,15 +359,6 @@ class StructureTestCase(unittest.TestCas
         except Exception as detail:
             return detail.__class__, str(detail)
 
-    @unittest.skip('test disabled')
-    def test_subclass_creation(self):
-        meta = type(Structure)
-        # same as 'class X(Structure): pass'
-        # fails, since we need either a _fields_ or a _abstract_ attribute
-        cls, msg = self.get_except(meta, "X", (Structure,), {})
-        self.assertEqual((cls, msg),
-                (AttributeError, "class must define a '_fields_' attribute"))
-
     def test_abstract_class(self):
         class X(Structure):
             _abstract_ = "something"
--- a/Lib/email/feedparser.py
+++ b/Lib/email/feedparser.py
@@ -189,7 +189,7 @@ class FeedParser:
         assert not self._msgstack
         # Look for final set of defects
         if root.get_content_maintype() == 'multipart' \
-               and not root.is_multipart():
+               and not root.is_multipart() and not self._headersonly:
             defect = errors.MultipartInvariantViolationDefect()
             self.policy.handle_defect(root, defect)
         return root
--- a/Lib/enum.py
+++ b/Lib/enum.py
@@ -12,6 +12,7 @@ __all__ = [
         'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',
         'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',
         'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',
+        'pickle_by_global_name', 'pickle_by_enum_name',
         ]
 
 
@@ -918,7 +919,6 @@ class EnumType(type):
         body['__module__'] = module
         tmp_cls = type(name, (object, ), body)
         cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)
-        cls.__reduce_ex__ = _reduce_ex_by_global_name
         if as_global:
             global_enum(cls)
         else:
@@ -1225,7 +1225,13 @@ class Enum(metaclass=EnumType):
         return hash(self._name_)
 
     def __reduce_ex__(self, proto):
-        return getattr, (self.__class__, self._name_)
+        return self.__class__, (self._value_, )
+
+    def __deepcopy__(self,memo):
+        return self
+
+    def __copy__(self):
+        return self
 
     # enum.property is used to provide access to the `name` and
     # `value` attributes of enum members while keeping some measure of
@@ -1291,8 +1297,14 @@ class StrEnum(str, ReprEnum):
         return name.lower()
 
 
-def _reduce_ex_by_global_name(self, proto):
+def pickle_by_global_name(self, proto):
+    # should not be used with Flag-type enums
     return self.name
+_reduce_ex_by_global_name = pickle_by_global_name
+
+def pickle_by_enum_name(self, proto):
+    # should not be used with Flag-type enums
+    return getattr, (self.__class__, self._name_)
 
 class FlagBoundary(StrEnum):
     """
@@ -1314,23 +1326,6 @@ class Flag(Enum, boundary=STRICT):
     Support for flags
     """
 
-    def __reduce_ex__(self, proto):
-        cls = self.__class__
-        unknown = self._value_ & ~cls._flag_mask_
-        member_value = self._value_ & cls._flag_mask_
-        if unknown and member_value:
-            return _or_, (cls(member_value), unknown)
-        for val in _iter_bits_lsb(member_value):
-            rest = member_value & ~val
-            if rest:
-                return _or_, (cls(rest), cls._value2member_map_.get(val))
-            else:
-                break
-        if self._name_ is None:
-            return cls, (self._value_,)
-        else:
-            return getattr, (cls, self._name_)
-
     _numeric_repr_ = repr
 
     def _generate_next_value_(name, start, count, last_values):
@@ -1457,12 +1452,11 @@ class Flag(Enum, boundary=STRICT):
         else:
             pseudo_member._name_ = None
         # use setdefault in case another thread already created a composite
-        # with this value, but only if all members are known
-        # note: zero is a special case -- add it
-        if not unknown:
-            pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
-            if neg_value is not None:
-                cls._value2member_map_[neg_value] = pseudo_member
+        # with this value
+        # note: zero is a special case -- always add it
+        pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
+        if neg_value is not None:
+            cls._value2member_map_[neg_value] = pseudo_member
         return pseudo_member
 
     def __contains__(self, other):
@@ -1534,14 +1528,10 @@ class Flag(Enum, boundary=STRICT):
 
     def __invert__(self):
         if self._inverted_ is None:
-            if self._boundary_ is KEEP:
-                # use all bits
+            if self._boundary_ in (EJECT, KEEP):
                 self._inverted_ = self.__class__(~self._value_)
             else:
-                # calculate flags not in this member
-                self._inverted_ = self.__class__(self._flag_mask_ ^ self._value_)
-            if isinstance(self._inverted_, self.__class__):
-                self._inverted_._inverted_ = self
+                self._inverted_ = self.__class__(self._singles_mask_ & ~self._value_)
         return self._inverted_
 
     __rand__ = __and__
@@ -2047,7 +2037,6 @@ def _old_convert_(etype, name, module, f
         # unless some values aren't comparable, in which case sort by name
         members.sort(key=lambda t: t[0])
     cls = etype(name, members, module=module, boundary=boundary or KEEP)
-    cls.__reduce_ex__ = _reduce_ex_by_global_name
     return cls
 
 _stdlib_enums = IntEnum, StrEnum, IntFlag
--- a/Lib/gettext.py
+++ b/Lib/gettext.py
@@ -444,10 +444,12 @@ class GNUTranslations(NullTranslations):
         missing = object()
         tmsg = self._catalog.get(ctxt_msg_id, missing)
         if tmsg is missing:
-            if self._fallback:
-                return self._fallback.pgettext(context, message)
-            return message
-        return tmsg
+            tmsg = self._catalog.get((ctxt_msg_id, self.plural(1)), missing)
+        if tmsg is not missing:
+            return tmsg
+        if self._fallback:
+            return self._fallback.pgettext(context, message)
+        return message
 
     def npgettext(self, context, msgid1, msgid2, n):
         ctxt_msg_id = self.CONTEXT % (context, msgid1)
--- a/Lib/idlelib/idle_test/test_stackviewer.py
+++ b/Lib/idlelib/idle_test/test_stackviewer.py
@@ -6,19 +6,12 @@ from test.support import requires
 from tkinter import Tk
 
 from idlelib.tree import TreeNode, ScrolledCanvas
-import sys
 
 
 class StackBrowserTest(unittest.TestCase):
 
     @classmethod
     def setUpClass(cls):
-        svs = stackviewer.sys
-        try:
-            abc
-        except NameError:
-            svs.last_type, svs.last_value, svs.last_traceback = (
-                sys.exc_info())
 
         requires('gui')
         cls.root = Tk()
@@ -26,8 +19,6 @@ class StackBrowserTest(unittest.TestCase
 
     @classmethod
     def tearDownClass(cls):
-        svs = stackviewer.sys
-        del svs.last_traceback, svs.last_type, svs.last_value
 
         cls.root.update_idletasks()
 ##        for id in cls.root.tk.call('after', 'info'):
@@ -36,7 +27,10 @@ class StackBrowserTest(unittest.TestCase
         del cls.root
 
     def test_init(self):
-        sb = stackviewer.StackBrowser(self.root)
+        try:
+            abc
+        except NameError as exc:
+            sb = stackviewer.StackBrowser(self.root, exc)
         isi = self.assertIsInstance
         isi(stackviewer.sc, ScrolledCanvas)
         isi(stackviewer.item, stackviewer.StackTreeItem)
--- a/Lib/idlelib/pyshell.py
+++ b/Lib/idlelib/pyshell.py
@@ -1363,19 +1363,19 @@ class PyShell(OutputWindow):
                 self.text.tag_remove(self.user_input_insert_tags, index_before)
             self.shell_sidebar.update_sidebar()
 
-    def open_stack_viewer(self, event=None):
+    def open_stack_viewer(self, event=None):  # -n mode only
         if self.interp.rpcclt:
             return self.interp.remote_stack_viewer()
+
+        from idlelib.stackviewer import StackBrowser
         try:
-            sys.last_traceback
+            StackBrowser(self.root, sys.last_value, self.flist)
         except:
             messagebox.showerror("No stack trace",
                 "There is no stack trace yet.\n"
-                "(sys.last_traceback is not defined)",
+                "(sys.last_value is not defined)",
                 parent=self.text)
-            return
-        from idlelib.stackviewer import StackBrowser
-        StackBrowser(self.root, self.flist)
+        return None
 
     def view_restart_mark(self, event=None):
         self.text.see("iomark")
--- a/Lib/idlelib/run.py
+++ b/Lib/idlelib/run.py
@@ -140,11 +140,12 @@ def main(del_exitfunc=False):
 
     capture_warnings(True)
     sys.argv[:] = [""]
-    sockthread = threading.Thread(target=manage_socket,
-                                  name='SockThread',
-                                  args=((LOCALHOST, port),))
-    sockthread.daemon = True
-    sockthread.start()
+    threading.Thread(target=manage_socket,
+                     name='SockThread',
+                     args=((LOCALHOST, port),),
+                     daemon=True,
+                    ).start()
+
     while True:
         try:
             if exit_now:
@@ -621,7 +622,7 @@ class Executive:
 
     def stackviewer(self, flist_oid=None):
         if self.user_exc_info:
-            typ, val, tb = self.user_exc_info
+            _, exc, tb = self.user_exc_info
         else:
             return None
         flist = None
@@ -629,9 +630,8 @@ class Executive:
             flist = self.rpchandler.get_remote_proxy(flist_oid)
         while tb and tb.tb_frame.f_globals["__name__"] in ["rpc", "run"]:
             tb = tb.tb_next
-        sys.last_type = typ
-        sys.last_value = val
-        item = stackviewer.StackTreeItem(flist, tb)
+        exc.__traceback__ = tb
+        item = stackviewer.StackTreeItem(exc, flist)
         return debugobj_r.remote_object_tree_item(item)
 
 
--- a/Lib/idlelib/stackviewer.py
+++ b/Lib/idlelib/stackviewer.py
@@ -1,33 +1,30 @@
 import linecache
 import os
-import sys
 
 import tkinter as tk
 
 from idlelib.debugobj import ObjectTreeItem, make_objecttreeitem
 from idlelib.tree import TreeNode, TreeItem, ScrolledCanvas
 
-def StackBrowser(root, flist=None, tb=None, top=None):
+def StackBrowser(root, exc, flist=None, top=None):
     global sc, item, node  # For testing.
     if top is None:
         top = tk.Toplevel(root)
     sc = ScrolledCanvas(top, bg="white", highlightthickness=0)
     sc.frame.pack(expand=1, fill="both")
-    item = StackTreeItem(flist, tb)
+    item = StackTreeItem(exc, flist)
     node = TreeNode(sc.canvas, None, item)
     node.expand()
 
 
 class StackTreeItem(TreeItem):
 
-    def __init__(self, flist=None, tb=None):
+    def __init__(self, exc, flist=None):
         self.flist = flist
-        self.stack = self.get_stack(tb)
-        self.text = self.get_exception()
+        self.stack = self.get_stack(None if exc is None else exc.__traceback__)
+        self.text = f"{type(exc).__name__}: {str(exc)}"
 
     def get_stack(self, tb):
-        if tb is None:
-            tb = sys.last_traceback
         stack = []
         if tb and tb.tb_frame is None:
             tb = tb.tb_next
@@ -36,17 +33,7 @@ class StackTreeItem(TreeItem):
             tb = tb.tb_next
         return stack
 
-    def get_exception(self):
-        type = sys.last_type
-        value = sys.last_value
-        if hasattr(type, "__name__"):
-            type = type.__name__
-        s = str(type)
-        if value is not None:
-            s = s + ": " + str(value)
-        return s
-
-    def GetText(self):
+    def GetText(self):  # Titlecase names are overrides.
         return self.text
 
     def GetSubList(self):
@@ -133,19 +120,9 @@ def _stack_viewer(parent):  # htest #
     flist = PyShellFileList(top)
     try: # to obtain a traceback object
         intentional_name_error
-    except NameError:
-        exc_type, exc_value, exc_tb = sys.exc_info()
-    # inject stack trace to sys
-    sys.last_type = exc_type
-    sys.last_value = exc_value
-    sys.last_traceback = exc_tb
-
-    StackBrowser(top, flist=flist, top=top, tb=exc_tb)
-
-    # restore sys to original state
-    del sys.last_type
-    del sys.last_value
-    del sys.last_traceback
+    except NameError as e:
+        StackBrowser(top, e, flist=flist, top=top)
+
 
 if __name__ == '__main__':
     from unittest import main
--- a/Lib/logging/handlers.py
+++ b/Lib/logging/handlers.py
@@ -1399,7 +1399,7 @@ class MemoryHandler(BufferingHandler):
         records to the target, if there is one. Override if you want
         different behaviour.
 
-        The record buffer is also cleared by this operation.
+        The record buffer is only cleared if a target has been set.
         """
         self.acquire()
         try:
--- a/Lib/multiprocessing/spawn.py
+++ b/Lib/multiprocessing/spawn.py
@@ -31,11 +31,13 @@ if sys.platform != 'win32':
     WINSERVICE = False
 else:
     WINEXE = getattr(sys, 'frozen', False)
-    WINSERVICE = sys.executable.lower().endswith("pythonservice.exe")
+    WINSERVICE = sys.executable and sys.executable.lower().endswith("pythonservice.exe")
 
 def set_executable(exe):
     global _python_exe
-    if sys.platform == 'win32':
+    if exe is None:
+        _python_exe = exe
+    elif sys.platform == 'win32':
         _python_exe = os.fsdecode(exe)
     else:
         _python_exe = os.fsencode(exe)
--- a/Lib/pydoc.py
+++ b/Lib/pydoc.py
@@ -1778,12 +1778,21 @@ def render_doc(thing, title='Python Libr
     return title % desc + '\n\n' + renderer.document(object, name)
 
 def doc(thing, title='Python Library Documentation: %s', forceload=0,
-        output=None):
+        output=None, is_cli=False):
     """Display text documentation, given an object or a path to an object."""
     if output is None:
-        pager(render_doc(thing, title, forceload))
+        try:
+            pager(render_doc(thing, title, forceload))
+        except ImportError as exc:
+            if is_cli:
+                raise
+            print(exc)
     else:
-        output.write(render_doc(thing, title, forceload, plaintext))
+        try:
+            s = render_doc(thing, title, forceload, plaintext)
+        except ImportError as exc:
+            s = str(exc)
+        output.write(s)
 
 def writedoc(thing, forceload=0):
     """Write HTML documentation to a file in the current directory."""
@@ -2042,8 +2051,8 @@ has the same effect as typing a particul
             self.output.flush()
             return self.input.readline()
 
-    def help(self, request):
-        if type(request) is type(''):
+    def help(self, request, is_cli=False):
+        if isinstance(request, str):
             request = request.strip()
             if request == 'keywords': self.listkeywords()
             elif request == 'symbols': self.listsymbols()
@@ -2054,13 +2063,13 @@ has the same effect as typing a particul
             elif request in self.symbols: self.showsymbol(request)
             elif request in ['True', 'False', 'None']:
                 # special case these keywords since they are objects too
-                doc(eval(request), 'Help on %s:')
+                doc(eval(request), 'Help on %s:', is_cli=is_cli)
             elif request in self.keywords: self.showtopic(request)
             elif request in self.topics: self.showtopic(request)
-            elif request: doc(request, 'Help on %s:', output=self._output)
-            else: doc(str, 'Help on %s:', output=self._output)
+            elif request: doc(request, 'Help on %s:', output=self._output, is_cli=is_cli)
+            else: doc(str, 'Help on %s:', output=self._output, is_cli=is_cli)
         elif isinstance(request, Helper): self()
-        else: doc(request, 'Help on %s:', output=self._output)
+        else: doc(request, 'Help on %s:', output=self._output, is_cli=is_cli)
         self.output.write('\n')
 
     def intro(self):
@@ -2798,7 +2807,7 @@ def cli():
                     else:
                         writedoc(arg)
                 else:
-                    help.help(arg)
+                    help.help(arg, is_cli=True)
             except (ImportError, ErrorDuringImport) as value:
                 print(value)
                 sys.exit(1)
--- a/Lib/re/_compiler.py
+++ b/Lib/re/_compiler.py
@@ -100,6 +100,13 @@ def _compile(code, pattern, flags):
                 emit(ANY_ALL)
             else:
                 emit(ANY)
+        elif op is POSSESSIVE_REPEAT:
+            # gh-106052: Possessive quantifiers do not work when the
+            # subpattern contains backtracking, i.e. "(?:ab?c)*+".
+            # Implement it as equivalent greedy qualifier in atomic group.
+            p = [(MAX_REPEAT, av)]
+            p = [(ATOMIC_GROUP, p)]
+            _compile(code, p, flags)
         elif op in REPEATING_CODES:
             if flags & SRE_FLAG_TEMPLATE:
                 raise error("internal: unsupported template operator %r" % (op,))
--- a/Lib/re/_parser.py
+++ b/Lib/re/_parser.py
@@ -114,7 +114,6 @@ class SubPattern:
         self.width = None
 
     def dump(self, level=0):
-        nl = True
         seqtypes = (tuple, list)
         for op, av in self.data:
             print(level*"  " + str(op), end='')
@@ -136,6 +135,9 @@ class SubPattern:
                 if item_no:
                     print(level*"  " + "ELSE")
                     item_no.dump(level+1)
+            elif isinstance(av, SubPattern):
+                print()
+                av.dump(level+1)
             elif isinstance(av, seqtypes):
                 nl = False
                 for a in av:
--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -346,7 +346,7 @@ def _args_from_interpreter_flags():
     if dev_mode:
         args.extend(('-X', 'dev'))
     for opt in ('faulthandler', 'tracemalloc', 'importtime',
-                'showrefcount', 'utf8'):
+                'frozen_modules', 'showrefcount', 'utf8'):
         if opt in xoptions:
             value = xoptions[opt]
             if value is True:
--- a/Lib/test/_test_multiprocessing.py
+++ b/Lib/test/_test_multiprocessing.py
@@ -13,6 +13,7 @@ import sys
 import os
 import gc
 import errno
+import functools
 import signal
 import array
 import socket
@@ -31,6 +32,7 @@ from test import support
 from test.support import hashlib_helper
 from test.support import import_helper
 from test.support import os_helper
+from test.support import script_helper
 from test.support import socket_helper
 from test.support import threading_helper
 from test.support import warnings_helper
@@ -170,6 +172,59 @@ def check_enough_semaphores():
                             "to run the test (required: %d)." % nsems_min)
 
 
+def only_run_in_spawn_testsuite(reason):
+    """Returns a decorator: raises SkipTest when SM != spawn at test time.
+
+    This can be useful to save overall Python test suite execution time.
+    "spawn" is the universal mode available on all platforms so this limits the
+    decorated test to only execute within test_multiprocessing_spawn.
+
+    This would not be necessary if we refactored our test suite to split things
+    into other test files when they are not start method specific to be rerun
+    under all start methods.
+    """
+
+    def decorator(test_item):
+
+        @functools.wraps(test_item)
+        def spawn_check_wrapper(*args, **kwargs):
+            if (start_method := multiprocessing.get_start_method()) != "spawn":
+                raise unittest.SkipTest(f"{start_method=}, not 'spawn'; {reason}")
+            return test_item(*args, **kwargs)
+
+        return spawn_check_wrapper
+
+    return decorator
+
+
+class TestInternalDecorators(unittest.TestCase):
+    """Logic within a test suite that could errantly skip tests? Test it!"""
+
+    @unittest.skipIf(sys.platform == "win32", "test requires that fork exists.")
+    def test_only_run_in_spawn_testsuite(self):
+        if multiprocessing.get_start_method() != "spawn":
+            raise unittest.SkipTest("only run in test_multiprocessing_spawn.")
+
+        try:
+            @only_run_in_spawn_testsuite("testing this decorator")
+            def return_four_if_spawn():
+                return 4
+        except Exception as err:
+            self.fail(f"expected decorated `def` not to raise; caught {err}")
+
+        orig_start_method = multiprocessing.get_start_method(allow_none=True)
+        try:
+            multiprocessing.set_start_method("spawn", force=True)
+            self.assertEqual(return_four_if_spawn(), 4)
+            multiprocessing.set_start_method("fork", force=True)
+            with self.assertRaises(unittest.SkipTest) as ctx:
+                return_four_if_spawn()
+            self.assertIn("testing this decorator", str(ctx.exception))
+            self.assertIn("start_method=", str(ctx.exception))
+        finally:
+            multiprocessing.set_start_method(orig_start_method, force=True)
+
+
 #
 # Creates a wrapper for a function which records the time it takes to finish
 #
@@ -5775,6 +5830,7 @@ class TestSyncManagerTypes(unittest.Test
 
 
 class TestNamedResource(unittest.TestCase):
+    @only_run_in_spawn_testsuite("spawn specific test.")
     def test_global_named_resource_spawn(self):
         #
         # gh-90549: Check that global named resources in main module
@@ -5785,22 +5841,18 @@ class TestNamedResource(unittest.TestCas
         with open(testfn, 'w', encoding='utf-8') as f:
             f.write(textwrap.dedent('''\
                 import multiprocessing as mp
-
                 ctx = mp.get_context('spawn')
-
                 global_resource = ctx.Semaphore()
-
                 def submain(): pass
-
                 if __name__ == '__main__':
                     p = ctx.Process(target=submain)
                     p.start()
                     p.join()
             '''))
-        rc, out, err = test.support.script_helper.assert_python_ok(testfn)
+        rc, out, err = script_helper.assert_python_ok(testfn)
         # on error, err = 'UserWarning: resource_tracker: There appear to
         # be 1 leaked semaphore objects to clean up at shutdown'
-        self.assertEqual(err, b'')
+        self.assertFalse(err, msg=err.decode('utf-8'))
 
 
 class MiscTestCase(unittest.TestCase):
@@ -5809,6 +5861,24 @@ class MiscTestCase(unittest.TestCase):
         support.check__all__(self, multiprocessing, extra=multiprocessing.__all__,
                              not_exported=['SUBDEBUG', 'SUBWARNING'])
 
+    @only_run_in_spawn_testsuite("avoids redundant testing.")
+    def test_spawn_sys_executable_none_allows_import(self):
+        # Regression test for a bug introduced in
+        # https://github.com/python/cpython/issues/90876 that caused an
+        # ImportError in multiprocessing when sys.executable was None.
+        # This can be true in embedded environments.
+        rc, out, err = script_helper.assert_python_ok(
+            "-c",
+            """if 1:
+            import sys
+            sys.executable = None
+            assert "multiprocessing" not in sys.modules, "already imported!"
+            import multiprocessing
+            import multiprocessing.spawn  # This should not fail\n""",
+        )
+        self.assertEqual(rc, 0)
+        self.assertFalse(err, msg=err.decode('utf-8'))
+
 
 #
 # Mixins
--- a/Lib/test/clinic.test
+++ /dev/null
@@ -1,3558 +0,0 @@
-/*[clinic input]
-output preset block
-[clinic start generated code]*/
-/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3c81ac2402d06a8b]*/
-
-
-/*[clinic input]
-test_object_converter
-
-    a: object
-    b: object(converter="PyUnicode_FSConverter")
-    c: object(subclass_of="&PyUnicode_Type")
-    d: object(type="PyUnicode_Object *")
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_object_converter__doc__,
-"test_object_converter($module, a, b, c, d, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECT_CONVERTER_METHODDEF    \
-    {"test_object_converter", _PyCFunction_CAST(test_object_converter), METH_FASTCALL, test_object_converter__doc__},
-
-static PyObject *
-test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
-                           PyObject *c, PyUnicode_Object *d);
-
-static PyObject *
-test_object_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-    PyUnicode_Object *d;
-
-    if (!_PyArg_CheckPositional("test_object_converter", nargs, 4, 4)) {
-        goto exit;
-    }
-    a = args[0];
-    if (!PyUnicode_FSConverter(args[1], &b)) {
-        goto exit;
-    }
-    if (!PyUnicode_Check(args[2])) {
-        _PyArg_BadArgument("test_object_converter", "argument 3", "str", args[2]);
-        goto exit;
-    }
-    c = args[2];
-    d = (PyUnicode_Object *)args[3];
-    return_value = test_object_converter_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
-                           PyObject *c, PyUnicode_Object *d)
-/*[clinic end generated code: output=886f4f9b598726b6 input=005e6a8a711a869b]*/
-
-
-/*[clinic input]
-test_object_converter_one_arg
-
-    a: object
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_object_converter_one_arg__doc__,
-"test_object_converter_one_arg($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECT_CONVERTER_ONE_ARG_METHODDEF    \
-    {"test_object_converter_one_arg", (PyCFunction)test_object_converter_one_arg, METH_O, test_object_converter_one_arg__doc__},
-
-static PyObject *
-test_object_converter_one_arg(PyObject *module, PyObject *a)
-/*[clinic end generated code: output=6da755f8502139df input=d635d92a421f1ca3]*/
-
-
-/*[clinic input]
-test_objects_converter
-
-    a: object
-    b: object = NULL
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_objects_converter__doc__,
-"test_objects_converter($module, a, b=<unrepresentable>, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECTS_CONVERTER_METHODDEF    \
-    {"test_objects_converter", _PyCFunction_CAST(test_objects_converter), METH_FASTCALL, test_objects_converter__doc__},
-
-static PyObject *
-test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_objects_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *b = NULL;
-
-    if (!_PyArg_CheckPositional("test_objects_converter", nargs, 1, 2)) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    b = args[1];
-skip_optional:
-    return_value = test_objects_converter_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=fc26328b79d46bb7 input=4cbb3d9edd2a36f3]*/
-
-
-/*[clinic input]
-test_object_converter_subclass_of
-
-    a: object(subclass_of="&PyLong_Type")
-    b: object(subclass_of="&PyTuple_Type")
-    c: object(subclass_of="&PyList_Type")
-    d: object(subclass_of="&PySet_Type")
-    e: object(subclass_of="&PyFrozenSet_Type")
-    f: object(subclass_of="&PyDict_Type")
-    g: object(subclass_of="&PyUnicode_Type")
-    h: object(subclass_of="&PyBytes_Type")
-    i: object(subclass_of="&PyByteArray_Type")
-    j: object(subclass_of="&MyType")
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_object_converter_subclass_of__doc__,
-"test_object_converter_subclass_of($module, a, b, c, d, e, f, g, h, i,\n"
-"                                  j, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECT_CONVERTER_SUBCLASS_OF_METHODDEF    \
-    {"test_object_converter_subclass_of", _PyCFunction_CAST(test_object_converter_subclass_of), METH_FASTCALL, test_object_converter_subclass_of__doc__},
-
-static PyObject *
-test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d,
-                                       PyObject *e, PyObject *f, PyObject *g,
-                                       PyObject *h, PyObject *i, PyObject *j);
-
-static PyObject *
-test_object_converter_subclass_of(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-    PyObject *d;
-    PyObject *e;
-    PyObject *f;
-    PyObject *g;
-    PyObject *h;
-    PyObject *i;
-    PyObject *j;
-
-    if (!_PyArg_CheckPositional("test_object_converter_subclass_of", nargs, 10, 10)) {
-        goto exit;
-    }
-    if (!PyLong_Check(args[0])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 1", "int", args[0]);
-        goto exit;
-    }
-    a = args[0];
-    if (!PyTuple_Check(args[1])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 2", "tuple", args[1]);
-        goto exit;
-    }
-    b = args[1];
-    if (!PyList_Check(args[2])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 3", "list", args[2]);
-        goto exit;
-    }
-    c = args[2];
-    if (!PySet_Check(args[3])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 4", "set", args[3]);
-        goto exit;
-    }
-    d = args[3];
-    if (!PyFrozenSet_Check(args[4])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 5", "frozenset", args[4]);
-        goto exit;
-    }
-    e = args[4];
-    if (!PyDict_Check(args[5])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 6", "dict", args[5]);
-        goto exit;
-    }
-    f = args[5];
-    if (!PyUnicode_Check(args[6])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 7", "str", args[6]);
-        goto exit;
-    }
-    g = args[6];
-    if (!PyBytes_Check(args[7])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 8", "bytes", args[7]);
-        goto exit;
-    }
-    h = args[7];
-    if (!PyByteArray_Check(args[8])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 9", "bytearray", args[8]);
-        goto exit;
-    }
-    i = args[8];
-    if (!PyObject_TypeCheck(args[9], &MyType)) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 10", (&MyType)->tp_name, args[9]);
-        goto exit;
-    }
-    j = args[9];
-    return_value = test_object_converter_subclass_of_impl(module, a, b, c, d, e, f, g, h, i, j);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d,
-                                       PyObject *e, PyObject *f, PyObject *g,
-                                       PyObject *h, PyObject *i, PyObject *j)
-/*[clinic end generated code: output=e4b07c9a54479a40 input=31b06b772d5f983e]*/
-
-
-/*[clinic input]
-test_PyBytesObject_converter
-
-    a: PyBytesObject
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_PyBytesObject_converter__doc__,
-"test_PyBytesObject_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PYBYTESOBJECT_CONVERTER_METHODDEF    \
-    {"test_PyBytesObject_converter", (PyCFunction)test_PyBytesObject_converter, METH_O, test_PyBytesObject_converter__doc__},
-
-static PyObject *
-test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a);
-
-static PyObject *
-test_PyBytesObject_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    PyBytesObject *a;
-
-    if (!PyBytes_Check(arg)) {
-        _PyArg_BadArgument("test_PyBytesObject_converter", "argument", "bytes", arg);
-        goto exit;
-    }
-    a = (PyBytesObject *)arg;
-    return_value = test_PyBytesObject_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a)
-/*[clinic end generated code: output=7539d628e6fceace input=12b10c7cb5750400]*/
-
-
-/*[clinic input]
-test_PyByteArrayObject_converter
-
-    a: PyByteArrayObject
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_PyByteArrayObject_converter__doc__,
-"test_PyByteArrayObject_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PYBYTEARRAYOBJECT_CONVERTER_METHODDEF    \
-    {"test_PyByteArrayObject_converter", (PyCFunction)test_PyByteArrayObject_converter, METH_O, test_PyByteArrayObject_converter__doc__},
-
-static PyObject *
-test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a);
-
-static PyObject *
-test_PyByteArrayObject_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    PyByteArrayObject *a;
-
-    if (!PyByteArray_Check(arg)) {
-        _PyArg_BadArgument("test_PyByteArrayObject_converter", "argument", "bytearray", arg);
-        goto exit;
-    }
-    a = (PyByteArrayObject *)arg;
-    return_value = test_PyByteArrayObject_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a)
-/*[clinic end generated code: output=1245af9f5b3e355e input=5a657da535d194ae]*/
-
-
-/*[clinic input]
-test_unicode_converter
-
-    a: unicode
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unicode_converter__doc__,
-"test_unicode_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNICODE_CONVERTER_METHODDEF    \
-    {"test_unicode_converter", (PyCFunction)test_unicode_converter, METH_O, test_unicode_converter__doc__},
-
-static PyObject *
-test_unicode_converter_impl(PyObject *module, PyObject *a);
-
-static PyObject *
-test_unicode_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-
-    if (!PyUnicode_Check(arg)) {
-        _PyArg_BadArgument("test_unicode_converter", "argument", "str", arg);
-        goto exit;
-    }
-    if (PyUnicode_READY(arg) == -1) {
-        goto exit;
-    }
-    a = arg;
-    return_value = test_unicode_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unicode_converter_impl(PyObject *module, PyObject *a)
-/*[clinic end generated code: output=18f1e3880c862611 input=aa33612df92aa9c5]*/
-
-
-/*[clinic input]
-test_bool_converter
-
-    a: bool = True
-    b: bool(accept={object}) = True
-    c: bool(accept={int}) = True
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_bool_converter__doc__,
-"test_bool_converter($module, a=True, b=True, c=True, /)\n"
-"--\n"
-"\n");
-
-#define TEST_BOOL_CONVERTER_METHODDEF    \
-    {"test_bool_converter", _PyCFunction_CAST(test_bool_converter), METH_FASTCALL, test_bool_converter__doc__},
-
-static PyObject *
-test_bool_converter_impl(PyObject *module, int a, int b, int c);
-
-static PyObject *
-test_bool_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    int a = 1;
-    int b = 1;
-    int c = 1;
-
-    if (!_PyArg_CheckPositional("test_bool_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = PyObject_IsTrue(args[0]);
-    if (a < 0) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    b = PyObject_IsTrue(args[1]);
-    if (b < 0) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    c = _PyLong_AsInt(args[2]);
-    if (c == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_bool_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_bool_converter_impl(PyObject *module, int a, int b, int c)
-/*[clinic end generated code: output=27f0e653a70b9be3 input=939854fa9f248c60]*/
-
-
-/*[clinic input]
-test_char_converter
-
-    a: char = b'A'
-    b: char = b'\a'
-    c: char = b'\b'
-    d: char = b'\t'
-    e: char = b'\n'
-    f: char = b'\v'
-    g: char = b'\f'
-    h: char = b'\r'
-    i: char = b'"'
-    j: char = b"'"
-    k: char = b'?'
-    l: char = b'\\'
-    m: char = b'\000'
-    n: char = b'\377'
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_char_converter__doc__,
-"test_char_converter($module, a=b\'A\', b=b\'\\x07\', c=b\'\\x08\', d=b\'\\t\',\n"
-"                    e=b\'\\n\', f=b\'\\x0b\', g=b\'\\x0c\', h=b\'\\r\', i=b\'\"\',\n"
-"                    j=b\"\'\", k=b\'?\', l=b\'\\\\\', m=b\'\\x00\', n=b\'\\xff\', /)\n"
-"--\n"
-"\n");
-
-#define TEST_CHAR_CONVERTER_METHODDEF    \
-    {"test_char_converter", _PyCFunction_CAST(test_char_converter), METH_FASTCALL, test_char_converter__doc__},
-
-static PyObject *
-test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
-                         char e, char f, char g, char h, char i, char j,
-                         char k, char l, char m, char n);
-
-static PyObject *
-test_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    char a = 'A';
-    char b = '\x07';
-    char c = '\x08';
-    char d = '\t';
-    char e = '\n';
-    char f = '\x0b';
-    char g = '\x0c';
-    char h = '\r';
-    char i = '"';
-    char j = '\'';
-    char k = '?';
-    char l = '\\';
-    char m = '\x00';
-    char n = '\xff';
-
-    if (!_PyArg_CheckPositional("test_char_converter", nargs, 0, 14)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[0]) && PyBytes_GET_SIZE(args[0]) == 1) {
-        a = PyBytes_AS_STRING(args[0])[0];
-    }
-    else if (PyByteArray_Check(args[0]) && PyByteArray_GET_SIZE(args[0]) == 1) {
-        a = PyByteArray_AS_STRING(args[0])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 1", "a byte string of length 1", args[0]);
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[1]) && PyBytes_GET_SIZE(args[1]) == 1) {
-        b = PyBytes_AS_STRING(args[1])[0];
-    }
-    else if (PyByteArray_Check(args[1]) && PyByteArray_GET_SIZE(args[1]) == 1) {
-        b = PyByteArray_AS_STRING(args[1])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 2", "a byte string of length 1", args[1]);
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[2]) && PyBytes_GET_SIZE(args[2]) == 1) {
-        c = PyBytes_AS_STRING(args[2])[0];
-    }
-    else if (PyByteArray_Check(args[2]) && PyByteArray_GET_SIZE(args[2]) == 1) {
-        c = PyByteArray_AS_STRING(args[2])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 3", "a byte string of length 1", args[2]);
-        goto exit;
-    }
-    if (nargs < 4) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[3]) && PyBytes_GET_SIZE(args[3]) == 1) {
-        d = PyBytes_AS_STRING(args[3])[0];
-    }
-    else if (PyByteArray_Check(args[3]) && PyByteArray_GET_SIZE(args[3]) == 1) {
-        d = PyByteArray_AS_STRING(args[3])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 4", "a byte string of length 1", args[3]);
-        goto exit;
-    }
-    if (nargs < 5) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[4]) && PyBytes_GET_SIZE(args[4]) == 1) {
-        e = PyBytes_AS_STRING(args[4])[0];
-    }
-    else if (PyByteArray_Check(args[4]) && PyByteArray_GET_SIZE(args[4]) == 1) {
-        e = PyByteArray_AS_STRING(args[4])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 5", "a byte string of length 1", args[4]);
-        goto exit;
-    }
-    if (nargs < 6) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[5]) && PyBytes_GET_SIZE(args[5]) == 1) {
-        f = PyBytes_AS_STRING(args[5])[0];
-    }
-    else if (PyByteArray_Check(args[5]) && PyByteArray_GET_SIZE(args[5]) == 1) {
-        f = PyByteArray_AS_STRING(args[5])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 6", "a byte string of length 1", args[5]);
-        goto exit;
-    }
-    if (nargs < 7) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[6]) && PyBytes_GET_SIZE(args[6]) == 1) {
-        g = PyBytes_AS_STRING(args[6])[0];
-    }
-    else if (PyByteArray_Check(args[6]) && PyByteArray_GET_SIZE(args[6]) == 1) {
-        g = PyByteArray_AS_STRING(args[6])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 7", "a byte string of length 1", args[6]);
-        goto exit;
-    }
-    if (nargs < 8) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[7]) && PyBytes_GET_SIZE(args[7]) == 1) {
-        h = PyBytes_AS_STRING(args[7])[0];
-    }
-    else if (PyByteArray_Check(args[7]) && PyByteArray_GET_SIZE(args[7]) == 1) {
-        h = PyByteArray_AS_STRING(args[7])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 8", "a byte string of length 1", args[7]);
-        goto exit;
-    }
-    if (nargs < 9) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[8]) && PyBytes_GET_SIZE(args[8]) == 1) {
-        i = PyBytes_AS_STRING(args[8])[0];
-    }
-    else if (PyByteArray_Check(args[8]) && PyByteArray_GET_SIZE(args[8]) == 1) {
-        i = PyByteArray_AS_STRING(args[8])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 9", "a byte string of length 1", args[8]);
-        goto exit;
-    }
-    if (nargs < 10) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[9]) && PyBytes_GET_SIZE(args[9]) == 1) {
-        j = PyBytes_AS_STRING(args[9])[0];
-    }
-    else if (PyByteArray_Check(args[9]) && PyByteArray_GET_SIZE(args[9]) == 1) {
-        j = PyByteArray_AS_STRING(args[9])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 10", "a byte string of length 1", args[9]);
-        goto exit;
-    }
-    if (nargs < 11) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[10]) && PyBytes_GET_SIZE(args[10]) == 1) {
-        k = PyBytes_AS_STRING(args[10])[0];
-    }
-    else if (PyByteArray_Check(args[10]) && PyByteArray_GET_SIZE(args[10]) == 1) {
-        k = PyByteArray_AS_STRING(args[10])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 11", "a byte string of length 1", args[10]);
-        goto exit;
-    }
-    if (nargs < 12) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[11]) && PyBytes_GET_SIZE(args[11]) == 1) {
-        l = PyBytes_AS_STRING(args[11])[0];
-    }
-    else if (PyByteArray_Check(args[11]) && PyByteArray_GET_SIZE(args[11]) == 1) {
-        l = PyByteArray_AS_STRING(args[11])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 12", "a byte string of length 1", args[11]);
-        goto exit;
-    }
-    if (nargs < 13) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[12]) && PyBytes_GET_SIZE(args[12]) == 1) {
-        m = PyBytes_AS_STRING(args[12])[0];
-    }
-    else if (PyByteArray_Check(args[12]) && PyByteArray_GET_SIZE(args[12]) == 1) {
-        m = PyByteArray_AS_STRING(args[12])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 13", "a byte string of length 1", args[12]);
-        goto exit;
-    }
-    if (nargs < 14) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[13]) && PyBytes_GET_SIZE(args[13]) == 1) {
-        n = PyBytes_AS_STRING(args[13])[0];
-    }
-    else if (PyByteArray_Check(args[13]) && PyByteArray_GET_SIZE(args[13]) == 1) {
-        n = PyByteArray_AS_STRING(args[13])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 14", "a byte string of length 1", args[13]);
-        goto exit;
-    }
-skip_optional:
-    return_value = test_char_converter_impl(module, a, b, c, d, e, f, g, h, i, j, k, l, m, n);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
-                         char e, char f, char g, char h, char i, char j,
-                         char k, char l, char m, char n)
-/*[clinic end generated code: output=98589f02422fe6b1 input=e42330417a44feac]*/
-
-
-/*[clinic input]
-test_unsigned_char_converter
-
-    a: unsigned_char = 12
-    b: unsigned_char(bitwise=False) = 34
-    c: unsigned_char(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_char_converter__doc__,
-"test_unsigned_char_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_CHAR_CONVERTER_METHODDEF    \
-    {"test_unsigned_char_converter", _PyCFunction_CAST(test_unsigned_char_converter), METH_FASTCALL, test_unsigned_char_converter__doc__},
-
-static PyObject *
-test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
-                                  unsigned char b, unsigned char c);
-
-static PyObject *
-test_unsigned_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned char a = 12;
-    unsigned char b = 34;
-    unsigned char c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_char_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    {
-        long ival = PyLong_AsLong(args[0]);
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else if (ival < 0) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is less than minimum");
-            goto exit;
-        }
-        else if (ival > UCHAR_MAX) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is greater than maximum");
-            goto exit;
-        }
-        else {
-            a = (unsigned char) ival;
-        }
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    {
-        long ival = PyLong_AsLong(args[1]);
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else if (ival < 0) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is less than minimum");
-            goto exit;
-        }
-        else if (ival > UCHAR_MAX) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is greater than maximum");
-            goto exit;
-        }
-        else {
-            b = (unsigned char) ival;
-        }
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    {
-        unsigned long ival = PyLong_AsUnsignedLongMask(args[2]);
-        if (ival == (unsigned long)-1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else {
-            c = (unsigned char) ival;
-        }
-    }
-skip_optional:
-    return_value = test_unsigned_char_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
-                                  unsigned char b, unsigned char c)
-/*[clinic end generated code: output=45920dbedc22eb55 input=021414060993e289]*/
-
-
-/*[clinic input]
-test_short_converter
-
-    a: short = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_short_converter__doc__,
-"test_short_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_SHORT_CONVERTER_METHODDEF    \
-    {"test_short_converter", _PyCFunction_CAST(test_short_converter), METH_FASTCALL, test_short_converter__doc__},
-
-static PyObject *
-test_short_converter_impl(PyObject *module, short a);
-
-static PyObject *
-test_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    short a = 12;
-
-    if (!_PyArg_CheckPositional("test_short_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    {
-        long ival = PyLong_AsLong(args[0]);
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else if (ival < SHRT_MIN) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "signed short integer is less than minimum");
-            goto exit;
-        }
-        else if (ival > SHRT_MAX) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "signed short integer is greater than maximum");
-            goto exit;
-        }
-        else {
-            a = (short) ival;
-        }
-    }
-skip_optional:
-    return_value = test_short_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_short_converter_impl(PyObject *module, short a)
-/*[clinic end generated code: output=a580945bd6963d45 input=6a8a7a509a498ff4]*/
-
-
-/*[clinic input]
-test_unsigned_short_converter
-
-    a: unsigned_short = 12
-    b: unsigned_short(bitwise=False) = 34
-    c: unsigned_short(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_short_converter__doc__,
-"test_unsigned_short_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_SHORT_CONVERTER_METHODDEF    \
-    {"test_unsigned_short_converter", _PyCFunction_CAST(test_unsigned_short_converter), METH_FASTCALL, test_unsigned_short_converter__doc__},
-
-static PyObject *
-test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
-                                   unsigned short b, unsigned short c);
-
-static PyObject *
-test_unsigned_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned short a = 12;
-    unsigned short b = 34;
-    unsigned short c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_short_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedShort_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedShort_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    c = (unsigned short)PyLong_AsUnsignedLongMask(args[2]);
-    if (c == (unsigned short)-1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_unsigned_short_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
-                                   unsigned short b, unsigned short c)
-/*[clinic end generated code: output=e6e990df729114fc input=cdfd8eff3d9176b4]*/
-
-
-/*[clinic input]
-test_int_converter
-
-    a: int = 12
-    b: int(accept={int}) = 34
-    c: int(accept={str}) = 45
-    d: int(type='myenum') = 67
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_int_converter__doc__,
-"test_int_converter($module, a=12, b=34, c=45, d=67, /)\n"
-"--\n"
-"\n");
-
-#define TEST_INT_CONVERTER_METHODDEF    \
-    {"test_int_converter", _PyCFunction_CAST(test_int_converter), METH_FASTCALL, test_int_converter__doc__},
-
-static PyObject *
-test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d);
-
-static PyObject *
-test_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    int a = 12;
-    int b = 34;
-    int c = 45;
-    myenum d = 67;
-
-    if (!_PyArg_CheckPositional("test_int_converter", nargs, 0, 4)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = _PyLong_AsInt(args[0]);
-    if (a == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    b = _PyLong_AsInt(args[1]);
-    if (b == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!PyUnicode_Check(args[2])) {
-        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
-        goto exit;
-    }
-    if (PyUnicode_READY(args[2])) {
-        goto exit;
-    }
-    if (PyUnicode_GET_LENGTH(args[2]) != 1) {
-        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
-        goto exit;
-    }
-    c = PyUnicode_READ_CHAR(args[2], 0);
-    if (nargs < 4) {
-        goto skip_optional;
-    }
-    d = _PyLong_AsInt(args[3]);
-    if (d == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_int_converter_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d)
-/*[clinic end generated code: output=800993036e078c07 input=d20541fc1ca0553e]*/
-
-
-/*[clinic input]
-test_unsigned_int_converter
-
-    a: unsigned_int = 12
-    b: unsigned_int(bitwise=False) = 34
-    c: unsigned_int(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_int_converter__doc__,
-"test_unsigned_int_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_INT_CONVERTER_METHODDEF    \
-    {"test_unsigned_int_converter", _PyCFunction_CAST(test_unsigned_int_converter), METH_FASTCALL, test_unsigned_int_converter__doc__},
-
-static PyObject *
-test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
-                                 unsigned int b, unsigned int c);
-
-static PyObject *
-test_unsigned_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned int a = 12;
-    unsigned int b = 34;
-    unsigned int c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_int_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedInt_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedInt_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    c = (unsigned int)PyLong_AsUnsignedLongMask(args[2]);
-    if (c == (unsigned int)-1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_unsigned_int_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
-                                 unsigned int b, unsigned int c)
-/*[clinic end generated code: output=f9cdbe410ccc98a3 input=5533534828b62fc0]*/
-
-
-/*[clinic input]
-test_long_converter
-
-    a: long = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_long_converter__doc__,
-"test_long_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_LONG_CONVERTER_METHODDEF    \
-    {"test_long_converter", _PyCFunction_CAST(test_long_converter), METH_FASTCALL, test_long_converter__doc__},
-
-static PyObject *
-test_long_converter_impl(PyObject *module, long a);
-
-static PyObject *
-test_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    long a = 12;
-
-    if (!_PyArg_CheckPositional("test_long_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = PyLong_AsLong(args[0]);
-    if (a == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_long_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_long_converter_impl(PyObject *module, long a)
-/*[clinic end generated code: output=02b3a83495c1d236 input=d2179e3c9cdcde89]*/
-
-
-/*[clinic input]
-test_unsigned_long_converter
-
-    a: unsigned_long = 12
-    b: unsigned_long(bitwise=False) = 34
-    c: unsigned_long(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_long_converter__doc__,
-"test_unsigned_long_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_LONG_CONVERTER_METHODDEF    \
-    {"test_unsigned_long_converter", _PyCFunction_CAST(test_unsigned_long_converter), METH_FASTCALL, test_unsigned_long_converter__doc__},
-
-static PyObject *
-test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
-                                  unsigned long b, unsigned long c);
-
-static PyObject *
-test_unsigned_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned long a = 12;
-    unsigned long b = 34;
-    unsigned long c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_long_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLong_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLong_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!PyLong_Check(args[2])) {
-        _PyArg_BadArgument("test_unsigned_long_converter", "argument 3", "int", args[2]);
-        goto exit;
-    }
-    c = PyLong_AsUnsignedLongMask(args[2]);
-skip_optional:
-    return_value = test_unsigned_long_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
-                                  unsigned long b, unsigned long c)
-/*[clinic end generated code: output=540bb0ba2894e1fe input=f450d94cae1ef73b]*/
-
-
-/*[clinic input]
-test_long_long_converter
-
-    a: long_long = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_long_long_converter__doc__,
-"test_long_long_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_LONG_LONG_CONVERTER_METHODDEF    \
-    {"test_long_long_converter", _PyCFunction_CAST(test_long_long_converter), METH_FASTCALL, test_long_long_converter__doc__},
-
-static PyObject *
-test_long_long_converter_impl(PyObject *module, long long a);
-
-static PyObject *
-test_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    long long a = 12;
-
-    if (!_PyArg_CheckPositional("test_long_long_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = PyLong_AsLongLong(args[0]);
-    if (a == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_long_long_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_long_long_converter_impl(PyObject *module, long long a)
-/*[clinic end generated code: output=f9d4ed79ad2db857 input=d5fc81577ff4dd02]*/
-
-
-/*[clinic input]
-test_unsigned_long_long_converter
-
-    a: unsigned_long_long = 12
-    b: unsigned_long_long(bitwise=False) = 34
-    c: unsigned_long_long(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_long_long_converter__doc__,
-"test_unsigned_long_long_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_LONG_LONG_CONVERTER_METHODDEF    \
-    {"test_unsigned_long_long_converter", _PyCFunction_CAST(test_unsigned_long_long_converter), METH_FASTCALL, test_unsigned_long_long_converter__doc__},
-
-static PyObject *
-test_unsigned_long_long_converter_impl(PyObject *module,
-                                       unsigned long long a,
-                                       unsigned long long b,
-                                       unsigned long long c);
-
-static PyObject *
-test_unsigned_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned long long a = 12;
-    unsigned long long b = 34;
-    unsigned long long c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_long_long_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLongLong_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLongLong_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!PyLong_Check(args[2])) {
-        _PyArg_BadArgument("test_unsigned_long_long_converter", "argument 3", "int", args[2]);
-        goto exit;
-    }
-    c = PyLong_AsUnsignedLongLongMask(args[2]);
-skip_optional:
-    return_value = test_unsigned_long_long_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_long_long_converter_impl(PyObject *module,
-                                       unsigned long long a,
-                                       unsigned long long b,
-                                       unsigned long long c)
-/*[clinic end generated code: output=3d69994f618b46bb input=a15115dc41866ff4]*/
-
-
-/*[clinic input]
-test_Py_ssize_t_converter
-
-    a: Py_ssize_t = 12
-    b: Py_ssize_t(accept={int}) = 34
-    c: Py_ssize_t(accept={int, NoneType}) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_ssize_t_converter__doc__,
-"test_Py_ssize_t_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_SSIZE_T_CONVERTER_METHODDEF    \
-    {"test_Py_ssize_t_converter", _PyCFunction_CAST(test_Py_ssize_t_converter), METH_FASTCALL, test_Py_ssize_t_converter__doc__},
-
-static PyObject *
-test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                               Py_ssize_t c);
-
-static PyObject *
-test_Py_ssize_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    Py_ssize_t a = 12;
-    Py_ssize_t b = 34;
-    Py_ssize_t c = 56;
-
-    if (!_PyArg_CheckPositional("test_Py_ssize_t_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    {
-        Py_ssize_t ival = -1;
-        PyObject *iobj = _PyNumber_Index(args[0]);
-        if (iobj != NULL) {
-            ival = PyLong_AsSsize_t(iobj);
-            Py_DECREF(iobj);
-        }
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        a = ival;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    {
-        Py_ssize_t ival = -1;
-        PyObject *iobj = _PyNumber_Index(args[1]);
-        if (iobj != NULL) {
-            ival = PyLong_AsSsize_t(iobj);
-            Py_DECREF(iobj);
-        }
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        b = ival;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!_Py_convert_optional_to_ssize_t(args[2], &c)) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_Py_ssize_t_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                               Py_ssize_t c)
-/*[clinic end generated code: output=48214bc3d01f4dd7 input=3855f184bb3f299d]*/
-
-
-/*[clinic input]
-test_slice_index_converter
-
-    a: slice_index = 12
-    b: slice_index(accept={int}) = 34
-    c: slice_index(accept={int, NoneType}) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_slice_index_converter__doc__,
-"test_slice_index_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_SLICE_INDEX_CONVERTER_METHODDEF    \
-    {"test_slice_index_converter", _PyCFunction_CAST(test_slice_index_converter), METH_FASTCALL, test_slice_index_converter__doc__},
-
-static PyObject *
-test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                                Py_ssize_t c);
-
-static PyObject *
-test_slice_index_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    Py_ssize_t a = 12;
-    Py_ssize_t b = 34;
-    Py_ssize_t c = 56;
-
-    if (!_PyArg_CheckPositional("test_slice_index_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyEval_SliceIndex(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyEval_SliceIndexNotNone(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!_PyEval_SliceIndex(args[2], &c)) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_slice_index_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                                Py_ssize_t c)
-/*[clinic end generated code: output=67506ed999361212 input=edeadb0ee126f531]*/
-
-
-/*[clinic input]
-test_size_t_converter
-
-    a: size_t = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_size_t_converter__doc__,
-"test_size_t_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_SIZE_T_CONVERTER_METHODDEF    \
-    {"test_size_t_converter", _PyCFunction_CAST(test_size_t_converter), METH_FASTCALL, test_size_t_converter__doc__},
-
-static PyObject *
-test_size_t_converter_impl(PyObject *module, size_t a);
-
-static PyObject *
-test_size_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    size_t a = 12;
-
-    if (!_PyArg_CheckPositional("test_size_t_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_Size_t_Converter(args[0], &a)) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_size_t_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_size_t_converter_impl(PyObject *module, size_t a)
-/*[clinic end generated code: output=1653ecb5cbf775aa input=52e93a0fed0f1fb3]*/
-
-
-/*[clinic input]
-test_float_converter
-
-    a: float = 12.5
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_float_converter__doc__,
-"test_float_converter($module, a=12.5, /)\n"
-"--\n"
-"\n");
-
-#define TEST_FLOAT_CONVERTER_METHODDEF    \
-    {"test_float_converter", _PyCFunction_CAST(test_float_converter), METH_FASTCALL, test_float_converter__doc__},
-
-static PyObject *
-test_float_converter_impl(PyObject *module, float a);
-
-static PyObject *
-test_float_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    float a = 12.5;
-
-    if (!_PyArg_CheckPositional("test_float_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (PyFloat_CheckExact(args[0])) {
-        a = (float) (PyFloat_AS_DOUBLE(args[0]));
-    }
-    else
-    {
-        a = (float) PyFloat_AsDouble(args[0]);
-        if (a == -1.0 && PyErr_Occurred()) {
-            goto exit;
-        }
-    }
-skip_optional:
-    return_value = test_float_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_float_converter_impl(PyObject *module, float a)
-/*[clinic end generated code: output=36ad006990a8a91e input=259c0d98eca35034]*/
-
-
-/*[clinic input]
-test_double_converter
-
-    a: double = 12.5
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_double_converter__doc__,
-"test_double_converter($module, a=12.5, /)\n"
-"--\n"
-"\n");
-
-#define TEST_DOUBLE_CONVERTER_METHODDEF    \
-    {"test_double_converter", _PyCFunction_CAST(test_double_converter), METH_FASTCALL, test_double_converter__doc__},
-
-static PyObject *
-test_double_converter_impl(PyObject *module, double a);
-
-static PyObject *
-test_double_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    double a = 12.5;
-
-    if (!_PyArg_CheckPositional("test_double_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (PyFloat_CheckExact(args[0])) {
-        a = PyFloat_AS_DOUBLE(args[0]);
-    }
-    else
-    {
-        a = PyFloat_AsDouble(args[0]);
-        if (a == -1.0 && PyErr_Occurred()) {
-            goto exit;
-        }
-    }
-skip_optional:
-    return_value = test_double_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_double_converter_impl(PyObject *module, double a)
-/*[clinic end generated code: output=7435925592bac795 input=c6a9945706a41c27]*/
-
-
-/*[clinic input]
-test_Py_complex_converter
-
-    a: Py_complex
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_complex_converter__doc__,
-"test_Py_complex_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_COMPLEX_CONVERTER_METHODDEF    \
-    {"test_Py_complex_converter", (PyCFunction)test_Py_complex_converter, METH_O, test_Py_complex_converter__doc__},
-
-static PyObject *
-test_Py_complex_converter_impl(PyObject *module, Py_complex a);
-
-static PyObject *
-test_Py_complex_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    Py_complex a;
-
-    a = PyComplex_AsCComplex(arg);
-    if (PyErr_Occurred()) {
-        goto exit;
-    }
-    return_value = test_Py_complex_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_Py_complex_converter_impl(PyObject *module, Py_complex a)
-/*[clinic end generated code: output=c2ecbec2144ca540 input=070f216a515beb79]*/
-
-
-/*[clinic input]
-test_str_converter
-
-    a: str = NULL
-    b: str = "ab"
-    c: str(accept={str}) = "cd"
-    d: str(accept={robuffer}) = "cef"
-    e: str(accept={str, NoneType}) = "gh"
-    f: str(accept={robuffer}, zeroes=True) = "ij"
-    g: str(accept={robuffer, str}, zeroes=True) = "kl"
-    h: str(accept={robuffer, str, NoneType}, zeroes=True) = "mn"
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_str_converter__doc__,
-"test_str_converter($module, a=<unrepresentable>, b=\'ab\', c=\'cd\',\n"
-"                   d=\'cef\', e=\'gh\', f=\'ij\', g=\'kl\', h=\'mn\', /)\n"
-"--\n"
-"\n");
-
-#define TEST_STR_CONVERTER_METHODDEF    \
-    {"test_str_converter", _PyCFunction_CAST(test_str_converter), METH_FASTCALL, test_str_converter__doc__},
-
-static PyObject *
-test_str_converter_impl(PyObject *module, const char *a, const char *b,
-                        const char *c, const char *d, const char *e,
-                        const char *f, Py_ssize_t f_length, const char *g,
-                        Py_ssize_t g_length, const char *h,
-                        Py_ssize_t h_length);
-
-static PyObject *
-test_str_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    const char *a = NULL;
-    const char *b = "ab";
-    const char *c = "cd";
-    const char *d = "cef";
-    const char *e = "gh";
-    const char *f = "ij";
-    Py_ssize_t f_length;
-    const char *g = "kl";
-    Py_ssize_t g_length;
-    const char *h = "mn";
-    Py_ssize_t h_length;
-
-    if (!_PyArg_ParseStack(args, nargs, "|sssyzy#s#z#:test_str_converter",
-        &a, &b, &c, &d, &e, &f, &f_length, &g, &g_length, &h, &h_length)) {
-        goto exit;
-    }
-    return_value = test_str_converter_impl(module, a, b, c, d, e, f, f_length, g, g_length, h, h_length);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_str_converter_impl(PyObject *module, const char *a, const char *b,
-                        const char *c, const char *d, const char *e,
-                        const char *f, Py_ssize_t f_length, const char *g,
-                        Py_ssize_t g_length, const char *h,
-                        Py_ssize_t h_length)
-/*[clinic end generated code: output=82cb06d5237ef062 input=8afe9da8185cd38c]*/
-
-
-/*[clinic input]
-test_str_converter_encoding
-
-    a: str(encoding="idna")
-    b: str(encoding="idna", accept={str})
-    c: str(encoding="idna", accept={bytes, bytearray, str})
-    d: str(encoding="idna", zeroes=True)
-    e: str(encoding="idna", accept={bytes, bytearray, str}, zeroes=True)
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_str_converter_encoding__doc__,
-"test_str_converter_encoding($module, a, b, c, d, e, /)\n"
-"--\n"
-"\n");
-
-#define TEST_STR_CONVERTER_ENCODING_METHODDEF    \
-    {"test_str_converter_encoding", _PyCFunction_CAST(test_str_converter_encoding), METH_FASTCALL, test_str_converter_encoding__doc__},
-
-static PyObject *
-test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
-                                 char *d, Py_ssize_t d_length, char *e,
-                                 Py_ssize_t e_length);
-
-static PyObject *
-test_str_converter_encoding(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    char *a = NULL;
-    char *b = NULL;
-    char *c = NULL;
-    char *d = NULL;
-    Py_ssize_t d_length;
-    char *e = NULL;
-    Py_ssize_t e_length;
-
-    if (!_PyArg_ParseStack(args, nargs, "esesetes#et#:test_str_converter_encoding",
-        "idna", &a, "idna", &b, "idna", &c, "idna", &d, &d_length, "idna", &e, &e_length)) {
-        goto exit;
-    }
-    return_value = test_str_converter_encoding_impl(module, a, b, c, d, d_length, e, e_length);
-    /* Post parse cleanup for a */
-    PyMem_FREE(a);
-    /* Post parse cleanup for b */
-    PyMem_FREE(b);
-    /* Post parse cleanup for c */
-    PyMem_FREE(c);
-    /* Post parse cleanup for d */
-    PyMem_FREE(d);
-    /* Post parse cleanup for e */
-    PyMem_FREE(e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
-                                 char *d, Py_ssize_t d_length, char *e,
-                                 Py_ssize_t e_length)
-/*[clinic end generated code: output=999c1deecfa15b0a input=eb4c38e1f898f402]*/
-
-
-/*[clinic input]
-test_Py_UNICODE_converter
-
-    a: Py_UNICODE
-    b: Py_UNICODE(accept={str})
-    c: Py_UNICODE(accept={str, NoneType})
-    d: Py_UNICODE(zeroes=True)
-    e: Py_UNICODE(accept={str, NoneType}, zeroes=True)
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_UNICODE_converter__doc__,
-"test_Py_UNICODE_converter($module, a, b, c, d, e, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_UNICODE_CONVERTER_METHODDEF    \
-    {"test_Py_UNICODE_converter", _PyCFunction_CAST(test_Py_UNICODE_converter), METH_FASTCALL, test_Py_UNICODE_converter__doc__},
-
-static PyObject *
-test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
-                               const Py_UNICODE *b, const Py_UNICODE *c,
-                               const Py_UNICODE *d, Py_ssize_t d_length,
-                               const Py_UNICODE *e, Py_ssize_t e_length);
-
-static PyObject *
-test_Py_UNICODE_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    const Py_UNICODE *a = NULL;
-    const Py_UNICODE *b = NULL;
-    const Py_UNICODE *c = NULL;
-    const Py_UNICODE *d = NULL;
-    Py_ssize_t d_length;
-    const Py_UNICODE *e = NULL;
-    Py_ssize_t e_length;
-
-    if (!_PyArg_ParseStack(args, nargs, "O&O&O&u#Z#:test_Py_UNICODE_converter",
-        _PyUnicode_WideCharString_Converter, &a, _PyUnicode_WideCharString_Converter, &b, _PyUnicode_WideCharString_Opt_Converter, &c, &d, &d_length, &e, &e_length)) {
-        goto exit;
-    }
-    return_value = test_Py_UNICODE_converter_impl(module, a, b, c, d, d_length, e, e_length);
-
-exit:
-    /* Cleanup for a */
-    #if !USE_UNICODE_WCHAR_CACHE
-    PyMem_Free((void *)a);
-    #endif /* USE_UNICODE_WCHAR_CACHE */
-    /* Cleanup for b */
-    #if !USE_UNICODE_WCHAR_CACHE
-    PyMem_Free((void *)b);
-    #endif /* USE_UNICODE_WCHAR_CACHE */
-    /* Cleanup for c */
-    #if !USE_UNICODE_WCHAR_CACHE
-    PyMem_Free((void *)c);
-    #endif /* USE_UNICODE_WCHAR_CACHE */
-
-    return return_value;
-}
-
-static PyObject *
-test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
-                               const Py_UNICODE *b, const Py_UNICODE *c,
-                               const Py_UNICODE *d, Py_ssize_t d_length,
-                               const Py_UNICODE *e, Py_ssize_t e_length)
-/*[clinic end generated code: output=9d41b3a38a0f6f2f input=064a3b68ad7f04b0]*/
-
-
-/*[clinic input]
-test_Py_buffer_converter
-
-    a: Py_buffer
-    b: Py_buffer(accept={buffer})
-    c: Py_buffer(accept={str, buffer})
-    d: Py_buffer(accept={str, buffer, NoneType})
-    e: Py_buffer(accept={rwbuffer})
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_buffer_converter__doc__,
-"test_Py_buffer_converter($module, a, b, c, d, e, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_BUFFER_CONVERTER_METHODDEF    \
-    {"test_Py_buffer_converter", _PyCFunction_CAST(test_Py_buffer_converter), METH_FASTCALL, test_Py_buffer_converter__doc__},
-
-static PyObject *
-test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
-                              Py_buffer *c, Py_buffer *d, Py_buffer *e);
-
-static PyObject *
-test_Py_buffer_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    Py_buffer a = {NULL, NULL};
-    Py_buffer b = {NULL, NULL};
-    Py_buffer c = {NULL, NULL};
-    Py_buffer d = {NULL, NULL};
-    Py_buffer e = {NULL, NULL};
-
-    if (!_PyArg_ParseStack(args, nargs, "y*y*s*z*w*:test_Py_buffer_converter",
-        &a, &b, &c, &d, &e)) {
-        goto exit;
-    }
-    return_value = test_Py_buffer_converter_impl(module, &a, &b, &c, &d, &e);
-
-exit:
-    /* Cleanup for a */
-    if (a.obj) {
-       PyBuffer_Release(&a);
-    }
-    /* Cleanup for b */
-    if (b.obj) {
-       PyBuffer_Release(&b);
-    }
-    /* Cleanup for c */
-    if (c.obj) {
-       PyBuffer_Release(&c);
-    }
-    /* Cleanup for d */
-    if (d.obj) {
-       PyBuffer_Release(&d);
-    }
-    /* Cleanup for e */
-    if (e.obj) {
-       PyBuffer_Release(&e);
-    }
-
-    return return_value;
-}
-
-static PyObject *
-test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
-                              Py_buffer *c, Py_buffer *d, Py_buffer *e)
-/*[clinic end generated code: output=a153b71b4f45f952 input=6a9da0f56f9525fd]*/
-
-
-/*[clinic input]
-test_keywords
-
-    a: object
-    b: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords__doc__,
-"test_keywords($module, /, a, b)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_METHODDEF    \
-    {"test_keywords", _PyCFunction_CAST(test_keywords), METH_FASTCALL|METH_KEYWORDS, test_keywords__doc__},
-
-static PyObject *
-test_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *b;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    return_value = test_keywords_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=c03a52cfca192d3b input=0d3484844749c05b]*/
-
-
-/*[clinic input]
-test_keywords_kwonly
-
-    a: object
-    *
-    b: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_kwonly__doc__,
-"test_keywords_kwonly($module, /, a, *, b)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_KWONLY_METHODDEF    \
-    {"test_keywords_kwonly", _PyCFunction_CAST(test_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly__doc__},
-
-static PyObject *
-test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *b;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    return_value = test_keywords_kwonly_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=4704adcb6c7df928 input=384adc78bfa0bff7]*/
-
-
-/*[clinic input]
-test_keywords_opt
-
-    a: object
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_opt__doc__,
-"test_keywords_opt($module, /, a, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_OPT_METHODDEF    \
-    {"test_keywords_opt", _PyCFunction_CAST(test_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt__doc__},
-
-static PyObject *
-test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                       PyObject *c);
-
-static PyObject *
-test_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    c = args[2];
-skip_optional_pos:
-    return_value = test_keywords_opt_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                       PyObject *c)
-/*[clinic end generated code: output=de3ee1039da35fa1 input=eda7964f784f4607]*/
-
-
-/*[clinic input]
-test_keywords_opt_kwonly
-
-    a: object
-    b: object = None
-    *
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_opt_kwonly__doc__,
-"test_keywords_opt_kwonly($module, /, a, b=None, *, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_OPT_KWONLY_METHODDEF    \
-    {"test_keywords_opt_kwonly", _PyCFunction_CAST(test_keywords_opt_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt_kwonly__doc__},
-
-static PyObject *
-test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c, PyObject *d);
-
-static PyObject *
-test_keywords_opt_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt_kwonly", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_keywords_opt_kwonly_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c, PyObject *d)
-/*[clinic end generated code: output=996394678586854e input=209387a4815e5082]*/
-
-
-/*[clinic input]
-test_keywords_kwonly_opt
-
-    a: object
-    *
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_kwonly_opt__doc__,
-"test_keywords_kwonly_opt($module, /, a, *, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_KWONLY_OPT_METHODDEF    \
-    {"test_keywords_kwonly_opt", _PyCFunction_CAST(test_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly_opt__doc__},
-
-static PyObject *
-test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c);
-
-static PyObject *
-test_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly_opt", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    c = args[2];
-skip_optional_kwonly:
-    return_value = test_keywords_kwonly_opt_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c)
-/*[clinic end generated code: output=4ea9947a903a2f24 input=18393cc64fa000f4]*/
-
-
-/*[clinic input]
-test_posonly_keywords
-
-    a: object
-    /
-    b: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords__doc__,
-"test_posonly_keywords($module, a, /, b)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_METHODDEF    \
-    {"test_posonly_keywords", _PyCFunction_CAST(test_posonly_keywords), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords__doc__},
-
-static PyObject *
-test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_posonly_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *b;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    return_value = test_posonly_keywords_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=478aad346a188a80 input=1767b0ebdf06060e]*/
-
-
-/*[clinic input]
-test_posonly_kwonly
-
-    a: object
-    /
-    *
-    c: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_kwonly__doc__,
-"test_posonly_kwonly($module, a, /, *, c)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KWONLY_METHODDEF    \
-    {"test_posonly_kwonly", _PyCFunction_CAST(test_posonly_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly__doc__},
-
-static PyObject *
-test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c);
-
-static PyObject *
-test_posonly_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *c;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    c = args[1];
-    return_value = test_posonly_kwonly_impl(module, a, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c)
-/*[clinic end generated code: output=d747975a0b28e9c2 input=9042f2818f664839]*/
-
-
-/*[clinic input]
-test_posonly_keywords_kwonly
-
-    a: object
-    /
-    b: object
-    *
-    c: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_kwonly__doc__,
-"test_posonly_keywords_kwonly($module, a, /, b, *, c)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_KWONLY_METHODDEF    \
-    {"test_posonly_keywords_kwonly", _PyCFunction_CAST(test_posonly_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly__doc__},
-
-static PyObject *
-test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                                  PyObject *c);
-
-static PyObject *
-test_posonly_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly", 0};
-    PyObject *argsbuf[3];
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    c = args[2];
-    return_value = test_posonly_keywords_kwonly_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                                  PyObject *c)
-/*[clinic end generated code: output=5b99f692f8ddaa4a input=29546ebdca492fea]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt
-
-    a: object
-    /
-    b: object
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt__doc__,
-"test_posonly_keywords_opt($module, a, /, b, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT_METHODDEF    \
-    {"test_posonly_keywords_opt", _PyCFunction_CAST(test_posonly_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                               PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 4, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    d = args[3];
-skip_optional_pos:
-    return_value = test_posonly_keywords_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                               PyObject *c, PyObject *d)
-/*[clinic end generated code: output=fd5dfbac5727aebb input=cdf5a9625e554e9b]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt2
-
-    a: object
-    /
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt2__doc__,
-"test_posonly_keywords_opt2($module, a, /, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT2_METHODDEF    \
-    {"test_posonly_keywords_opt2", _PyCFunction_CAST(test_posonly_keywords_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2__doc__},
-
-static PyObject *
-test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                                PyObject *c);
-
-static PyObject *
-test_posonly_keywords_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    c = args[2];
-skip_optional_pos:
-    return_value = test_posonly_keywords_opt2_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                                PyObject *c)
-/*[clinic end generated code: output=777f58ac70775420 input=1581299d21d16f14]*/
-
-
-/*[clinic input]
-test_posonly_opt_keywords_opt
-
-    a: object
-    b: object = None
-    /
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_opt_keywords_opt__doc__,
-"test_posonly_opt_keywords_opt($module, a, b=None, /, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_OPT_KEYWORDS_OPT_METHODDEF    \
-    {"test_posonly_opt_keywords_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt__doc__},
-
-static PyObject *
-test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
-                                   PyObject *b, PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_opt_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional_posonly;
-    }
-    noptargs--;
-    b = args[1];
-skip_optional_posonly:
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    d = args[3];
-skip_optional_pos:
-    return_value = test_posonly_opt_keywords_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
-                                   PyObject *b, PyObject *c, PyObject *d)
-/*[clinic end generated code: output=2c18b8edff78ed22 input=408798ec3d42949f]*/
-
-
-/*[clinic input]
-test_posonly_kwonly_opt
-
-    a: object
-    /
-    *
-    b: object
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_kwonly_opt__doc__,
-"test_posonly_kwonly_opt($module, a, /, *, b, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_kwonly_opt", _PyCFunction_CAST(test_posonly_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                             PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_posonly_kwonly_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                             PyObject *c, PyObject *d)
-/*[clinic end generated code: output=8db9ab5602e1efaf input=8d8e5643bbbc2309]*/
-
-
-/*[clinic input]
-test_posonly_kwonly_opt2
-
-    a: object
-    /
-    *
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_kwonly_opt2__doc__,
-"test_posonly_kwonly_opt2($module, a, /, *, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KWONLY_OPT2_METHODDEF    \
-    {"test_posonly_kwonly_opt2", _PyCFunction_CAST(test_posonly_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt2__doc__},
-
-static PyObject *
-test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c);
-
-static PyObject *
-test_posonly_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt2", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    c = args[2];
-skip_optional_kwonly:
-    return_value = test_posonly_kwonly_opt2_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c)
-/*[clinic end generated code: output=6cfe546265d85d2c input=f7e5eed94f75fff0]*/
-
-
-/*[clinic input]
-test_posonly_opt_kwonly_opt
-
-    a: object
-    b: object = None
-    /
-    *
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_opt_kwonly_opt__doc__,
-"test_posonly_opt_kwonly_opt($module, a, b=None, /, *, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_OPT_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                                 PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_kwonly_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional_posonly;
-    }
-    noptargs--;
-    b = args[1];
-skip_optional_posonly:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_posonly_opt_kwonly_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                                 PyObject *c, PyObject *d)
-/*[clinic end generated code: output=8b5e21a30cad22b7 input=1e557dc979d120fd]*/
-
-
-/*[clinic input]
-test_posonly_keywords_kwonly_opt
-
-    a: object
-    /
-    b: object
-    *
-    c: object
-    d: object = None
-    e: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_kwonly_opt__doc__,
-"test_posonly_keywords_kwonly_opt($module, a, /, b, *, c, d=None, e=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_keywords_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                      PyObject *b, PyObject *c, PyObject *d,
-                                      PyObject *e);
-
-static PyObject *
-test_posonly_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt", 0};
-    PyObject *argsbuf[5];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    c = args[2];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    e = args[4];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_kwonly_opt_impl(module, a, b, c, d, e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                      PyObject *b, PyObject *c, PyObject *d,
-                                      PyObject *e)
-/*[clinic end generated code: output=950b9ace38b8b4a7 input=c3884a4f956fdc89]*/
-
-
-/*[clinic input]
-test_posonly_keywords_kwonly_opt2
-
-    a: object
-    /
-    b: object
-    *
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_kwonly_opt2__doc__,
-"test_posonly_keywords_kwonly_opt2($module, a, /, b, *, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_KWONLY_OPT2_METHODDEF    \
-    {"test_posonly_keywords_kwonly_opt2", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt2__doc__},
-
-static PyObject *
-test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_keywords_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt2", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_kwonly_opt2_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d)
-/*[clinic end generated code: output=fb6951a21b517317 input=68d01d7c0f6dafb0]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt_kwonly_opt
-
-    a: object
-    /
-    b: object
-    c: object = None
-    *
-    d: object = None
-    e: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt_kwonly_opt__doc__,
-"test_posonly_keywords_opt_kwonly_opt($module, a, /, b, c=None, *,\n"
-"                                     d=None, e=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                          PyObject *b, PyObject *c,
-                                          PyObject *d, PyObject *e);
-
-static PyObject *
-test_posonly_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt_kwonly_opt", 0};
-    PyObject *argsbuf[5];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    e = args[4];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                          PyObject *b, PyObject *c,
-                                          PyObject *d, PyObject *e)
-/*[clinic end generated code: output=4db10815a99a857e input=d0883d45876f186c]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt2_kwonly_opt
-
-    a: object
-    /
-    b: object = None
-    c: object = None
-    *
-    d: object = None
-    e: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt2_kwonly_opt__doc__,
-"test_posonly_keywords_opt2_kwonly_opt($module, a, /, b=None, c=None, *,\n"
-"                                      d=None, e=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT2_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_keywords_opt2_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt2_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                           PyObject *b, PyObject *c,
-                                           PyObject *d, PyObject *e);
-
-static PyObject *
-test_posonly_keywords_opt2_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2_kwonly_opt", 0};
-    PyObject *argsbuf[5];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    e = args[4];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_opt2_kwonly_opt_impl(module, a, b, c, d, e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                           PyObject *b, PyObject *c,
-                                           PyObject *d, PyObject *e)
-/*[clinic end generated code: output=0416689b23ebf66e input=c95e2e1ec93035ad]*/
-
-
-/*[clinic input]
-test_posonly_opt_keywords_opt_kwonly_opt
-
-    a: object
-    b: object = None
-    /
-    c: object = None
-    d: object = None
-    *
-    e: object = None
-    f: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_opt_keywords_opt_kwonly_opt__doc__,
-"test_posonly_opt_keywords_opt_kwonly_opt($module, a, b=None, /, c=None,\n"
-"                                         d=None, *, e=None, f=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_OPT_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_opt_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                              PyObject *b, PyObject *c,
-                                              PyObject *d, PyObject *e,
-                                              PyObject *f);
-
-static PyObject *
-test_posonly_opt_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "", "c", "d", "e", "f", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt_kwonly_opt", 0};
-    PyObject *argsbuf[6];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-    PyObject *f = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional_posonly;
-    }
-    noptargs--;
-    b = args[1];
-skip_optional_posonly:
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[4]) {
-        e = args[4];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    f = args[5];
-skip_optional_kwonly:
-    return_value = test_posonly_opt_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e, f);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                              PyObject *b, PyObject *c,
-                                              PyObject *d, PyObject *e,
-                                              PyObject *f)
-/*[clinic end generated code: output=8892a137a8c8f46f input=9914857713c5bbf8]*/
-
-/*[clinic input]
-test_keyword_only_parameter
-
-
-    *
-    co_lnotab: PyBytesObject(c_default="(PyBytesObject *)self->co_lnotab") = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keyword_only_parameter__doc__,
-"test_keyword_only_parameter($module, /, *, co_lnotab=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORD_ONLY_PARAMETER_METHODDEF    \
-    {"test_keyword_only_parameter", _PyCFunction_CAST(test_keyword_only_parameter), METH_FASTCALL|METH_KEYWORDS, test_keyword_only_parameter__doc__},
-
-static PyObject *
-test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab);
-
-static PyObject *
-test_keyword_only_parameter(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"co_lnotab", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keyword_only_parameter", 0};
-    PyObject *argsbuf[1];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
-    PyBytesObject *co_lnotab = (PyBytesObject *)self->co_lnotab;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (!PyBytes_Check(args[0])) {
-        _PyArg_BadArgument("test_keyword_only_parameter", "argument 'co_lnotab'", "bytes", args[0]);
-        goto exit;
-    }
-    co_lnotab = (PyBytesObject *)args[0];
-skip_optional_kwonly:
-    return_value = test_keyword_only_parameter_impl(module, co_lnotab);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab)
-/*[clinic end generated code: output=332b5f4b444c5d55 input=303df5046c7e37a3]*/
-
-
-/*[clinic input]
-output push
-output preset buffer
-[clinic start generated code]*/
-/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5bff3376ee0df0b5]*/
-
-#ifdef CONDITION_A
-/*[clinic input]
-test_preprocessor_guarded_condition_a
-[clinic start generated code]*/
-
-static PyObject *
-test_preprocessor_guarded_condition_a_impl(PyObject *module)
-/*[clinic end generated code: output=ad012af18085add6 input=8edb8706a98cda7e]*/
-#elif CONDITION_B
-/*[clinic input]
-test_preprocessor_guarded_elif_condition_b
-[clinic start generated code]*/
-
-static PyObject *
-test_preprocessor_guarded_elif_condition_b_impl(PyObject *module)
-/*[clinic end generated code: output=615f2dee82b138d1 input=53777cebbf7fee32]*/
-#else
-/*[clinic input]
-test_preprocessor_guarded_else
-[clinic start generated code]*/
-
-static PyObject *
-test_preprocessor_guarded_else_impl(PyObject *module)
-/*[clinic end generated code: output=13af7670aac51b12 input=6657ab31d74c29fc]*/
-#endif
-
-/*[clinic input]
-dump buffer
-output pop
-[clinic start generated code]*/
-
-#if defined(CONDITION_A)
-
-PyDoc_STRVAR(test_preprocessor_guarded_condition_a__doc__,
-"test_preprocessor_guarded_condition_a($module, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF    \
-    {"test_preprocessor_guarded_condition_a", (PyCFunction)test_preprocessor_guarded_condition_a, METH_NOARGS, test_preprocessor_guarded_condition_a__doc__},
-
-static PyObject *
-test_preprocessor_guarded_condition_a(PyObject *module, PyObject *Py_UNUSED(ignored))
-{
-    return test_preprocessor_guarded_condition_a_impl(module);
-}
-
-#endif /* defined(CONDITION_A) */
-
-#if !defined(CONDITION_A) && (CONDITION_B)
-
-PyDoc_STRVAR(test_preprocessor_guarded_elif_condition_b__doc__,
-"test_preprocessor_guarded_elif_condition_b($module, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF    \
-    {"test_preprocessor_guarded_elif_condition_b", (PyCFunction)test_preprocessor_guarded_elif_condition_b, METH_NOARGS, test_preprocessor_guarded_elif_condition_b__doc__},
-
-static PyObject *
-test_preprocessor_guarded_elif_condition_b(PyObject *module, PyObject *Py_UNUSED(ignored))
-{
-    return test_preprocessor_guarded_elif_condition_b_impl(module);
-}
-
-#endif /* !defined(CONDITION_A) && (CONDITION_B) */
-
-#if !defined(CONDITION_A) && !(CONDITION_B)
-
-PyDoc_STRVAR(test_preprocessor_guarded_else__doc__,
-"test_preprocessor_guarded_else($module, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF    \
-    {"test_preprocessor_guarded_else", (PyCFunction)test_preprocessor_guarded_else, METH_NOARGS, test_preprocessor_guarded_else__doc__},
-
-static PyObject *
-test_preprocessor_guarded_else(PyObject *module, PyObject *Py_UNUSED(ignored))
-{
-    return test_preprocessor_guarded_else_impl(module);
-}
-
-#endif /* !defined(CONDITION_A) && !(CONDITION_B) */
-
-#ifndef TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
-    #define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
-#endif /* !defined(TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF) */
-
-#ifndef TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
-    #define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
-#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF) */
-
-#ifndef TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
-    #define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
-#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF) */
-/*[clinic end generated code: output=3804bb18d454038c input=3fc80c9989d2f2e1]*/
-
-/*[clinic input]
-test_vararg_and_posonly
-
-
-    a: object
-    *args: object
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg_and_posonly__doc__,
-"test_vararg_and_posonly($module, a, /, *args)\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_AND_POSONLY_METHODDEF    \
-    {"test_vararg_and_posonly", _PyCFunction_CAST(test_vararg_and_posonly), METH_FASTCALL, test_vararg_and_posonly__doc__},
-
-static PyObject *
-test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args);
-
-static PyObject *
-test_vararg_and_posonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *__clinic_args = NULL;
-
-    if (!_PyArg_CheckPositional("test_vararg_and_posonly", nargs, 1, PY_SSIZE_T_MAX)) {
-        goto exit;
-    }
-    a = args[0];
-    __clinic_args = PyTuple_New(nargs - 1);
-    if (!__clinic_args) {
-        goto exit;
-    }
-    for (Py_ssize_t i = 0; i < nargs - 1; ++i) {
-        PyTuple_SET_ITEM(__clinic_args, i, Py_NewRef(args[1 + i]));
-    }
-    return_value = test_vararg_and_posonly_impl(module, a, __clinic_args);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args)
-/*[clinic end generated code: output=79b75dc07decc8d6 input=08dc2bf7afbf1613]*/
-
-/*[clinic input]
-test_vararg
-
-
-    a: object
-    *args: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg__doc__,
-"test_vararg($module, /, a, *args)\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_METHODDEF    \
-    {"test_vararg", _PyCFunction_CAST(test_vararg), METH_FASTCALL|METH_KEYWORDS, test_vararg__doc__},
-
-static PyObject *
-test_vararg_impl(PyObject *module, PyObject *a, PyObject *args);
-
-static PyObject *
-test_vararg(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *__clinic_args = NULL;
-
-    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    __clinic_args = args[1];
-    return_value = test_vararg_impl(module, a, __clinic_args);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_impl(PyObject *module, PyObject *a, PyObject *args)
-/*[clinic end generated code: output=ce9334333757f6ea input=81d33815ad1bae6e]*/
-
-/*[clinic input]
-test_vararg_with_default
-
-
-    a: object
-    *args: object
-    b: bool = False
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg_with_default__doc__,
-"test_vararg_with_default($module, /, a, *args, b=False)\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_WITH_DEFAULT_METHODDEF    \
-    {"test_vararg_with_default", _PyCFunction_CAST(test_vararg_with_default), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_default__doc__},
-
-static PyObject *
-test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
-                              int b);
-
-static PyObject *
-test_vararg_with_default(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_default", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = Py_MIN(nargs, 1) + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *__clinic_args = NULL;
-    int b = 0;
-
-    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    __clinic_args = args[1];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    b = PyObject_IsTrue(args[2]);
-    if (b < 0) {
-        goto exit;
-    }
-skip_optional_kwonly:
-    return_value = test_vararg_with_default_impl(module, a, __clinic_args, b);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
-                              int b)
-/*[clinic end generated code: output=32fb19dd6bcf9185 input=6e110b54acd9b22d]*/
-
-/*[clinic input]
-test_vararg_with_only_defaults
-
-
-    *args: object
-    b: bool = False
-    c: object = ' '
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg_with_only_defaults__doc__,
-"test_vararg_with_only_defaults($module, /, *args, b=False, c=\' \')\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_WITH_ONLY_DEFAULTS_METHODDEF    \
-    {"test_vararg_with_only_defaults", _PyCFunction_CAST(test_vararg_with_only_defaults), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_only_defaults__doc__},
-
-static PyObject *
-test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
-                                    PyObject *c);
-
-static PyObject *
-test_vararg_with_only_defaults(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_only_defaults", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = 0 + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
-    PyObject *__clinic_args = NULL;
-    int b = 0;
-    PyObject *c = " ";
-
-    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    __clinic_args = args[0];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[1]) {
-        b = PyObject_IsTrue(args[1]);
-        if (b < 0) {
-            goto exit;
-        }
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    c = args[2];
-skip_optional_kwonly:
-    return_value = test_vararg_with_only_defaults_impl(module, __clinic_args, b, c);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
-                                    PyObject *c)
-/*[clinic end generated code: output=7e393689e6ce61a3 input=fa56a709a035666e]*/
-
-/*[clinic input]
-test_paramname_module
-
-    module as mod: object
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_paramname_module__doc__,
-"test_paramname_module($module, /, module)\n"
-"--\n"
-"\n");
-
-#define TEST_PARAMNAME_MODULE_METHODDEF    \
-    {"test_paramname_module", _PyCFunction_CAST(test_paramname_module), METH_FASTCALL|METH_KEYWORDS, test_paramname_module__doc__},
-
-static PyObject *
-test_paramname_module_impl(PyObject *module, PyObject *mod);
-
-static PyObject *
-test_paramname_module(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"module", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_paramname_module", 0};
-    PyObject *argsbuf[1];
-    PyObject *mod;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    mod = args[0];
-    return_value = test_paramname_module_impl(module, mod);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_paramname_module_impl(PyObject *module, PyObject *mod)
-/*[clinic end generated code: output=23379a7ffa65c514 input=afefe259667f13ba]*/
--- /dev/null
+++ b/Lib/test/clinic.test.c
@@ -0,0 +1,4250 @@
+/*[clinic input]
+output preset block
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3c81ac2402d06a8b]*/
+
+/*[clinic input]
+class Test "TestObj *" "TestType"
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=fc7e50384d12b83f]*/
+
+/*[clinic input]
+test_object_converter
+
+    a: object
+    b: object(converter="PyUnicode_FSConverter")
+    c: object(subclass_of="&PyUnicode_Type")
+    d: object(type="PyUnicode_Object *")
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_object_converter__doc__,
+"test_object_converter($module, a, b, c, d, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECT_CONVERTER_METHODDEF    \
+    {"test_object_converter", _PyCFunction_CAST(test_object_converter), METH_FASTCALL, test_object_converter__doc__},
+
+static PyObject *
+test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
+                           PyObject *c, PyUnicode_Object *d);
+
+static PyObject *
+test_object_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyUnicode_Object *d;
+
+    if (!_PyArg_CheckPositional("test_object_converter", nargs, 4, 4)) {
+        goto exit;
+    }
+    a = args[0];
+    if (!PyUnicode_FSConverter(args[1], &b)) {
+        goto exit;
+    }
+    if (!PyUnicode_Check(args[2])) {
+        _PyArg_BadArgument("test_object_converter", "argument 3", "str", args[2]);
+        goto exit;
+    }
+    c = args[2];
+    d = (PyUnicode_Object *)args[3];
+    return_value = test_object_converter_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
+                           PyObject *c, PyUnicode_Object *d)
+/*[clinic end generated code: output=886f4f9b598726b6 input=005e6a8a711a869b]*/
+
+
+/*[clinic input]
+cloned = test_object_converter
+Check the clone feature.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(cloned__doc__,
+"cloned($module, a, b, c, d, /)\n"
+"--\n"
+"\n"
+"Check the clone feature.");
+
+#define CLONED_METHODDEF    \
+    {"cloned", _PyCFunction_CAST(cloned), METH_FASTCALL, cloned__doc__},
+
+static PyObject *
+cloned_impl(PyObject *module, PyObject *a, PyObject *b, PyObject *c,
+            PyUnicode_Object *d);
+
+static PyObject *
+cloned(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyUnicode_Object *d;
+
+    if (!_PyArg_CheckPositional("cloned", nargs, 4, 4)) {
+        goto exit;
+    }
+    a = args[0];
+    if (!PyUnicode_FSConverter(args[1], &b)) {
+        goto exit;
+    }
+    if (!PyUnicode_Check(args[2])) {
+        _PyArg_BadArgument("cloned", "argument 3", "str", args[2]);
+        goto exit;
+    }
+    c = args[2];
+    d = (PyUnicode_Object *)args[3];
+    return_value = cloned_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+cloned_impl(PyObject *module, PyObject *a, PyObject *b, PyObject *c,
+            PyUnicode_Object *d)
+/*[clinic end generated code: output=026b483e27c38065 input=0543614019d6fcc7]*/
+
+
+/*[clinic input]
+test_object_converter_one_arg
+
+    a: object
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_object_converter_one_arg__doc__,
+"test_object_converter_one_arg($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECT_CONVERTER_ONE_ARG_METHODDEF    \
+    {"test_object_converter_one_arg", (PyCFunction)test_object_converter_one_arg, METH_O, test_object_converter_one_arg__doc__},
+
+static PyObject *
+test_object_converter_one_arg(PyObject *module, PyObject *a)
+/*[clinic end generated code: output=6da755f8502139df input=d635d92a421f1ca3]*/
+
+
+/*[clinic input]
+test_objects_converter
+
+    a: object
+    b: object = NULL
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_objects_converter__doc__,
+"test_objects_converter($module, a, b=<unrepresentable>, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECTS_CONVERTER_METHODDEF    \
+    {"test_objects_converter", _PyCFunction_CAST(test_objects_converter), METH_FASTCALL, test_objects_converter__doc__},
+
+static PyObject *
+test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_objects_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b = NULL;
+
+    if (!_PyArg_CheckPositional("test_objects_converter", nargs, 1, 2)) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    b = args[1];
+skip_optional:
+    return_value = test_objects_converter_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=fc26328b79d46bb7 input=4cbb3d9edd2a36f3]*/
+
+
+/*[clinic input]
+test_object_converter_subclass_of
+
+    a: object(subclass_of="&PyLong_Type")
+    b: object(subclass_of="&PyTuple_Type")
+    c: object(subclass_of="&PyList_Type")
+    d: object(subclass_of="&PySet_Type")
+    e: object(subclass_of="&PyFrozenSet_Type")
+    f: object(subclass_of="&PyDict_Type")
+    g: object(subclass_of="&PyUnicode_Type")
+    h: object(subclass_of="&PyBytes_Type")
+    i: object(subclass_of="&PyByteArray_Type")
+    j: object(subclass_of="&MyType")
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_object_converter_subclass_of__doc__,
+"test_object_converter_subclass_of($module, a, b, c, d, e, f, g, h, i,\n"
+"                                  j, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECT_CONVERTER_SUBCLASS_OF_METHODDEF    \
+    {"test_object_converter_subclass_of", _PyCFunction_CAST(test_object_converter_subclass_of), METH_FASTCALL, test_object_converter_subclass_of__doc__},
+
+static PyObject *
+test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d,
+                                       PyObject *e, PyObject *f, PyObject *g,
+                                       PyObject *h, PyObject *i, PyObject *j);
+
+static PyObject *
+test_object_converter_subclass_of(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyObject *d;
+    PyObject *e;
+    PyObject *f;
+    PyObject *g;
+    PyObject *h;
+    PyObject *i;
+    PyObject *j;
+
+    if (!_PyArg_CheckPositional("test_object_converter_subclass_of", nargs, 10, 10)) {
+        goto exit;
+    }
+    if (!PyLong_Check(args[0])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 1", "int", args[0]);
+        goto exit;
+    }
+    a = args[0];
+    if (!PyTuple_Check(args[1])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 2", "tuple", args[1]);
+        goto exit;
+    }
+    b = args[1];
+    if (!PyList_Check(args[2])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 3", "list", args[2]);
+        goto exit;
+    }
+    c = args[2];
+    if (!PySet_Check(args[3])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 4", "set", args[3]);
+        goto exit;
+    }
+    d = args[3];
+    if (!PyFrozenSet_Check(args[4])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 5", "frozenset", args[4]);
+        goto exit;
+    }
+    e = args[4];
+    if (!PyDict_Check(args[5])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 6", "dict", args[5]);
+        goto exit;
+    }
+    f = args[5];
+    if (!PyUnicode_Check(args[6])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 7", "str", args[6]);
+        goto exit;
+    }
+    g = args[6];
+    if (!PyBytes_Check(args[7])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 8", "bytes", args[7]);
+        goto exit;
+    }
+    h = args[7];
+    if (!PyByteArray_Check(args[8])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 9", "bytearray", args[8]);
+        goto exit;
+    }
+    i = args[8];
+    if (!PyObject_TypeCheck(args[9], &MyType)) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 10", (&MyType)->tp_name, args[9]);
+        goto exit;
+    }
+    j = args[9];
+    return_value = test_object_converter_subclass_of_impl(module, a, b, c, d, e, f, g, h, i, j);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d,
+                                       PyObject *e, PyObject *f, PyObject *g,
+                                       PyObject *h, PyObject *i, PyObject *j)
+/*[clinic end generated code: output=e4b07c9a54479a40 input=31b06b772d5f983e]*/
+
+
+/*[clinic input]
+test_PyBytesObject_converter
+
+    a: PyBytesObject
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_PyBytesObject_converter__doc__,
+"test_PyBytesObject_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PYBYTESOBJECT_CONVERTER_METHODDEF    \
+    {"test_PyBytesObject_converter", (PyCFunction)test_PyBytesObject_converter, METH_O, test_PyBytesObject_converter__doc__},
+
+static PyObject *
+test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a);
+
+static PyObject *
+test_PyBytesObject_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    PyBytesObject *a;
+
+    if (!PyBytes_Check(arg)) {
+        _PyArg_BadArgument("test_PyBytesObject_converter", "argument", "bytes", arg);
+        goto exit;
+    }
+    a = (PyBytesObject *)arg;
+    return_value = test_PyBytesObject_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a)
+/*[clinic end generated code: output=7539d628e6fceace input=12b10c7cb5750400]*/
+
+
+/*[clinic input]
+test_PyByteArrayObject_converter
+
+    a: PyByteArrayObject
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_PyByteArrayObject_converter__doc__,
+"test_PyByteArrayObject_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PYBYTEARRAYOBJECT_CONVERTER_METHODDEF    \
+    {"test_PyByteArrayObject_converter", (PyCFunction)test_PyByteArrayObject_converter, METH_O, test_PyByteArrayObject_converter__doc__},
+
+static PyObject *
+test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a);
+
+static PyObject *
+test_PyByteArrayObject_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    PyByteArrayObject *a;
+
+    if (!PyByteArray_Check(arg)) {
+        _PyArg_BadArgument("test_PyByteArrayObject_converter", "argument", "bytearray", arg);
+        goto exit;
+    }
+    a = (PyByteArrayObject *)arg;
+    return_value = test_PyByteArrayObject_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a)
+/*[clinic end generated code: output=1245af9f5b3e355e input=5a657da535d194ae]*/
+
+
+/*[clinic input]
+test_unicode_converter
+
+    a: unicode
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unicode_converter__doc__,
+"test_unicode_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNICODE_CONVERTER_METHODDEF    \
+    {"test_unicode_converter", (PyCFunction)test_unicode_converter, METH_O, test_unicode_converter__doc__},
+
+static PyObject *
+test_unicode_converter_impl(PyObject *module, PyObject *a);
+
+static PyObject *
+test_unicode_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+
+    if (!PyUnicode_Check(arg)) {
+        _PyArg_BadArgument("test_unicode_converter", "argument", "str", arg);
+        goto exit;
+    }
+    if (PyUnicode_READY(arg) == -1) {
+        goto exit;
+    }
+    a = arg;
+    return_value = test_unicode_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unicode_converter_impl(PyObject *module, PyObject *a)
+/*[clinic end generated code: output=18f1e3880c862611 input=aa33612df92aa9c5]*/
+
+
+/*[clinic input]
+test_bool_converter
+
+    a: bool = True
+    b: bool(accept={object}) = True
+    c: bool(accept={int}) = True
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_bool_converter__doc__,
+"test_bool_converter($module, a=True, b=True, c=True, /)\n"
+"--\n"
+"\n");
+
+#define TEST_BOOL_CONVERTER_METHODDEF    \
+    {"test_bool_converter", _PyCFunction_CAST(test_bool_converter), METH_FASTCALL, test_bool_converter__doc__},
+
+static PyObject *
+test_bool_converter_impl(PyObject *module, int a, int b, int c);
+
+static PyObject *
+test_bool_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    int a = 1;
+    int b = 1;
+    int c = 1;
+
+    if (!_PyArg_CheckPositional("test_bool_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = PyObject_IsTrue(args[0]);
+    if (a < 0) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    b = PyObject_IsTrue(args[1]);
+    if (b < 0) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    c = _PyLong_AsInt(args[2]);
+    if (c == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_bool_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_bool_converter_impl(PyObject *module, int a, int b, int c)
+/*[clinic end generated code: output=27f0e653a70b9be3 input=939854fa9f248c60]*/
+
+
+/*[clinic input]
+test_char_converter
+
+    a: char = b'A'
+    b: char = b'\a'
+    c: char = b'\b'
+    d: char = b'\t'
+    e: char = b'\n'
+    f: char = b'\v'
+    g: char = b'\f'
+    h: char = b'\r'
+    i: char = b'"'
+    j: char = b"'"
+    k: char = b'?'
+    l: char = b'\\'
+    m: char = b'\000'
+    n: char = b'\377'
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_char_converter__doc__,
+"test_char_converter($module, a=b\'A\', b=b\'\\x07\', c=b\'\\x08\', d=b\'\\t\',\n"
+"                    e=b\'\\n\', f=b\'\\x0b\', g=b\'\\x0c\', h=b\'\\r\', i=b\'\"\',\n"
+"                    j=b\"\'\", k=b\'?\', l=b\'\\\\\', m=b\'\\x00\', n=b\'\\xff\', /)\n"
+"--\n"
+"\n");
+
+#define TEST_CHAR_CONVERTER_METHODDEF    \
+    {"test_char_converter", _PyCFunction_CAST(test_char_converter), METH_FASTCALL, test_char_converter__doc__},
+
+static PyObject *
+test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
+                         char e, char f, char g, char h, char i, char j,
+                         char k, char l, char m, char n);
+
+static PyObject *
+test_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    char a = 'A';
+    char b = '\x07';
+    char c = '\x08';
+    char d = '\t';
+    char e = '\n';
+    char f = '\x0b';
+    char g = '\x0c';
+    char h = '\r';
+    char i = '"';
+    char j = '\'';
+    char k = '?';
+    char l = '\\';
+    char m = '\x00';
+    char n = '\xff';
+
+    if (!_PyArg_CheckPositional("test_char_converter", nargs, 0, 14)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[0]) && PyBytes_GET_SIZE(args[0]) == 1) {
+        a = PyBytes_AS_STRING(args[0])[0];
+    }
+    else if (PyByteArray_Check(args[0]) && PyByteArray_GET_SIZE(args[0]) == 1) {
+        a = PyByteArray_AS_STRING(args[0])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 1", "a byte string of length 1", args[0]);
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[1]) && PyBytes_GET_SIZE(args[1]) == 1) {
+        b = PyBytes_AS_STRING(args[1])[0];
+    }
+    else if (PyByteArray_Check(args[1]) && PyByteArray_GET_SIZE(args[1]) == 1) {
+        b = PyByteArray_AS_STRING(args[1])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 2", "a byte string of length 1", args[1]);
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[2]) && PyBytes_GET_SIZE(args[2]) == 1) {
+        c = PyBytes_AS_STRING(args[2])[0];
+    }
+    else if (PyByteArray_Check(args[2]) && PyByteArray_GET_SIZE(args[2]) == 1) {
+        c = PyByteArray_AS_STRING(args[2])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 3", "a byte string of length 1", args[2]);
+        goto exit;
+    }
+    if (nargs < 4) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[3]) && PyBytes_GET_SIZE(args[3]) == 1) {
+        d = PyBytes_AS_STRING(args[3])[0];
+    }
+    else if (PyByteArray_Check(args[3]) && PyByteArray_GET_SIZE(args[3]) == 1) {
+        d = PyByteArray_AS_STRING(args[3])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 4", "a byte string of length 1", args[3]);
+        goto exit;
+    }
+    if (nargs < 5) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[4]) && PyBytes_GET_SIZE(args[4]) == 1) {
+        e = PyBytes_AS_STRING(args[4])[0];
+    }
+    else if (PyByteArray_Check(args[4]) && PyByteArray_GET_SIZE(args[4]) == 1) {
+        e = PyByteArray_AS_STRING(args[4])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 5", "a byte string of length 1", args[4]);
+        goto exit;
+    }
+    if (nargs < 6) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[5]) && PyBytes_GET_SIZE(args[5]) == 1) {
+        f = PyBytes_AS_STRING(args[5])[0];
+    }
+    else if (PyByteArray_Check(args[5]) && PyByteArray_GET_SIZE(args[5]) == 1) {
+        f = PyByteArray_AS_STRING(args[5])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 6", "a byte string of length 1", args[5]);
+        goto exit;
+    }
+    if (nargs < 7) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[6]) && PyBytes_GET_SIZE(args[6]) == 1) {
+        g = PyBytes_AS_STRING(args[6])[0];
+    }
+    else if (PyByteArray_Check(args[6]) && PyByteArray_GET_SIZE(args[6]) == 1) {
+        g = PyByteArray_AS_STRING(args[6])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 7", "a byte string of length 1", args[6]);
+        goto exit;
+    }
+    if (nargs < 8) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[7]) && PyBytes_GET_SIZE(args[7]) == 1) {
+        h = PyBytes_AS_STRING(args[7])[0];
+    }
+    else if (PyByteArray_Check(args[7]) && PyByteArray_GET_SIZE(args[7]) == 1) {
+        h = PyByteArray_AS_STRING(args[7])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 8", "a byte string of length 1", args[7]);
+        goto exit;
+    }
+    if (nargs < 9) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[8]) && PyBytes_GET_SIZE(args[8]) == 1) {
+        i = PyBytes_AS_STRING(args[8])[0];
+    }
+    else if (PyByteArray_Check(args[8]) && PyByteArray_GET_SIZE(args[8]) == 1) {
+        i = PyByteArray_AS_STRING(args[8])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 9", "a byte string of length 1", args[8]);
+        goto exit;
+    }
+    if (nargs < 10) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[9]) && PyBytes_GET_SIZE(args[9]) == 1) {
+        j = PyBytes_AS_STRING(args[9])[0];
+    }
+    else if (PyByteArray_Check(args[9]) && PyByteArray_GET_SIZE(args[9]) == 1) {
+        j = PyByteArray_AS_STRING(args[9])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 10", "a byte string of length 1", args[9]);
+        goto exit;
+    }
+    if (nargs < 11) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[10]) && PyBytes_GET_SIZE(args[10]) == 1) {
+        k = PyBytes_AS_STRING(args[10])[0];
+    }
+    else if (PyByteArray_Check(args[10]) && PyByteArray_GET_SIZE(args[10]) == 1) {
+        k = PyByteArray_AS_STRING(args[10])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 11", "a byte string of length 1", args[10]);
+        goto exit;
+    }
+    if (nargs < 12) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[11]) && PyBytes_GET_SIZE(args[11]) == 1) {
+        l = PyBytes_AS_STRING(args[11])[0];
+    }
+    else if (PyByteArray_Check(args[11]) && PyByteArray_GET_SIZE(args[11]) == 1) {
+        l = PyByteArray_AS_STRING(args[11])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 12", "a byte string of length 1", args[11]);
+        goto exit;
+    }
+    if (nargs < 13) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[12]) && PyBytes_GET_SIZE(args[12]) == 1) {
+        m = PyBytes_AS_STRING(args[12])[0];
+    }
+    else if (PyByteArray_Check(args[12]) && PyByteArray_GET_SIZE(args[12]) == 1) {
+        m = PyByteArray_AS_STRING(args[12])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 13", "a byte string of length 1", args[12]);
+        goto exit;
+    }
+    if (nargs < 14) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[13]) && PyBytes_GET_SIZE(args[13]) == 1) {
+        n = PyBytes_AS_STRING(args[13])[0];
+    }
+    else if (PyByteArray_Check(args[13]) && PyByteArray_GET_SIZE(args[13]) == 1) {
+        n = PyByteArray_AS_STRING(args[13])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 14", "a byte string of length 1", args[13]);
+        goto exit;
+    }
+skip_optional:
+    return_value = test_char_converter_impl(module, a, b, c, d, e, f, g, h, i, j, k, l, m, n);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
+                         char e, char f, char g, char h, char i, char j,
+                         char k, char l, char m, char n)
+/*[clinic end generated code: output=98589f02422fe6b1 input=e42330417a44feac]*/
+
+
+/*[clinic input]
+test_unsigned_char_converter
+
+    a: unsigned_char = 12
+    b: unsigned_char(bitwise=False) = 34
+    c: unsigned_char(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_char_converter__doc__,
+"test_unsigned_char_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_CHAR_CONVERTER_METHODDEF    \
+    {"test_unsigned_char_converter", _PyCFunction_CAST(test_unsigned_char_converter), METH_FASTCALL, test_unsigned_char_converter__doc__},
+
+static PyObject *
+test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
+                                  unsigned char b, unsigned char c);
+
+static PyObject *
+test_unsigned_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned char a = 12;
+    unsigned char b = 34;
+    unsigned char c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_char_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    {
+        long ival = PyLong_AsLong(args[0]);
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else if (ival < 0) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is less than minimum");
+            goto exit;
+        }
+        else if (ival > UCHAR_MAX) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is greater than maximum");
+            goto exit;
+        }
+        else {
+            a = (unsigned char) ival;
+        }
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    {
+        long ival = PyLong_AsLong(args[1]);
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else if (ival < 0) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is less than minimum");
+            goto exit;
+        }
+        else if (ival > UCHAR_MAX) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is greater than maximum");
+            goto exit;
+        }
+        else {
+            b = (unsigned char) ival;
+        }
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    {
+        unsigned long ival = PyLong_AsUnsignedLongMask(args[2]);
+        if (ival == (unsigned long)-1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else {
+            c = (unsigned char) ival;
+        }
+    }
+skip_optional:
+    return_value = test_unsigned_char_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
+                                  unsigned char b, unsigned char c)
+/*[clinic end generated code: output=45920dbedc22eb55 input=021414060993e289]*/
+
+
+/*[clinic input]
+test_short_converter
+
+    a: short = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_short_converter__doc__,
+"test_short_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_SHORT_CONVERTER_METHODDEF    \
+    {"test_short_converter", _PyCFunction_CAST(test_short_converter), METH_FASTCALL, test_short_converter__doc__},
+
+static PyObject *
+test_short_converter_impl(PyObject *module, short a);
+
+static PyObject *
+test_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    short a = 12;
+
+    if (!_PyArg_CheckPositional("test_short_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    {
+        long ival = PyLong_AsLong(args[0]);
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else if (ival < SHRT_MIN) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "signed short integer is less than minimum");
+            goto exit;
+        }
+        else if (ival > SHRT_MAX) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "signed short integer is greater than maximum");
+            goto exit;
+        }
+        else {
+            a = (short) ival;
+        }
+    }
+skip_optional:
+    return_value = test_short_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_short_converter_impl(PyObject *module, short a)
+/*[clinic end generated code: output=a580945bd6963d45 input=6a8a7a509a498ff4]*/
+
+
+/*[clinic input]
+test_unsigned_short_converter
+
+    a: unsigned_short = 12
+    b: unsigned_short(bitwise=False) = 34
+    c: unsigned_short(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_short_converter__doc__,
+"test_unsigned_short_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_SHORT_CONVERTER_METHODDEF    \
+    {"test_unsigned_short_converter", _PyCFunction_CAST(test_unsigned_short_converter), METH_FASTCALL, test_unsigned_short_converter__doc__},
+
+static PyObject *
+test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
+                                   unsigned short b, unsigned short c);
+
+static PyObject *
+test_unsigned_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned short a = 12;
+    unsigned short b = 34;
+    unsigned short c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_short_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedShort_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedShort_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    c = (unsigned short)PyLong_AsUnsignedLongMask(args[2]);
+    if (c == (unsigned short)-1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_unsigned_short_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
+                                   unsigned short b, unsigned short c)
+/*[clinic end generated code: output=e6e990df729114fc input=cdfd8eff3d9176b4]*/
+
+
+/*[clinic input]
+test_int_converter
+
+    a: int = 12
+    b: int(accept={int}) = 34
+    c: int(accept={str}) = 45
+    d: int(type='myenum') = 67
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_int_converter__doc__,
+"test_int_converter($module, a=12, b=34, c=45, d=67, /)\n"
+"--\n"
+"\n");
+
+#define TEST_INT_CONVERTER_METHODDEF    \
+    {"test_int_converter", _PyCFunction_CAST(test_int_converter), METH_FASTCALL, test_int_converter__doc__},
+
+static PyObject *
+test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d);
+
+static PyObject *
+test_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    int a = 12;
+    int b = 34;
+    int c = 45;
+    myenum d = 67;
+
+    if (!_PyArg_CheckPositional("test_int_converter", nargs, 0, 4)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = _PyLong_AsInt(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    b = _PyLong_AsInt(args[1]);
+    if (b == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!PyUnicode_Check(args[2])) {
+        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
+        goto exit;
+    }
+    if (PyUnicode_READY(args[2])) {
+        goto exit;
+    }
+    if (PyUnicode_GET_LENGTH(args[2]) != 1) {
+        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
+        goto exit;
+    }
+    c = PyUnicode_READ_CHAR(args[2], 0);
+    if (nargs < 4) {
+        goto skip_optional;
+    }
+    d = _PyLong_AsInt(args[3]);
+    if (d == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_int_converter_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d)
+/*[clinic end generated code: output=800993036e078c07 input=d20541fc1ca0553e]*/
+
+
+/*[clinic input]
+test_unsigned_int_converter
+
+    a: unsigned_int = 12
+    b: unsigned_int(bitwise=False) = 34
+    c: unsigned_int(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_int_converter__doc__,
+"test_unsigned_int_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_INT_CONVERTER_METHODDEF    \
+    {"test_unsigned_int_converter", _PyCFunction_CAST(test_unsigned_int_converter), METH_FASTCALL, test_unsigned_int_converter__doc__},
+
+static PyObject *
+test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
+                                 unsigned int b, unsigned int c);
+
+static PyObject *
+test_unsigned_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned int a = 12;
+    unsigned int b = 34;
+    unsigned int c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_int_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedInt_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedInt_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    c = (unsigned int)PyLong_AsUnsignedLongMask(args[2]);
+    if (c == (unsigned int)-1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_unsigned_int_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
+                                 unsigned int b, unsigned int c)
+/*[clinic end generated code: output=f9cdbe410ccc98a3 input=5533534828b62fc0]*/
+
+
+/*[clinic input]
+test_long_converter
+
+    a: long = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_long_converter__doc__,
+"test_long_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_LONG_CONVERTER_METHODDEF    \
+    {"test_long_converter", _PyCFunction_CAST(test_long_converter), METH_FASTCALL, test_long_converter__doc__},
+
+static PyObject *
+test_long_converter_impl(PyObject *module, long a);
+
+static PyObject *
+test_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    long a = 12;
+
+    if (!_PyArg_CheckPositional("test_long_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = PyLong_AsLong(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_long_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_long_converter_impl(PyObject *module, long a)
+/*[clinic end generated code: output=02b3a83495c1d236 input=d2179e3c9cdcde89]*/
+
+
+/*[clinic input]
+test_unsigned_long_converter
+
+    a: unsigned_long = 12
+    b: unsigned_long(bitwise=False) = 34
+    c: unsigned_long(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_long_converter__doc__,
+"test_unsigned_long_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_LONG_CONVERTER_METHODDEF    \
+    {"test_unsigned_long_converter", _PyCFunction_CAST(test_unsigned_long_converter), METH_FASTCALL, test_unsigned_long_converter__doc__},
+
+static PyObject *
+test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
+                                  unsigned long b, unsigned long c);
+
+static PyObject *
+test_unsigned_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned long a = 12;
+    unsigned long b = 34;
+    unsigned long c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_long_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLong_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLong_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!PyLong_Check(args[2])) {
+        _PyArg_BadArgument("test_unsigned_long_converter", "argument 3", "int", args[2]);
+        goto exit;
+    }
+    c = PyLong_AsUnsignedLongMask(args[2]);
+skip_optional:
+    return_value = test_unsigned_long_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
+                                  unsigned long b, unsigned long c)
+/*[clinic end generated code: output=540bb0ba2894e1fe input=f450d94cae1ef73b]*/
+
+
+/*[clinic input]
+test_long_long_converter
+
+    a: long_long = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_long_long_converter__doc__,
+"test_long_long_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_LONG_LONG_CONVERTER_METHODDEF    \
+    {"test_long_long_converter", _PyCFunction_CAST(test_long_long_converter), METH_FASTCALL, test_long_long_converter__doc__},
+
+static PyObject *
+test_long_long_converter_impl(PyObject *module, long long a);
+
+static PyObject *
+test_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    long long a = 12;
+
+    if (!_PyArg_CheckPositional("test_long_long_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = PyLong_AsLongLong(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_long_long_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_long_long_converter_impl(PyObject *module, long long a)
+/*[clinic end generated code: output=f9d4ed79ad2db857 input=d5fc81577ff4dd02]*/
+
+
+/*[clinic input]
+test_unsigned_long_long_converter
+
+    a: unsigned_long_long = 12
+    b: unsigned_long_long(bitwise=False) = 34
+    c: unsigned_long_long(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_long_long_converter__doc__,
+"test_unsigned_long_long_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_LONG_LONG_CONVERTER_METHODDEF    \
+    {"test_unsigned_long_long_converter", _PyCFunction_CAST(test_unsigned_long_long_converter), METH_FASTCALL, test_unsigned_long_long_converter__doc__},
+
+static PyObject *
+test_unsigned_long_long_converter_impl(PyObject *module,
+                                       unsigned long long a,
+                                       unsigned long long b,
+                                       unsigned long long c);
+
+static PyObject *
+test_unsigned_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned long long a = 12;
+    unsigned long long b = 34;
+    unsigned long long c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_long_long_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLongLong_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLongLong_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!PyLong_Check(args[2])) {
+        _PyArg_BadArgument("test_unsigned_long_long_converter", "argument 3", "int", args[2]);
+        goto exit;
+    }
+    c = PyLong_AsUnsignedLongLongMask(args[2]);
+skip_optional:
+    return_value = test_unsigned_long_long_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_long_long_converter_impl(PyObject *module,
+                                       unsigned long long a,
+                                       unsigned long long b,
+                                       unsigned long long c)
+/*[clinic end generated code: output=3d69994f618b46bb input=a15115dc41866ff4]*/
+
+
+/*[clinic input]
+test_Py_ssize_t_converter
+
+    a: Py_ssize_t = 12
+    b: Py_ssize_t(accept={int}) = 34
+    c: Py_ssize_t(accept={int, NoneType}) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_ssize_t_converter__doc__,
+"test_Py_ssize_t_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_SSIZE_T_CONVERTER_METHODDEF    \
+    {"test_Py_ssize_t_converter", _PyCFunction_CAST(test_Py_ssize_t_converter), METH_FASTCALL, test_Py_ssize_t_converter__doc__},
+
+static PyObject *
+test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                               Py_ssize_t c);
+
+static PyObject *
+test_Py_ssize_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    Py_ssize_t a = 12;
+    Py_ssize_t b = 34;
+    Py_ssize_t c = 56;
+
+    if (!_PyArg_CheckPositional("test_Py_ssize_t_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    {
+        Py_ssize_t ival = -1;
+        PyObject *iobj = _PyNumber_Index(args[0]);
+        if (iobj != NULL) {
+            ival = PyLong_AsSsize_t(iobj);
+            Py_DECREF(iobj);
+        }
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        a = ival;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    {
+        Py_ssize_t ival = -1;
+        PyObject *iobj = _PyNumber_Index(args[1]);
+        if (iobj != NULL) {
+            ival = PyLong_AsSsize_t(iobj);
+            Py_DECREF(iobj);
+        }
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        b = ival;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!_Py_convert_optional_to_ssize_t(args[2], &c)) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_Py_ssize_t_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                               Py_ssize_t c)
+/*[clinic end generated code: output=48214bc3d01f4dd7 input=3855f184bb3f299d]*/
+
+
+/*[clinic input]
+test_slice_index_converter
+
+    a: slice_index = 12
+    b: slice_index(accept={int}) = 34
+    c: slice_index(accept={int, NoneType}) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_slice_index_converter__doc__,
+"test_slice_index_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_SLICE_INDEX_CONVERTER_METHODDEF    \
+    {"test_slice_index_converter", _PyCFunction_CAST(test_slice_index_converter), METH_FASTCALL, test_slice_index_converter__doc__},
+
+static PyObject *
+test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                                Py_ssize_t c);
+
+static PyObject *
+test_slice_index_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    Py_ssize_t a = 12;
+    Py_ssize_t b = 34;
+    Py_ssize_t c = 56;
+
+    if (!_PyArg_CheckPositional("test_slice_index_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyEval_SliceIndex(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyEval_SliceIndexNotNone(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!_PyEval_SliceIndex(args[2], &c)) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_slice_index_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                                Py_ssize_t c)
+/*[clinic end generated code: output=67506ed999361212 input=edeadb0ee126f531]*/
+
+
+/*[clinic input]
+test_size_t_converter
+
+    a: size_t = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_size_t_converter__doc__,
+"test_size_t_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_SIZE_T_CONVERTER_METHODDEF    \
+    {"test_size_t_converter", _PyCFunction_CAST(test_size_t_converter), METH_FASTCALL, test_size_t_converter__doc__},
+
+static PyObject *
+test_size_t_converter_impl(PyObject *module, size_t a);
+
+static PyObject *
+test_size_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    size_t a = 12;
+
+    if (!_PyArg_CheckPositional("test_size_t_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_Size_t_Converter(args[0], &a)) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_size_t_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_size_t_converter_impl(PyObject *module, size_t a)
+/*[clinic end generated code: output=1653ecb5cbf775aa input=52e93a0fed0f1fb3]*/
+
+
+/*[clinic input]
+test_float_converter
+
+    a: float = 12.5
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_float_converter__doc__,
+"test_float_converter($module, a=12.5, /)\n"
+"--\n"
+"\n");
+
+#define TEST_FLOAT_CONVERTER_METHODDEF    \
+    {"test_float_converter", _PyCFunction_CAST(test_float_converter), METH_FASTCALL, test_float_converter__doc__},
+
+static PyObject *
+test_float_converter_impl(PyObject *module, float a);
+
+static PyObject *
+test_float_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    float a = 12.5;
+
+    if (!_PyArg_CheckPositional("test_float_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (PyFloat_CheckExact(args[0])) {
+        a = (float) (PyFloat_AS_DOUBLE(args[0]));
+    }
+    else
+    {
+        a = (float) PyFloat_AsDouble(args[0]);
+        if (a == -1.0 && PyErr_Occurred()) {
+            goto exit;
+        }
+    }
+skip_optional:
+    return_value = test_float_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_float_converter_impl(PyObject *module, float a)
+/*[clinic end generated code: output=36ad006990a8a91e input=259c0d98eca35034]*/
+
+
+/*[clinic input]
+test_double_converter
+
+    a: double = 12.5
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_double_converter__doc__,
+"test_double_converter($module, a=12.5, /)\n"
+"--\n"
+"\n");
+
+#define TEST_DOUBLE_CONVERTER_METHODDEF    \
+    {"test_double_converter", _PyCFunction_CAST(test_double_converter), METH_FASTCALL, test_double_converter__doc__},
+
+static PyObject *
+test_double_converter_impl(PyObject *module, double a);
+
+static PyObject *
+test_double_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    double a = 12.5;
+
+    if (!_PyArg_CheckPositional("test_double_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (PyFloat_CheckExact(args[0])) {
+        a = PyFloat_AS_DOUBLE(args[0]);
+    }
+    else
+    {
+        a = PyFloat_AsDouble(args[0]);
+        if (a == -1.0 && PyErr_Occurred()) {
+            goto exit;
+        }
+    }
+skip_optional:
+    return_value = test_double_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_double_converter_impl(PyObject *module, double a)
+/*[clinic end generated code: output=7435925592bac795 input=c6a9945706a41c27]*/
+
+
+/*[clinic input]
+test_Py_complex_converter
+
+    a: Py_complex
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_complex_converter__doc__,
+"test_Py_complex_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_COMPLEX_CONVERTER_METHODDEF    \
+    {"test_Py_complex_converter", (PyCFunction)test_Py_complex_converter, METH_O, test_Py_complex_converter__doc__},
+
+static PyObject *
+test_Py_complex_converter_impl(PyObject *module, Py_complex a);
+
+static PyObject *
+test_Py_complex_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    Py_complex a;
+
+    a = PyComplex_AsCComplex(arg);
+    if (PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = test_Py_complex_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_Py_complex_converter_impl(PyObject *module, Py_complex a)
+/*[clinic end generated code: output=c2ecbec2144ca540 input=070f216a515beb79]*/
+
+
+/*[clinic input]
+test_str_converter
+
+    a: str = NULL
+    b: str = "ab"
+    c: str(accept={str}) = "cd"
+    d: str(accept={robuffer}) = "cef"
+    e: str(accept={str, NoneType}) = "gh"
+    f: str(accept={robuffer}, zeroes=True) = "ij"
+    g: str(accept={robuffer, str}, zeroes=True) = "kl"
+    h: str(accept={robuffer, str, NoneType}, zeroes=True) = "mn"
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_str_converter__doc__,
+"test_str_converter($module, a=<unrepresentable>, b=\'ab\', c=\'cd\',\n"
+"                   d=\'cef\', e=\'gh\', f=\'ij\', g=\'kl\', h=\'mn\', /)\n"
+"--\n"
+"\n");
+
+#define TEST_STR_CONVERTER_METHODDEF    \
+    {"test_str_converter", _PyCFunction_CAST(test_str_converter), METH_FASTCALL, test_str_converter__doc__},
+
+static PyObject *
+test_str_converter_impl(PyObject *module, const char *a, const char *b,
+                        const char *c, const char *d, const char *e,
+                        const char *f, Py_ssize_t f_length, const char *g,
+                        Py_ssize_t g_length, const char *h,
+                        Py_ssize_t h_length);
+
+static PyObject *
+test_str_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    const char *a = NULL;
+    const char *b = "ab";
+    const char *c = "cd";
+    const char *d = "cef";
+    const char *e = "gh";
+    const char *f = "ij";
+    Py_ssize_t f_length;
+    const char *g = "kl";
+    Py_ssize_t g_length;
+    const char *h = "mn";
+    Py_ssize_t h_length;
+
+    if (!_PyArg_ParseStack(args, nargs, "|sssyzy#s#z#:test_str_converter",
+        &a, &b, &c, &d, &e, &f, &f_length, &g, &g_length, &h, &h_length)) {
+        goto exit;
+    }
+    return_value = test_str_converter_impl(module, a, b, c, d, e, f, f_length, g, g_length, h, h_length);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_str_converter_impl(PyObject *module, const char *a, const char *b,
+                        const char *c, const char *d, const char *e,
+                        const char *f, Py_ssize_t f_length, const char *g,
+                        Py_ssize_t g_length, const char *h,
+                        Py_ssize_t h_length)
+/*[clinic end generated code: output=82cb06d5237ef062 input=8afe9da8185cd38c]*/
+
+
+/*[clinic input]
+test_str_converter_encoding
+
+    a: str(encoding="idna")
+    b: str(encoding="idna", accept={str})
+    c: str(encoding="idna", accept={bytes, bytearray, str})
+    d: str(encoding="idna", zeroes=True)
+    e: str(encoding="idna", accept={bytes, bytearray, str}, zeroes=True)
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_str_converter_encoding__doc__,
+"test_str_converter_encoding($module, a, b, c, d, e, /)\n"
+"--\n"
+"\n");
+
+#define TEST_STR_CONVERTER_ENCODING_METHODDEF    \
+    {"test_str_converter_encoding", _PyCFunction_CAST(test_str_converter_encoding), METH_FASTCALL, test_str_converter_encoding__doc__},
+
+static PyObject *
+test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
+                                 char *d, Py_ssize_t d_length, char *e,
+                                 Py_ssize_t e_length);
+
+static PyObject *
+test_str_converter_encoding(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    char *a = NULL;
+    char *b = NULL;
+    char *c = NULL;
+    char *d = NULL;
+    Py_ssize_t d_length;
+    char *e = NULL;
+    Py_ssize_t e_length;
+
+    if (!_PyArg_ParseStack(args, nargs, "esesetes#et#:test_str_converter_encoding",
+        "idna", &a, "idna", &b, "idna", &c, "idna", &d, &d_length, "idna", &e, &e_length)) {
+        goto exit;
+    }
+    return_value = test_str_converter_encoding_impl(module, a, b, c, d, d_length, e, e_length);
+    /* Post parse cleanup for a */
+    PyMem_FREE(a);
+    /* Post parse cleanup for b */
+    PyMem_FREE(b);
+    /* Post parse cleanup for c */
+    PyMem_FREE(c);
+    /* Post parse cleanup for d */
+    PyMem_FREE(d);
+    /* Post parse cleanup for e */
+    PyMem_FREE(e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
+                                 char *d, Py_ssize_t d_length, char *e,
+                                 Py_ssize_t e_length)
+/*[clinic end generated code: output=999c1deecfa15b0a input=eb4c38e1f898f402]*/
+
+
+/*[clinic input]
+test_Py_UNICODE_converter
+
+    a: Py_UNICODE
+    b: Py_UNICODE(accept={str})
+    c: Py_UNICODE(accept={str, NoneType})
+    d: Py_UNICODE(zeroes=True)
+    e: Py_UNICODE(accept={str, NoneType}, zeroes=True)
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_UNICODE_converter__doc__,
+"test_Py_UNICODE_converter($module, a, b, c, d, e, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_UNICODE_CONVERTER_METHODDEF    \
+    {"test_Py_UNICODE_converter", _PyCFunction_CAST(test_Py_UNICODE_converter), METH_FASTCALL, test_Py_UNICODE_converter__doc__},
+
+static PyObject *
+test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
+                               const Py_UNICODE *b, const Py_UNICODE *c,
+                               const Py_UNICODE *d, Py_ssize_t d_length,
+                               const Py_UNICODE *e, Py_ssize_t e_length);
+
+static PyObject *
+test_Py_UNICODE_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    const Py_UNICODE *a = NULL;
+    const Py_UNICODE *b = NULL;
+    const Py_UNICODE *c = NULL;
+    const Py_UNICODE *d = NULL;
+    Py_ssize_t d_length;
+    const Py_UNICODE *e = NULL;
+    Py_ssize_t e_length;
+
+    if (!_PyArg_ParseStack(args, nargs, "O&O&O&u#Z#:test_Py_UNICODE_converter",
+        _PyUnicode_WideCharString_Converter, &a, _PyUnicode_WideCharString_Converter, &b, _PyUnicode_WideCharString_Opt_Converter, &c, &d, &d_length, &e, &e_length)) {
+        goto exit;
+    }
+    return_value = test_Py_UNICODE_converter_impl(module, a, b, c, d, d_length, e, e_length);
+
+exit:
+    /* Cleanup for a */
+    #if !USE_UNICODE_WCHAR_CACHE
+    PyMem_Free((void *)a);
+    #endif /* USE_UNICODE_WCHAR_CACHE */
+    /* Cleanup for b */
+    #if !USE_UNICODE_WCHAR_CACHE
+    PyMem_Free((void *)b);
+    #endif /* USE_UNICODE_WCHAR_CACHE */
+    /* Cleanup for c */
+    #if !USE_UNICODE_WCHAR_CACHE
+    PyMem_Free((void *)c);
+    #endif /* USE_UNICODE_WCHAR_CACHE */
+
+    return return_value;
+}
+
+static PyObject *
+test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
+                               const Py_UNICODE *b, const Py_UNICODE *c,
+                               const Py_UNICODE *d, Py_ssize_t d_length,
+                               const Py_UNICODE *e, Py_ssize_t e_length)
+/*[clinic end generated code: output=9d41b3a38a0f6f2f input=064a3b68ad7f04b0]*/
+
+
+/*[clinic input]
+test_Py_buffer_converter
+
+    a: Py_buffer
+    b: Py_buffer(accept={buffer})
+    c: Py_buffer(accept={str, buffer})
+    d: Py_buffer(accept={str, buffer, NoneType})
+    e: Py_buffer(accept={rwbuffer})
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_buffer_converter__doc__,
+"test_Py_buffer_converter($module, a, b, c, d, e, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_BUFFER_CONVERTER_METHODDEF    \
+    {"test_Py_buffer_converter", _PyCFunction_CAST(test_Py_buffer_converter), METH_FASTCALL, test_Py_buffer_converter__doc__},
+
+static PyObject *
+test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
+                              Py_buffer *c, Py_buffer *d, Py_buffer *e);
+
+static PyObject *
+test_Py_buffer_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    Py_buffer a = {NULL, NULL};
+    Py_buffer b = {NULL, NULL};
+    Py_buffer c = {NULL, NULL};
+    Py_buffer d = {NULL, NULL};
+    Py_buffer e = {NULL, NULL};
+
+    if (!_PyArg_ParseStack(args, nargs, "y*y*s*z*w*:test_Py_buffer_converter",
+        &a, &b, &c, &d, &e)) {
+        goto exit;
+    }
+    return_value = test_Py_buffer_converter_impl(module, &a, &b, &c, &d, &e);
+
+exit:
+    /* Cleanup for a */
+    if (a.obj) {
+       PyBuffer_Release(&a);
+    }
+    /* Cleanup for b */
+    if (b.obj) {
+       PyBuffer_Release(&b);
+    }
+    /* Cleanup for c */
+    if (c.obj) {
+       PyBuffer_Release(&c);
+    }
+    /* Cleanup for d */
+    if (d.obj) {
+       PyBuffer_Release(&d);
+    }
+    /* Cleanup for e */
+    if (e.obj) {
+       PyBuffer_Release(&e);
+    }
+
+    return return_value;
+}
+
+static PyObject *
+test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
+                              Py_buffer *c, Py_buffer *d, Py_buffer *e)
+/*[clinic end generated code: output=a153b71b4f45f952 input=6a9da0f56f9525fd]*/
+
+
+/*[clinic input]
+test_keywords
+
+    a: object
+    b: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords__doc__,
+"test_keywords($module, /, a, b)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_METHODDEF    \
+    {"test_keywords", _PyCFunction_CAST(test_keywords), METH_FASTCALL|METH_KEYWORDS, test_keywords__doc__},
+
+static PyObject *
+test_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *b;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    return_value = test_keywords_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=c03a52cfca192d3b input=0d3484844749c05b]*/
+
+
+/*[clinic input]
+test_keywords_kwonly
+
+    a: object
+    *
+    b: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_kwonly__doc__,
+"test_keywords_kwonly($module, /, a, *, b)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_KWONLY_METHODDEF    \
+    {"test_keywords_kwonly", _PyCFunction_CAST(test_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly__doc__},
+
+static PyObject *
+test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *b;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    return_value = test_keywords_kwonly_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=4704adcb6c7df928 input=384adc78bfa0bff7]*/
+
+
+/*[clinic input]
+test_keywords_opt
+
+    a: object
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_opt__doc__,
+"test_keywords_opt($module, /, a, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_OPT_METHODDEF    \
+    {"test_keywords_opt", _PyCFunction_CAST(test_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt__doc__},
+
+static PyObject *
+test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                       PyObject *c);
+
+static PyObject *
+test_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    c = args[2];
+skip_optional_pos:
+    return_value = test_keywords_opt_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                       PyObject *c)
+/*[clinic end generated code: output=de3ee1039da35fa1 input=eda7964f784f4607]*/
+
+
+/*[clinic input]
+test_keywords_opt_kwonly
+
+    a: object
+    b: object = None
+    *
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_opt_kwonly__doc__,
+"test_keywords_opt_kwonly($module, /, a, b=None, *, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_OPT_KWONLY_METHODDEF    \
+    {"test_keywords_opt_kwonly", _PyCFunction_CAST(test_keywords_opt_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt_kwonly__doc__},
+
+static PyObject *
+test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c, PyObject *d);
+
+static PyObject *
+test_keywords_opt_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt_kwonly", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_keywords_opt_kwonly_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c, PyObject *d)
+/*[clinic end generated code: output=996394678586854e input=209387a4815e5082]*/
+
+
+/*[clinic input]
+test_keywords_kwonly_opt
+
+    a: object
+    *
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_kwonly_opt__doc__,
+"test_keywords_kwonly_opt($module, /, a, *, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_KWONLY_OPT_METHODDEF    \
+    {"test_keywords_kwonly_opt", _PyCFunction_CAST(test_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly_opt__doc__},
+
+static PyObject *
+test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c);
+
+static PyObject *
+test_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly_opt", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    c = args[2];
+skip_optional_kwonly:
+    return_value = test_keywords_kwonly_opt_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c)
+/*[clinic end generated code: output=4ea9947a903a2f24 input=18393cc64fa000f4]*/
+
+
+/*[clinic input]
+test_posonly_keywords
+
+    a: object
+    /
+    b: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords__doc__,
+"test_posonly_keywords($module, a, /, b)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_METHODDEF    \
+    {"test_posonly_keywords", _PyCFunction_CAST(test_posonly_keywords), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords__doc__},
+
+static PyObject *
+test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_posonly_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *b;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    return_value = test_posonly_keywords_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=478aad346a188a80 input=1767b0ebdf06060e]*/
+
+
+/*[clinic input]
+test_posonly_kwonly
+
+    a: object
+    /
+    *
+    c: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_kwonly__doc__,
+"test_posonly_kwonly($module, a, /, *, c)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KWONLY_METHODDEF    \
+    {"test_posonly_kwonly", _PyCFunction_CAST(test_posonly_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly__doc__},
+
+static PyObject *
+test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c);
+
+static PyObject *
+test_posonly_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *c;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    c = args[1];
+    return_value = test_posonly_kwonly_impl(module, a, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c)
+/*[clinic end generated code: output=d747975a0b28e9c2 input=9042f2818f664839]*/
+
+
+/*[clinic input]
+test_posonly_keywords_kwonly
+
+    a: object
+    /
+    b: object
+    *
+    c: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_kwonly__doc__,
+"test_posonly_keywords_kwonly($module, a, /, b, *, c)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_KWONLY_METHODDEF    \
+    {"test_posonly_keywords_kwonly", _PyCFunction_CAST(test_posonly_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly__doc__},
+
+static PyObject *
+test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                                  PyObject *c);
+
+static PyObject *
+test_posonly_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly", 0};
+    PyObject *argsbuf[3];
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    c = args[2];
+    return_value = test_posonly_keywords_kwonly_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                                  PyObject *c)
+/*[clinic end generated code: output=5b99f692f8ddaa4a input=29546ebdca492fea]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt
+
+    a: object
+    /
+    b: object
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt__doc__,
+"test_posonly_keywords_opt($module, a, /, b, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT_METHODDEF    \
+    {"test_posonly_keywords_opt", _PyCFunction_CAST(test_posonly_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                               PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 4, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    d = args[3];
+skip_optional_pos:
+    return_value = test_posonly_keywords_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                               PyObject *c, PyObject *d)
+/*[clinic end generated code: output=fd5dfbac5727aebb input=cdf5a9625e554e9b]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt2
+
+    a: object
+    /
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt2__doc__,
+"test_posonly_keywords_opt2($module, a, /, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT2_METHODDEF    \
+    {"test_posonly_keywords_opt2", _PyCFunction_CAST(test_posonly_keywords_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2__doc__},
+
+static PyObject *
+test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                                PyObject *c);
+
+static PyObject *
+test_posonly_keywords_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    c = args[2];
+skip_optional_pos:
+    return_value = test_posonly_keywords_opt2_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                                PyObject *c)
+/*[clinic end generated code: output=777f58ac70775420 input=1581299d21d16f14]*/
+
+
+/*[clinic input]
+test_posonly_opt_keywords_opt
+
+    a: object
+    b: object = None
+    /
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_opt_keywords_opt__doc__,
+"test_posonly_opt_keywords_opt($module, a, b=None, /, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_OPT_KEYWORDS_OPT_METHODDEF    \
+    {"test_posonly_opt_keywords_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt__doc__},
+
+static PyObject *
+test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
+                                   PyObject *b, PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_opt_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional_posonly;
+    }
+    noptargs--;
+    b = args[1];
+skip_optional_posonly:
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    d = args[3];
+skip_optional_pos:
+    return_value = test_posonly_opt_keywords_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
+                                   PyObject *b, PyObject *c, PyObject *d)
+/*[clinic end generated code: output=2c18b8edff78ed22 input=408798ec3d42949f]*/
+
+
+/*[clinic input]
+test_posonly_kwonly_opt
+
+    a: object
+    /
+    *
+    b: object
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_kwonly_opt__doc__,
+"test_posonly_kwonly_opt($module, a, /, *, b, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_kwonly_opt", _PyCFunction_CAST(test_posonly_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                             PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_posonly_kwonly_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                             PyObject *c, PyObject *d)
+/*[clinic end generated code: output=8db9ab5602e1efaf input=8d8e5643bbbc2309]*/
+
+
+/*[clinic input]
+test_posonly_kwonly_opt2
+
+    a: object
+    /
+    *
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_kwonly_opt2__doc__,
+"test_posonly_kwonly_opt2($module, a, /, *, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KWONLY_OPT2_METHODDEF    \
+    {"test_posonly_kwonly_opt2", _PyCFunction_CAST(test_posonly_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt2__doc__},
+
+static PyObject *
+test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c);
+
+static PyObject *
+test_posonly_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt2", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    c = args[2];
+skip_optional_kwonly:
+    return_value = test_posonly_kwonly_opt2_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c)
+/*[clinic end generated code: output=6cfe546265d85d2c input=f7e5eed94f75fff0]*/
+
+
+/*[clinic input]
+test_posonly_opt_kwonly_opt
+
+    a: object
+    b: object = None
+    /
+    *
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_opt_kwonly_opt__doc__,
+"test_posonly_opt_kwonly_opt($module, a, b=None, /, *, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_OPT_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                                 PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_kwonly_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional_posonly;
+    }
+    noptargs--;
+    b = args[1];
+skip_optional_posonly:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_posonly_opt_kwonly_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                                 PyObject *c, PyObject *d)
+/*[clinic end generated code: output=8b5e21a30cad22b7 input=1e557dc979d120fd]*/
+
+
+/*[clinic input]
+test_posonly_keywords_kwonly_opt
+
+    a: object
+    /
+    b: object
+    *
+    c: object
+    d: object = None
+    e: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_kwonly_opt__doc__,
+"test_posonly_keywords_kwonly_opt($module, a, /, b, *, c, d=None, e=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_keywords_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                      PyObject *b, PyObject *c, PyObject *d,
+                                      PyObject *e);
+
+static PyObject *
+test_posonly_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt", 0};
+    PyObject *argsbuf[5];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    c = args[2];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    e = args[4];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_kwonly_opt_impl(module, a, b, c, d, e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                      PyObject *b, PyObject *c, PyObject *d,
+                                      PyObject *e)
+/*[clinic end generated code: output=950b9ace38b8b4a7 input=c3884a4f956fdc89]*/
+
+
+/*[clinic input]
+test_posonly_keywords_kwonly_opt2
+
+    a: object
+    /
+    b: object
+    *
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_kwonly_opt2__doc__,
+"test_posonly_keywords_kwonly_opt2($module, a, /, b, *, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_KWONLY_OPT2_METHODDEF    \
+    {"test_posonly_keywords_kwonly_opt2", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt2__doc__},
+
+static PyObject *
+test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_keywords_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt2", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_kwonly_opt2_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d)
+/*[clinic end generated code: output=fb6951a21b517317 input=68d01d7c0f6dafb0]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt_kwonly_opt
+
+    a: object
+    /
+    b: object
+    c: object = None
+    *
+    d: object = None
+    e: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt_kwonly_opt__doc__,
+"test_posonly_keywords_opt_kwonly_opt($module, a, /, b, c=None, *,\n"
+"                                     d=None, e=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                          PyObject *b, PyObject *c,
+                                          PyObject *d, PyObject *e);
+
+static PyObject *
+test_posonly_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt_kwonly_opt", 0};
+    PyObject *argsbuf[5];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    e = args[4];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                          PyObject *b, PyObject *c,
+                                          PyObject *d, PyObject *e)
+/*[clinic end generated code: output=4db10815a99a857e input=d0883d45876f186c]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt2_kwonly_opt
+
+    a: object
+    /
+    b: object = None
+    c: object = None
+    *
+    d: object = None
+    e: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt2_kwonly_opt__doc__,
+"test_posonly_keywords_opt2_kwonly_opt($module, a, /, b=None, c=None, *,\n"
+"                                      d=None, e=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT2_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_keywords_opt2_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt2_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                           PyObject *b, PyObject *c,
+                                           PyObject *d, PyObject *e);
+
+static PyObject *
+test_posonly_keywords_opt2_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2_kwonly_opt", 0};
+    PyObject *argsbuf[5];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    e = args[4];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_opt2_kwonly_opt_impl(module, a, b, c, d, e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                           PyObject *b, PyObject *c,
+                                           PyObject *d, PyObject *e)
+/*[clinic end generated code: output=0416689b23ebf66e input=c95e2e1ec93035ad]*/
+
+
+/*[clinic input]
+test_posonly_opt_keywords_opt_kwonly_opt
+
+    a: object
+    b: object = None
+    /
+    c: object = None
+    d: object = None
+    *
+    e: object = None
+    f: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_opt_keywords_opt_kwonly_opt__doc__,
+"test_posonly_opt_keywords_opt_kwonly_opt($module, a, b=None, /, c=None,\n"
+"                                         d=None, *, e=None, f=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_OPT_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_opt_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                              PyObject *b, PyObject *c,
+                                              PyObject *d, PyObject *e,
+                                              PyObject *f);
+
+static PyObject *
+test_posonly_opt_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "", "c", "d", "e", "f", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt_kwonly_opt", 0};
+    PyObject *argsbuf[6];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+    PyObject *f = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional_posonly;
+    }
+    noptargs--;
+    b = args[1];
+skip_optional_posonly:
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[4]) {
+        e = args[4];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    f = args[5];
+skip_optional_kwonly:
+    return_value = test_posonly_opt_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e, f);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                              PyObject *b, PyObject *c,
+                                              PyObject *d, PyObject *e,
+                                              PyObject *f)
+/*[clinic end generated code: output=8892a137a8c8f46f input=9914857713c5bbf8]*/
+
+/*[clinic input]
+test_keyword_only_parameter
+
+
+    *
+    co_lnotab: PyBytesObject(c_default="(PyBytesObject *)self->co_lnotab") = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keyword_only_parameter__doc__,
+"test_keyword_only_parameter($module, /, *, co_lnotab=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORD_ONLY_PARAMETER_METHODDEF    \
+    {"test_keyword_only_parameter", _PyCFunction_CAST(test_keyword_only_parameter), METH_FASTCALL|METH_KEYWORDS, test_keyword_only_parameter__doc__},
+
+static PyObject *
+test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab);
+
+static PyObject *
+test_keyword_only_parameter(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"co_lnotab", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keyword_only_parameter", 0};
+    PyObject *argsbuf[1];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
+    PyBytesObject *co_lnotab = (PyBytesObject *)self->co_lnotab;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (!PyBytes_Check(args[0])) {
+        _PyArg_BadArgument("test_keyword_only_parameter", "argument 'co_lnotab'", "bytes", args[0]);
+        goto exit;
+    }
+    co_lnotab = (PyBytesObject *)args[0];
+skip_optional_kwonly:
+    return_value = test_keyword_only_parameter_impl(module, co_lnotab);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab)
+/*[clinic end generated code: output=332b5f4b444c5d55 input=303df5046c7e37a3]*/
+
+
+/*[clinic input]
+output push
+output preset buffer
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5bff3376ee0df0b5]*/
+
+#ifdef CONDITION_A
+/*[clinic input]
+test_preprocessor_guarded_condition_a
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_condition_a_impl(PyObject *module)
+/*[clinic end generated code: output=ad012af18085add6 input=8edb8706a98cda7e]*/
+#elif CONDITION_B
+/*[clinic input]
+test_preprocessor_guarded_elif_condition_b
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_elif_condition_b_impl(PyObject *module)
+/*[clinic end generated code: output=615f2dee82b138d1 input=53777cebbf7fee32]*/
+#else
+/*[clinic input]
+test_preprocessor_guarded_else
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_else_impl(PyObject *module)
+/*[clinic end generated code: output=13af7670aac51b12 input=6657ab31d74c29fc]*/
+#endif
+
+#ifndef CONDITION_C
+/*[clinic input]
+test_preprocessor_guarded_ifndef_condition_c
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_ifndef_condition_c_impl(PyObject *module)
+/*[clinic end generated code: output=ed422e8c895bb0a5 input=e9b50491cea2b668]*/
+#else
+/*[clinic input]
+test_preprocessor_guarded_ifndef_not_condition_c
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_ifndef_not_condition_c_impl(PyObject *module)
+/*[clinic end generated code: output=de6f4c6a67f8c536 input=da74e30e01c6f2c5]*/
+#endif
+
+#if \
+CONDITION_D
+/*[clinic input]
+test_preprocessor_guarded_if_with_continuation
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_if_with_continuation_impl(PyObject *module)
+/*[clinic end generated code: output=3d0712ca9e2d15b9 input=4a956fd91be30284]*/
+#endif
+
+#if CONDITION_E ||CONDITION_F
+#warning "different type of CPP directive"
+/*[clinic input]
+test_preprocessor_guarded_if_e_or_f
+Makes sure cpp.Monitor handles other directives than preprocessor conditionals.
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_if_e_or_f_impl(PyObject *module)
+/*[clinic end generated code: output=e49d24ff64ad88bc input=57b9c37f938bc4f1]*/
+#endif
+
+/*[clinic input]
+dump buffer
+output pop
+[clinic start generated code]*/
+
+#if defined(CONDITION_A)
+
+PyDoc_STRVAR(test_preprocessor_guarded_condition_a__doc__,
+"test_preprocessor_guarded_condition_a($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF    \
+    {"test_preprocessor_guarded_condition_a", (PyCFunction)test_preprocessor_guarded_condition_a, METH_NOARGS, test_preprocessor_guarded_condition_a__doc__},
+
+static PyObject *
+test_preprocessor_guarded_condition_a(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_condition_a_impl(module);
+}
+
+#endif /* defined(CONDITION_A) */
+
+#if !defined(CONDITION_A) && (CONDITION_B)
+
+PyDoc_STRVAR(test_preprocessor_guarded_elif_condition_b__doc__,
+"test_preprocessor_guarded_elif_condition_b($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF    \
+    {"test_preprocessor_guarded_elif_condition_b", (PyCFunction)test_preprocessor_guarded_elif_condition_b, METH_NOARGS, test_preprocessor_guarded_elif_condition_b__doc__},
+
+static PyObject *
+test_preprocessor_guarded_elif_condition_b(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_elif_condition_b_impl(module);
+}
+
+#endif /* !defined(CONDITION_A) && (CONDITION_B) */
+
+#if !defined(CONDITION_A) && !(CONDITION_B)
+
+PyDoc_STRVAR(test_preprocessor_guarded_else__doc__,
+"test_preprocessor_guarded_else($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF    \
+    {"test_preprocessor_guarded_else", (PyCFunction)test_preprocessor_guarded_else, METH_NOARGS, test_preprocessor_guarded_else__doc__},
+
+static PyObject *
+test_preprocessor_guarded_else(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_else_impl(module);
+}
+
+#endif /* !defined(CONDITION_A) && !(CONDITION_B) */
+
+#if !defined(CONDITION_C)
+
+PyDoc_STRVAR(test_preprocessor_guarded_ifndef_condition_c__doc__,
+"test_preprocessor_guarded_ifndef_condition_c($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF    \
+    {"test_preprocessor_guarded_ifndef_condition_c", (PyCFunction)test_preprocessor_guarded_ifndef_condition_c, METH_NOARGS, test_preprocessor_guarded_ifndef_condition_c__doc__},
+
+static PyObject *
+test_preprocessor_guarded_ifndef_condition_c(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_ifndef_condition_c_impl(module);
+}
+
+#endif /* !defined(CONDITION_C) */
+
+#if defined(CONDITION_C)
+
+PyDoc_STRVAR(test_preprocessor_guarded_ifndef_not_condition_c__doc__,
+"test_preprocessor_guarded_ifndef_not_condition_c($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF    \
+    {"test_preprocessor_guarded_ifndef_not_condition_c", (PyCFunction)test_preprocessor_guarded_ifndef_not_condition_c, METH_NOARGS, test_preprocessor_guarded_ifndef_not_condition_c__doc__},
+
+static PyObject *
+test_preprocessor_guarded_ifndef_not_condition_c(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_ifndef_not_condition_c_impl(module);
+}
+
+#endif /* defined(CONDITION_C) */
+
+#if (CONDITION_D)
+
+PyDoc_STRVAR(test_preprocessor_guarded_if_with_continuation__doc__,
+"test_preprocessor_guarded_if_with_continuation($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF    \
+    {"test_preprocessor_guarded_if_with_continuation", (PyCFunction)test_preprocessor_guarded_if_with_continuation, METH_NOARGS, test_preprocessor_guarded_if_with_continuation__doc__},
+
+static PyObject *
+test_preprocessor_guarded_if_with_continuation(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_if_with_continuation_impl(module);
+}
+
+#endif /* (CONDITION_D) */
+
+#if (CONDITION_E || CONDITION_F)
+
+PyDoc_STRVAR(test_preprocessor_guarded_if_e_or_f__doc__,
+"test_preprocessor_guarded_if_e_or_f($module, /)\n"
+"--\n"
+"\n"
+"Makes sure cpp.Monitor handles other directives than preprocessor conditionals.");
+
+#define TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF    \
+    {"test_preprocessor_guarded_if_e_or_f", (PyCFunction)test_preprocessor_guarded_if_e_or_f, METH_NOARGS, test_preprocessor_guarded_if_e_or_f__doc__},
+
+static PyObject *
+test_preprocessor_guarded_if_e_or_f(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_if_e_or_f_impl(module);
+}
+
+#endif /* (CONDITION_E || CONDITION_F) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF) */
+/*[clinic end generated code: output=fcfae7cac7a99e62 input=3fc80c9989d2f2e1]*/
+
+/*[clinic input]
+test_vararg_and_posonly
+
+
+    a: object
+    *args: object
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg_and_posonly__doc__,
+"test_vararg_and_posonly($module, a, /, *args)\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_AND_POSONLY_METHODDEF    \
+    {"test_vararg_and_posonly", _PyCFunction_CAST(test_vararg_and_posonly), METH_FASTCALL, test_vararg_and_posonly__doc__},
+
+static PyObject *
+test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args);
+
+static PyObject *
+test_vararg_and_posonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *__clinic_args = NULL;
+
+    if (!_PyArg_CheckPositional("test_vararg_and_posonly", nargs, 1, PY_SSIZE_T_MAX)) {
+        goto exit;
+    }
+    a = args[0];
+    __clinic_args = PyTuple_New(nargs - 1);
+    if (!__clinic_args) {
+        goto exit;
+    }
+    for (Py_ssize_t i = 0; i < nargs - 1; ++i) {
+        PyTuple_SET_ITEM(__clinic_args, i, Py_NewRef(args[1 + i]));
+    }
+    return_value = test_vararg_and_posonly_impl(module, a, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args)
+/*[clinic end generated code: output=79b75dc07decc8d6 input=08dc2bf7afbf1613]*/
+
+/*[clinic input]
+test_vararg
+
+
+    a: object
+    *args: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg__doc__,
+"test_vararg($module, /, a, *args)\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_METHODDEF    \
+    {"test_vararg", _PyCFunction_CAST(test_vararg), METH_FASTCALL|METH_KEYWORDS, test_vararg__doc__},
+
+static PyObject *
+test_vararg_impl(PyObject *module, PyObject *a, PyObject *args);
+
+static PyObject *
+test_vararg(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *__clinic_args = NULL;
+
+    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    __clinic_args = args[1];
+    return_value = test_vararg_impl(module, a, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_impl(PyObject *module, PyObject *a, PyObject *args)
+/*[clinic end generated code: output=ce9334333757f6ea input=81d33815ad1bae6e]*/
+
+/*[clinic input]
+test_vararg_with_default
+
+
+    a: object
+    *args: object
+    b: bool = False
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg_with_default__doc__,
+"test_vararg_with_default($module, /, a, *args, b=False)\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_WITH_DEFAULT_METHODDEF    \
+    {"test_vararg_with_default", _PyCFunction_CAST(test_vararg_with_default), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_default__doc__},
+
+static PyObject *
+test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
+                              int b);
+
+static PyObject *
+test_vararg_with_default(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_default", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = Py_MIN(nargs, 1) + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *__clinic_args = NULL;
+    int b = 0;
+
+    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    __clinic_args = args[1];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    b = PyObject_IsTrue(args[2]);
+    if (b < 0) {
+        goto exit;
+    }
+skip_optional_kwonly:
+    return_value = test_vararg_with_default_impl(module, a, __clinic_args, b);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
+                              int b)
+/*[clinic end generated code: output=32fb19dd6bcf9185 input=6e110b54acd9b22d]*/
+
+/*[clinic input]
+test_vararg_with_only_defaults
+
+
+    *args: object
+    b: bool = False
+    c: object = ' '
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg_with_only_defaults__doc__,
+"test_vararg_with_only_defaults($module, /, *args, b=False, c=\' \')\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_WITH_ONLY_DEFAULTS_METHODDEF    \
+    {"test_vararg_with_only_defaults", _PyCFunction_CAST(test_vararg_with_only_defaults), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_only_defaults__doc__},
+
+static PyObject *
+test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
+                                    PyObject *c);
+
+static PyObject *
+test_vararg_with_only_defaults(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_only_defaults", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = 0 + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
+    PyObject *__clinic_args = NULL;
+    int b = 0;
+    PyObject *c = " ";
+
+    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    __clinic_args = args[0];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[1]) {
+        b = PyObject_IsTrue(args[1]);
+        if (b < 0) {
+            goto exit;
+        }
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    c = args[2];
+skip_optional_kwonly:
+    return_value = test_vararg_with_only_defaults_impl(module, __clinic_args, b, c);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
+                                    PyObject *c)
+/*[clinic end generated code: output=7e393689e6ce61a3 input=fa56a709a035666e]*/
+
+/*[clinic input]
+test_paramname_module
+
+    module as mod: object
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_paramname_module__doc__,
+"test_paramname_module($module, /, module)\n"
+"--\n"
+"\n");
+
+#define TEST_PARAMNAME_MODULE_METHODDEF    \
+    {"test_paramname_module", _PyCFunction_CAST(test_paramname_module), METH_FASTCALL|METH_KEYWORDS, test_paramname_module__doc__},
+
+static PyObject *
+test_paramname_module_impl(PyObject *module, PyObject *mod);
+
+static PyObject *
+test_paramname_module(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"module", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_paramname_module", 0};
+    PyObject *argsbuf[1];
+    PyObject *mod;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    mod = args[0];
+    return_value = test_paramname_module_impl(module, mod);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_paramname_module_impl(PyObject *module, PyObject *mod)
+/*[clinic end generated code: output=23379a7ffa65c514 input=afefe259667f13ba]*/
+
+
+/*[clinic input]
+Test.cls_with_param
+    cls: defining_class
+    /
+    a: int
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_cls_with_param__doc__,
+"cls_with_param($self, /, a)\n"
+"--\n"
+"\n");
+
+#define TEST_CLS_WITH_PARAM_METHODDEF    \
+    {"cls_with_param", _PyCFunction_CAST(Test_cls_with_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, Test_cls_with_param__doc__},
+
+static PyObject *
+Test_cls_with_param_impl(TestObj *self, PyTypeObject *cls, int a);
+
+static PyObject *
+Test_cls_with_param(TestObj *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "cls_with_param", 0};
+    PyObject *argsbuf[1];
+    int a;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = _PyLong_AsInt(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = Test_cls_with_param_impl(self, cls, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+Test_cls_with_param_impl(TestObj *self, PyTypeObject *cls, int a)
+/*[clinic end generated code: output=9c06a8cfc495b4d1 input=af158077bd237ef9]*/
+
+
+/*[clinic input]
+Test.__init__
+Empty init method.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test___init____doc__,
+"Test()\n"
+"--\n"
+"\n"
+"Empty init method.");
+
+static int
+Test___init___impl(TestObj *self);
+
+static int
+Test___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    int return_value = -1;
+
+    if ((Py_IS_TYPE(self, TestType) ||
+         Py_TYPE(self)->tp_new == TestType->tp_new) &&
+        !_PyArg_NoPositional("Test", args)) {
+        goto exit;
+    }
+    if ((Py_IS_TYPE(self, TestType) ||
+         Py_TYPE(self)->tp_new == TestType->tp_new) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    return_value = Test___init___impl((TestObj *)self);
+
+exit:
+    return return_value;
+}
+
+static int
+Test___init___impl(TestObj *self)
+/*[clinic end generated code: output=f02b7d23eec3dc47 input=4ea79fee54d0c3ff]*/
+
+
+/*[clinic input]
+@classmethod
+Test.__new__
+Empty new method.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test__doc__,
+"Test()\n"
+"--\n"
+"\n"
+"Empty new method.");
+
+static PyObject *
+Test_impl(PyTypeObject *type);
+
+static PyObject *
+Test(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyObject *return_value = NULL;
+
+    if ((type == TestType ||
+         type->tp_init == TestType->tp_init) &&
+        !_PyArg_NoPositional("Test", args)) {
+        goto exit;
+    }
+    if ((type == TestType ||
+         type->tp_init == TestType->tp_init) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    return_value = Test_impl(type);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+Test_impl(PyTypeObject *type)
+/*[clinic end generated code: output=3a8a564e799cf5ce input=6fe98a19f097907f]*/
+
+
+/*[clinic input]
+Test.cls_no_params
+    cls: defining_class
+    /
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_cls_no_params__doc__,
+"cls_no_params($self, /)\n"
+"--\n"
+"\n");
+
+#define TEST_CLS_NO_PARAMS_METHODDEF    \
+    {"cls_no_params", _PyCFunction_CAST(Test_cls_no_params), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, Test_cls_no_params__doc__},
+
+static PyObject *
+Test_cls_no_params_impl(TestObj *self, PyTypeObject *cls);
+
+static PyObject *
+Test_cls_no_params(TestObj *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    if (nargs) {
+        PyErr_SetString(PyExc_TypeError, "cls_no_params() takes no arguments");
+        return NULL;
+    }
+    return Test_cls_no_params_impl(self, cls);
+}
+
+static PyObject *
+Test_cls_no_params_impl(TestObj *self, PyTypeObject *cls)
+/*[clinic end generated code: output=cc8845f22cff3dcb input=e7e2e4e344e96a11]*/
+
+
+/*[clinic input]
+Test.metho_not_default_return_converter -> int
+    a: object
+    /
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_metho_not_default_return_converter__doc__,
+"metho_not_default_return_converter($self, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_METHO_NOT_DEFAULT_RETURN_CONVERTER_METHODDEF    \
+    {"metho_not_default_return_converter", (PyCFunction)Test_metho_not_default_return_converter, METH_O, Test_metho_not_default_return_converter__doc__},
+
+static int
+Test_metho_not_default_return_converter_impl(TestObj *self, PyObject *a);
+
+static PyObject *
+Test_metho_not_default_return_converter(TestObj *self, PyObject *a)
+{
+    PyObject *return_value = NULL;
+    int _return_value;
+
+    _return_value = Test_metho_not_default_return_converter_impl(self, a);
+    if ((_return_value == -1) && PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = PyLong_FromLong((long)_return_value);
+
+exit:
+    return return_value;
+}
+
+static int
+Test_metho_not_default_return_converter_impl(TestObj *self, PyObject *a)
+/*[clinic end generated code: output=3350de11bd538007 input=428657129b521177]*/
+
+
+/*[clinic input]
+Test.an_metho_arg_named_arg
+    arg: int
+        Name should be mangled to 'arg_' in generated output.
+    /
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_an_metho_arg_named_arg__doc__,
+"an_metho_arg_named_arg($self, arg, /)\n"
+"--\n"
+"\n"
+"\n"
+"\n"
+"  arg\n"
+"    Name should be mangled to \'arg_\' in generated output.");
+
+#define TEST_AN_METHO_ARG_NAMED_ARG_METHODDEF    \
+    {"an_metho_arg_named_arg", (PyCFunction)Test_an_metho_arg_named_arg, METH_O, Test_an_metho_arg_named_arg__doc__},
+
+static PyObject *
+Test_an_metho_arg_named_arg_impl(TestObj *self, int arg);
+
+static PyObject *
+Test_an_metho_arg_named_arg(TestObj *self, PyObject *arg_)
+{
+    PyObject *return_value = NULL;
+    int arg;
+
+    arg = _PyLong_AsInt(arg_);
+    if (arg == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = Test_an_metho_arg_named_arg_impl(self, arg);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+Test_an_metho_arg_named_arg_impl(TestObj *self, int arg)
+/*[clinic end generated code: output=7d590626642194ae input=2a53a57cf5624f95]*/
+
+
+/*[clinic input]
+Test.__init__
+    *args: object
+    /
+Varargs init method. For example, nargs is translated to PyTuple_GET_SIZE.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test___init____doc__,
+"Test(*args)\n"
+"--\n"
+"\n"
+"Varargs init method. For example, nargs is translated to PyTuple_GET_SIZE.");
+
+static int
+Test___init___impl(TestObj *self, PyObject *args);
+
+static int
+Test___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    int return_value = -1;
+    PyObject *__clinic_args = NULL;
+
+    if ((Py_IS_TYPE(self, TestType) ||
+         Py_TYPE(self)->tp_new == TestType->tp_new) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    if (!_PyArg_CheckPositional("Test", PyTuple_GET_SIZE(args), 0, PY_SSIZE_T_MAX)) {
+        goto exit;
+    }
+    __clinic_args = PyTuple_GetSlice(0, -1);
+    return_value = Test___init___impl((TestObj *)self, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static int
+Test___init___impl(TestObj *self, PyObject *args)
+/*[clinic end generated code: output=126ad63fc2e5139e input=96c3ddc0cd38fc0c]*/
+
+
+/*[clinic input]
+@classmethod
+Test.__new__
+    *args: object
+    /
+Varargs new method. For example, nargs is translated to PyTuple_GET_SIZE.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test__doc__,
+"Test(*args)\n"
+"--\n"
+"\n"
+"Varargs new method. For example, nargs is translated to PyTuple_GET_SIZE.");
+
+static PyObject *
+Test_impl(PyTypeObject *type, PyObject *args);
+
+static PyObject *
+Test(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *__clinic_args = NULL;
+
+    if ((type == TestType ||
+         type->tp_init == TestType->tp_init) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    if (!_PyArg_CheckPositional("Test", PyTuple_GET_SIZE(args), 0, PY_SSIZE_T_MAX)) {
+        goto exit;
+    }
+    __clinic_args = PyTuple_GetSlice(0, -1);
+    return_value = Test_impl(type, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+Test_impl(PyTypeObject *type, PyObject *args)
+/*[clinic end generated code: output=4f01d446cfe4aeb9 input=26a672e2e9750120]*/
+
+
+/*[clinic input]
+Test.__init__
+    a: object
+Init method with positional or keyword arguments.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test___init____doc__,
+"Test(a)\n"
+"--\n"
+"\n"
+"Init method with positional or keyword arguments.");
+
+static int
+Test___init___impl(TestObj *self, PyObject *a);
+
+static int
+Test___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    int return_value = -1;
+    static const char * const _keywords[] = {"a", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "Test", 0};
+    PyObject *argsbuf[1];
+    PyObject * const *fastargs;
+    Py_ssize_t nargs = PyTuple_GET_SIZE(args);
+    PyObject *a;
+
+    fastargs = _PyArg_UnpackKeywords(_PyTuple_CAST(args)->ob_item, nargs, kwargs, NULL, &_parser, 1, 1, 0, argsbuf);
+    if (!fastargs) {
+        goto exit;
+    }
+    a = fastargs[0];
+    return_value = Test___init___impl((TestObj *)self, a);
+
+exit:
+    return return_value;
+}
+
+static int
+Test___init___impl(TestObj *self, PyObject *a)
+/*[clinic end generated code: output=5afcf1a525211a09 input=a8f9222a6ab35c59]*/
+
+
+/*[clinic input]
+@classmethod
+Test.class_method
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_class_method__doc__,
+"class_method($type, /)\n"
+"--\n"
+"\n");
+
+#define TEST_CLASS_METHOD_METHODDEF    \
+    {"class_method", (PyCFunction)Test_class_method, METH_NOARGS|METH_CLASS, Test_class_method__doc__},
+
+static PyObject *
+Test_class_method_impl(PyTypeObject *type);
+
+static PyObject *
+Test_class_method(PyTypeObject *type, PyObject *Py_UNUSED(ignored))
+{
+    return Test_class_method_impl(type);
+}
+
+static PyObject *
+Test_class_method_impl(PyTypeObject *type)
+/*[clinic end generated code: output=47fb7ecca1abcaaa input=43bc4a0494547b80]*/
+
+
+/*[clinic input]
+@staticmethod
+Test.static_method
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_static_method__doc__,
+"static_method()\n"
+"--\n"
+"\n");
+
+#define TEST_STATIC_METHOD_METHODDEF    \
+    {"static_method", (PyCFunction)Test_static_method, METH_NOARGS|METH_STATIC, Test_static_method__doc__},
+
+static PyObject *
+Test_static_method_impl();
+
+static PyObject *
+Test_static_method(void *null, PyObject *Py_UNUSED(ignored))
+{
+    return Test_static_method_impl();
+}
+
+static PyObject *
+Test_static_method_impl()
+/*[clinic end generated code: output=82524a63025cf7ab input=dae892fac55ae72b]*/
+
+
+/*[clinic input]
+@coexist
+Test.meth_coexist
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_meth_coexist__doc__,
+"meth_coexist($self, /)\n"
+"--\n"
+"\n");
+
+#define TEST_METH_COEXIST_METHODDEF    \
+    {"meth_coexist", (PyCFunction)Test_meth_coexist, METH_NOARGS|METH_COEXIST, Test_meth_coexist__doc__},
+
+static PyObject *
+Test_meth_coexist_impl(TestObj *self);
+
+static PyObject *
+Test_meth_coexist(TestObj *self, PyObject *Py_UNUSED(ignored))
+{
+    return Test_meth_coexist_impl(self);
+}
+
+static PyObject *
+Test_meth_coexist_impl(TestObj *self)
+/*[clinic end generated code: output=808a293d0cd27439 input=2a1d75b5e6fec6dd]*/
+
+
+/*[clinic input]
+output push
+output preset buffer
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5bff3376ee0df0b5]*/
+
+/*[clinic input]
+buffer_clear
+  a: int
+We'll call 'destination buffer clear' after this.
+
+Argument Clinic's buffer preset puts most generated code into the
+'buffer' destination, except from 'impl_definition', which is put into
+the 'block' destination, so we should expect everything but
+'impl_definition' to be cleared.
+[clinic start generated code]*/
+
+static PyObject *
+buffer_clear_impl(PyObject *module, int a)
+/*[clinic end generated code: output=f14bba74677e1846 input=a4c308a6fdab043c]*/
+
+/*[clinic input]
+destination buffer clear
+output pop
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=f20d06adb8252084]*/
+
+
+/*[clinic input]
+output push
+destination test1 new buffer
+output everything suppress
+output docstring_definition test1
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5a77c454970992fc]*/
+
+/*[clinic input]
+new_dest
+  a: int
+Only this docstring should be outputted to test1.
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=da5af421ed8996ed]*/
+
+/*[clinic input]
+dump test1
+output pop
+[clinic start generated code]*/
+
+PyDoc_STRVAR(new_dest__doc__,
+"new_dest($module, /, a)\n"
+"--\n"
+"\n"
+"Only this docstring should be outputted to test1.");
+/*[clinic end generated code: output=9cac703f51d90e84 input=090db8df4945576d]*/
--- a/Lib/test/libregrtest/runtest_mp.py
+++ b/Lib/test/libregrtest/runtest_mp.py
@@ -269,6 +269,7 @@ class TestWorkerProcess(threading.Thread
             encoding = locale.getencoding()
         else:
             encoding = sys.stdout.encoding
+
         # gh-94026: Write stdout+stderr to a tempfile as workaround for
         # non-blocking pipes on Emscripten with NodeJS.
         with tempfile.TemporaryFile('w+', encoding=encoding) as stdout_fh:
@@ -277,7 +278,14 @@ class TestWorkerProcess(threading.Thread
             # Python finalization: too late for libregrtest.
             retcode = self._run_process(test_name, stdout_fh)
             stdout_fh.seek(0)
-            stdout = stdout_fh.read().strip()
+
+            try:
+                stdout = stdout_fh.read().strip()
+            except Exception as exc:
+                # gh-101634: Catch UnicodeDecodeError if stdout cannot be
+                # decoded from encoding
+                err_msg = f"Cannot read process stdout: {exc}"
+                return self.mp_result_error(ChildError(test_name), '', err_msg)
 
         if retcode is None:
             return self.mp_result_error(Timeout(test_name), stdout)
@@ -452,6 +460,8 @@ class MultiprocessTestRunner:
             # Thread got an exception
             format_exc = item[1]
             print_warning(f"regrtest worker thread failed: {format_exc}")
+            result = ChildError("<regrtest worker>")
+            self.regrtest.accumulate_result(result)
             return True
 
         self.test_index += 1
--- a/Lib/test/test_abc.py
+++ b/Lib/test/test_abc.py
@@ -448,15 +448,16 @@ def test_factory(abc_ABCMeta, abc_get_ca
 
             # Also check that issubclass() propagates exceptions raised by
             # __subclasses__.
+            class CustomError(Exception): ...
             exc_msg = "exception from __subclasses__"
 
             def raise_exc():
-                raise Exception(exc_msg)
+                raise CustomError(exc_msg)
 
             class S(metaclass=abc_ABCMeta):
                 __subclasses__ = raise_exc
 
-            with self.assertRaisesRegex(Exception, exc_msg):
+            with self.assertRaisesRegex(CustomError, exc_msg):
                 issubclass(int, S)
 
         def test_subclasshook(self):
--- a/Lib/test/test_ast.py
+++ b/Lib/test/test_ast.py
@@ -3,6 +3,7 @@ import builtins
 import dis
 import enum
 import os
+import re
 import sys
 import types
 import unittest
@@ -862,6 +863,32 @@ class AST_Tests(unittest.TestCase):
             msg="source code string cannot contain null bytes"):
             ast.parse("a\0b")
 
+    def assert_none_check(self, node: type[ast.AST], attr: str, source: str) -> None:
+        with self.subTest(f"{node.__name__}.{attr}"):
+            tree = ast.parse(source)
+            found = 0
+            for child in ast.walk(tree):
+                if isinstance(child, node):
+                    setattr(child, attr, None)
+                    found += 1
+            self.assertEqual(found, 1)
+            e = re.escape(f"field '{attr}' is required for {node.__name__}")
+            with self.assertRaisesRegex(ValueError, f"^{e}$"):
+                compile(tree, "<test>", "exec")
+
+    def test_none_checks(self) -> None:
+        tests = [
+            (ast.alias, "name", "import spam as SPAM"),
+            (ast.arg, "arg", "def spam(SPAM): spam"),
+            (ast.comprehension, "target", "[spam for SPAM in spam]"),
+            (ast.comprehension, "iter", "[spam for spam in SPAM]"),
+            (ast.keyword, "value", "spam(**SPAM)"),
+            (ast.match_case, "pattern", "match spam:\n case SPAM: spam"),
+            (ast.withitem, "context_expr", "with SPAM: spam"),
+        ]
+        for node, attr, source in tests:
+            self.assert_none_check(node, attr, source)
+
 class ASTHelpers_Test(unittest.TestCase):
     maxDiff = None
 
--- /dev/null
+++ b/Lib/test/test_capi/test_codecs.py
@@ -0,0 +1,54 @@
+import unittest
+from test.support import import_helper
+
+_testcapi = import_helper.import_module('_testcapi')
+
+
+class CAPITest(unittest.TestCase):
+
+    def test_decodeutf8(self):
+        """Test PyUnicode_DecodeUTF8()"""
+        decodeutf8 = _testcapi.unicode_decodeutf8
+
+        for s in ['abc', '\xa1\xa2', '\u4f60\u597d', 'a\U0001f600']:
+            b = s.encode('utf-8')
+            self.assertEqual(decodeutf8(b), s)
+            self.assertEqual(decodeutf8(b, 'strict'), s)
+
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'\x80')
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'\xc0')
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'\xff')
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'a\xf0\x9f')
+        self.assertEqual(decodeutf8(b'a\xf0\x9f', 'replace'), 'a\ufffd')
+        self.assertEqual(decodeutf8(b'a\xf0\x9fb', 'replace'), 'a\ufffdb')
+
+        self.assertRaises(LookupError, decodeutf8, b'a\x80', 'foo')
+        # TODO: Test PyUnicode_DecodeUTF8() with NULL as data and
+        # negative size.
+
+    def test_decodeutf8stateful(self):
+        """Test PyUnicode_DecodeUTF8Stateful()"""
+        decodeutf8stateful = _testcapi.unicode_decodeutf8stateful
+
+        for s in ['abc', '\xa1\xa2', '\u4f60\u597d', 'a\U0001f600']:
+            b = s.encode('utf-8')
+            self.assertEqual(decodeutf8stateful(b), (s, len(b)))
+            self.assertEqual(decodeutf8stateful(b, 'strict'), (s, len(b)))
+
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'\x80')
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'\xc0')
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'\xff')
+        self.assertEqual(decodeutf8stateful(b'a\xf0\x9f'), ('a', 1))
+        self.assertEqual(decodeutf8stateful(b'a\xf0\x9f', 'replace'), ('a', 1))
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'a\xf0\x9fb')
+        self.assertEqual(decodeutf8stateful(b'a\xf0\x9fb', 'replace'), ('a\ufffdb', 4))
+
+        self.assertRaises(LookupError, decodeutf8stateful, b'a\x80', 'foo')
+        # TODO: Test PyUnicode_DecodeUTF8Stateful() with NULL as data and
+        # negative size.
+        # TODO: Test PyUnicode_DecodeUTF8Stateful() with NULL as the address of
+        # "consumed".
+
+
+if __name__ == "__main__":
+    unittest.main()
--- a/Lib/test/test_capi/test_misc.py
+++ b/Lib/test/test_capi/test_misc.py
@@ -3,6 +3,7 @@
 
 from collections import OrderedDict
 import _thread
+import contextlib
 import importlib.machinery
 import importlib.util
 import os
@@ -40,6 +41,8 @@ import _testinternalcapi
 Py_DEBUG = hasattr(sys, 'gettotalrefcount')
 
 
+NULL = None
+
 def decode_stderr(err):
     return err.decode('utf-8', 'replace').replace('\r', '')
 
@@ -910,6 +913,46 @@ class CAPITest(unittest.TestCase):
         with self.assertRaises(SystemError):
             _testcapi.function_get_module(None)  # not a function
 
+    def test_sys_getobject(self):
+        getobject = _testcapi.sys_getobject
+
+        self.assertIs(getobject(b'stdout'), sys.stdout)
+        with support.swap_attr(sys, '\U0001f40d', 42):
+            self.assertEqual(getobject('\U0001f40d'.encode()), 42)
+
+        self.assertIs(getobject(b'nonexisting'), AttributeError)
+        self.assertIs(getobject(b'\xff'), AttributeError)
+        # CRASHES getobject(NULL)
+
+    def test_sys_setobject(self):
+        setobject = _testcapi.sys_setobject
+
+        value = ['value']
+        value2 = ['value2']
+        try:
+            self.assertEqual(setobject(b'newattr', value), 0)
+            self.assertIs(sys.newattr, value)
+            self.assertEqual(setobject(b'newattr', value2), 0)
+            self.assertIs(sys.newattr, value2)
+            self.assertEqual(setobject(b'newattr', NULL), 0)
+            self.assertFalse(hasattr(sys, 'newattr'))
+            self.assertEqual(setobject(b'newattr', NULL), 0)
+        finally:
+            with contextlib.suppress(AttributeError):
+                del sys.newattr
+        try:
+            self.assertEqual(setobject('\U0001f40d'.encode(), value), 0)
+            self.assertIs(getattr(sys, '\U0001f40d'), value)
+            self.assertEqual(setobject('\U0001f40d'.encode(), NULL), 0)
+            self.assertFalse(hasattr(sys, '\U0001f40d'))
+        finally:
+            with contextlib.suppress(AttributeError):
+                delattr(sys, '\U0001f40d')
+
+        with self.assertRaises(UnicodeDecodeError):
+            setobject(b'\xff', value)
+        # CRASHES setobject(NULL, value)
+
 
 class TestPendingCalls(unittest.TestCase):
 
--- a/Lib/test/test_clinic.py
+++ b/Lib/test/test_clinic.py
@@ -3,11 +3,15 @@
 # Licensed to the PSF under a contributor agreement.
 
 from test import support, test_tools
-from test.support import import_helper, os_helper
+from test.support import os_helper
+from test.support import SHORT_TIMEOUT, requires_subprocess
+from test.support.os_helper import TESTFN, unlink
+from textwrap import dedent
 from unittest import TestCase
 import collections
 import inspect
 import os.path
+import subprocess
 import sys
 import unittest
 
@@ -17,6 +21,19 @@ with test_tools.imports_under_tool('clin
     from clinic import DSLParser
 
 
+class _ParserBase(TestCase):
+    maxDiff = None
+
+    def expect_parser_failure(self, parser, _input):
+        with support.captured_stdout() as stdout:
+            with self.assertRaises(SystemExit):
+                parser(_input)
+        return stdout.getvalue()
+
+    def parse_function_should_fail(self, _input):
+        return self.expect_parser_failure(self.parse_function, _input)
+
+
 class FakeConverter:
     def __init__(self, name, args):
         self.name = name
@@ -87,7 +104,15 @@ class FakeClinic:
 
     _module_and_class = clinic.Clinic._module_and_class
 
-class ClinicWholeFileTest(TestCase):
+
+class ClinicWholeFileTest(_ParserBase):
+    def setUp(self):
+        self.clinic = clinic.Clinic(clinic.CLanguage(None), filename="test.c")
+
+    def expect_failure(self, raw):
+        _input = dedent(raw).strip()
+        return self.expect_parser_failure(self.clinic.parse, _input)
+
     def test_eol(self):
         # regression test:
         # clinic's block parser didn't recognize
@@ -97,15 +122,217 @@ class ClinicWholeFileTest(TestCase):
         # so it would spit out an end line for you.
         # and since you really already had one,
         # the last line of the block got corrupted.
-        c = clinic.Clinic(clinic.CLanguage(None), filename="file")
         raw = "/*[clinic]\nfoo\n[clinic]*/"
-        cooked = c.parse(raw).splitlines()
+        cooked = self.clinic.parse(raw).splitlines()
         end_line = cooked[2].rstrip()
         # this test is redundant, it's just here explicitly to catch
         # the regression test so we don't forget what it looked like
         self.assertNotEqual(end_line, "[clinic]*/[clinic]*/")
         self.assertEqual(end_line, "[clinic]*/")
 
+    def test_mangled_marker_line(self):
+        raw = """
+            /*[clinic input]
+            [clinic start generated code]*/
+            /*[clinic end generated code: foo]*/
+        """
+        msg = (
+            'Error in file "test.c" on line 3:\n'
+            "Mangled Argument Clinic marker line: '/*[clinic end generated code: foo]*/'\n"
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_checksum_mismatch(self):
+        raw = """
+            /*[clinic input]
+            [clinic start generated code]*/
+            /*[clinic end generated code: output=0123456789abcdef input=fedcba9876543210]*/
+        """
+        msg = (
+            'Error in file "test.c" on line 3:\n'
+            'Checksum mismatch!\n'
+            'Expected: 0123456789abcdef\n'
+            'Computed: da39a3ee5e6b4b0d\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertIn(msg, out)
+
+    def test_garbage_after_stop_line(self):
+        raw = """
+            /*[clinic input]
+            [clinic start generated code]*/foobarfoobar!
+        """
+        msg = (
+            'Error in file "test.c" on line 2:\n'
+            "Garbage after stop line: 'foobarfoobar!'\n"
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_whitespace_before_stop_line(self):
+        raw = """
+            /*[clinic input]
+             [clinic start generated code]*/
+        """
+        msg = (
+            'Error in file "test.c" on line 2:\n'
+            "Whitespace is not allowed before the stop line: ' [clinic start generated code]*/'\n"
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_parse_with_body_prefix(self):
+        clang = clinic.CLanguage(None)
+        clang.body_prefix = "//"
+        clang.start_line = "//[{dsl_name} start]"
+        clang.stop_line = "//[{dsl_name} stop]"
+        cl = clinic.Clinic(clang, filename="test.c")
+        raw = dedent("""
+            //[clinic start]
+            //module test
+            //[clinic stop]
+        """).strip()
+        out = cl.parse(raw)
+        expected = dedent("""
+            //[clinic start]
+            //module test
+            //
+            //[clinic stop]
+            /*[clinic end generated code: output=da39a3ee5e6b4b0d input=65fab8adff58cf08]*/
+        """).lstrip()  # Note, lstrip() because of the newline
+        self.assertEqual(out, expected)
+
+    def test_cpp_monitor_fail_nested_block_comment(self):
+        raw = """
+            /* start
+            /* nested
+            */
+            */
+        """
+        msg = (
+            'Error in file "test.c" on line 2:\n'
+            'Nested block comment!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_cpp_monitor_fail_invalid_format_noarg(self):
+        raw = """
+            #if
+            a()
+            #endif
+        """
+        msg = (
+            'Error in file "test.c" on line 1:\n'
+            'Invalid format for #if line: no argument!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_cpp_monitor_fail_invalid_format_toomanyargs(self):
+        raw = """
+            #ifdef A B
+            a()
+            #endif
+        """
+        msg = (
+            'Error in file "test.c" on line 1:\n'
+            'Invalid format for #ifdef line: should be exactly one argument!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_cpp_monitor_fail_no_matching_if(self):
+        raw = '#else'
+        msg = (
+            'Error in file "test.c" on line 1:\n'
+            '#else without matching #if / #ifdef / #ifndef!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_directive_output_unknown_preset(self):
+        out = self.expect_failure("""
+            /*[clinic input]
+            output preset nosuchpreset
+            [clinic start generated code]*/
+        """)
+        msg = "Unknown preset 'nosuchpreset'"
+        self.assertIn(msg, out)
+
+    def test_directive_output_cant_pop(self):
+        out = self.expect_failure("""
+            /*[clinic input]
+            output pop
+            [clinic start generated code]*/
+        """)
+        msg = "Can't 'output pop', stack is empty"
+        self.assertIn(msg, out)
+
+    def test_directive_output_print(self):
+        raw = dedent("""
+            /*[clinic input]
+            output print 'I told you once.'
+            [clinic start generated code]*/
+        """)
+        out = self.clinic.parse(raw)
+        # The generated output will differ for every run, but we can check that
+        # it starts with the clinic block, we check that it contains all the
+        # expected fields, and we check that it contains the checksum line.
+        self.assertTrue(out.startswith(dedent("""
+            /*[clinic input]
+            output print 'I told you once.'
+            [clinic start generated code]*/
+        """)))
+        fields = {
+            "cpp_endif",
+            "cpp_if",
+            "docstring_definition",
+            "docstring_prototype",
+            "impl_definition",
+            "impl_prototype",
+            "methoddef_define",
+            "methoddef_ifndef",
+            "parser_definition",
+            "parser_prototype",
+        }
+        for field in fields:
+            with self.subTest(field=field):
+                self.assertIn(field, out)
+        last_line = out.rstrip().split("\n")[-1]
+        self.assertTrue(
+            last_line.startswith("/*[clinic end generated code: output=")
+        )
+
+    def test_unknown_destination_command(self):
+        out = self.expect_failure("""
+            /*[clinic input]
+            destination buffer nosuchcommand
+            [clinic start generated code]*/
+        """)
+        msg = "unknown destination command 'nosuchcommand'"
+        self.assertIn(msg, out)
+
+    def test_no_access_to_members_in_converter_init(self):
+        out = self.expect_failure("""
+            /*[python input]
+            class Custom_converter(CConverter):
+                converter = "some_c_function"
+                def converter_init(self):
+                    self.function.noaccess
+            [python start generated code]*/
+            /*[clinic input]
+            module test
+            test.fn
+                a: Custom
+            [clinic start generated code]*/
+        """)
+        msg = (
+            "Stepped on a land mine, trying to access attribute 'noaccess':\n"
+            "Don't access members of self.function inside converter_init!"
+        )
+        self.assertIn(msg, out)
 
 
 class ClinicGroupPermuterTest(TestCase):
@@ -170,43 +397,43 @@ class ClinicLinearFormatTest(TestCase):
     def test_no_substitution(self):
         self._test("""
           abc
-          """, """
+        """, """
           abc
-          """)
+        """)
 
     def test_empty_substitution(self):
         self._test("""
           abc
           {name}
           def
-          """, """
+        """, """
           abc
           def
-          """, name='')
+        """, name='')
 
     def test_single_line_substitution(self):
         self._test("""
           abc
           {name}
           def
-          """, """
+        """, """
           abc
           GARGLE
           def
-          """, name='GARGLE')
+        """, name='GARGLE')
 
     def test_multiline_substitution(self):
         self._test("""
           abc
           {name}
           def
-          """, """
+        """, """
           abc
           bingle
           bungle
 
           def
-          """, name='bingle\nbungle\n')
+        """, name='bingle\nbungle\n')
 
 class InertParser:
     def __init__(self, clinic):
@@ -239,9 +466,9 @@ class ClinicBlockParserTest(TestCase):
 
     def test_round_trip_1(self):
         self.round_trip("""
-    verbatim text here
-    lah dee dah
-""")
+            verbatim text here
+            lah dee dah
+        """)
     def test_round_trip_2(self):
         self.round_trip("""
     verbatim text here
@@ -284,23 +511,39 @@ xyz
 """)
 
 
-class ClinicParserTest(TestCase):
+class ClinicParserTest(_ParserBase):
+    def checkDocstring(self, fn, expected):
+        self.assertTrue(hasattr(fn, "docstring"))
+        self.assertEqual(fn.docstring.strip(),
+                         dedent(expected).strip())
+
     def test_trivial(self):
         parser = DSLParser(FakeClinic())
-        block = clinic.Block("module os\nos.access")
+        block = clinic.Block("""
+            module os
+            os.access
+        """)
         parser.parse(block)
         module, function = block.signatures
         self.assertEqual("access", function.name)
         self.assertEqual("os", module.name)
 
     def test_ignore_line(self):
-        block = self.parse("#\nmodule os\nos.access")
+        block = self.parse(dedent("""
+            #
+            module os
+            os.access
+        """))
         module, function = block.signatures
         self.assertEqual("access", function.name)
         self.assertEqual("os", module.name)
 
     def test_param(self):
-        function = self.parse_function("module os\nos.access\n   path: int")
+        function = self.parse_function("""
+            module os
+            os.access
+                path: int
+        """)
         self.assertEqual("access", function.name)
         self.assertEqual(2, len(function.parameters))
         p = function.parameters['path']
@@ -308,236 +551,296 @@ class ClinicParserTest(TestCase):
         self.assertIsInstance(p.converter, clinic.int_converter)
 
     def test_param_default(self):
-        function = self.parse_function("module os\nos.access\n    follow_symlinks: bool = True")
+        function = self.parse_function("""
+            module os
+            os.access
+                follow_symlinks: bool = True
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(True, p.default)
 
     def test_param_with_continuations(self):
-        function = self.parse_function("module os\nos.access\n    follow_symlinks: \\\n   bool \\\n   =\\\n    True")
+        function = self.parse_function(r"""
+            module os
+            os.access
+                follow_symlinks: \
+                bool \
+                = \
+                True
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(True, p.default)
 
     def test_param_default_expression(self):
-        function = self.parse_function("module os\nos.access\n    follow_symlinks: int(c_default='MAXSIZE') = sys.maxsize")
+        function = self.parse_function("""
+            module os
+            os.access
+                follow_symlinks: int(c_default='MAXSIZE') = sys.maxsize
+            """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(sys.maxsize, p.default)
         self.assertEqual("MAXSIZE", p.converter.c_default)
 
-        s = self.parse_function_should_fail("module os\nos.access\n    follow_symlinks: int = sys.maxsize")
-        self.assertEqual(s, "Error on line 0:\nWhen you specify a named constant ('sys.maxsize') as your default value,\nyou MUST specify a valid c_default.\n")
+        expected_msg = (
+            "Error on line 0:\n"
+            "When you specify a named constant ('sys.maxsize') as your default value,\n"
+            "you MUST specify a valid c_default.\n"
+        )
+        out = self.parse_function_should_fail("""
+            module os
+            os.access
+                follow_symlinks: int = sys.maxsize
+        """)
+        self.assertEqual(out, expected_msg)
 
     def test_param_no_docstring(self):
         function = self.parse_function("""
-module os
-os.access
-    follow_symlinks: bool = True
-    something_else: str = ''""")
+            module os
+            os.access
+                follow_symlinks: bool = True
+                something_else: str = ''
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(3, len(function.parameters))
-        self.assertIsInstance(function.parameters['something_else'].converter, clinic.str_converter)
+        conv = function.parameters['something_else'].converter
+        self.assertIsInstance(conv, clinic.str_converter)
 
     def test_param_default_parameters_out_of_order(self):
-        s = self.parse_function_should_fail("""
-module os
-os.access
-    follow_symlinks: bool = True
-    something_else: str""")
-        self.assertEqual(s, """Error on line 0:
-Can't have a parameter without a default ('something_else')
-after a parameter with a default!
-""")
+        expected_msg = (
+            "Error on line 0:\n"
+            "Can't have a parameter without a default ('something_else')\n"
+            "after a parameter with a default!\n"
+        )
+        out = self.parse_function_should_fail("""
+            module os
+            os.access
+                follow_symlinks: bool = True
+                something_else: str""")
+        self.assertEqual(out, expected_msg)
 
     def disabled_test_converter_arguments(self):
-        function = self.parse_function("module os\nos.access\n    path: path_t(allow_fd=1)")
+        function = self.parse_function("""
+            module os
+            os.access
+                path: path_t(allow_fd=1)
+        """)
         p = function.parameters['path']
         self.assertEqual(1, p.converter.args['allow_fd'])
 
     def test_function_docstring(self):
         function = self.parse_function("""
-module os
-os.stat as os_stat_fn
+            module os
+            os.stat as os_stat_fn
 
-   path: str
-       Path to be examined
+               path: str
+                   Path to be examined
 
-Perform a stat system call on the given path.""")
-        self.assertEqual("""
-stat($module, /, path)
---
-
-Perform a stat system call on the given path.
-
-  path
-    Path to be examined
-""".strip(), function.docstring)
+            Perform a stat system call on the given path.
+        """)
+        self.checkDocstring(function, """
+            stat($module, /, path)
+            --
+
+            Perform a stat system call on the given path.
+
+              path
+                Path to be examined
+        """)
 
     def test_explicit_parameters_in_docstring(self):
-        function = self.parse_function("""
-module foo
-foo.bar
-  x: int
-     Documentation for x.
-  y: int
+        function = self.parse_function(dedent("""
+            module foo
+            foo.bar
+              x: int
+                 Documentation for x.
+              y: int
+
+            This is the documentation for foo.
+
+            Okay, we're done here.
+        """))
+        self.checkDocstring(function, """
+            bar($module, /, x, y)
+            --
 
-This is the documentation for foo.
+            This is the documentation for foo.
 
-Okay, we're done here.
-""")
-        self.assertEqual("""
-bar($module, /, x, y)
---
+              x
+                Documentation for x.
 
-This is the documentation for foo.
-
-  x
-    Documentation for x.
-
-Okay, we're done here.
-""".strip(), function.docstring)
+            Okay, we're done here.
+        """)
 
     def test_parser_regression_special_character_in_parameter_column_of_docstring_first_line(self):
-        function = self.parse_function("""
-module os
-os.stat
-    path: str
-This/used to break Clinic!
-""")
-        self.assertEqual("stat($module, /, path)\n--\n\nThis/used to break Clinic!", function.docstring)
+        function = self.parse_function(dedent("""
+            module os
+            os.stat
+                path: str
+            This/used to break Clinic!
+        """))
+        self.checkDocstring(function, """
+            stat($module, /, path)
+            --
+
+            This/used to break Clinic!
+        """)
 
     def test_c_name(self):
-        function = self.parse_function("module os\nos.stat as os_stat_fn")
+        function = self.parse_function("""
+            module os
+            os.stat as os_stat_fn
+        """)
         self.assertEqual("os_stat_fn", function.c_basename)
 
     def test_return_converter(self):
-        function = self.parse_function("module os\nos.stat -> int")
+        function = self.parse_function("""
+            module os
+            os.stat -> int
+        """)
         self.assertIsInstance(function.return_converter, clinic.int_return_converter)
 
     def test_star(self):
-        function = self.parse_function("module os\nos.access\n    *\n    follow_symlinks: bool = True")
+        function = self.parse_function("""
+            module os
+            os.access
+                *
+                follow_symlinks: bool = True
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(inspect.Parameter.KEYWORD_ONLY, p.kind)
         self.assertEqual(0, p.group)
 
     def test_group(self):
-        function = self.parse_function("module window\nwindow.border\n [\n ls : int\n ]\n /\n")
+        function = self.parse_function("""
+            module window
+            window.border
+                [
+                ls: int
+                ]
+                /
+        """)
         p = function.parameters['ls']
         self.assertEqual(1, p.group)
 
     def test_left_group(self):
         function = self.parse_function("""
-module curses
-curses.addch
-   [
-   y: int
-     Y-coordinate.
-   x: int
-     X-coordinate.
-   ]
-   ch: char
-     Character to add.
-   [
-   attr: long
-     Attributes for the character.
-   ]
-   /
-""")
-        for name, group in (
+            module curses
+            curses.addch
+                [
+                y: int
+                    Y-coordinate.
+                x: int
+                    X-coordinate.
+                ]
+                ch: char
+                    Character to add.
+                [
+                attr: long
+                    Attributes for the character.
+                ]
+                /
+        """)
+        dataset = (
             ('y', -1), ('x', -1),
             ('ch', 0),
             ('attr', 1),
-            ):
-            p = function.parameters[name]
-            self.assertEqual(p.group, group)
-            self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
-        self.assertEqual(function.docstring.strip(), """
-addch([y, x,] ch, [attr])
-
-
-  y
-    Y-coordinate.
-  x
-    X-coordinate.
-  ch
-    Character to add.
-  attr
-    Attributes for the character.
-            """.strip())
+        )
+        for name, group in dataset:
+            with self.subTest(name=name, group=group):
+                p = function.parameters[name]
+                self.assertEqual(p.group, group)
+                self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
+        self.checkDocstring(function, """
+            addch([y, x,] ch, [attr])
+
+
+              y
+                Y-coordinate.
+              x
+                X-coordinate.
+              ch
+                Character to add.
+              attr
+                Attributes for the character.
+        """)
 
     def test_nested_groups(self):
         function = self.parse_function("""
-module curses
-curses.imaginary
-   [
-   [
-   y1: int
-     Y-coordinate.
-   y2: int
-     Y-coordinate.
-   ]
-   x1: int
-     X-coordinate.
-   x2: int
-     X-coordinate.
-   ]
-   ch: char
-     Character to add.
-   [
-   attr1: long
-     Attributes for the character.
-   attr2: long
-     Attributes for the character.
-   attr3: long
-     Attributes for the character.
-   [
-   attr4: long
-     Attributes for the character.
-   attr5: long
-     Attributes for the character.
-   attr6: long
-     Attributes for the character.
-   ]
-   ]
-   /
-""")
-        for name, group in (
+            module curses
+            curses.imaginary
+               [
+               [
+               y1: int
+                 Y-coordinate.
+               y2: int
+                 Y-coordinate.
+               ]
+               x1: int
+                 X-coordinate.
+               x2: int
+                 X-coordinate.
+               ]
+               ch: char
+                 Character to add.
+               [
+               attr1: long
+                 Attributes for the character.
+               attr2: long
+                 Attributes for the character.
+               attr3: long
+                 Attributes for the character.
+               [
+               attr4: long
+                 Attributes for the character.
+               attr5: long
+                 Attributes for the character.
+               attr6: long
+                 Attributes for the character.
+               ]
+               ]
+               /
+        """)
+        dataset = (
             ('y1', -2), ('y2', -2),
             ('x1', -1), ('x2', -1),
             ('ch', 0),
             ('attr1', 1), ('attr2', 1), ('attr3', 1),
             ('attr4', 2), ('attr5', 2), ('attr6', 2),
-            ):
-            p = function.parameters[name]
-            self.assertEqual(p.group, group)
-            self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
-
-        self.assertEqual(function.docstring.strip(), """
-imaginary([[y1, y2,] x1, x2,] ch, [attr1, attr2, attr3, [attr4, attr5,
-          attr6]])
-
-
-  y1
-    Y-coordinate.
-  y2
-    Y-coordinate.
-  x1
-    X-coordinate.
-  x2
-    X-coordinate.
-  ch
-    Character to add.
-  attr1
-    Attributes for the character.
-  attr2
-    Attributes for the character.
-  attr3
-    Attributes for the character.
-  attr4
-    Attributes for the character.
-  attr5
-    Attributes for the character.
-  attr6
-    Attributes for the character.
-                """.strip())
+        )
+        for name, group in dataset:
+            with self.subTest(name=name, group=group):
+                p = function.parameters[name]
+                self.assertEqual(p.group, group)
+                self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
+
+        self.checkDocstring(function, """
+            imaginary([[y1, y2,] x1, x2,] ch, [attr1, attr2, attr3, [attr4, attr5,
+                      attr6]])
+
+
+              y1
+                Y-coordinate.
+              y2
+                Y-coordinate.
+              x1
+                X-coordinate.
+              x2
+                X-coordinate.
+              ch
+                Character to add.
+              attr1
+                Attributes for the character.
+              attr2
+                Attributes for the character.
+              attr3
+                Attributes for the character.
+              attr4
+                Attributes for the character.
+              attr5
+                Attributes for the character.
+              attr6
+                Attributes for the character.
+        """)
 
     def parse_function_should_fail(self, s):
         with support.captured_stdout() as stdout:
@@ -546,218 +849,295 @@ imaginary([[y1, y2,] x1, x2,] ch, [attr1
         return stdout.getvalue()
 
     def test_disallowed_grouping__two_top_groups_on_left(self):
-        s = self.parse_function_should_fail("""
-module foo
-foo.two_top_groups_on_left
-    [
-    group1 : int
-    ]
-    [
-    group2 : int
-    ]
-    param: int
-            """)
-        self.assertEqual(s,
-            ('Error on line 0:\n'
-            'Function two_top_groups_on_left has an unsupported group configuration. (Unexpected state 2.b)\n'))
+        expected_msg = (
+            'Error on line 0:\n'
+            'Function two_top_groups_on_left has an unsupported group '
+            'configuration. (Unexpected state 2.b)\n'
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.two_top_groups_on_left
+                [
+                group1 : int
+                ]
+                [
+                group2 : int
+                ]
+                param: int
+        """)
+        self.assertEqual(out, expected_msg)
 
     def test_disallowed_grouping__two_top_groups_on_right(self):
-        self.parse_function_should_fail("""
-module foo
-foo.two_top_groups_on_right
-    param: int
-    [
-    group1 : int
-    ]
-    [
-    group2 : int
-    ]
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.two_top_groups_on_right
+                param: int
+                [
+                group1 : int
+                ]
+                [
+                group2 : int
+                ]
+        """)
+        msg = (
+            "Function two_top_groups_on_right has an unsupported group "
+            "configuration. (Unexpected state 6.b)"
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__parameter_after_group_on_right(self):
-        self.parse_function_should_fail("""
-module foo
-foo.parameter_after_group_on_right
-    param: int
-    [
-    [
-    group1 : int
-    ]
-    group2 : int
-    ]
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.parameter_after_group_on_right
+                param: int
+                [
+                [
+                group1 : int
+                ]
+                group2 : int
+                ]
+        """)
+        msg = (
+            "Function parameter_after_group_on_right has an unsupported group "
+            "configuration. (Unexpected state 6.a)"
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__group_after_parameter_on_left(self):
-        self.parse_function_should_fail("""
-module foo
-foo.group_after_parameter_on_left
-    [
-    group2 : int
-    [
-    group1 : int
-    ]
-    ]
-    param: int
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.group_after_parameter_on_left
+                [
+                group2 : int
+                [
+                group1 : int
+                ]
+                ]
+                param: int
+        """)
+        msg = (
+            "Function group_after_parameter_on_left has an unsupported group "
+            "configuration. (Unexpected state 2.b)"
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__empty_group_on_left(self):
-        self.parse_function_should_fail("""
-module foo
-foo.empty_group
-    [
-    [
-    ]
-    group2 : int
-    ]
-    param: int
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.empty_group
+                [
+                [
+                ]
+                group2 : int
+                ]
+                param: int
+        """)
+        msg = (
+            "Function empty_group has an empty group.\n"
+            "All groups must contain at least one parameter."
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__empty_group_on_right(self):
-        self.parse_function_should_fail("""
-module foo
-foo.empty_group
-    param: int
-    [
-    [
-    ]
-    group2 : int
-    ]
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.empty_group
+                param: int
+                [
+                [
+                ]
+                group2 : int
+                ]
+        """)
+        msg = (
+            "Function empty_group has an empty group.\n"
+            "All groups must contain at least one parameter."
+        )
+        self.assertIn(msg, out)
+
+    def test_disallowed_grouping__no_matching_bracket(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.empty_group
+                param: int
+                ]
+                group2: int
+                ]
+        """)
+        msg = "Function empty_group has a ] without a matching [."
+        self.assertIn(msg, out)
 
     def test_no_parameters(self):
         function = self.parse_function("""
-module foo
-foo.bar
+            module foo
+            foo.bar
 
-Docstring
+            Docstring
 
-""")
+        """)
         self.assertEqual("bar($module, /)\n--\n\nDocstring", function.docstring)
         self.assertEqual(1, len(function.parameters)) # self!
 
     def test_init_with_no_parameters(self):
         function = self.parse_function("""
-module foo
-class foo.Bar "unused" "notneeded"
-foo.Bar.__init__
+            module foo
+            class foo.Bar "unused" "notneeded"
+            foo.Bar.__init__
+
+            Docstring
 
-Docstring
+        """, signatures_in_block=3, function_index=2)
 
-""", signatures_in_block=3, function_index=2)
         # self is not in the signature
         self.assertEqual("Bar()\n--\n\nDocstring", function.docstring)
         # but it *is* a parameter
         self.assertEqual(1, len(function.parameters))
 
     def test_illegal_module_line(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar => int
-    /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar => int
+                /
+        """)
+        msg = "Illegal function name: foo.bar => int"
+        self.assertIn(msg, out)
 
     def test_illegal_c_basename(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar as 935
-    /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar as 935
+                /
+        """)
+        msg = "Illegal C basename: 935"
+        self.assertIn(msg, out)
 
     def test_single_star(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    *
-    *
-""")
-
-    def test_parameters_required_after_star_without_initial_parameters_or_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    *
-""")
-
-    def test_parameters_required_after_star_without_initial_parameters_with_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    *
-Docstring here.
-""")
-
-    def test_parameters_required_after_star_with_initial_parameters_without_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    this: int
-    *
-""")
-
-    def test_parameters_required_after_star_with_initial_parameters_and_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    this: int
-    *
-Docstring.
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                *
+                *
+        """)
+        self.assertIn("Function bar uses '*' more than once.", out)
+
+    def test_parameters_required_after_star(self):
+        dataset = (
+            "module foo\nfoo.bar\n  *",
+            "module foo\nfoo.bar\n  *\nDocstring here.",
+            "module foo\nfoo.bar\n  this: int\n  *",
+            "module foo\nfoo.bar\n  this: int\n  *\nDocstring.",
+        )
+        msg = "Function bar specifies '*' without any parameters afterwards."
+        for block in dataset:
+            with self.subTest(block=block):
+                out = self.parse_function_should_fail(block)
+                self.assertIn(msg, out)
 
     def test_single_slash(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    /
-    /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                /
+                /
+        """)
+        msg = (
+            "Function bar has an unsupported group configuration. "
+            "(Unexpected state 0.d)"
+        )
+        self.assertIn(msg, out)
+
+    def test_double_slash(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                a: int
+                /
+                b: int
+                /
+        """)
+        msg = "Function bar uses '/' more than once."
+        self.assertIn(msg, out)
 
     def test_mix_star_and_slash(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-   x: int
-   y: int
-   *
-   z: int
-   /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+               x: int
+               y: int
+               *
+               z: int
+               /
+        """)
+        msg = (
+            "Function bar mixes keyword-only and positional-only parameters, "
+            "which is unsupported."
+        )
+        self.assertIn(msg, out)
 
     def test_parameters_not_permitted_after_slash_for_now(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    /
-    x: int
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                /
+                x: int
+        """)
+        msg = (
+            "Function bar has an unsupported group configuration. "
+            "(Unexpected state 0.d)"
+        )
+        self.assertIn(msg, out)
 
     def test_parameters_no_more_than_one_vararg(self):
-        s = self.parse_function_should_fail("""
-module foo
-foo.bar
-   *vararg1: object
-   *vararg2: object
-""")
-        self.assertEqual(s, "Error on line 0:\nToo many var args\n")
+        expected_msg = (
+            "Error on line 0:\n"
+            "Too many var args\n"
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+               *vararg1: object
+               *vararg2: object
+        """)
+        self.assertEqual(out, expected_msg)
 
     def test_function_not_at_column_0(self):
         function = self.parse_function("""
-  module foo
-  foo.bar
-    x: int
-      Nested docstring here, goeth.
-    *
-    y: str
-  Not at column 0!
-""")
-        self.assertEqual("""
-bar($module, /, x, *, y)
---
-
-Not at column 0!
-
-  x
-    Nested docstring here, goeth.
-""".strip(), function.docstring)
+              module foo
+              foo.bar
+                x: int
+                  Nested docstring here, goeth.
+                *
+                y: str
+              Not at column 0!
+        """)
+        self.checkDocstring(function, """
+            bar($module, /, x, *, y)
+            --
+
+            Not at column 0!
+
+              x
+                Nested docstring here, goeth.
+        """)
+
+    def test_indent_stack_no_tabs(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+               *vararg1: object
+            \t*vararg2: object
+        """)
+        msg = "Tab characters are illegal in the Clinic DSL."
+        self.assertIn(msg, out)
+
+    def test_indent_stack_illegal_outdent(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+              a: object
+             b: object
+        """)
+        self.assertIn("Illegal outdent", out)
 
     def test_directive(self):
         c = FakeClinic()
@@ -771,46 +1151,133 @@ Not at column 0!
     def test_legacy_converters(self):
         block = self.parse('module os\nos.access\n   path: "s"')
         module, function = block.signatures
-        self.assertIsInstance((function.parameters['path']).converter, clinic.str_converter)
+        conv = (function.parameters['path']).converter
+        self.assertIsInstance(conv, clinic.str_converter)
 
     def test_legacy_converters_non_string_constant_annotation(self):
-        expected_failure_message = """\
-Error on line 0:
-Annotations must be either a name, a function call, or a string.
-"""
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: 42')
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: 42.42')
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: 42j')
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: b"42"')
-        self.assertEqual(s, expected_failure_message)
+        expected_failure_message = (
+            "Error on line 0:\n"
+            "Annotations must be either a name, a function call, or a string.\n"
+        )
+        dataset = (
+            'module os\nos.access\n   path: 42',
+            'module os\nos.access\n   path: 42.42',
+            'module os\nos.access\n   path: 42j',
+            'module os\nos.access\n   path: b"42"',
+        )
+        for block in dataset:
+            with self.subTest(block=block):
+                out = self.parse_function_should_fail(block)
+                self.assertEqual(out, expected_failure_message)
 
     def test_other_bizarre_things_in_annotations_fail(self):
-        expected_failure_message = """\
-Error on line 0:
-Annotations must be either a name, a function call, or a string.
-"""
-
-        s = self.parse_function_should_fail(
-            'module os\nos.access\n   path: {"some": "dictionary"}'
+        expected_failure_message = (
+            "Error on line 0:\n"
+            "Annotations must be either a name, a function call, or a string.\n"
         )
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail(
-            'module os\nos.access\n   path: ["list", "of", "strings"]'
+        dataset = (
+            'module os\nos.access\n   path: {"some": "dictionary"}',
+            'module os\nos.access\n   path: ["list", "of", "strings"]',
+            'module os\nos.access\n   path: (x for x in range(42))',
         )
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail(
-            'module os\nos.access\n   path: (x for x in range(42))'
+        for block in dataset:
+            with self.subTest(block=block):
+                out = self.parse_function_should_fail(block)
+                self.assertEqual(out, expected_failure_message)
+
+    def test_self_param_placement(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'self' parameter, if specified, must be the very first thing "
+            "in the parameter block.\n"
+        )
+        block = """
+            module foo
+            foo.func
+                a: int
+                self: self(type="PyObject *")
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_self_param_cannot_be_optional(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'self' parameter cannot be marked optional.\n"
         )
-        self.assertEqual(s, expected_failure_message)
+        block = """
+            module foo
+            foo.func
+                self: self(type="PyObject *") = None
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_defining_class_param_placement(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'defining_class' parameter, if specified, must either be the "
+            "first thing in the parameter block, or come just after 'self'.\n"
+        )
+        block = """
+            module foo
+            foo.func
+                self: self(type="PyObject *")
+                a: int
+                cls: defining_class
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_defining_class_param_cannot_be_optional(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'defining_class' parameter cannot be marked optional.\n"
+        )
+        block = """
+            module foo
+            foo.func
+                cls: defining_class(type="PyObject *") = None
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_slot_methods_cannot_access_defining_class(self):
+        block = """
+            module foo
+            class Foo "" ""
+            Foo.__init__
+                cls: defining_class
+                a: object
+        """
+        msg = "Slot methods cannot access their defining class."
+        with self.assertRaisesRegex(ValueError, msg):
+            self.parse_function(block)
+
+    def test_new_must_be_a_class_method(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "__new__ must be a class method!\n"
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            class Foo "" ""
+            Foo.__new__
+        """)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_init_must_be_a_normal_method(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "__init__ must be a normal method, not a class or static method!\n"
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            class Foo "" ""
+            @classmethod
+            Foo.__init__
+        """)
+        self.assertEqual(out, expected_error_msg)
 
     def parse(self, text):
         c = FakeClinic()
@@ -833,39 +1300,278 @@ Annotations must be either a name, a fun
         self.assertEqual(repr(clinic.NULL), '<Null>')
 
         # test that fail fails
+        expected = (
+            'Error in file "clown.txt" on line 69:\n'
+            'The igloos are melting!\n'
+        )
         with support.captured_stdout() as stdout:
             with self.assertRaises(SystemExit):
-                clinic.fail('The igloos are melting!', filename='clown.txt', line_number=69)
-        self.assertEqual(stdout.getvalue(), 'Error in file "clown.txt" on line 69:\nThe igloos are melting!\n')
+                clinic.fail('The igloos are melting!',
+                            filename='clown.txt', line_number=69)
+        actual = stdout.getvalue()
+        self.assertEqual(actual, expected)
 
 
 class ClinicExternalTest(TestCase):
     maxDiff = None
+    clinic_py = os.path.join(test_tools.toolsdir, "clinic", "clinic.py")
+
+    def _do_test(self, *args, expect_success=True):
+        with subprocess.Popen(
+            [sys.executable, "-Xutf8", self.clinic_py, *args],
+            encoding="utf-8",
+            bufsize=0,
+            stdout=subprocess.PIPE,
+            stderr=subprocess.PIPE,
+        ) as proc:
+            proc.wait()
+            if expect_success and proc.returncode:
+                self.fail("".join([*proc.stdout, *proc.stderr]))
+            stdout = proc.stdout.read()
+            stderr = proc.stderr.read()
+            # Clinic never writes to stderr.
+            self.assertEqual(stderr, "")
+            return stdout
+
+    def expect_success(self, *args):
+        return self._do_test(*args)
+
+    def expect_failure(self, *args):
+        return self._do_test(*args, expect_success=False)
 
     def test_external(self):
-        # bpo-42398: Test that the destination file is left unchanged if the
-        # content does not change. Moreover, check also that the file
-        # modification time does not change in this case.
-        source = support.findfile('clinic.test')
+        CLINIC_TEST = 'clinic.test.c'
+        source = support.findfile(CLINIC_TEST)
         with open(source, 'r', encoding='utf-8') as f:
             orig_contents = f.read()
 
-        with os_helper.temp_dir() as tmp_dir:
-            testfile = os.path.join(tmp_dir, 'clinic.test.c')
-            with open(testfile, 'w', encoding='utf-8') as f:
-                f.write(orig_contents)
-            old_mtime_ns = os.stat(testfile).st_mtime_ns
-
-            clinic.parse_file(testfile)
-
-            with open(testfile, 'r', encoding='utf-8') as f:
-                new_contents = f.read()
-            new_mtime_ns = os.stat(testfile).st_mtime_ns
+        # Run clinic CLI and verify that it does not complain.
+        self.addCleanup(unlink, TESTFN)
+        out = self.expect_success("-f", "-o", TESTFN, source)
+        self.assertEqual(out, "")
+
+        with open(TESTFN, 'r', encoding='utf-8') as f:
+            new_contents = f.read()
 
         self.assertEqual(new_contents, orig_contents)
+
+    def test_no_change(self):
+        # bpo-42398: Test that the destination file is left unchanged if the
+        # content does not change. Moreover, check also that the file
+        # modification time does not change in this case.
+        code = dedent("""
+            /*[clinic input]
+            [clinic start generated code]*/
+            /*[clinic end generated code: output=da39a3ee5e6b4b0d input=da39a3ee5e6b4b0d]*/
+        """)
+        with os_helper.temp_dir() as tmp_dir:
+            fn = os.path.join(tmp_dir, "test.c")
+            with open(fn, "w", encoding="utf-8") as f:
+                f.write(code)
+            pre_mtime = os.stat(fn).st_mtime_ns
+            self.expect_success(fn)
+            post_mtime = os.stat(fn).st_mtime_ns
         # Don't change the file modification time
         # if the content does not change
-        self.assertEqual(new_mtime_ns, old_mtime_ns)
+        self.assertEqual(pre_mtime, post_mtime)
+
+    def test_cli_force(self):
+        invalid_input = dedent("""
+            /*[clinic input]
+            output preset block
+            module test
+            test.fn
+                a: int
+            [clinic start generated code]*/
+
+            const char *hand_edited = "output block is overwritten";
+            /*[clinic end generated code: output=bogus input=bogus]*/
+        """)
+        fail_msg = dedent("""
+            Checksum mismatch!
+            Expected: bogus
+            Computed: 2ed19
+            Suggested fix: remove all generated code including the end marker,
+            or use the '-f' option.
+        """)
+        with os_helper.temp_dir() as tmp_dir:
+            fn = os.path.join(tmp_dir, "test.c")
+            with open(fn, "w", encoding="utf-8") as f:
+                f.write(invalid_input)
+            # First, run the CLI without -f and expect failure.
+            # Note, we cannot check the entire fail msg, because the path to
+            # the tmp file will change for every run.
+            out = self.expect_failure(fn)
+            self.assertTrue(out.endswith(fail_msg))
+            # Then, force regeneration; success expected.
+            out = self.expect_success("-f", fn)
+            self.assertEqual(out, "")
+            # Verify by checking the checksum.
+            checksum = (
+                "/*[clinic end generated code: "
+                "output=6c2289b73f32bc19 input=9543a8d2da235301]*/\n"
+            )
+            with open(fn, 'r', encoding='utf-8') as f:
+                generated = f.read()
+            self.assertTrue(generated.endswith(checksum))
+
+    def test_cli_make(self):
+        c_code = dedent("""
+            /*[clinic input]
+            [clinic start generated code]*/
+        """)
+        py_code = "pass"
+        c_files = "file1.c", "file2.c"
+        py_files = "file1.py", "file2.py"
+
+        def create_files(files, srcdir, code):
+            for fn in files:
+                path = os.path.join(srcdir, fn)
+                with open(path, "w", encoding="utf-8") as f:
+                    f.write(code)
+
+        with os_helper.temp_dir() as tmp_dir:
+            # add some folders, some C files and a Python file
+            create_files(c_files, tmp_dir, c_code)
+            create_files(py_files, tmp_dir, py_code)
+
+            # create C files in externals/ dir
+            ext_path = os.path.join(tmp_dir, "externals")
+            with os_helper.temp_dir(path=ext_path) as externals:
+                create_files(c_files, externals, c_code)
+
+                # run clinic in verbose mode with --make on tmpdir
+                out = self.expect_success("-v", "--make", "--srcdir", tmp_dir)
+
+            # expect verbose mode to only mention the C files in tmp_dir
+            for filename in c_files:
+                with self.subTest(filename=filename):
+                    path = os.path.join(tmp_dir, filename)
+                    self.assertIn(path, out)
+            for filename in py_files:
+                with self.subTest(filename=filename):
+                    path = os.path.join(tmp_dir, filename)
+                    self.assertNotIn(path, out)
+            # don't expect C files from the externals dir
+            for filename in c_files:
+                with self.subTest(filename=filename):
+                    path = os.path.join(ext_path, filename)
+                    self.assertNotIn(path, out)
+
+    def test_cli_verbose(self):
+        with os_helper.temp_dir() as tmp_dir:
+            fn = os.path.join(tmp_dir, "test.c")
+            with open(fn, "w", encoding="utf-8") as f:
+                f.write("")
+            out = self.expect_success("-v", fn)
+            self.assertEqual(out.strip(), fn)
+
+    def test_cli_help(self):
+        out = self.expect_success("-h")
+        self.assertIn("usage: clinic.py", out)
+
+    def test_cli_converters(self):
+        prelude = dedent("""
+            Legacy converters:
+                B C D L O S U Y Z Z#
+                b c d f h i l p s s# s* u u# w* y y# y* z z# z*
+
+            Converters:
+        """)
+        expected_converters = (
+            "bool",
+            "byte",
+            "char",
+            "defining_class",
+            "double",
+            "fildes",
+            "float",
+            "int",
+            "long",
+            "long_long",
+            "object",
+            "Py_buffer",
+            "Py_complex",
+            "Py_ssize_t",
+            "Py_UNICODE",
+            "PyByteArrayObject",
+            "PyBytesObject",
+            "self",
+            "short",
+            "size_t",
+            "slice_index",
+            "str",
+            "unicode",
+            "unsigned_char",
+            "unsigned_int",
+            "unsigned_long",
+            "unsigned_long_long",
+            "unsigned_short",
+        )
+        finale = dedent("""
+            Return converters:
+                bool()
+                double()
+                float()
+                init()
+                int()
+                long()
+                NoneType()
+                Py_ssize_t()
+                size_t()
+                unsigned_int()
+                unsigned_long()
+
+            All converters also accept (c_default=None, py_default=None, annotation=None).
+            All return converters also accept (py_default=None).
+        """)
+        out = self.expect_success("--converters")
+        # We cannot simply compare the output, because the repr of the *accept*
+        # param may change (it's a set, thus unordered). So, let's compare the
+        # start and end of the expected output, and then assert that the
+        # converters appear lined up in alphabetical order.
+        self.assertTrue(out.startswith(prelude), out)
+        self.assertTrue(out.endswith(finale), out)
+
+        out = out.removeprefix(prelude)
+        out = out.removesuffix(finale)
+        lines = out.split("\n")
+        for converter, line in zip(expected_converters, lines):
+            line = line.lstrip()
+            with self.subTest(converter=converter):
+                self.assertTrue(
+                    line.startswith(converter),
+                    f"expected converter {converter!r}, got {line!r}"
+                )
+
+    def test_cli_fail_converters_and_filename(self):
+        out = self.expect_failure("--converters", "test.c")
+        msg = (
+            "Usage error: can't specify --converters "
+            "and a filename at the same time"
+        )
+        self.assertIn(msg, out)
+
+    def test_cli_fail_no_filename(self):
+        out = self.expect_failure()
+        self.assertIn("usage: clinic.py", out)
+
+    def test_cli_fail_output_and_multiple_files(self):
+        out = self.expect_failure("-o", "out.c", "input.c", "moreinput.c")
+        msg = "Usage error: can't use -o with multiple filenames"
+        self.assertIn(msg, out)
+
+    def test_cli_fail_filename_or_output_and_make(self):
+        for opts in ("-o", "out.c"), ("filename.c",):
+            with self.subTest(opts=opts):
+                out = self.expect_failure("--make", *opts)
+                msg = "Usage error: can't use -o or filenames with --make"
+                self.assertIn(msg, out)
+
+    def test_cli_fail_make_without_srcdir(self):
+        out = self.expect_failure("--make", "--srcdir", "")
+        msg = "Usage error: --srcdir must not be empty with --make"
+        self.assertIn(msg, out)
 
 
 try:
@@ -1327,5 +2033,111 @@ class ClinicFunctionalTest(unittest.Test
             ac_tester.gh_99240_double_free('a', '\0b')
 
 
+class PermutationTests(unittest.TestCase):
+    """Test permutation support functions."""
+
+    def test_permute_left_option_groups(self):
+        expected = (
+            (),
+            (3,),
+            (2, 3),
+            (1, 2, 3),
+        )
+        data = list(zip([1, 2, 3]))  # Generate a list of 1-tuples.
+        actual = tuple(clinic.permute_left_option_groups(data))
+        self.assertEqual(actual, expected)
+
+    def test_permute_right_option_groups(self):
+        expected = (
+            (),
+            (1,),
+            (1, 2),
+            (1, 2, 3),
+        )
+        data = list(zip([1, 2, 3]))  # Generate a list of 1-tuples.
+        actual = tuple(clinic.permute_right_option_groups(data))
+        self.assertEqual(actual, expected)
+
+    def test_permute_optional_groups(self):
+        empty = {
+            "left": (), "required": (), "right": (),
+            "expected": ((),),
+        }
+        noleft1 = {
+            "left": (), "required": ("b",), "right": ("c",),
+            "expected": (
+                ("b",),
+                ("b", "c"),
+            ),
+        }
+        noleft2 = {
+            "left": (), "required": ("b", "c",), "right": ("d",),
+            "expected": (
+                ("b", "c"),
+                ("b", "c", "d"),
+            ),
+        }
+        noleft3 = {
+            "left": (), "required": ("b", "c",), "right": ("d", "e"),
+            "expected": (
+                ("b", "c"),
+                ("b", "c", "d"),
+                ("b", "c", "d", "e"),
+            ),
+        }
+        noright1 = {
+            "left": ("a",), "required": ("b",), "right": (),
+            "expected": (
+                ("b",),
+                ("a", "b"),
+            ),
+        }
+        noright2 = {
+            "left": ("a",), "required": ("b", "c"), "right": (),
+            "expected": (
+                ("b", "c"),
+                ("a", "b", "c"),
+            ),
+        }
+        noright3 = {
+            "left": ("a", "b"), "required": ("c",), "right": (),
+            "expected": (
+                ("c",),
+                ("b", "c"),
+                ("a", "b", "c"),
+            ),
+        }
+        leftandright1 = {
+            "left": ("a",), "required": ("b",), "right": ("c",),
+            "expected": (
+                ("b",),
+                ("a", "b"),  # Prefer left.
+                ("a", "b", "c"),
+            ),
+        }
+        leftandright2 = {
+            "left": ("a", "b"), "required": ("c", "d"), "right": ("e", "f"),
+            "expected": (
+                ("c", "d"),
+                ("b", "c", "d"),       # Prefer left.
+                ("a", "b", "c", "d"),  # Prefer left.
+                ("a", "b", "c", "d", "e"),
+                ("a", "b", "c", "d", "e", "f"),
+            ),
+        }
+        dataset = (
+            empty,
+            noleft1, noleft2, noleft3,
+            noright1, noright2, noright3,
+            leftandright1, leftandright2,
+        )
+        for params in dataset:
+            with self.subTest(**params):
+                left, required, right, expected = params.values()
+                permutations = clinic.permute_optional_groups(left, required, right)
+                actual = tuple(permutations)
+                self.assertEqual(actual, expected)
+
+
 if __name__ == "__main__":
     unittest.main()
--- a/Lib/test/test_cmd_line_script.py
+++ b/Lib/test/test_cmd_line_script.py
@@ -777,7 +777,7 @@ class CmdLineTest(unittest.TestCase):
         with os_helper.temp_dir() as work_dir:
             script_name = _make_test_script(work_dir, 'script.py', script)
             with open(script_name, "r") as fp:
-                p = spawn_python(f"/dev/fd/{fp.fileno()}", close_fds=False, pass_fds=(0,1,2,fp.fileno()))
+                p = spawn_python(f"/dev/fd/{fp.fileno()}", close_fds=True, pass_fds=(0,1,2,fp.fileno()))
                 out, err = p.communicate()
                 self.assertEqual(out, b"12345678912345678912345\n")
 
--- a/Lib/test/test_codecs.py
+++ b/Lib/test/test_codecs.py
@@ -2823,15 +2823,16 @@ class TransformCodecTest(unittest.TestCa
     def test_custom_zlib_error_is_wrapped(self):
         # Check zlib codec gives a good error for malformed input
         msg = "^decoding with 'zlib_codec' codec failed"
-        with self.assertRaisesRegex(Exception, msg) as failure:
+        with self.assertRaises(zlib.error) as failure:
             codecs.decode(b"hello", "zlib_codec")
         self.assertIsInstance(failure.exception.__cause__,
                                                 type(failure.exception))
 
     def test_custom_hex_error_is_wrapped(self):
         # Check hex codec gives a good error for malformed input
+        import binascii
         msg = "^decoding with 'hex_codec' codec failed"
-        with self.assertRaisesRegex(Exception, msg) as failure:
+        with self.assertRaises(binascii.Error) as failure:
             codecs.decode(b"hello", "hex_codec")
         self.assertIsInstance(failure.exception.__cause__,
                                                 type(failure.exception))
--- a/Lib/test/test_colorsys.py
+++ b/Lib/test/test_colorsys.py
@@ -69,6 +69,16 @@ class ColorsysTest(unittest.TestCase):
             self.assertTripleEqual(hls, colorsys.rgb_to_hls(*rgb))
             self.assertTripleEqual(rgb, colorsys.hls_to_rgb(*hls))
 
+    def test_hls_nearwhite(self):  # gh-106498
+        values = (
+            # rgb, hls: these do not work in reverse
+            ((0.9999999999999999, 1, 1), (0.5, 1.0, 1.0)),
+            ((1, 0.9999999999999999, 0.9999999999999999), (0.0, 1.0, 1.0)),
+        )
+        for rgb, hls in values:
+            self.assertTripleEqual(hls, colorsys.rgb_to_hls(*rgb))
+            self.assertTripleEqual((1.0, 1.0, 1.0), colorsys.hls_to_rgb(*hls))
+
     def test_yiq_roundtrip(self):
         for r in frange(0.0, 1.0, 0.2):
             for g in frange(0.0, 1.0, 0.2):
--- a/Lib/test/test_concurrent_futures.py
+++ b/Lib/test/test_concurrent_futures.py
@@ -1167,6 +1167,11 @@ def _crash(delay=None):
     faulthandler._sigsegv()
 
 
+def _crash_with_data(data):
+    """Induces a segfault with dummy data in input."""
+    _crash()
+
+
 def _exit():
     """Induces a sys exit with exitcode 1."""
     sys.exit(1)
@@ -1366,6 +1371,19 @@ class ExecutorDeadlockTest:
         # dangling threads
         executor_manager.join()
 
+    def test_crash_big_data(self):
+        # Test that there is a clean exception instad of a deadlock when a
+        # child process crashes while some data is being written into the
+        # queue.
+        # https://github.com/python/cpython/issues/94777
+        self.executor.shutdown(wait=True)
+        data = "a" * support.PIPE_MAX_SIZE
+        with self.executor_type(max_workers=2,
+                                mp_context=self.get_context()) as executor:
+            self.executor = executor  # Allow clean up in fail_on_deadlock
+            with self.assertRaises(BrokenProcessPool):
+                list(executor.map(_crash_with_data, [data] * 10))
+
 
 create_executor_tests(ExecutorDeadlockTest,
                       executor_mixins=(ProcessPoolForkMixin,
--- a/Lib/test/test_decimal.py
+++ b/Lib/test/test_decimal.py
@@ -20,7 +20,7 @@ Cowlishaw's tests can be downloaded from
 
 This test module can be called from command line with one parameter (Arithmetic
 or Behaviour) to test each part, or without parameter to test both parts. If
-you're working through IDLE, you can import this test module and call test_main()
+you're working through IDLE, you can import this test module and call test()
 with the corresponding argument.
 """
 
@@ -32,7 +32,7 @@ import pickle, copy
 import unittest
 import numbers
 import locale
-from test.support import (run_unittest, run_doctest, is_resource_enabled,
+from test.support import (is_resource_enabled,
                           requires_IEEE_754, requires_docstrings,
                           requires_legacy_unicode_capi, check_sanitizer)
 from test.support import (TestFailed,
@@ -62,6 +62,7 @@ sys.modules['decimal'] = C
 fractions = {C:cfractions, P:pfractions}
 sys.modules['decimal'] = orig_sys_decimal
 
+requires_cdecimal = unittest.skipUnless(C, "test requires C version")
 
 # Useful Test Constant
 Signals = {
@@ -99,7 +100,7 @@ RoundingModes = [
 ]
 
 # Tests are built around these assumed context defaults.
-# test_main() restores the original context.
+# test() restores the original context.
 ORIGINAL_CONTEXT = {
   C: C.getcontext().copy() if C else None,
   P: P.getcontext().copy()
@@ -133,7 +134,7 @@ skip_if_extra_functionality = unittest.s
   EXTRA_FUNCTIONALITY, "test requires regular build")
 
 
-class IBMTestCases(unittest.TestCase):
+class IBMTestCases:
     """Class which tests the Decimal class against the IBM test cases."""
 
     def setUp(self):
@@ -488,14 +489,10 @@ class IBMTestCases(unittest.TestCase):
     def change_clamp(self, clamp):
         self.context.clamp = clamp
 
-class CIBMTestCases(IBMTestCases):
-    decimal = C
-class PyIBMTestCases(IBMTestCases):
-    decimal = P
 
 # The following classes test the behaviour of Decimal according to PEP 327
 
-class ExplicitConstructionTest(unittest.TestCase):
+class ExplicitConstructionTest:
     '''Unit tests for Explicit Construction cases of Decimal.'''
 
     def test_explicit_empty(self):
@@ -838,12 +835,13 @@ class ExplicitConstructionTest(unittest.
         for input, expected in test_values.items():
             self.assertEqual(str(Decimal(input)), expected)
 
-class CExplicitConstructionTest(ExplicitConstructionTest):
+@requires_cdecimal
+class CExplicitConstructionTest(ExplicitConstructionTest, unittest.TestCase):
     decimal = C
-class PyExplicitConstructionTest(ExplicitConstructionTest):
+class PyExplicitConstructionTest(ExplicitConstructionTest, unittest.TestCase):
     decimal = P
 
-class ImplicitConstructionTest(unittest.TestCase):
+class ImplicitConstructionTest:
     '''Unit tests for Implicit Construction cases of Decimal.'''
 
     def test_implicit_from_None(self):
@@ -920,12 +918,13 @@ class ImplicitConstructionTest(unittest.
             self.assertEqual(eval('Decimal(10)' + sym + 'E()'),
                              '10' + rop + 'str')
 
-class CImplicitConstructionTest(ImplicitConstructionTest):
+@requires_cdecimal
+class CImplicitConstructionTest(ImplicitConstructionTest, unittest.TestCase):
     decimal = C
-class PyImplicitConstructionTest(ImplicitConstructionTest):
+class PyImplicitConstructionTest(ImplicitConstructionTest, unittest.TestCase):
     decimal = P
 
-class FormatTest(unittest.TestCase):
+class FormatTest:
     '''Unit tests for the format function.'''
     def test_formatting(self):
         Decimal = self.decimal.Decimal
@@ -1262,12 +1261,13 @@ class FormatTest(unittest.TestCase):
         a = A.from_float(42)
         self.assertEqual(self.decimal.Decimal, a.a_type)
 
-class CFormatTest(FormatTest):
+@requires_cdecimal
+class CFormatTest(FormatTest, unittest.TestCase):
     decimal = C
-class PyFormatTest(FormatTest):
+class PyFormatTest(FormatTest, unittest.TestCase):
     decimal = P
 
-class ArithmeticOperatorsTest(unittest.TestCase):
+class ArithmeticOperatorsTest:
     '''Unit tests for all arithmetic operators, binary and unary.'''
 
     def test_addition(self):
@@ -1523,14 +1523,17 @@ class ArithmeticOperatorsTest(unittest.T
         equality_ops = operator.eq, operator.ne
 
         # results when InvalidOperation is not trapped
-        for x, y in qnan_pairs + snan_pairs:
-            for op in order_ops + equality_ops:
-                got = op(x, y)
-                expected = True if op is operator.ne else False
-                self.assertIs(expected, got,
-                              "expected {0!r} for operator.{1}({2!r}, {3!r}); "
-                              "got {4!r}".format(
-                        expected, op.__name__, x, y, got))
+        with localcontext() as ctx:
+            ctx.traps[InvalidOperation] = 0
+
+            for x, y in qnan_pairs + snan_pairs:
+                for op in order_ops + equality_ops:
+                    got = op(x, y)
+                    expected = True if op is operator.ne else False
+                    self.assertIs(expected, got,
+                                "expected {0!r} for operator.{1}({2!r}, {3!r}); "
+                                "got {4!r}".format(
+                            expected, op.__name__, x, y, got))
 
         # repeat the above, but this time trap the InvalidOperation
         with localcontext() as ctx:
@@ -1562,9 +1565,10 @@ class ArithmeticOperatorsTest(unittest.T
         self.assertEqual(Decimal(1).copy_sign(-2), d)
         self.assertRaises(TypeError, Decimal(1).copy_sign, '-2')
 
-class CArithmeticOperatorsTest(ArithmeticOperatorsTest):
+@requires_cdecimal
+class CArithmeticOperatorsTest(ArithmeticOperatorsTest, unittest.TestCase):
     decimal = C
-class PyArithmeticOperatorsTest(ArithmeticOperatorsTest):
+class PyArithmeticOperatorsTest(ArithmeticOperatorsTest, unittest.TestCase):
     decimal = P
 
 # The following are two functions used to test threading in the next class
@@ -1654,7 +1658,7 @@ def thfunc2(cls):
 
 
 @threading_helper.requires_working_threading()
-class ThreadingTest(unittest.TestCase):
+class ThreadingTest:
     '''Unit tests for thread local contexts in Decimal.'''
 
     # Take care executing this test from IDLE, there's an issue in threading
@@ -1699,13 +1703,14 @@ class ThreadingTest(unittest.TestCase):
         DefaultContext.Emin = save_emin
 
 
-class CThreadingTest(ThreadingTest):
+@requires_cdecimal
+class CThreadingTest(ThreadingTest, unittest.TestCase):
     decimal = C
 
-class PyThreadingTest(ThreadingTest):
+class PyThreadingTest(ThreadingTest, unittest.TestCase):
     decimal = P
 
-class UsabilityTest(unittest.TestCase):
+class UsabilityTest:
     '''Unit tests for Usability cases of Decimal.'''
 
     def test_comparison_operators(self):
@@ -2521,9 +2526,10 @@ class UsabilityTest(unittest.TestCase):
         self.assertEqual(Decimal(-12).fma(45, Decimal(67)),
                          Decimal(-12).fma(Decimal(45), Decimal(67)))
 
-class CUsabilityTest(UsabilityTest):
+@requires_cdecimal
+class CUsabilityTest(UsabilityTest, unittest.TestCase):
     decimal = C
-class PyUsabilityTest(UsabilityTest):
+class PyUsabilityTest(UsabilityTest, unittest.TestCase):
     decimal = P
 
     def setUp(self):
@@ -2535,7 +2541,7 @@ class PyUsabilityTest(UsabilityTest):
         sys.set_int_max_str_digits(self._previous_int_limit)
         super().tearDown()
 
-class PythonAPItests(unittest.TestCase):
+class PythonAPItests:
 
     def test_abc(self):
         Decimal = self.decimal.Decimal
@@ -2884,12 +2890,13 @@ class PythonAPItests(unittest.TestCase):
         self.assertTrue(issubclass(decimal.DivisionUndefined, ZeroDivisionError))
         self.assertTrue(issubclass(decimal.InvalidContext, InvalidOperation))
 
-class CPythonAPItests(PythonAPItests):
+@requires_cdecimal
+class CPythonAPItests(PythonAPItests, unittest.TestCase):
     decimal = C
-class PyPythonAPItests(PythonAPItests):
+class PyPythonAPItests(PythonAPItests, unittest.TestCase):
     decimal = P
 
-class ContextAPItests(unittest.TestCase):
+class ContextAPItests:
 
     def test_none_args(self):
         Context = self.decimal.Context
@@ -3635,12 +3642,13 @@ class ContextAPItests(unittest.TestCase)
         self.assertRaises(TypeError, c.to_integral_value, '10')
         self.assertRaises(TypeError, c.to_integral_value, 10, 'x')
 
-class CContextAPItests(ContextAPItests):
+@requires_cdecimal
+class CContextAPItests(ContextAPItests, unittest.TestCase):
     decimal = C
-class PyContextAPItests(ContextAPItests):
+class PyContextAPItests(ContextAPItests, unittest.TestCase):
     decimal = P
 
-class ContextWithStatement(unittest.TestCase):
+class ContextWithStatement:
     # Can't do these as docstrings until Python 2.6
     # as doctest can't handle __future__ statements
 
@@ -3704,9 +3712,13 @@ class ContextWithStatement(unittest.Test
 
     def test_local_context_kwargs_does_not_overwrite_existing_argument(self):
         ctx = self.decimal.getcontext()
-        ctx.prec = 28
+        orig_prec = ctx.prec
         with self.decimal.localcontext(prec=10) as ctx2:
-            self.assertEqual(ctx.prec, 28)
+            self.assertEqual(ctx2.prec, 10)
+            self.assertEqual(ctx.prec, orig_prec)
+        with self.decimal.localcontext(prec=20) as ctx2:
+            self.assertEqual(ctx2.prec, 20)
+            self.assertEqual(ctx.prec, orig_prec)
 
     def test_nested_with_statements(self):
         # Use a copy of the supplied context in the block
@@ -3800,12 +3812,13 @@ class ContextWithStatement(unittest.Test
                         self.assertEqual(c4.prec, 4)
                         del c4
 
-class CContextWithStatement(ContextWithStatement):
+@requires_cdecimal
+class CContextWithStatement(ContextWithStatement, unittest.TestCase):
     decimal = C
-class PyContextWithStatement(ContextWithStatement):
+class PyContextWithStatement(ContextWithStatement, unittest.TestCase):
     decimal = P
 
-class ContextFlags(unittest.TestCase):
+class ContextFlags:
 
     def test_flags_irrelevant(self):
         # check that the result (numeric result + flags raised) of an
@@ -4072,12 +4085,13 @@ class ContextFlags(unittest.TestCase):
         self.assertTrue(context.traps[FloatOperation])
         self.assertTrue(context.traps[Inexact])
 
-class CContextFlags(ContextFlags):
+@requires_cdecimal
+class CContextFlags(ContextFlags, unittest.TestCase):
     decimal = C
-class PyContextFlags(ContextFlags):
+class PyContextFlags(ContextFlags, unittest.TestCase):
     decimal = P
 
-class SpecialContexts(unittest.TestCase):
+class SpecialContexts:
     """Test the context templates."""
 
     def test_context_templates(self):
@@ -4157,12 +4171,13 @@ class SpecialContexts(unittest.TestCase)
             if ex:
                 raise ex
 
-class CSpecialContexts(SpecialContexts):
+@requires_cdecimal
+class CSpecialContexts(SpecialContexts, unittest.TestCase):
     decimal = C
-class PySpecialContexts(SpecialContexts):
+class PySpecialContexts(SpecialContexts, unittest.TestCase):
     decimal = P
 
-class ContextInputValidation(unittest.TestCase):
+class ContextInputValidation:
 
     def test_invalid_context(self):
         Context = self.decimal.Context
@@ -4224,12 +4239,13 @@ class ContextInputValidation(unittest.Te
         self.assertRaises(TypeError, Context, flags=(0,1))
         self.assertRaises(TypeError, Context, traps=(1,0))
 
-class CContextInputValidation(ContextInputValidation):
+@requires_cdecimal
+class CContextInputValidation(ContextInputValidation, unittest.TestCase):
     decimal = C
-class PyContextInputValidation(ContextInputValidation):
+class PyContextInputValidation(ContextInputValidation, unittest.TestCase):
     decimal = P
 
-class ContextSubclassing(unittest.TestCase):
+class ContextSubclassing:
 
     def test_context_subclassing(self):
         decimal = self.decimal
@@ -4338,12 +4354,14 @@ class ContextSubclassing(unittest.TestCa
         for signal in OrderedSignals[decimal]:
             self.assertFalse(c.traps[signal])
 
-class CContextSubclassing(ContextSubclassing):
+@requires_cdecimal
+class CContextSubclassing(ContextSubclassing, unittest.TestCase):
     decimal = C
-class PyContextSubclassing(ContextSubclassing):
+class PyContextSubclassing(ContextSubclassing, unittest.TestCase):
     decimal = P
 
 @skip_if_extra_functionality
+@requires_cdecimal
 class CheckAttributes(unittest.TestCase):
 
     def test_module_attributes(self):
@@ -4373,7 +4391,7 @@ class CheckAttributes(unittest.TestCase)
         y = [s for s in dir(C.Decimal(9)) if '__' in s or not s.startswith('_')]
         self.assertEqual(set(x) - set(y), set())
 
-class Coverage(unittest.TestCase):
+class Coverage:
 
     def test_adjusted(self):
         Decimal = self.decimal.Decimal
@@ -4630,9 +4648,10 @@ class Coverage(unittest.TestCase):
         y = c.copy_sign(x, 1)
         self.assertEqual(y, -x)
 
-class CCoverage(Coverage):
+@requires_cdecimal
+class CCoverage(Coverage, unittest.TestCase):
     decimal = C
-class PyCoverage(Coverage):
+class PyCoverage(Coverage, unittest.TestCase):
     decimal = P
 
     def setUp(self):
@@ -4885,6 +4904,7 @@ class CFunctionality(unittest.TestCase):
         self.assertEqual(C.DecTraps,
                          C.DecErrors|C.DecOverflow|C.DecUnderflow)
 
+@requires_cdecimal
 class CWhitebox(unittest.TestCase):
     """Whitebox testing for _decimal"""
 
@@ -5662,8 +5682,38 @@ class CWhitebox(unittest.TestCase):
             self.assertEqual(Decimal(400) ** -1, Decimal('0.0025'))
 
 
+    def test_c_signaldict_segfault(self):
+        # See gh-106263 for details.
+        SignalDict = type(C.Context().flags)
+        sd = SignalDict()
+        err_msg = "invalid signal dict"
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            len(sd)
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            iter(sd)
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            repr(sd)
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd[C.InvalidOperation] = True
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd[C.InvalidOperation]
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd == C.Context().flags
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            C.Context().flags == sd
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd.copy()
+
 @requires_docstrings
-@unittest.skipUnless(C, "test requires C version")
+@requires_cdecimal
 class SignatureTest(unittest.TestCase):
     """Function signatures"""
 
@@ -5799,52 +5849,10 @@ class SignatureTest(unittest.TestCase):
         doit('Context')
 
 
-all_tests = [
-  CExplicitConstructionTest, PyExplicitConstructionTest,
-  CImplicitConstructionTest, PyImplicitConstructionTest,
-  CFormatTest,               PyFormatTest,
-  CArithmeticOperatorsTest,  PyArithmeticOperatorsTest,
-  CThreadingTest,            PyThreadingTest,
-  CUsabilityTest,            PyUsabilityTest,
-  CPythonAPItests,           PyPythonAPItests,
-  CContextAPItests,          PyContextAPItests,
-  CContextWithStatement,     PyContextWithStatement,
-  CContextFlags,             PyContextFlags,
-  CSpecialContexts,          PySpecialContexts,
-  CContextInputValidation,   PyContextInputValidation,
-  CContextSubclassing,       PyContextSubclassing,
-  CCoverage,                 PyCoverage,
-  CFunctionality,            PyFunctionality,
-  CWhitebox,                 PyWhitebox,
-  CIBMTestCases,             PyIBMTestCases,
-]
-
-# Delete C tests if _decimal.so is not present.
-if not C:
-    all_tests = all_tests[1::2]
-else:
-    all_tests.insert(0, CheckAttributes)
-    all_tests.insert(1, SignatureTest)
-
-
-def test_main(arith=None, verbose=None, todo_tests=None, debug=None):
-    """ Execute the tests.
-
-    Runs all arithmetic tests if arith is True or if the "decimal" resource
-    is enabled in regrtest.py
-    """
-
-    init(C)
-    init(P)
-    global TEST_ALL, DEBUG
-    TEST_ALL = arith if arith is not None else is_resource_enabled('decimal')
-    DEBUG = debug
-
-    if todo_tests is None:
-        test_classes = all_tests
-    else:
-        test_classes = [CIBMTestCases, PyIBMTestCases]
-
+def load_tests(loader, tests, pattern):
+    if TODO_TESTS is not None:
+        # Run only Arithmetic tests
+        tests = loader.suiteClass()
     # Dynamically build custom test definition for each file in the test
     # directory and add the definitions to the DecimalTest class.  This
     # procedure insures that new files do not get skipped.
@@ -5852,34 +5860,69 @@ def test_main(arith=None, verbose=None,
         if '.decTest' not in filename or filename.startswith("."):
             continue
         head, tail = filename.split('.')
-        if todo_tests is not None and head not in todo_tests:
+        if TODO_TESTS is not None and head not in TODO_TESTS:
             continue
         tester = lambda self, f=filename: self.eval_file(directory + f)
-        setattr(CIBMTestCases, 'test_' + head, tester)
-        setattr(PyIBMTestCases, 'test_' + head, tester)
+        setattr(IBMTestCases, 'test_' + head, tester)
         del filename, head, tail, tester
+    for prefix, mod in ('C', C), ('Py', P):
+        if not mod:
+            continue
+        test_class = type(prefix + 'IBMTestCases',
+                          (IBMTestCases, unittest.TestCase),
+                          {'decimal': mod})
+        tests.addTest(loader.loadTestsFromTestCase(test_class))
+
+    if TODO_TESTS is None:
+        from doctest import DocTestSuite, IGNORE_EXCEPTION_DETAIL
+        for mod in C, P:
+            if not mod:
+                continue
+            def setUp(slf, mod=mod):
+                sys.modules['decimal'] = mod
+            def tearDown(slf):
+                sys.modules['decimal'] = orig_sys_decimal
+            optionflags = IGNORE_EXCEPTION_DETAIL if mod is C else 0
+            sys.modules['decimal'] = mod
+            tests.addTest(DocTestSuite(mod, setUp=setUp, tearDown=tearDown,
+                                   optionflags=optionflags))
+            sys.modules['decimal'] = orig_sys_decimal
+    return tests
 
+def setUpModule():
+    init(C)
+    init(P)
+    global TEST_ALL
+    TEST_ALL = ARITH if ARITH is not None else is_resource_enabled('decimal')
 
-    try:
-        run_unittest(*test_classes)
-        if todo_tests is None:
-            from doctest import IGNORE_EXCEPTION_DETAIL
-            savedecimal = sys.modules['decimal']
-            if C:
-                sys.modules['decimal'] = C
-                run_doctest(C, verbose, optionflags=IGNORE_EXCEPTION_DETAIL)
-            sys.modules['decimal'] = P
-            run_doctest(P, verbose)
-            sys.modules['decimal'] = savedecimal
-    finally:
-        if C: C.setcontext(ORIGINAL_CONTEXT[C])
-        P.setcontext(ORIGINAL_CONTEXT[P])
-        if not C:
-            warnings.warn('C tests skipped: no module named _decimal.',
-                          UserWarning)
-        if not orig_sys_decimal is sys.modules['decimal']:
-            raise TestFailed("Internal error: unbalanced number of changes to "
-                             "sys.modules['decimal'].")
+def tearDownModule():
+    if C: C.setcontext(ORIGINAL_CONTEXT[C])
+    P.setcontext(ORIGINAL_CONTEXT[P])
+    if not C:
+        warnings.warn('C tests skipped: no module named _decimal.',
+                      UserWarning)
+    if not orig_sys_decimal is sys.modules['decimal']:
+        raise TestFailed("Internal error: unbalanced number of changes to "
+                         "sys.modules['decimal'].")
+
+
+ARITH = None
+TEST_ALL = True
+TODO_TESTS = None
+DEBUG = False
+
+def test(arith=None, verbose=None, todo_tests=None, debug=None):
+    """ Execute the tests.
+
+    Runs all arithmetic tests if arith is True or if the "decimal" resource
+    is enabled in regrtest.py
+    """
+
+    global ARITH, TODO_TESTS, DEBUG
+    ARITH = arith
+    TODO_TESTS = todo_tests
+    DEBUG = debug
+    unittest.main(__name__, verbosity=2 if verbose else 1, exit=False, argv=[__name__])
 
 
 if __name__ == '__main__':
@@ -5890,8 +5933,8 @@ if __name__ == '__main__':
     (opt, args) = p.parse_args()
 
     if opt.skip:
-        test_main(arith=False, verbose=True)
+        test(arith=False, verbose=True)
     elif args:
-        test_main(arith=True, verbose=True, todo_tests=args, debug=opt.debug)
+        test(arith=True, verbose=True, todo_tests=args, debug=opt.debug)
     else:
-        test_main(arith=True, verbose=True)
+        test(arith=True, verbose=True)
--- a/Lib/test/test_dtrace.py
+++ b/Lib/test/test_dtrace.py
@@ -3,6 +3,7 @@ import os.path
 import re
 import subprocess
 import sys
+import sysconfig
 import types
 import unittest
 
@@ -173,6 +174,75 @@ class SystemTapOptimizedTests(TraceTests
     backend = SystemTapBackend()
     optimize_python = 2
 
+class CheckDtraceProbes(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        if sysconfig.get_config_var('WITH_DTRACE'):
+            readelf_major_version, readelf_minor_version = cls.get_readelf_version()
+            if support.verbose:
+                print(f"readelf version: {readelf_major_version}.{readelf_minor_version}")
+        else:
+            raise unittest.SkipTest("CPython must be configured with the --with-dtrace option.")
+
+
+    @staticmethod
+    def get_readelf_version():
+        try:
+            cmd = ["readelf", "--version"]
+            proc = subprocess.Popen(
+                cmd,
+                stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE,
+                universal_newlines=True,
+            )
+            with proc:
+                version, stderr = proc.communicate()
+
+            if proc.returncode:
+                raise Exception(
+                    f"Command {' '.join(cmd)!r} failed "
+                    f"with exit code {proc.returncode}: "
+                    f"stdout={version!r} stderr={stderr!r}"
+                )
+        except OSError:
+            raise unittest.SkipTest("Couldn't find readelf on the path")
+
+        # Regex to parse:
+        # 'GNU readelf (GNU Binutils) 2.40.0\n' -> 2.40
+        match = re.search(r"^(?:GNU) readelf.*?\b(\d+)\.(\d+)", version)
+        if match is None:
+            raise unittest.SkipTest(f"Unable to parse readelf version: {version}")
+
+        return int(match.group(1)), int(match.group(2))
+
+    def get_readelf_output(self):
+        command = ["readelf", "-n", sys.executable]
+        stdout, _ = subprocess.Popen(
+            command,
+            stdout=subprocess.PIPE,
+            stderr=subprocess.STDOUT,
+            universal_newlines=True,
+        ).communicate()
+        return stdout
+
+    def test_check_probes(self):
+        readelf_output = self.get_readelf_output()
+
+        available_probe_names = [
+            "Name: import__find__load__done",
+            "Name: import__find__load__start",
+            "Name: audit",
+            "Name: gc__start",
+            "Name: gc__done",
+            "Name: function__entry",
+            "Name: function__return",
+            "Name: line",
+        ]
+
+        for probe_name in available_probe_names:
+            with self.subTest(probe_name=probe_name):
+                self.assertIn(probe_name, readelf_output)
+
 
 if __name__ == '__main__':
     unittest.main()
--- /dev/null
+++ b/Lib/test/test_email/data/msg_47.txt
@@ -0,0 +1,14 @@
+Date: 01 Jan 2001 00:01+0000
+From: arthur@example.example
+MIME-Version: 1.0
+Content-Type: multipart/mixed; boundary=foo
+
+--foo
+Content-Type: text/plain
+bar
+
+--foo
+Content-Type: text/html
+<html><body><p>baz</p></body></html>
+
+--foo--
\ No newline at end of file
--- a/Lib/test/test_email/test_email.py
+++ b/Lib/test/test_email/test_email.py
@@ -3696,6 +3696,16 @@ class TestParsers(TestEmailBase):
         self.assertIsInstance(msg.get_payload(), str)
         self.assertIsInstance(msg.get_payload(decode=True), bytes)
 
+    def test_header_parser_multipart_is_valid(self):
+        # Don't flag valid multipart emails as having defects
+        with openfile('msg_47.txt', encoding="utf-8") as fp:
+            msgdata = fp.read()
+
+        parser = email.parser.Parser(policy=email.policy.default)
+        parsed_msg = parser.parsestr(msgdata, headersonly=True)
+
+        self.assertEqual(parsed_msg.defects, [])
+
     def test_bytes_parser_does_not_close_file(self):
         with openfile('msg_02.txt', 'rb') as fp:
             email.parser.BytesParser().parse(fp)
--- a/Lib/test/test_email/test_message.py
+++ b/Lib/test/test_email/test_message.py
@@ -696,14 +696,16 @@ class TestEmailMessageBase:
             self.assertIsNone(part['Content-Disposition'])
 
     class _TestSetRaisingContentManager:
+        class CustomError(Exception):
+            pass
         def set_content(self, msg, content, *args, **kw):
-            raise Exception('test')
+            raise self.CustomError('test')
 
     def test_default_content_manager_for_add_comes_from_policy(self):
         cm = self._TestSetRaisingContentManager()
         m = self.message(policy=self.policy.clone(content_manager=cm))
         for method in ('add_related', 'add_alternative', 'add_attachment'):
-            with self.assertRaises(Exception) as ar:
+            with self.assertRaises(self._TestSetRaisingContentManager.CustomError) as ar:
                 getattr(m, method)('')
             self.assertEqual(str(ar.exception), 'test')
 
--- a/Lib/test/test_enum.py
+++ b/Lib/test/test_enum.py
@@ -32,6 +32,11 @@ def load_tests(loader, tests, ignore):
                 '../../Doc/library/enum.rst',
                 optionflags=doctest.ELLIPSIS|doctest.NORMALIZE_WHITESPACE,
                 ))
+    if os.path.exists('Doc/howto/enum.rst'):
+        tests.addTests(doctest.DocFileSuite(
+                '../../Doc/howto/enum.rst',
+                optionflags=doctest.ELLIPSIS|doctest.NORMALIZE_WHITESPACE,
+                ))
     return tests
 
 MODULE = __name__
@@ -67,6 +72,7 @@ try:
         LARRY = 1
         CURLY = 2
         MOE = 4
+        BIG = 389
 except Exception as exc:
     FlagStooges = exc
 
@@ -75,17 +81,20 @@ class FlagStoogesWithZero(Flag):
     LARRY = 1
     CURLY = 2
     MOE = 4
+    BIG = 389
 
 class IntFlagStooges(IntFlag):
     LARRY = 1
     CURLY = 2
     MOE = 4
+    BIG = 389
 
 class IntFlagStoogesWithZero(IntFlag):
     NOFLAG = 0
     LARRY = 1
     CURLY = 2
     MOE = 4
+    BIG = 389
 
 # for pickle test and subclass tests
 class Name(StrEnum):
@@ -766,9 +775,17 @@ class _MinimalOutputTests:
         TE = self.MainEnum
         copied = copy.copy(TE)
         self.assertEqual(copied, TE)
+        self.assertIs(copied, TE)
         deep = copy.deepcopy(TE)
         self.assertEqual(deep, TE)
+        self.assertIs(deep, TE)
 
+    def test_copy_member(self):
+        TE = self.MainEnum
+        copied = copy.copy(TE.first)
+        self.assertIs(copied, TE.first)
+        deep = copy.deepcopy(TE.first)
+        self.assertIs(deep, TE.first)
 
 class _FlagTests:
 
@@ -780,6 +797,89 @@ class _FlagTests:
             self.MainEnum('RED')
         self.assertIs(ctx.exception.__context__, None)
 
+    def test_closed_invert_expectations(self):
+        class ClosedAB(self.enum_type):
+            A = 1
+            B = 2
+            MASK = 3
+        A, B = ClosedAB
+        AB_MASK = ClosedAB.MASK
+        #
+        self.assertIs(~A, B)
+        self.assertIs(~B, A)
+        self.assertIs(~(A|B), ClosedAB(0))
+        self.assertIs(~AB_MASK, ClosedAB(0))
+        self.assertIs(~ClosedAB(0), (A|B))
+        #
+        class ClosedXYZ(self.enum_type):
+            X = 4
+            Y = 2
+            Z = 1
+            MASK = 7
+        X, Y, Z = ClosedXYZ
+        XYZ_MASK = ClosedXYZ.MASK
+        #
+        self.assertIs(~X, Y|Z)
+        self.assertIs(~Y, X|Z)
+        self.assertIs(~Z, X|Y)
+        self.assertIs(~(X|Y), Z)
+        self.assertIs(~(X|Z), Y)
+        self.assertIs(~(Y|Z), X)
+        self.assertIs(~(X|Y|Z), ClosedXYZ(0))
+        self.assertIs(~XYZ_MASK, ClosedXYZ(0))
+        self.assertIs(~ClosedXYZ(0), (X|Y|Z))
+
+    def test_open_invert_expectations(self):
+        class OpenAB(self.enum_type):
+            A = 1
+            B = 2
+            MASK = 255
+        A, B = OpenAB
+        AB_MASK = OpenAB.MASK
+        #
+        if OpenAB._boundary_ in (EJECT, KEEP):
+            self.assertIs(~A, OpenAB(254))
+            self.assertIs(~B, OpenAB(253))
+            self.assertIs(~(A|B), OpenAB(252))
+            self.assertIs(~AB_MASK, OpenAB(0))
+            self.assertIs(~OpenAB(0), AB_MASK)
+        else:
+            self.assertIs(~A, B)
+            self.assertIs(~B, A)
+            self.assertIs(~(A|B), OpenAB(0))
+            self.assertIs(~AB_MASK, OpenAB(0))
+            self.assertIs(~OpenAB(0), (A|B))
+        #
+        class OpenXYZ(self.enum_type):
+            X = 4
+            Y = 2
+            Z = 1
+            MASK = 31
+        X, Y, Z = OpenXYZ
+        XYZ_MASK = OpenXYZ.MASK
+        #
+        if OpenXYZ._boundary_ in (EJECT, KEEP):
+            self.assertIs(~X, OpenXYZ(27))
+            self.assertIs(~Y, OpenXYZ(29))
+            self.assertIs(~Z, OpenXYZ(30))
+            self.assertIs(~(X|Y), OpenXYZ(25))
+            self.assertIs(~(X|Z), OpenXYZ(26))
+            self.assertIs(~(Y|Z), OpenXYZ(28))
+            self.assertIs(~(X|Y|Z), OpenXYZ(24))
+            self.assertIs(~XYZ_MASK, OpenXYZ(0))
+            self.assertTrue(~OpenXYZ(0), XYZ_MASK)
+        else:
+            self.assertIs(~X, Y|Z)
+            self.assertIs(~Y, X|Z)
+            self.assertIs(~Z, X|Y)
+            self.assertIs(~(X|Y), Z)
+            self.assertIs(~(X|Z), Y)
+            self.assertIs(~(Y|Z), X)
+            self.assertIs(~(X|Y|Z), OpenXYZ(0))
+            self.assertIs(~XYZ_MASK, OpenXYZ(0))
+            self.assertTrue(~OpenXYZ(0), (X|Y|Z))
+
+
 class TestPlainEnum(_EnumTests, _PlainOutputTests, unittest.TestCase):
     enum_type = Enum
 
@@ -1860,7 +1960,6 @@ class TestSpecial(unittest.TestCase):
             __qualname__ = 'NEI'
             x = ('the-x', 1)
             y = ('the-y', 2)
-
         self.assertIs(NEI.__new__, Enum.__new__)
         self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
         globals()['NamedInt'] = NamedInt
@@ -1868,6 +1967,10 @@ class TestSpecial(unittest.TestCase):
         NI5 = NamedInt('test', 5)
         self.assertEqual(NI5, 5)
         self.assertEqual(NEI.y.value, 2)
+        with self.assertRaisesRegex(TypeError, "name and value must be specified"):
+            test_pickle_dump_load(self.assertIs, NEI.y)
+        # fix pickle support and try again
+        NEI.__reduce_ex__ = enum.pickle_by_enum_name
         test_pickle_dump_load(self.assertIs, NEI.y)
         test_pickle_dump_load(self.assertIs, NEI)
 
@@ -2944,22 +3047,6 @@ class OldTestFlag(unittest.TestCase):
         self.assertIs(Open.RO ^ Open.CE, Open.CE)
         self.assertIs(Open.CE ^ Open.CE, Open.RO)
 
-    def test_invert(self):
-        Perm = self.Perm
-        RW = Perm.R | Perm.W
-        RX = Perm.R | Perm.X
-        WX = Perm.W | Perm.X
-        RWX = Perm.R | Perm.W | Perm.X
-        values = list(Perm) + [RW, RX, WX, RWX, Perm(0)]
-        for i in values:
-            self.assertIs(type(~i), Perm)
-            self.assertEqual(~~i, i)
-        for i in Perm:
-            self.assertIs(~~i, i)
-        Open = self.Open
-        self.assertIs(Open.WO & ~Open.WO, Open.RO)
-        self.assertIs((Open.WO|Open.CE) & ~Open.WO, Open.CE)
-
     def test_bool(self):
         Perm = self.Perm
         for f in Perm:
@@ -3120,11 +3207,17 @@ class OldTestFlag(unittest.TestCase):
         test_pickle_dump_load(self.assertEqual,
                         FlagStooges.CURLY&~FlagStooges.CURLY)
         test_pickle_dump_load(self.assertIs, FlagStooges)
+        test_pickle_dump_load(self.assertEqual, FlagStooges.BIG)
+        test_pickle_dump_load(self.assertEqual,
+                        FlagStooges.CURLY|FlagStooges.BIG)
 
         test_pickle_dump_load(self.assertIs, FlagStoogesWithZero.CURLY)
         test_pickle_dump_load(self.assertEqual,
                         FlagStoogesWithZero.CURLY|FlagStoogesWithZero.MOE)
         test_pickle_dump_load(self.assertIs, FlagStoogesWithZero.NOFLAG)
+        test_pickle_dump_load(self.assertEqual, FlagStoogesWithZero.BIG)
+        test_pickle_dump_load(self.assertEqual,
+                        FlagStoogesWithZero.CURLY|FlagStoogesWithZero.BIG)
 
         test_pickle_dump_load(self.assertIs, IntFlagStooges.CURLY)
         test_pickle_dump_load(self.assertEqual,
@@ -3134,11 +3227,19 @@ class OldTestFlag(unittest.TestCase):
         test_pickle_dump_load(self.assertEqual, IntFlagStooges(0))
         test_pickle_dump_load(self.assertEqual, IntFlagStooges(0x30))
         test_pickle_dump_load(self.assertIs, IntFlagStooges)
+        test_pickle_dump_load(self.assertEqual, IntFlagStooges.BIG)
+        test_pickle_dump_load(self.assertEqual, IntFlagStooges.BIG|1)
+        test_pickle_dump_load(self.assertEqual,
+                        IntFlagStooges.CURLY|IntFlagStooges.BIG)
 
         test_pickle_dump_load(self.assertIs, IntFlagStoogesWithZero.CURLY)
         test_pickle_dump_load(self.assertEqual,
                         IntFlagStoogesWithZero.CURLY|IntFlagStoogesWithZero.MOE)
         test_pickle_dump_load(self.assertIs, IntFlagStoogesWithZero.NOFLAG)
+        test_pickle_dump_load(self.assertEqual, IntFlagStoogesWithZero.BIG)
+        test_pickle_dump_load(self.assertEqual, IntFlagStoogesWithZero.BIG|1)
+        test_pickle_dump_load(self.assertEqual,
+                        IntFlagStoogesWithZero.CURLY|IntFlagStoogesWithZero.BIG)
 
     @unittest.skipIf(
             python_version >= (3, 12),
--- a/Lib/test/test_gettext.py
+++ b/Lib/test/test_gettext.py
@@ -329,6 +329,8 @@ class PluralFormsTestCase(GettextBaseTes
         x = gettext.npgettext('With context',
                               'There is %s file', 'There are %s files', 2)
         eq(x, 'Hay %s ficheros (context)')
+        x = gettext.pgettext('With context', 'There is %s file')
+        eq(x, 'Hay %s fichero (context)')
 
     def test_plural_forms2(self):
         eq = self.assertEqual
@@ -349,6 +351,8 @@ class PluralFormsTestCase(GettextBaseTes
         x = t.npgettext('With context',
                         'There is %s file', 'There are %s files', 2)
         eq(x, 'Hay %s ficheros (context)')
+        x = gettext.pgettext('With context', 'There is %s file')
+        eq(x, 'Hay %s fichero (context)')
 
     # Examples from http://www.gnu.org/software/gettext/manual/gettext.html
 
--- a/Lib/test/test_import/__init__.py
+++ b/Lib/test/test_import/__init__.py
@@ -17,6 +17,7 @@ import threading
 import time
 import unittest
 from unittest import mock
+import _imp
 
 from test.support import os_helper
 from test.support import (
@@ -529,6 +530,13 @@ class ImportTests(unittest.TestCase):
                                     env=env,
                                     cwd=os.path.dirname(pyexe))
 
+    def test_issue105979(self):
+        # this used to crash
+        with self.assertRaises(ImportError) as cm:
+            _imp.get_frozen_object("x", b"6\'\xd5Cu\x12")
+        self.assertIn("Frozen object named 'x' is invalid",
+                      str(cm.exception))
+
 
 @skip_if_dont_write_bytecode
 class FilePermissionTests(unittest.TestCase):
--- a/Lib/test/test_importlib/test_main.py
+++ b/Lib/test/test_importlib/test_main.py
@@ -56,7 +56,7 @@ class BasicTests(fixtures.DistInfoPkg, u
         dict(name=''),
     )
     def test_invalid_inputs_to_from_name(self, name):
-        with self.assertRaises(Exception):
+        with self.assertRaises(ValueError):
             Distribution.from_name(name)
 
 
--- a/Lib/test/test_logging.py
+++ b/Lib/test/test_logging.py
@@ -1981,17 +1981,17 @@ class SysLogHandlerTest(BaseTest):
         # The log message sent to the SysLogHandler is properly received.
         logger = logging.getLogger("slh")
         logger.error("sp\xe4m")
-        self.handled.wait()
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>sp\xc3\xa4m\x00')
         self.handled.clear()
         self.sl_hdlr.append_nul = False
         logger.error("sp\xe4m")
-        self.handled.wait()
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>sp\xc3\xa4m')
         self.handled.clear()
         self.sl_hdlr.ident = "h\xe4m-"
         logger.error("sp\xe4m")
-        self.handled.wait()
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>h\xc3\xa4m-sp\xc3\xa4m')
 
     def test_udp_reconnection(self):
@@ -1999,7 +1999,7 @@ class SysLogHandlerTest(BaseTest):
         self.sl_hdlr.close()
         self.handled.clear()
         logger.error("sp\xe4m")
-        self.handled.wait(0.1)
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>sp\xc3\xa4m\x00')
 
 @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "Unix sockets required")
--- a/Lib/test/test_mailbox.py
+++ b/Lib/test/test_mailbox.py
@@ -116,10 +116,13 @@ class TestMailbox(TestBase):
         self.assertMailboxEmpty()
 
     def test_add_that_raises_leaves_mailbox_empty(self):
+        class CustomError(Exception): ...
+        exc_msg = "a fake error"
+
         def raiser(*args, **kw):
-            raise Exception("a fake error")
+            raise CustomError(exc_msg)
         support.patch(self, email.generator.BytesGenerator, 'flatten', raiser)
-        with self.assertRaises(Exception):
+        with self.assertRaisesRegex(CustomError, exc_msg):
             self._box.add(email.message_from_string("From: Alphso"))
         self.assertEqual(len(self._box), 0)
         self._box.close()
--- a/Lib/test/test_mmap.py
+++ b/Lib/test/test_mmap.py
@@ -299,6 +299,27 @@ class MmapTests(unittest.TestCase):
         self.assertEqual(m.find(b'one', 1, -2), -1)
         self.assertEqual(m.find(bytearray(b'one')), 0)
 
+        for i in range(-n-1, n+1):
+            for j in range(-n-1, n+1):
+                for p in [b"o", b"on", b"two", b"ones", b"s"]:
+                    expected = data.find(p, i, j)
+                    self.assertEqual(m.find(p, i, j), expected, (p, i, j))
+
+    def test_find_does_not_access_beyond_buffer(self):
+        try:
+            flags = mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS
+            PAGESIZE = mmap.PAGESIZE
+            PROT_NONE = 0
+            PROT_READ = mmap.PROT_READ
+        except AttributeError as e:
+            raise unittest.SkipTest("mmap flags unavailable") from e
+        for i in range(0, 2049):
+            with mmap.mmap(-1, PAGESIZE * (i + 1),
+                           flags=flags, prot=PROT_NONE) as guard:
+                with mmap.mmap(-1, PAGESIZE * (i + 2048),
+                               flags=flags, prot=PROT_READ) as fm:
+                    fm.find(b"fo", -2)
+
 
     def test_rfind(self):
         # test the new 'end' parameter works as expected
--- a/Lib/test/test_opcache.py
+++ b/Lib/test/test_opcache.py
@@ -429,6 +429,35 @@ class TestLoadMethodCache(unittest.TestC
             self.assertFalse(f())
 
 
+class TestCallCache(unittest.TestCase):
+    def test_too_many_defaults_0(self):
+        def f():
+            pass
+
+        f.__defaults__ = (None,)
+        for _ in range(1025):
+            f()
+
+    def test_too_many_defaults_1(self):
+        def f(x):
+            pass
+
+        f.__defaults__ = (None, None)
+        for _ in range(1025):
+            f(None)
+            f()
+
+    def test_too_many_defaults_2(self):
+        def f(x, y):
+            pass
+
+        f.__defaults__ = (None, None, None)
+        for _ in range(1025):
+            f(None, None)
+            f(None)
+            f()
+
+
 if __name__ == "__main__":
     import unittest
     unittest.main()
--- a/Lib/test/test_pydoc.py
+++ b/Lib/test/test_pydoc.py
@@ -24,7 +24,8 @@ from collections import namedtuple
 from urllib.request import urlopen, urlcleanup
 from test.support import import_helper
 from test.support import os_helper
-from test.support.script_helper import assert_python_ok, assert_python_failure
+from test.support.script_helper import (assert_python_ok,
+                                        assert_python_failure, spawn_python)
 from test.support import threading_helper
 from test.support import (reap_children, captured_output, captured_stdout,
                           captured_stderr, is_emscripten, is_wasi,
@@ -631,6 +632,21 @@ class PydocDocTest(unittest.TestCase):
         # Testing that the subclasses section does not appear
         self.assertNotIn('Built-in subclasses', text)
 
+    def test_fail_help_cli(self):
+        elines = (missing_pattern % 'abd').splitlines()
+        with spawn_python("-c" "help()") as proc:
+            out, _ = proc.communicate(b"abd")
+            olines = out.decode().splitlines()[-9:-6]
+            olines[0] = olines[0].removeprefix('help> ')
+            self.assertEqual(elines, olines)
+
+    def test_fail_help_output_redirect(self):
+        with StringIO() as buf:
+            helper = pydoc.Helper(output=buf)
+            helper.help("abd")
+            expected = missing_pattern % "abd"
+            self.assertEqual(expected, buf.getvalue().strip().replace('\n', os.linesep))
+
     @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),
                      'trace function introduces __locals__ unexpectedly')
     @requires_docstrings
--- a/Lib/test/test_re.py
+++ b/Lib/test/test_re.py
@@ -1077,33 +1077,6 @@ class ReTests(unittest.TestCase):
     def test_category(self):
         self.assertEqual(re.match(r"(\s)", " ").group(1), " ")
 
-    @cpython_only
-    def test_case_helpers(self):
-        import _sre
-        for i in range(128):
-            c = chr(i)
-            lo = ord(c.lower())
-            self.assertEqual(_sre.ascii_tolower(i), lo)
-            self.assertEqual(_sre.unicode_tolower(i), lo)
-            iscased = c in string.ascii_letters
-            self.assertEqual(_sre.ascii_iscased(i), iscased)
-            self.assertEqual(_sre.unicode_iscased(i), iscased)
-
-        for i in list(range(128, 0x1000)) + [0x10400, 0x10428]:
-            c = chr(i)
-            self.assertEqual(_sre.ascii_tolower(i), i)
-            if i != 0x0130:
-                self.assertEqual(_sre.unicode_tolower(i), ord(c.lower()))
-            iscased = c != c.lower() or c != c.upper()
-            self.assertFalse(_sre.ascii_iscased(i))
-            self.assertEqual(_sre.unicode_iscased(i),
-                             c != c.lower() or c != c.upper())
-
-        self.assertEqual(_sre.ascii_tolower(0x0130), 0x0130)
-        self.assertEqual(_sre.unicode_tolower(0x0130), ord('i'))
-        self.assertFalse(_sre.ascii_iscased(0x0130))
-        self.assertTrue(_sre.unicode_iscased(0x0130))
-
     def test_not_literal(self):
         self.assertEqual(re.search(r"\s([^a])", " b").group(1), "b")
         self.assertEqual(re.search(r"\s([^a]*)", " bb").group(1), "bb")
@@ -1800,20 +1773,6 @@ class ReTests(unittest.TestCase):
         pat = re.compile(b'..')
         self.assertEqual(pat.sub(lambda m: b'bytes', b'a5'), b'bytes')
 
-    def test_dealloc(self):
-        # issue 3299: check for segfault in debug build
-        import _sre
-        # the overflow limit is different on wide and narrow builds and it
-        # depends on the definition of SRE_CODE (see sre.h).
-        # 2**128 should be big enough to overflow on both. For smaller values
-        # a RuntimeError is raised instead of OverflowError.
-        long_overflow = 2**128
-        self.assertRaises(TypeError, re.finditer, "a", {})
-        with self.assertRaises(OverflowError):
-            _sre.compile("abc", 0, [long_overflow], 0, {}, ())
-        with self.assertRaises(TypeError):
-            _sre.compile({}, 0, [], 0, [], [])
-
     def test_search_dot_unicode(self):
         self.assertTrue(re.search("123.*-", '123abc-'))
         self.assertTrue(re.search("123.*-", '123\xe9-'))
@@ -1871,21 +1830,6 @@ class ReTests(unittest.TestCase):
         self.assertRaises(OverflowError, re.compile, r".{%d,}?" % 2**128)
         self.assertRaises(OverflowError, re.compile, r".{%d,%d}" % (2**129, 2**128))
 
-    @cpython_only
-    def test_repeat_minmax_overflow_maxrepeat(self):
-        try:
-            from _sre import MAXREPEAT
-        except ImportError:
-            self.skipTest('requires _sre.MAXREPEAT constant')
-        string = "x" * 100000
-        self.assertIsNone(re.match(r".{%d}" % (MAXREPEAT - 1), string))
-        self.assertEqual(re.match(r".{,%d}" % (MAXREPEAT - 1), string).span(),
-                         (0, 100000))
-        self.assertIsNone(re.match(r".{%d,}?" % (MAXREPEAT - 1), string))
-        self.assertRaises(OverflowError, re.compile, r".{%d}" % MAXREPEAT)
-        self.assertRaises(OverflowError, re.compile, r".{,%d}" % MAXREPEAT)
-        self.assertRaises(OverflowError, re.compile, r".{%d,}?" % MAXREPEAT)
-
     def test_backref_group_name_in_exception(self):
         # Issue 17341: Poor error message when compiling invalid regex
         self.checkPatternError('(?P=<foo>)',
@@ -2452,6 +2396,16 @@ class ReTests(unittest.TestCase):
         self.assertTrue(template_re1.match('ahoy'))
         self.assertFalse(template_re1.match('nope'))
 
+    def test_bug_gh106052(self):
+        self.assertEqual(re.match("(?>(?:ab?c)+)", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?:ab?c)++", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?>(?:ab?c)*)", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?:ab?c)*+", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?>(?:ab?c)?)", "a").span(), (0, 0))
+        self.assertEqual(re.match("(?:ab?c)?+", "a").span(), (0, 0))
+        self.assertEqual(re.match("(?>(?:ab?c){1,3})", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?:ab?c){1,3}+", "aca").span(), (0, 2))
+
     @unittest.skipIf(multiprocessing is None, 'test requires multiprocessing')
     def test_regression_gh94675(self):
         pattern = re.compile(r'(?<=[({}])(((//[^\n]*)?[\n])([\000-\040])*)*'
@@ -2533,7 +2487,10 @@ ELSE
 
     def test_atomic_group(self):
         self.assertEqual(get_debug_out(r'(?>ab?)'), '''\
-ATOMIC_GROUP [(LITERAL, 97), (MAX_REPEAT, (0, 1, [(LITERAL, 98)]))]
+ATOMIC_GROUP
+  LITERAL 97
+  MAX_REPEAT 0 1
+    LITERAL 98
 
  0. INFO 4 0b0 1 2 (to 5)
  5: ATOMIC_GROUP 11 (to 17)
@@ -2545,6 +2502,7 @@ ATOMIC_GROUP [(LITERAL, 97), (MAX_REPEAT
 17: SUCCESS
 ''')
 
+    @unittest.expectedFailure  # gh-106052
     def test_possesive_repeat_one(self):
         self.assertEqual(get_debug_out(r'a?+'), '''\
 POSSESSIVE_REPEAT 0 1
@@ -2557,6 +2515,7 @@ POSSESSIVE_REPEAT 0 1
 12: SUCCESS
 ''')
 
+    @unittest.expectedFailure  # gh-106052
     def test_possesive_repeat(self):
         self.assertEqual(get_debug_out(r'(?:ab)?+'), '''\
 POSSESSIVE_REPEAT 0 1
@@ -2717,6 +2676,64 @@ class ImplementationTest(unittest.TestCa
                     self.assertTrue(hasattr(mod, attr))
                 del sys.modules[name]
 
+    @cpython_only
+    def test_case_helpers(self):
+        import _sre
+        for i in range(128):
+            c = chr(i)
+            lo = ord(c.lower())
+            self.assertEqual(_sre.ascii_tolower(i), lo)
+            self.assertEqual(_sre.unicode_tolower(i), lo)
+            iscased = c in string.ascii_letters
+            self.assertEqual(_sre.ascii_iscased(i), iscased)
+            self.assertEqual(_sre.unicode_iscased(i), iscased)
+
+        for i in list(range(128, 0x1000)) + [0x10400, 0x10428]:
+            c = chr(i)
+            self.assertEqual(_sre.ascii_tolower(i), i)
+            if i != 0x0130:
+                self.assertEqual(_sre.unicode_tolower(i), ord(c.lower()))
+            iscased = c != c.lower() or c != c.upper()
+            self.assertFalse(_sre.ascii_iscased(i))
+            self.assertEqual(_sre.unicode_iscased(i),
+                             c != c.lower() or c != c.upper())
+
+        self.assertEqual(_sre.ascii_tolower(0x0130), 0x0130)
+        self.assertEqual(_sre.unicode_tolower(0x0130), ord('i'))
+        self.assertFalse(_sre.ascii_iscased(0x0130))
+        self.assertTrue(_sre.unicode_iscased(0x0130))
+
+    @cpython_only
+    def test_dealloc(self):
+        # issue 3299: check for segfault in debug build
+        import _sre
+        # the overflow limit is different on wide and narrow builds and it
+        # depends on the definition of SRE_CODE (see sre.h).
+        # 2**128 should be big enough to overflow on both. For smaller values
+        # a RuntimeError is raised instead of OverflowError.
+        long_overflow = 2**128
+        self.assertRaises(TypeError, re.finditer, "a", {})
+        with self.assertRaises(OverflowError):
+            _sre.compile("abc", 0, [long_overflow], 0, {}, ())
+        with self.assertRaises(TypeError):
+            _sre.compile({}, 0, [], 0, [], [])
+
+    @cpython_only
+    def test_repeat_minmax_overflow_maxrepeat(self):
+        try:
+            from _sre import MAXREPEAT
+        except ImportError:
+            self.skipTest('requires _sre.MAXREPEAT constant')
+        string = "x" * 100000
+        self.assertIsNone(re.match(r".{%d}" % (MAXREPEAT - 1), string))
+        self.assertEqual(re.match(r".{,%d}" % (MAXREPEAT - 1), string).span(),
+                         (0, 100000))
+        self.assertIsNone(re.match(r".{%d,}?" % (MAXREPEAT - 1), string))
+        self.assertRaises(OverflowError, re.compile, r".{%d}" % MAXREPEAT)
+        self.assertRaises(OverflowError, re.compile, r".{,%d}" % MAXREPEAT)
+        self.assertRaises(OverflowError, re.compile, r".{%d,}?" % MAXREPEAT)
+
+
 class ExternalTests(unittest.TestCase):
 
     def test_re_benchmarks(self):
--- a/Lib/test/test_regrtest.py
+++ b/Lib/test/test_regrtest.py
@@ -7,6 +7,7 @@ Note: test_regrtest cannot be run twice
 import contextlib
 import glob
 import io
+import locale
 import os.path
 import platform
 import re
@@ -1518,6 +1519,41 @@ class ArgsTestCase(BaseTestCase):
         for name in names:
             self.assertFalse(os.path.exists(name), name)
 
+    def test_mp_decode_error(self):
+        # gh-101634: If a worker stdout cannot be decoded, report a failed test
+        # and a non-zero exit code.
+        if sys.platform == 'win32':
+            encoding = locale.getencoding()
+        else:
+            encoding = sys.stdout.encoding
+            if encoding is None:
+                encoding = sys.__stdout__.encoding
+                if encoding is None:
+                    self.skipTest(f"cannot get regrtest worker encoding")
+
+        nonascii = b"byte:\xa0\xa9\xff\n"
+        try:
+            nonascii.decode(encoding)
+        except UnicodeDecodeError:
+            pass
+        else:
+            self.skipTest(f"{encoding} can decode non-ASCII bytes {nonascii!a}")
+
+        code = textwrap.dedent(fr"""
+            import sys
+            # bytes which cannot be decoded from UTF-8
+            nonascii = {nonascii!a}
+            sys.stdout.buffer.write(nonascii)
+            sys.stdout.buffer.flush()
+        """)
+        testname = self.create_test(code=code)
+
+        output = self.run_tests("--fail-env-changed", "-v", "-j1", testname,
+                                exitcode=EXITCODE_BAD_TEST)
+        self.check_executed_tests(output, [testname],
+                                  failed=[testname],
+                                  randomize=True)
+
 
 class TestUtils(unittest.TestCase):
     def test_format_duration(self):
--- a/Lib/test/test_shutil.py
+++ b/Lib/test/test_shutil.py
@@ -2451,7 +2451,7 @@ class _ZeroCopyFileTest(object):
     def test_same_file(self):
         self.addCleanup(self.reset)
         with self.get_files() as (src, dst):
-            with self.assertRaises(Exception):
+            with self.assertRaises((OSError, _GiveupOnFastCopy)):
                 self.zerocopy_fun(src, src)
         # Make sure src file is not corrupted.
         self.assertEqual(read_file(TESTFN, binary=True), self.FILEDATA)
--- a/Lib/test/test_sqlite3/test_userfunctions.py
+++ b/Lib/test/test_sqlite3/test_userfunctions.py
@@ -195,7 +195,6 @@ class FunctionTests(unittest.TestCase):
         self.con.create_function("returnblob", 0, func_returnblob)
         self.con.create_function("returnlonglong", 0, func_returnlonglong)
         self.con.create_function("returnnan", 0, lambda: float("nan"))
-        self.con.create_function("returntoolargeint", 0, lambda: 1 << 65)
         self.con.create_function("return_noncont_blob", 0,
                                  lambda: memoryview(b"blob")[::2])
         self.con.create_function("raiseexception", 0, func_raiseexception)
@@ -294,11 +293,6 @@ class FunctionTests(unittest.TestCase):
         cur.execute("select returnnan()")
         self.assertIsNone(cur.fetchone()[0])
 
-    def test_func_return_too_large_int(self):
-        cur = self.con.cursor()
-        self.assertRaisesRegex(sqlite.DataError, "string or blob too big",
-                               self.con.execute, "select returntoolargeint()")
-
     @with_tracebacks(ZeroDivisionError, name="func_raiseexception")
     def test_func_exception(self):
         cur = self.con.cursor()
@@ -444,9 +438,10 @@ class FunctionTests(unittest.TestCase):
     @with_tracebacks(OverflowError)
     def test_func_return_too_large_int(self):
         cur = self.con.cursor()
+        msg = "string or blob too big"
         for value in 2**63, -2**63-1, 2**64:
             self.con.create_function("largeint", 0, lambda value=value: value)
-            with self.assertRaises(sqlite.DataError):
+            with self.assertRaisesRegex(sqlite.DataError, msg):
                 cur.execute("select largeint()")
 
     @with_tracebacks(UnicodeEncodeError, "surrogates not allowed", "chr")
--- a/Lib/test/test_subprocess.py
+++ b/Lib/test/test_subprocess.py
@@ -1690,6 +1690,14 @@ class RunFuncTestCase(BaseTestCase):
         res = subprocess.run(args)
         self.assertEqual(res.returncode, 57)
 
+    @unittest.skipUnless(mswindows, "Maybe test trigger a leak on Ubuntu")
+    def test_run_with_an_empty_env(self):
+        # gh-105436: fix subprocess.run(..., env={}) broken on Windows
+        args = [sys.executable, "-c", 'pass']
+        # Ignore subprocess errors - we only care that the API doesn't
+        # raise an OSError
+        subprocess.run(args, env={})
+
     def test_capture_output(self):
         cp = self.run_python(("import sys;"
                               "sys.stdout.write('BDFL'); "
--- a/Lib/test/test_tcl.py
+++ b/Lib/test/test_tcl.py
@@ -23,14 +23,6 @@ except ImportError:
 
 tcl_version = tuple(map(int, _tkinter.TCL_VERSION.split('.')))
 
-_tk_patchlevel = None
-def get_tk_patchlevel():
-    global _tk_patchlevel
-    if _tk_patchlevel is None:
-        tcl = Tcl()
-        _tk_patchlevel = tcl.info_patchlevel()
-    return _tk_patchlevel
-
 
 class TkinterTest(unittest.TestCase):
 
@@ -574,7 +566,6 @@ class TclTest(unittest.TestCase):
                 (1, '2', (3.4,)) if self.wantobjects else
                 ('1', '2', '3.4')),
         ]
-        tk_patchlevel = get_tk_patchlevel()
         if not self.wantobjects:
             expected = ('12', '\u20ac', '\xe2\x82\xac', '3.4')
         else:
@@ -583,8 +574,8 @@ class TclTest(unittest.TestCase):
             (call('dict', 'create', 12, '\u20ac', b'\xe2\x82\xac', (3.4,)),
                 expected),
         ]
-        dbg_info = ('want objects? %s, Tcl version: %s, Tk patchlevel: %s'
-                    % (self.wantobjects, tcl_version, tk_patchlevel))
+        dbg_info = ('want objects? %s, Tcl version: %s, Tcl patchlevel: %s'
+                    % (self.wantobjects, tcl_version, self.interp.info_patchlevel()))
         for arg, res in testcases:
             self.assertEqual(splitlist(arg), res,
                              'arg=%a, %s' % (arg, dbg_info))
--- a/Lib/test/test_types.py
+++ b/Lib/test/test_types.py
@@ -226,8 +226,8 @@ class TypesTests(unittest.TestCase):
     def test_int__format__(self):
         def test(i, format_spec, result):
             # just make sure we have the unified type for integers
-            assert type(i) == int
-            assert type(format_spec) == str
+            self.assertIs(type(i), int)
+            self.assertIs(type(format_spec), str)
             self.assertEqual(i.__format__(format_spec), result)
 
         test(123456789, 'd', '123456789')
@@ -782,8 +782,8 @@ class UnionTests(unittest.TestCase):
 
     def test_or_type_operator_with_TypeVar(self):
         TV = typing.TypeVar('T')
-        assert TV | str == typing.Union[TV, str]
-        assert str | TV == typing.Union[str, TV]
+        self.assertEqual(TV | str, typing.Union[TV, str])
+        self.assertEqual(str | TV, typing.Union[str, TV])
         self.assertIs((int | TV)[int], int)
         self.assertIs((TV | int)[int], int)
 
@@ -887,43 +887,45 @@ class UnionTests(unittest.TestCase):
         ForwardBefore = 'Forward' | T
         def forward_after(x: ForwardAfter[int]) -> None: ...
         def forward_before(x: ForwardBefore[int]) -> None: ...
-        assert typing.get_args(typing.get_type_hints(forward_after)['x']) == (int, Forward)
-        assert typing.get_args(typing.get_type_hints(forward_before)['x']) == (int, Forward)
+        self.assertEqual(typing.get_args(typing.get_type_hints(forward_after)['x']),
+                         (int, Forward))
+        self.assertEqual(typing.get_args(typing.get_type_hints(forward_before)['x']),
+                         (int, Forward))
 
     def test_or_type_operator_with_Protocol(self):
         class Proto(typing.Protocol):
             def meth(self) -> int:
                 ...
-        assert Proto | str == typing.Union[Proto, str]
+        self.assertEqual(Proto | str, typing.Union[Proto, str])
 
     def test_or_type_operator_with_Alias(self):
-        assert list | str == typing.Union[list, str]
-        assert typing.List | str == typing.Union[typing.List, str]
+        self.assertEqual(list | str, typing.Union[list, str])
+        self.assertEqual(typing.List | str, typing.Union[typing.List, str])
 
     def test_or_type_operator_with_NamedTuple(self):
-        NT=namedtuple('A', ['B', 'C', 'D'])
-        assert NT | str == typing.Union[NT,str]
+        NT = namedtuple('A', ['B', 'C', 'D'])
+        self.assertEqual(NT | str, typing.Union[NT, str])
 
     def test_or_type_operator_with_TypedDict(self):
         class Point2D(typing.TypedDict):
             x: int
             y: int
             label: str
-        assert Point2D | str == typing.Union[Point2D, str]
+        self.assertEqual(Point2D | str, typing.Union[Point2D, str])
 
     def test_or_type_operator_with_NewType(self):
         UserId = typing.NewType('UserId', int)
-        assert UserId | str == typing.Union[UserId, str]
+        self.assertEqual(UserId | str, typing.Union[UserId, str])
 
     def test_or_type_operator_with_IO(self):
-        assert typing.IO | str == typing.Union[typing.IO, str]
+        self.assertEqual(typing.IO | str, typing.Union[typing.IO, str])
 
     def test_or_type_operator_with_SpecialForm(self):
-        assert typing.Any | str == typing.Union[typing.Any, str]
-        assert typing.NoReturn | str == typing.Union[typing.NoReturn, str]
-        assert typing.Optional[int] | str == typing.Union[typing.Optional[int], str]
-        assert typing.Optional[int] | str == typing.Union[int, str, None]
-        assert typing.Union[int, bool] | str == typing.Union[int, bool, str]
+        self.assertEqual(typing.Any | str, typing.Union[typing.Any, str])
+        self.assertEqual(typing.NoReturn | str, typing.Union[typing.NoReturn, str])
+        self.assertEqual(typing.Optional[int] | str, typing.Union[typing.Optional[int], str])
+        self.assertEqual(typing.Optional[int] | str, typing.Union[int, str, None])
+        self.assertEqual(typing.Union[int, bool] | str, typing.Union[int, bool, str])
 
     def test_or_type_operator_with_Literal(self):
         Literal = typing.Literal
@@ -955,12 +957,12 @@ class UnionTests(unittest.TestCase):
                          (Literal[1], Literal[Ints.B]))
 
     def test_or_type_repr(self):
-        assert repr(int | str) == "int | str"
-        assert repr((int | str) | list) == "int | str | list"
-        assert repr(int | (str | list)) == "int | str | list"
-        assert repr(int | None) == "int | None"
-        assert repr(int | type(None)) == "int | None"
-        assert repr(int | typing.GenericAlias(list, int)) == "int | list[int]"
+        self.assertEqual(repr(int | str), "int | str")
+        self.assertEqual(repr((int | str) | list), "int | str | list")
+        self.assertEqual(repr(int | (str | list)), "int | str | list")
+        self.assertEqual(repr(int | None), "int | None")
+        self.assertEqual(repr(int | type(None)), "int | None")
+        self.assertEqual(repr(int | typing.GenericAlias(list, int)), "int | list[int]")
 
     def test_or_type_operator_with_genericalias(self):
         a = list[int]
--- a/Lib/test/test_typing.py
+++ b/Lib/test/test_typing.py
@@ -4,6 +4,7 @@ from collections import defaultdict
 from functools import lru_cache, wraps
 import inspect
 import itertools
+import gc
 import pickle
 import re
 import sys
@@ -2643,6 +2644,104 @@ class ProtocolTests(BaseTestCase):
         with self.assertRaises(TypeError):
             issubclass(PG, PG[int])
 
+        only_classes_allowed = r"issubclass\(\) arg 1 must be a class"
+
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, P)
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, PG)
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, BadP)
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, BadPG)
+
+    def test_implicit_issubclass_between_two_protocols(self):
+        @runtime_checkable
+        class CallableMembersProto(Protocol):
+            def meth(self): ...
+
+        # All the below protocols should be considered "subclasses"
+        # of CallableMembersProto at runtime,
+        # even though none of them explicitly subclass CallableMembersProto
+
+        class IdenticalProto(Protocol):
+            def meth(self): ...
+
+        class SupersetProto(Protocol):
+            def meth(self): ...
+            def meth2(self): ...
+
+        class NonCallableMembersProto(Protocol):
+            meth: Callable[[], None]
+
+        class NonCallableMembersSupersetProto(Protocol):
+            meth: Callable[[], None]
+            meth2: Callable[[str, int], bool]
+
+        class MixedMembersProto1(Protocol):
+            meth: Callable[[], None]
+            def meth2(self): ...
+
+        class MixedMembersProto2(Protocol):
+            def meth(self): ...
+            meth2: Callable[[str, int], bool]
+
+        for proto in (
+            IdenticalProto, SupersetProto, NonCallableMembersProto,
+            NonCallableMembersSupersetProto, MixedMembersProto1, MixedMembersProto2
+        ):
+            with self.subTest(proto=proto.__name__):
+                self.assertIsSubclass(proto, CallableMembersProto)
+
+        # These two shouldn't be considered subclasses of CallableMembersProto, however,
+        # since they don't have the `meth` protocol member
+
+        class EmptyProtocol(Protocol): ...
+        class UnrelatedProtocol(Protocol):
+            def wut(self): ...
+
+        self.assertNotIsSubclass(EmptyProtocol, CallableMembersProto)
+        self.assertNotIsSubclass(UnrelatedProtocol, CallableMembersProto)
+
+        # These aren't protocols at all (despite having annotations),
+        # so they should only be considered subclasses of CallableMembersProto
+        # if they *actually have an attribute* matching the `meth` member
+        # (just having an annotation is insufficient)
+
+        class AnnotatedButNotAProtocol:
+            meth: Callable[[], None]
+
+        class NotAProtocolButAnImplicitSubclass:
+            def meth(self): pass
+
+        class NotAProtocolButAnImplicitSubclass2:
+            meth: Callable[[], None]
+            def meth(self): pass
+
+        class NotAProtocolButAnImplicitSubclass3:
+            meth: Callable[[], None]
+            meth2: Callable[[int, str], bool]
+            def meth(self): pass
+            def meth(self, x, y): return True
+
+        self.assertNotIsSubclass(AnnotatedButNotAProtocol, CallableMembersProto)
+        self.assertIsSubclass(NotAProtocolButAnImplicitSubclass, CallableMembersProto)
+        self.assertIsSubclass(NotAProtocolButAnImplicitSubclass2, CallableMembersProto)
+        self.assertIsSubclass(NotAProtocolButAnImplicitSubclass3, CallableMembersProto)
+
+    def test_isinstance_checks_not_at_whim_of_gc(self):
+        self.addCleanup(gc.enable)
+        gc.disable()
+
+        with self.assertRaisesRegex(
+            TypeError,
+            "Protocols can only inherit from other protocols"
+        ):
+            class Foo(collections.abc.Mapping, Protocol):
+                pass
+
+        self.assertNotIsInstance([], collections.abc.Mapping)
+
     def test_protocols_issubclass_non_callable(self):
         class C:
             x = 1
@@ -3349,6 +3448,71 @@ class ProtocolTests(BaseTestCase):
 
         Foo()  # Previously triggered RecursionError
 
+    def test_empty_protocol_decorated_with_final(self):
+        @final
+        @runtime_checkable
+        class EmptyProtocol(Protocol): ...
+
+        self.assertIsSubclass(object, EmptyProtocol)
+        self.assertIsInstance(object(), EmptyProtocol)
+
+    def test_protocol_decorated_with_final_callable_members(self):
+        @final
+        @runtime_checkable
+        class ProtocolWithMethod(Protocol):
+            def startswith(self, string: str) -> bool: ...
+
+        self.assertIsSubclass(str, ProtocolWithMethod)
+        self.assertNotIsSubclass(int, ProtocolWithMethod)
+        self.assertIsInstance('foo', ProtocolWithMethod)
+        self.assertNotIsInstance(42, ProtocolWithMethod)
+
+    def test_protocol_decorated_with_final_noncallable_members(self):
+        @final
+        @runtime_checkable
+        class ProtocolWithNonCallableMember(Protocol):
+            x: int
+
+        class Foo:
+            x = 42
+
+        only_callable_members_please = (
+            r"Protocols with non-method members don't support issubclass()"
+        )
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(Foo, ProtocolWithNonCallableMember)
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(int, ProtocolWithNonCallableMember)
+
+        self.assertIsInstance(Foo(), ProtocolWithNonCallableMember)
+        self.assertNotIsInstance(42, ProtocolWithNonCallableMember)
+
+    def test_protocol_decorated_with_final_mixed_members(self):
+        @final
+        @runtime_checkable
+        class ProtocolWithMixedMembers(Protocol):
+            x: int
+            def method(self) -> None: ...
+
+        class Foo:
+            x = 42
+            def method(self) -> None: ...
+
+        only_callable_members_please = (
+            r"Protocols with non-method members don't support issubclass()"
+        )
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(Foo, ProtocolWithMixedMembers)
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(int, ProtocolWithMixedMembers)
+
+        self.assertIsInstance(Foo(), ProtocolWithMixedMembers)
+        self.assertNotIsInstance(42, ProtocolWithMixedMembers)
+
 
 class GenericTests(BaseTestCase):
 
--- a/Lib/test/test_warnings/__init__.py
+++ b/Lib/test/test_warnings/__init__.py
@@ -388,9 +388,13 @@ class FilterTests(BaseTest):
             with self.module.catch_warnings(
                 module=self.module, action="error", category=FutureWarning
             ):
-                self.module.warn("Other types of warnings are not errors")
-                self.assertRaises(FutureWarning,
-                                  self.module.warn, FutureWarning("msg"))
+                with support.captured_stderr() as stderr:
+                    error_msg = "Other types of warnings are not errors"
+                    self.module.warn(error_msg)
+                    self.assertRaises(FutureWarning,
+                                      self.module.warn, FutureWarning("msg"))
+                    stderr = stderr.getvalue()
+                    self.assertIn(error_msg, stderr)
 
 class CFilterTests(FilterTests, unittest.TestCase):
     module = c_warnings
--- a/Lib/test/test_zipfile.py
+++ b/Lib/test/test_zipfile.py
@@ -3444,6 +3444,13 @@ with zipfile.ZipFile(io.BytesIO(), "w")
         assert e.suffixes == []
 
     @pass_alpharep
+    def test_suffix_no_filename(self, alpharep):
+        alpharep.filename = None
+        root = zipfile.Path(alpharep)
+        assert root.joinpath('example').suffix == ""
+        assert root.joinpath('example').suffixes == []
+
+    @pass_alpharep
     def test_stem(self, alpharep):
         """
         The final path component, without its suffix
@@ -3460,6 +3467,8 @@ with zipfile.ZipFile(io.BytesIO(), "w")
         d = root / "d"
         assert d.stem == "d"
 
+        assert (root / ".gitignore").stem == ".gitignore"
+
     @pass_alpharep
     def test_root_parent(self, alpharep):
         root = zipfile.Path(alpharep)
--- a/Lib/tkinter/test/support.py
+++ b/Lib/tkinter/test/support.py
@@ -80,28 +80,28 @@ def simulate_mouse_click(widget, x, y):
 
 import _tkinter
 tcl_version = tuple(map(int, _tkinter.TCL_VERSION.split('.')))
+tk_version = tuple(map(int, _tkinter.TK_VERSION.split('.')))
 
-def requires_tcl(*version):
-    if len(version) <= 2:
-        return unittest.skipUnless(tcl_version >= version,
-            'requires Tcl version >= ' + '.'.join(map(str, version)))
+def requires_tk(*version):
+    if len(version) <= 2 and tk_version >= version:
+        return lambda test: test
 
     def deco(test):
         @functools.wraps(test)
         def newtest(self):
-            if get_tk_patchlevel() < version:
-                self.skipTest('requires Tcl version >= ' +
+            root = getattr(self, 'root', None)
+            if get_tk_patchlevel(root) < version:
+                self.skipTest('requires Tk version >= ' +
                                 '.'.join(map(str, version)))
             test(self)
         return newtest
     return deco
 
 _tk_patchlevel = None
-def get_tk_patchlevel():
+def get_tk_patchlevel(root):
     global _tk_patchlevel
     if _tk_patchlevel is None:
-        tcl = tkinter.Tcl()
-        _tk_patchlevel = tcl.info_patchlevel()
+        _tk_patchlevel = tkinter._parse_version(root.tk.globalgetvar('tk_patchLevel'))
     return _tk_patchlevel
 
 units = {
--- a/Lib/tkinter/test/test_tkinter/test_images.py
+++ b/Lib/tkinter/test/test_tkinter/test_images.py
@@ -2,7 +2,7 @@ import unittest
 import tkinter
 from test import support
 from test.support import os_helper
-from tkinter.test.support import AbstractTkTest, AbstractDefaultRootTest, requires_tcl
+from tkinter.test.support import AbstractTkTest, AbstractDefaultRootTest, requires_tk
 
 support.requires('gui')
 
@@ -213,11 +213,11 @@ class PhotoImageTest(AbstractTkTest, uni
     def test_create_from_gif_data(self):
         self.check_create_from_data('gif')
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_create_from_png_file(self):
         self.check_create_from_file('png')
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_create_from_png_data(self):
         self.check_create_from_data('png')
 
--- a/Lib/tkinter/test/test_tkinter/test_widgets.py
+++ b/Lib/tkinter/test/test_tkinter/test_widgets.py
@@ -4,7 +4,7 @@ from tkinter import TclError
 import os
 from test.support import requires
 
-from tkinter.test.support import (requires_tcl,
+from tkinter.test.support import (requires_tk,
                                   get_tk_patchlevel, widget_eq,
                                   AbstractDefaultRootTest)
 from tkinter.test.widget_tests import (
@@ -614,7 +614,7 @@ class TextTest(AbstractWidgetTest, unitt
         widget = self.create()
         self.checkColorParam(widget, 'inactiveselectbackground')
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_configure_insertunfocussed(self):
         widget = self.create()
         self.checkEnumParam(widget, 'insertunfocussed',
@@ -919,7 +919,7 @@ class CanvasTest(AbstractWidgetTest, uni
         for i in range(4):
             self.assertIsInstance(coords[i], float)
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_moveto(self):
         widget = self.create()
         i1 = widget.create_rectangle(1, 1, 20, 20, tags='group')
@@ -964,7 +964,7 @@ class ListboxTest(AbstractWidgetTest, un
         self.checkEnumParam(widget, 'activestyle',
                             'dotbox', 'none', 'underline')
 
-    test_configure_justify = requires_tcl(8, 6, 5)(StandardOptionsTests.test_configure_justify)
+    test_configure_justify = requires_tk(8, 6, 5)(StandardOptionsTests.test_configure_justify)
 
     def test_configure_listvariable(self):
         widget = self.create()
@@ -1103,7 +1103,7 @@ class ScaleTest(AbstractWidgetTest, unit
 
     def test_configure_from(self):
         widget = self.create()
-        conv = float if get_tk_patchlevel() >= (8, 6, 10) else float_round
+        conv = float if get_tk_patchlevel(self.root) >= (8, 6, 10) else float_round
         self.checkFloatParam(widget, 'from', 100, 14.9, 15.1, conv=conv)
 
     def test_configure_label(self):
@@ -1230,19 +1230,19 @@ class PanedWindowTest(AbstractWidgetTest
         widget = self.create()
         self.checkBooleanParam(widget, 'opaqueresize')
 
-    @requires_tcl(8, 6, 5)
+    @requires_tk(8, 6, 5)
     def test_configure_proxybackground(self):
         widget = self.create()
         self.checkColorParam(widget, 'proxybackground')
 
-    @requires_tcl(8, 6, 5)
+    @requires_tk(8, 6, 5)
     def test_configure_proxyborderwidth(self):
         widget = self.create()
         self.checkPixelsParam(widget, 'proxyborderwidth',
                               0, 1.3, 2.9, 6, -2, '10p',
                               conv=False)
 
-    @requires_tcl(8, 6, 5)
+    @requires_tk(8, 6, 5)
     def test_configure_proxyrelief(self):
         widget = self.create()
         self.checkReliefParam(widget, 'proxyrelief')
--- a/Lib/tkinter/test/test_ttk/test_style.py
+++ b/Lib/tkinter/test/test_ttk/test_style.py
@@ -170,7 +170,7 @@ class StyleTest(AbstractTkTest, unittest
                     newname = f'C.{name}'
                     self.assertEqual(style.map(newname), {})
                     style.map(newname, **default)
-                    if theme == 'alt' and name == '.' and get_tk_patchlevel() < (8, 6, 1):
+                    if theme == 'alt' and name == '.' and get_tk_patchlevel(self.root) < (8, 6, 1):
                         default['embossed'] = [('disabled', '1')]
                     self.assertEqual(style.map(newname), default)
                     for key, value in default.items():
--- a/Lib/tkinter/test/test_ttk/test_widgets.py
+++ b/Lib/tkinter/test/test_ttk/test_widgets.py
@@ -5,7 +5,7 @@ from test.support import requires, gc_co
 import sys
 
 from test.test_ttk_textonly import MockTclObj
-from tkinter.test.support import (AbstractTkTest, tcl_version, get_tk_patchlevel,
+from tkinter.test.support import (AbstractTkTest, tk_version, get_tk_patchlevel,
                                   simulate_mouse_click, AbstractDefaultRootTest)
 from tkinter.test.widget_tests import (add_standard_options,
     AbstractWidgetTest, StandardOptionsTests, IntegerSizeTests, PixelSizeTests,
@@ -20,7 +20,7 @@ class StandardTtkOptionsTests(StandardOp
         widget = self.create()
         self.assertEqual(widget['class'], '')
         errmsg='attempt to change read-only option'
-        if get_tk_patchlevel() < (8, 6, 0, 'beta', 3):
+        if get_tk_patchlevel(self.root) < (8, 6, 0, 'beta', 3):
             errmsg='Attempt to change read-only option'
         self.checkInvalidParam(widget, 'class', 'Foo', errmsg=errmsg)
         widget2 = self.create(class_='Foo')
@@ -562,7 +562,7 @@ class PanedWindowTest(AbstractWidgetTest
         widget = self.create()
         self.assertEqual(str(widget['orient']), 'vertical')
         errmsg='attempt to change read-only option'
-        if get_tk_patchlevel() < (8, 6, 0, 'beta', 3):
+        if get_tk_patchlevel(self.root) < (8, 6, 0, 'beta', 3):
             errmsg='Attempt to change read-only option'
         self.checkInvalidParam(widget, 'orient', 'horizontal',
                 errmsg=errmsg)
@@ -1528,7 +1528,7 @@ class TreeviewTest(AbstractWidgetTest, u
 
     def test_heading_callback(self):
         def simulate_heading_click(x, y):
-            if tcl_version >= (8, 6):
+            if tk_version >= (8, 6):
                 self.assertEqual(self.tv.identify_column(x), '#0')
                 self.assertEqual(self.tv.identify_region(x, y), 'heading')
             simulate_mouse_click(self.tv, x, y)
--- a/Lib/tkinter/test/widget_tests.py
+++ b/Lib/tkinter/test/widget_tests.py
@@ -2,7 +2,7 @@
 
 import unittest
 import tkinter
-from tkinter.test.support import (AbstractTkTest, tcl_version,
+from tkinter.test.support import (AbstractTkTest, tk_version,
                                   pixels_conv, tcl_obj_eq)
 import test.support
 
@@ -23,7 +23,7 @@ class AbstractWidgetTest(AbstractTkTest)
             return self._scaling
 
     def _str(self, value):
-        if not self._stringify and self.wantobjects and tcl_version >= (8, 6):
+        if not self._stringify and self.wantobjects and tk_version >= (8, 6):
             return value
         if isinstance(value, tuple):
             return ' '.join(map(self._str, value))
@@ -157,7 +157,7 @@ class AbstractWidgetTest(AbstractTkTest)
                          'flat', 'groove', 'raised', 'ridge', 'solid', 'sunken')
         errmsg='bad relief "spam": must be '\
                'flat, groove, raised, ridge, solid, or sunken'
-        if tcl_version < (8, 6):
+        if tk_version < (8, 6):
             errmsg = None
         self.checkInvalidParam(widget, name, 'spam',
                 errmsg=errmsg)
--- a/Lib/typing.py
+++ b/Lib/typing.py
@@ -1,9 +1,6 @@
 """
 The typing module: Support for gradual typing as defined by PEP 484 and subsequent PEPs.
 
-Any name not present in __all__ is an implementation detail
-that may be changed without notice. Use at your own risk!
-
 Among other things, the module includes the following:
 * Generic, Protocol, and internal machinery to support generic aliases.
   All subscripted types like X[int], Union[int, str] are generic aliases.
@@ -17,6 +14,9 @@ Among other things, the module includes
 * Special types: NewType, NamedTuple, TypedDict.
 * Deprecated wrapper submodules for re and io related types.
 * Deprecated aliases for builtin types and collections.abc ABCs.
+
+Any name not present in __all__ is an implementation detail
+that may be changed without notice. Use at your own risk!
 """
 
 from abc import abstractmethod, ABCMeta
@@ -207,10 +207,12 @@ def _should_unflatten_callable_args(typ,
     """Internal helper for munging collections.abc.Callable's __args__.
 
     The canonical representation for a Callable's __args__ flattens the
-    argument types, see https://bugs.python.org/issue42195. For example::
+    argument types, see https://github.com/python/cpython/issues/86361.
 
-        collections.abc.Callable[[int, int], str].__args__ == (int, int, str)
-        collections.abc.Callable[ParamSpec, str].__args__ == (ParamSpec, str)
+    For example::
+
+        assert collections.abc.Callable[[int, int], str].__args__ == (int, int, str)
+        assert collections.abc.Callable[ParamSpec, str].__args__ == (ParamSpec, str)
 
     As a result, if we need to reconstruct the Callable from its __args__,
     we need to unflatten it.
@@ -339,8 +341,9 @@ _cleanups = []
 
 
 def _tp_cache(func=None, /, *, typed=False):
-    """Internal wrapper caching __getitem__ of generic types with a fallback to
-    original function for non-hashable arguments.
+    """Internal wrapper caching __getitem__ of generic types.
+
+    For non-hashable arguments, the original function is used as a fallback.
     """
     def decorator(func):
         cached = functools.lru_cache(typed=typed)(func)
@@ -556,7 +559,7 @@ def Never(self, parameters):
                 case str():
                     print("It's a str")
                 case _:
-                    never_call_me(arg)  # ok, arg is of type Never
+                    never_call_me(arg)  # OK, arg is of type Never
     """
     raise TypeError(f"{self} is not subscriptable")
 
@@ -589,13 +592,13 @@ def LiteralString(self, parameters):
 
         from typing import LiteralString
 
-        def run_query(sql: LiteralString) -> ...
+        def run_query(sql: LiteralString) -> None:
             ...
 
         def caller(arbitrary_string: str, literal_string: LiteralString) -> None:
-            run_query("SELECT * FROM students")  # ok
-            run_query(literal_string)  # ok
-            run_query("SELECT * FROM " + literal_string)  # ok
+            run_query("SELECT * FROM students")  # OK
+            run_query(literal_string)  # OK
+            run_query("SELECT * FROM " + literal_string)  # OK
             run_query(arbitrary_string)  # type checker error
             run_query(  # type checker error
                 f"SELECT * FROM students WHERE name = {arbitrary_string}"
@@ -614,10 +617,12 @@ def ClassVar(self, parameters):
 
     An annotation wrapped in ClassVar indicates that a given
     attribute is intended to be used as a class variable and
-    should not be set on instances of that class. Usage::
+    should not be set on instances of that class.
+
+    Usage::
 
         class Starship:
-            stats: ClassVar[Dict[str, int]] = {} # class variable
+            stats: ClassVar[dict[str, int]] = {} # class variable
             damage: int = 10                     # instance variable
 
     ClassVar accepts only types and cannot be further subscribed.
@@ -741,7 +746,9 @@ def TypeAlias(self, parameters):
 
     Use TypeAlias to indicate that an assignment should
     be recognized as a proper type alias definition by type
-    checkers. For example::
+    checkers.
+
+    For example::
 
         Predicate: TypeAlias = Callable[..., bool]
 
@@ -754,8 +761,8 @@ def TypeAlias(self, parameters):
 def Concatenate(self, parameters):
     """Special form for annotating higher-order functions.
 
-    ``Concatenate`` can be sed in conjunction with ``ParamSpec`` and
-    ``Callable`` to represent a higher order function which adds, removes or
+    ``Concatenate`` can be used in conjunction with ``ParamSpec`` and
+    ``Callable`` to represent a higher-order function which adds, removes or
     transforms the parameters of a callable.
 
     For example::
@@ -1713,8 +1720,9 @@ def Unpack(self, parameters):
     """Type unpack operator.
 
     The type unpack operator takes the child types from some container type,
-    such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For
-    example::
+    such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'.
+
+    For example::
 
         # For some generic class `Foo`:
         Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]
@@ -1883,7 +1891,7 @@ class _TypingEllipsis:
 
 
 _TYPING_INTERNALS = ['__parameters__', '__orig_bases__',  '__orig_class__',
-                     '_is_protocol', '_is_runtime_protocol']
+                     '_is_protocol', '_is_runtime_protocol', '__final__']
 
 _SPECIAL_NAMES = ['__abstractmethods__', '__annotations__', '__dict__', '__doc__',
                   '__init__', '__module__', '__new__', '__slots__',
@@ -2007,7 +2015,9 @@ class Protocol(Generic, metaclass=_Proto
                 ...
 
     Such classes are primarily used with static type checkers that recognize
-    structural subtyping (static duck-typing), for example::
+    structural subtyping (static duck-typing).
+
+    For example::
 
         class C:
             def meth(self) -> int:
@@ -2163,7 +2173,7 @@ class Annotated:
 
         assert Annotated[int, '$'].__metadata__ == ('$',)
 
-    - Nested Annotated are flattened::
+    - Nested Annotated types are flattened::
 
         assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]
 
@@ -2174,17 +2184,17 @@ class Annotated:
 
     - Annotated can be used as a generic type alias::
 
-        Optimized = Annotated[T, runtime.Optimize()]
+        Optimized: TypeAlias = Annotated[T, runtime.Optimize()]
         assert Optimized[int] == Annotated[int, runtime.Optimize()]
 
-        OptimizedList = Annotated[List[T], runtime.Optimize()]
-        assert OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
+        OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]
+        assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]
 
     - Annotated cannot be used with an unpacked TypeVarTuple::
 
-        Annotated[*Ts, Ann1]  # NOT valid
+        Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid
 
-      This would be equivalent to
+      This would be equivalent to::
 
         Annotated[T1, T2, T3, ..., Ann1]
 
@@ -2264,7 +2274,7 @@ def assert_type(val, typ, /):
     emits an error if the value is not of the specified type::
 
         def greet(name: str) -> None:
-            assert_type(name, str)  # ok
+            assert_type(name, str)  # OK
             assert_type(name, int)  # type checker error
     """
     return val
@@ -2402,8 +2412,10 @@ def _strip_annotations(t):
 def get_origin(tp):
     """Get the unsubscripted version of a type.
 
-    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
-    Annotated, and others. Return None for unsupported types. Examples::
+    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,
+    Annotated, and others. Return None for unsupported types.
+
+    Examples::
 
         assert get_origin(Literal[42]) is Literal
         assert get_origin(int) is None
@@ -2562,7 +2574,9 @@ def overload(func):
     """Decorator for overloaded functions/methods.
 
     In a stub file, place two or more stub definitions for the same
-    function in a row, each decorated with @overload.  For example::
+    function in a row, each decorated with @overload.
+
+    For example::
 
         @overload
         def utf8(value: None) -> None: ...
@@ -2573,7 +2587,7 @@ def overload(func):
 
     In a non-stub file (i.e. a regular .py file), do the same but
     follow it with an implementation.  The implementation should *not*
-    be decorated with @overload.  For example::
+    be decorated with @overload::
 
         @overload
         def utf8(value: None) -> None: ...
@@ -2685,11 +2699,13 @@ Callable = _CallableType(collections.abc
 Callable.__doc__ = \
     """Deprecated alias to collections.abc.Callable.
 
-    Callable[[int], str] signifies a function of (int) -> str.
+    Callable[[int], str] signifies a function that takes a single
+    parameter of type int and returns a str.
+
     The subscription syntax must always be used with exactly two
     values: the argument list and the return type.
-    The argument list must be a list of types, a ParamSpec or ellipsis.
-    The return type must be a single type.
+    The argument list must be a list of types, a ParamSpec,
+    Concatenate or ellipsis. The return type must be a single type.
 
     There is no syntax to indicate optional or keyword arguments;
     such function types are rarely used as callback types.
@@ -3073,7 +3089,9 @@ TypedDict.__mro_entries__ = lambda bases
 def Required(self, parameters):
     """Special typing construct to mark a TypedDict key as required.
 
-    This is mainly useful for total=False TypedDicts. For example::
+    This is mainly useful for total=False TypedDicts.
+
+    For example::
 
         class Movie(TypedDict, total=False):
             title: Required[str]
@@ -3115,7 +3133,9 @@ class NewType:
 
     NewType(name, tp) is considered a subtype of tp
     by static type checkers. At runtime, NewType(name, tp) returns
-    a dummy callable that simply returns its argument. Usage::
+    a dummy callable that simply returns its argument.
+
+    Usage::
 
         UserId = NewType('UserId', int)
 
--- a/Lib/unittest/test/testmock/testasync.py
+++ b/Lib/unittest/test/testmock/testasync.py
@@ -427,9 +427,10 @@ class AsyncArguments(IsolatedAsyncioTest
         self.assertEqual(output, 10)
 
     async def test_add_side_effect_exception(self):
+        class CustomError(Exception): pass
         async def addition(var): pass
-        mock = AsyncMock(addition, side_effect=Exception('err'))
-        with self.assertRaises(Exception):
+        mock = AsyncMock(addition, side_effect=CustomError('side-effect'))
+        with self.assertRaisesRegex(CustomError, 'side-effect'):
             await mock(5)
 
     async def test_add_side_effect_coroutine(self):
--- a/Lib/urllib/parse.py
+++ b/Lib/urllib/parse.py
@@ -52,18 +52,18 @@ __all__ = ["urlparse", "urlunparse", "ur
 
 uses_relative = ['', 'ftp', 'http', 'gopher', 'nntp', 'imap',
                  'wais', 'file', 'https', 'shttp', 'mms',
-                 'prospero', 'rtsp', 'rtspu', 'sftp',
+                 'prospero', 'rtsp', 'rtsps', 'rtspu', 'sftp',
                  'svn', 'svn+ssh', 'ws', 'wss']
 
 uses_netloc = ['', 'ftp', 'http', 'gopher', 'nntp', 'telnet',
                'imap', 'wais', 'file', 'mms', 'https', 'shttp',
-               'snews', 'prospero', 'rtsp', 'rtspu', 'rsync',
+               'snews', 'prospero', 'rtsp', 'rtsps', 'rtspu', 'rsync',
                'svn', 'svn+ssh', 'sftp', 'nfs', 'git', 'git+ssh',
                'ws', 'wss']
 
 uses_params = ['', 'ftp', 'hdl', 'prospero', 'http', 'imap',
-               'https', 'shttp', 'rtsp', 'rtspu', 'sip', 'sips',
-               'mms', 'sftp', 'tel']
+               'https', 'shttp', 'rtsp', 'rtsps', 'rtspu', 'sip',
+               'sips', 'mms', 'sftp', 'tel']
 
 # These are not actually used anymore, but should stay for backwards
 # compatibility.  (They are undocumented, but have a public-looking name.)
@@ -72,7 +72,7 @@ non_hierarchical = ['gopher', 'hdl', 'ma
                     'telnet', 'wais', 'imap', 'snews', 'sip', 'sips']
 
 uses_query = ['', 'http', 'wais', 'imap', 'https', 'shttp', 'mms',
-              'gopher', 'rtsp', 'rtspu', 'sip', 'sips']
+              'gopher', 'rtsp', 'rtsps', 'rtspu', 'sip', 'sips']
 
 uses_fragment = ['', 'ftp', 'hdl', 'http', 'gopher', 'news',
                  'nntp', 'wais', 'https', 'shttp', 'snews',
--- a/Lib/zipfile.py
+++ b/Lib/zipfile.py
@@ -2420,21 +2420,24 @@ class Path:
         encoding, args, kwargs = _extract_text_encoding(*args, **kwargs)
         return io.TextIOWrapper(stream, encoding, *args, **kwargs)
 
+    def _base(self):
+        return pathlib.PurePosixPath(self.at or self.root.filename)
+
     @property
     def name(self):
-        return pathlib.Path(self.at).name or self.filename.name
+        return self._base().name
 
     @property
     def suffix(self):
-        return pathlib.Path(self.at).suffix or self.filename.suffix
+        return self._base().suffix
 
     @property
     def suffixes(self):
-        return pathlib.Path(self.at).suffixes or self.filename.suffixes
+        return self._base().suffixes
 
     @property
     def stem(self):
-        return pathlib.Path(self.at).stem or self.filename.stem
+        return self._base().stem
 
     @property
     def filename(self):
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -1764,8 +1764,7 @@ altinstall: commoninstall
 
 commoninstall:  check-clean-src @FRAMEWORKALTINSTALLFIRST@ \
 		altbininstall libinstall inclinstall libainstall \
-		sharedinstall oldsharedinstall altmaninstall \
-		@FRAMEWORKALTINSTALLLAST@
+		sharedinstall oldsharedinstall altmaninstall @FRAMEWORKALTINSTALLLAST@
 
 # Install shared libraries enabled by Setup
 DESTDIRS=	$(exec_prefix) $(LIBDIR) $(BINLIBDEST) $(DESTSHARED)
@@ -1839,7 +1838,11 @@ altbininstall: $(BUILDPYTHON) @FRAMEWORK
 			$(DESTDIR)$(BINDIR)/python$(VERSION)$(EXE); \
 	fi
 
-bininstall: altbininstall
+# We depend on commoninstall here to make sure the installation is already usable
+# before we possibly overwrite the global 'python3' symlink to avoid causing
+# problems for anything else trying to run 'python3' while we install, particularly
+# if we're installing in parallel with -j.
+bininstall: commoninstall altbininstall
 	if test ! -d $(DESTDIR)$(LIBPC); then \
 		echo "Creating directory $(LIBPC)"; \
 		$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$(LIBPC); \
--- a/Misc/ACKS
+++ b/Misc/ACKS
@@ -224,6 +224,7 @@ Erik Bray
 Brian Brazil
 Demian Brecht
 Dave Brennan
+Christopher Richard James Brett
 Tom Bridgman
 Anthony Briggs
 Keith Briggs
--- a/Modules/_ctypes/_ctypes.c
+++ b/Modules/_ctypes/_ctypes.c
@@ -5158,6 +5158,8 @@ static PyObject *
 Pointer_get_contents(CDataObject *self, void *closure)
 {
     StgDictObject *stgdict;
+    PyObject *keep, *ptr_probe;
+    CDataObject *ptr2ptr;
 
     if (*(void **)self->b_ptr == NULL) {
         PyErr_SetString(PyExc_ValueError,
@@ -5167,6 +5169,33 @@ Pointer_get_contents(CDataObject *self,
 
     stgdict = PyObject_stgdict((PyObject *)self);
     assert(stgdict); /* Cannot be NULL for pointer instances */
+
+    keep = GetKeepedObjects(self);
+    if (keep != NULL) {
+        // check if it's a pointer to a pointer:
+        // pointers will have '0' key in the _objects
+        ptr_probe = PyDict_GetItemString(keep, "0");
+
+        if (ptr_probe != NULL) {
+            ptr2ptr = (CDataObject*) PyDict_GetItemString(keep, "1");
+            if (ptr2ptr ==  NULL) {
+                PyErr_SetString(PyExc_ValueError,
+                "Unexpected NULL pointer in _objects");
+                return NULL;
+            }
+            // don't construct a new object,
+            // return existing one instead to preserve refcount
+            assert(
+                *(void**) self->b_ptr == ptr2ptr->b_ptr ||
+                *(void**) self->b_value.c == ptr2ptr->b_ptr ||
+                *(void**) self->b_ptr == ptr2ptr->b_value.c ||
+                *(void**) self->b_value.c == ptr2ptr->b_value.c
+            ); // double-check that we are returning the same thing
+            Py_INCREF(ptr2ptr);
+            return (PyObject *) ptr2ptr;
+        }
+    }
+
     return PyCData_FromBaseObj(stgdict->proto,
                              (PyObject *)self, 0,
                              *(void **)self->b_ptr);
--- a/Modules/_ctypes/callbacks.c
+++ b/Modules/_ctypes/callbacks.c
@@ -499,12 +499,22 @@ long Call_GetClassObject(REFCLSID rclsid
 
     {
         PyObject *py_rclsid = PyLong_FromVoidPtr((void *)rclsid);
+        if (py_rclsid == NULL) {
+            Py_DECREF(func);
+            PyErr_WriteUnraisable(context ? context : Py_None);
+            return E_FAIL;
+        }
         PyObject *py_riid = PyLong_FromVoidPtr((void *)riid);
+        if (py_riid == NULL) {
+            Py_DECREF(func);
+            Py_DECREF(py_rclsid);
+            PyErr_WriteUnraisable(context ? context : Py_None);
+            return E_FAIL;
+        }
         PyObject *py_ppv = PyLong_FromVoidPtr(ppv);
-        if (!py_rclsid || !py_riid || !py_ppv) {
-            Py_XDECREF(py_rclsid);
-            Py_XDECREF(py_riid);
-            Py_XDECREF(py_ppv);
+        if (py_ppv == NULL) {
+            Py_DECREF(py_rclsid);
+            Py_DECREF(py_riid);
             Py_DECREF(func);
             PyErr_WriteUnraisable(context ? context : Py_None);
             return E_FAIL;
--- a/Modules/_curses_panel.c
+++ b/Modules/_curses_panel.c
@@ -670,9 +670,7 @@ _curses_panel_exec(PyObject *mod)
     state->PyCursesError = PyErr_NewException(
         "_curses_panel.error", NULL, NULL);
 
-    Py_INCREF(state->PyCursesError);
-    if (PyModule_AddObject(mod, "error", state->PyCursesError) < 0) {
-        Py_DECREF(state->PyCursesError);
+    if (PyModule_AddObjectRef(mod, "error", state->PyCursesError) < 0) {
         return -1;
     }
 
--- a/Modules/_datetimemodule.c
+++ b/Modules/_datetimemodule.c
@@ -6878,24 +6878,49 @@ _datetime_exec(PyObject *module)
     assert(DI100Y == days_before_year(100+1));
 
     us_per_ms = PyLong_FromLong(1000);
+    if (us_per_ms == NULL) {
+        goto error;
+    }
     us_per_second = PyLong_FromLong(1000000);
+    if (us_per_second == NULL) {
+        goto error;
+    }
     us_per_minute = PyLong_FromLong(60000000);
+    if (us_per_minute == NULL) {
+        goto error;
+    }
     seconds_per_day = PyLong_FromLong(24 * 3600);
-    if (us_per_ms == NULL || us_per_second == NULL ||
-        us_per_minute == NULL || seconds_per_day == NULL) {
-        return -1;
+    if (seconds_per_day == NULL) {
+        goto error;
     }
 
     /* The rest are too big for 32-bit ints, but even
      * us_per_week fits in 40 bits, so doubles should be exact.
      */
     us_per_hour = PyLong_FromDouble(3600000000.0);
+    if (us_per_hour == NULL) {
+        goto error;
+    }
     us_per_day = PyLong_FromDouble(86400000000.0);
+    if (us_per_day == NULL) {
+        goto error;
+    }
     us_per_week = PyLong_FromDouble(604800000000.0);
-    if (us_per_hour == NULL || us_per_day == NULL || us_per_week == NULL) {
-        return -1;
+    if (us_per_week == NULL) {
+        goto error;
     }
+
     return 0;
+
+error:
+    Py_XDECREF(us_per_ms);
+    Py_XDECREF(us_per_second);
+    Py_XDECREF(us_per_minute);
+    Py_XDECREF(us_per_hour);
+    Py_XDECREF(us_per_day);
+    Py_XDECREF(us_per_week);
+    Py_XDECREF(seconds_per_day);
+    return -1;
 }
 
 static struct PyModuleDef datetimemodule = {
--- a/Modules/_decimal/_decimal.c
+++ b/Modules/_decimal/_decimal.c
@@ -247,14 +247,12 @@ value_error_int(const char *mesg)
     return -1;
 }
 
-#ifdef CONFIG_32
 static PyObject *
 value_error_ptr(const char *mesg)
 {
     PyErr_SetString(PyExc_ValueError, mesg);
     return NULL;
 }
-#endif
 
 static int
 type_error_int(const char *mesg)
@@ -541,6 +539,8 @@ getround(PyObject *v)
    initialized to new SignalDicts. Once a SignalDict is tied to
    a context, it cannot be deleted. */
 
+static const char *INVALID_SIGNALDICT_ERROR_MSG = "invalid signal dict";
+
 static int
 signaldict_init(PyObject *self, PyObject *args UNUSED, PyObject *kwds UNUSED)
 {
@@ -549,8 +549,11 @@ signaldict_init(PyObject *self, PyObject
 }
 
 static Py_ssize_t
-signaldict_len(PyObject *self UNUSED)
+signaldict_len(PyObject *self)
 {
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_int(INVALID_SIGNALDICT_ERROR_MSG);
+    }
     return SIGNAL_MAP_LEN;
 }
 
@@ -558,6 +561,9 @@ static PyObject *SignalTuple;
 static PyObject *
 signaldict_iter(PyObject *self UNUSED)
 {
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
     return PyTuple_Type.tp_iter(SignalTuple);
 }
 
@@ -565,6 +571,9 @@ static PyObject *
 signaldict_getitem(PyObject *self, PyObject *key)
 {
     uint32_t flag;
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
 
     flag = exception_as_flag(key);
     if (flag & DEC_ERRORS) {
@@ -580,6 +589,10 @@ signaldict_setitem(PyObject *self, PyObj
     uint32_t flag;
     int x;
 
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_int(INVALID_SIGNALDICT_ERROR_MSG);
+    }
+
     if (value == NULL) {
         return value_error_int("signal keys cannot be deleted");
     }
@@ -612,6 +625,10 @@ signaldict_repr(PyObject *self)
     const char *b[SIGNAL_MAP_LEN]; /* bool */
     int i;
 
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
+
     assert(SIGNAL_MAP_LEN == 9);
 
     for (cm=signal_map, i=0; cm->name != NULL; cm++, i++) {
@@ -634,6 +651,10 @@ signaldict_richcompare(PyObject *v, PyOb
 
     assert(PyDecSignalDict_Check(v));
 
+    if ((SdFlagAddr(v) == NULL) || (SdFlagAddr(w) == NULL)) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
+
     if (op == Py_EQ || op == Py_NE) {
         if (PyDecSignalDict_Check(w)) {
             res = (SdFlags(v)==SdFlags(w)) ^ (op==Py_NE) ? Py_True : Py_False;
@@ -662,6 +683,9 @@ signaldict_richcompare(PyObject *v, PyOb
 static PyObject *
 signaldict_copy(PyObject *self, PyObject *args UNUSED)
 {
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
     return flags_as_dict(SdFlags(self));
 }
 
@@ -3658,9 +3682,13 @@ dec_as_integer_ratio(PyObject *self, PyO
             goto error;
         }
         Py_SETREF(numerator, _py_long_floor_divide(numerator, tmp));
+        if (numerator == NULL) {
+            Py_DECREF(tmp);
+            goto error;
+        }
         Py_SETREF(denominator, _py_long_floor_divide(denominator, tmp));
         Py_DECREF(tmp);
-        if (numerator == NULL || denominator == NULL) {
+        if (denominator == NULL) {
             goto error;
         }
     }
@@ -5918,21 +5946,15 @@ PyInit__decimal(void)
 
 
     /* Add types to the module */
-    Py_INCREF(&PyDec_Type);
-    CHECK_INT(PyModule_AddObject(m, "Decimal", (PyObject *)&PyDec_Type));
-    Py_INCREF(&PyDecContext_Type);
-    CHECK_INT(PyModule_AddObject(m, "Context",
-                                 (PyObject *)&PyDecContext_Type));
-    Py_INCREF(DecimalTuple);
-    CHECK_INT(PyModule_AddObject(m, "DecimalTuple", (PyObject *)DecimalTuple));
-
+    CHECK_INT(PyModule_AddObjectRef(m, "Decimal", (PyObject *)&PyDec_Type));
+    CHECK_INT(PyModule_AddObjectRef(m, "Context", (PyObject *)&PyDecContext_Type));
+    CHECK_INT(PyModule_AddObjectRef(m, "DecimalTuple", (PyObject *)DecimalTuple));
 
     /* Create top level exception */
     ASSIGN_PTR(DecimalException, PyErr_NewException(
                                      "decimal.DecimalException",
                                      PyExc_ArithmeticError, NULL));
-    Py_INCREF(DecimalException);
-    CHECK_INT(PyModule_AddObject(m, "DecimalException", DecimalException));
+    CHECK_INT(PyModule_AddObjectRef(m, "DecimalException", DecimalException));
 
     /* Create signal tuple */
     ASSIGN_PTR(SignalTuple, PyTuple_New(SIGNAL_MAP_LEN));
@@ -5972,8 +5994,7 @@ PyInit__decimal(void)
         Py_DECREF(base);
 
         /* add to module */
-        Py_INCREF(cm->ex);
-        CHECK_INT(PyModule_AddObject(m, cm->name, cm->ex));
+        CHECK_INT(PyModule_AddObjectRef(m, cm->name, cm->ex));
 
         /* add to signal tuple */
         Py_INCREF(cm->ex);
@@ -6003,45 +6024,39 @@ PyInit__decimal(void)
         ASSIGN_PTR(cm->ex, PyErr_NewException(cm->fqname, base, NULL));
         Py_DECREF(base);
 
-        Py_INCREF(cm->ex);
-        CHECK_INT(PyModule_AddObject(m, cm->name, cm->ex));
+        CHECK_INT(PyModule_AddObjectRef(m, cm->name, cm->ex));
     }
 
 
     /* Init default context template first */
     ASSIGN_PTR(default_context_template,
                PyObject_CallObject((PyObject *)&PyDecContext_Type, NULL));
-    Py_INCREF(default_context_template);
-    CHECK_INT(PyModule_AddObject(m, "DefaultContext",
-                                 default_context_template));
+    CHECK_INT(PyModule_AddObjectRef(m, "DefaultContext",
+                                    default_context_template));
 
 #ifndef WITH_DECIMAL_CONTEXTVAR
     ASSIGN_PTR(tls_context_key, PyUnicode_FromString("___DECIMAL_CTX__"));
-    Py_INCREF(Py_False);
-    CHECK_INT(PyModule_AddObject(m, "HAVE_CONTEXTVAR", Py_False));
+    CHECK_INT(PyModule_AddObjectRef(m, "HAVE_CONTEXTVAR", Py_False));
 #else
     ASSIGN_PTR(current_context_var, PyContextVar_New("decimal_context", NULL));
-    Py_INCREF(Py_True);
-    CHECK_INT(PyModule_AddObject(m, "HAVE_CONTEXTVAR", Py_True));
+    CHECK_INT(PyModule_AddObjectRef(m, "HAVE_CONTEXTVAR", Py_True));
 #endif
-    Py_INCREF(Py_True);
-    CHECK_INT(PyModule_AddObject(m, "HAVE_THREADS", Py_True));
+    CHECK_INT(PyModule_AddObjectRef(m, "HAVE_THREADS", Py_True));
 
     /* Init basic context template */
     ASSIGN_PTR(basic_context_template,
                PyObject_CallObject((PyObject *)&PyDecContext_Type, NULL));
     init_basic_context(basic_context_template);
-    Py_INCREF(basic_context_template);
-    CHECK_INT(PyModule_AddObject(m, "BasicContext",
-                                 basic_context_template));
+    CHECK_INT(PyModule_AddObjectRef(m, "BasicContext",
+                                    basic_context_template));
 
     /* Init extended context template */
     ASSIGN_PTR(extended_context_template,
                PyObject_CallObject((PyObject *)&PyDecContext_Type, NULL));
     init_extended_context(extended_context_template);
     Py_INCREF(extended_context_template);
-    CHECK_INT(PyModule_AddObject(m, "ExtendedContext",
-                                 extended_context_template));
+    CHECK_INT(PyModule_AddObjectRef(m, "ExtendedContext",
+                                    extended_context_template));
 
 
     /* Init mpd_ssize_t constants */
@@ -6060,8 +6075,7 @@ PyInit__decimal(void)
     /* Init string constants */
     for (i = 0; i < _PY_DEC_ROUND_GUARD; i++) {
         ASSIGN_PTR(round_map[i], PyUnicode_InternFromString(mpd_round_string[i]));
-        Py_INCREF(round_map[i]);
-        CHECK_INT(PyModule_AddObject(m, mpd_round_string[i], round_map[i]));
+        CHECK_INT(PyModule_AddObjectRef(m, mpd_round_string[i], round_map[i]));
     }
 
     /* Add specification version number */
--- a/Modules/_elementtree.c
+++ b/Modules/_elementtree.c
@@ -3263,10 +3263,14 @@ expat_start_handler(XMLParserObject* sel
         }
         while (attrib_in[0] && attrib_in[1]) {
             PyObject* key = makeuniversal(self, attrib_in[0]);
+            if (key == NULL) {
+                Py_DECREF(attrib);
+                Py_DECREF(tag);
+                return;
+            }
             PyObject* value = PyUnicode_DecodeUTF8(attrib_in[1], strlen(attrib_in[1]), "strict");
-            if (!key || !value) {
-                Py_XDECREF(value);
-                Py_XDECREF(key);
+            if (value == NULL) {
+                Py_DECREF(key);
                 Py_DECREF(attrib);
                 Py_DECREF(tag);
                 return;
--- a/Modules/_hashopenssl.c
+++ b/Modules/_hashopenssl.c
@@ -384,14 +384,15 @@ py_digest_by_digestmod(PyObject *module,
     } else {
         _hashlibstate *state = get_hashlib_state(module);
         // borrowed ref
-        name_obj = PyDict_GetItem(state->constructs, digestmod);
+        name_obj = PyDict_GetItemWithError(state->constructs, digestmod);
     }
     if (name_obj == NULL) {
-        _hashlibstate *state = get_hashlib_state(module);
-        PyErr_Clear();
-        PyErr_Format(
-            state->unsupported_digestmod_error,
-            "Unsupported digestmod %R", digestmod);
+        if (!PyErr_Occurred()) {
+            _hashlibstate *state = get_hashlib_state(module);
+            PyErr_Format(
+                state->unsupported_digestmod_error,
+                "Unsupported digestmod %R", digestmod);
+        }
         return NULL;
     }
 
--- a/Modules/_pickle.c
+++ b/Modules/_pickle.c
@@ -1116,39 +1116,49 @@ _Pickler_Write(PicklerObject *self, cons
 static PicklerObject *
 _Pickler_New(void)
 {
-    PicklerObject *self;
-
-    self = PyObject_GC_New(PicklerObject, &Pickler_Type);
-    if (self == NULL)
+    PyMemoTable *memo = PyMemoTable_New();
+    if (memo == NULL) {
         return NULL;
+    }
+
+    const Py_ssize_t max_output_len = WRITE_BUF_SIZE;
+    PyObject *output_buffer = PyBytes_FromStringAndSize(NULL, max_output_len);
+    if (output_buffer == NULL) {
+        goto error;
+    }
+
+    PicklerObject *self = PyObject_GC_New(PicklerObject, &Pickler_Type);
+    if (self == NULL) {
+        goto error;
+    }
 
+    self->memo = memo;
     self->pers_func = NULL;
+    self->pers_func_self = NULL;
     self->dispatch_table = NULL;
-    self->buffer_callback = NULL;
+    self->reducer_override = NULL;
     self->write = NULL;
+    self->output_buffer = output_buffer;
+    self->output_len = 0;
+    self->max_output_len = max_output_len;
     self->proto = 0;
     self->bin = 0;
     self->framing = 0;
     self->frame_start = -1;
+    self->buf_size = 0;
     self->fast = 0;
     self->fast_nesting = 0;
     self->fix_imports = 0;
     self->fast_memo = NULL;
-    self->max_output_len = WRITE_BUF_SIZE;
-    self->output_len = 0;
-    self->reducer_override = NULL;
-
-    self->memo = PyMemoTable_New();
-    self->output_buffer = PyBytes_FromStringAndSize(NULL,
-                                                    self->max_output_len);
-
-    if (self->memo == NULL || self->output_buffer == NULL) {
-        Py_DECREF(self);
-        return NULL;
-    }
+    self->buffer_callback = NULL;
 
     PyObject_GC_Track(self);
     return self;
+
+error:
+    PyMem_Free(memo);
+    Py_XDECREF(output_buffer);
+    return NULL;
 }
 
 static int
@@ -1599,13 +1609,29 @@ _Unpickler_MemoCleanup(UnpicklerObject *
 static UnpicklerObject *
 _Unpickler_New(void)
 {
-    UnpicklerObject *self;
-
-    self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);
-    if (self == NULL)
+    const int MEMO_SIZE = 32;
+    PyObject **memo = _Unpickler_NewMemo(MEMO_SIZE);
+    if (memo == NULL) {
         return NULL;
+    }
+
+    PyObject *stack = Pdata_New();
+    if (stack == NULL) {
+        goto error;
+    }
 
+    UnpicklerObject *self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);
+    if (self == NULL) {
+        goto error;
+    }
+
+    self->stack = (Pdata *)stack;
+    self->memo = memo;
+    self->memo_size = MEMO_SIZE;
+    self->memo_len = 0;
     self->pers_func = NULL;
+    self->pers_func_self = NULL;
+    memset(&self->buffer, 0, sizeof(Py_buffer));
     self->input_buffer = NULL;
     self->input_line = NULL;
     self->input_len = 0;
@@ -1623,19 +1649,14 @@ _Unpickler_New(void)
     self->marks_size = 0;
     self->proto = 0;
     self->fix_imports = 0;
-    memset(&self->buffer, 0, sizeof(Py_buffer));
-    self->memo_size = 32;
-    self->memo_len = 0;
-    self->memo = _Unpickler_NewMemo(self->memo_size);
-    self->stack = (Pdata *)Pdata_New();
-
-    if (self->memo == NULL || self->stack == NULL) {
-        Py_DECREF(self);
-        return NULL;
-    }
 
     PyObject_GC_Track(self);
     return self;
+
+error:
+    PyMem_Free(memo);
+    Py_XDECREF(stack);
+    return NULL;
 }
 
 /* Returns -1 (with an exception set) on failure, 0 on success. This may
@@ -1645,25 +1666,30 @@ _Unpickler_SetInputStream(UnpicklerObjec
 {
     /* Optional file methods */
     if (_PyObject_LookupAttr(file, &_Py_ID(peek), &self->peek) < 0) {
-        return -1;
+        goto error;
     }
     if (_PyObject_LookupAttr(file, &_Py_ID(readinto), &self->readinto) < 0) {
-        return -1;
+        goto error;
+    }
+    if (_PyObject_LookupAttr(file, &_Py_ID(read), &self->read) < 0) {
+        goto error;
+    }
+    if (_PyObject_LookupAttr(file, &_Py_ID(readline), &self->readline) < 0) {
+        goto error;
     }
-    (void)_PyObject_LookupAttr(file, &_Py_ID(read), &self->read);
-    (void)_PyObject_LookupAttr(file, &_Py_ID(readline), &self->readline);
     if (!self->readline || !self->read) {
-        if (!PyErr_Occurred()) {
-            PyErr_SetString(PyExc_TypeError,
-                            "file must have 'read' and 'readline' attributes");
-        }
-        Py_CLEAR(self->read);
-        Py_CLEAR(self->readinto);
-        Py_CLEAR(self->readline);
-        Py_CLEAR(self->peek);
-        return -1;
+        PyErr_SetString(PyExc_TypeError,
+                        "file must have 'read' and 'readline' attributes");
+        goto error;
     }
     return 0;
+
+error:
+    Py_CLEAR(self->read);
+    Py_CLEAR(self->readinto);
+    Py_CLEAR(self->readline);
+    Py_CLEAR(self->peek);
+    return -1;
 }
 
 /* Returns -1 (with an exception set) on failure, 0 on success. This may
@@ -4833,11 +4859,12 @@ _pickle_PicklerMemoProxy_copy_impl(Pickl
             PyObject *key, *value;
 
             key = PyLong_FromVoidPtr(entry.me_key);
+            if (key == NULL) {
+                goto error;
+            }
             value = Py_BuildValue("nO", entry.me_value, entry.me_key);
-
-            if (key == NULL || value == NULL) {
-                Py_XDECREF(key);
-                Py_XDECREF(value);
+            if (value == NULL) {
+                Py_DECREF(key);
                 goto error;
             }
             status = PyDict_SetItem(new_memo, key, value);
@@ -6033,13 +6060,21 @@ load_stack_global(UnpicklerObject *self)
     PyObject *global_name;
 
     PDATA_POP(self->stack, global_name);
+    if (global_name == NULL) {
+        return -1;
+    }
     PDATA_POP(self->stack, module_name);
-    if (module_name == NULL || !PyUnicode_CheckExact(module_name) ||
-        global_name == NULL || !PyUnicode_CheckExact(global_name)) {
+    if (module_name == NULL) {
+        Py_DECREF(global_name);
+        return -1;
+    }
+    if (!PyUnicode_CheckExact(module_name) ||
+        !PyUnicode_CheckExact(global_name))
+    {
         PickleState *st = _Pickle_GetGlobalState();
         PyErr_SetString(st->UnpicklingError, "STACK_GLOBAL requires str");
-        Py_XDECREF(global_name);
-        Py_XDECREF(module_name);
+        Py_DECREF(global_name);
+        Py_DECREF(module_name);
         return -1;
     }
     global = find_class(self, module_name, global_name);
--- a/Modules/_sqlite/connection.c
+++ b/Modules/_sqlite/connection.c
@@ -1792,10 +1792,12 @@ collation_callback(void *context, int te
     }
 
     string1 = PyUnicode_FromStringAndSize((const char*)text1_data, text1_length);
+    if (string1 == NULL) {
+        goto finally;
+    }
     string2 = PyUnicode_FromStringAndSize((const char*)text2_data, text2_length);
-
-    if (!string1 || !string2) {
-        goto finally; /* failed to allocate strings */
+    if (string2 == NULL) {
+        goto finally;
     }
 
     callback_context *ctx = (callback_context *)context;
--- a/Modules/_ssl.c
+++ b/Modules/_ssl.c
@@ -650,6 +650,10 @@ PySSL_SetError(PySSLSocket *sslsock, int
                     errstr = "Some I/O error occurred";
                 }
             } else {
+                if (ERR_GET_LIB(e) == ERR_LIB_SSL &&
+                        ERR_GET_REASON(e) == SSL_R_CERTIFICATE_VERIFY_FAILED) {
+                    type = state->PySSLCertVerificationErrorObject;
+                }
                 p = PY_SSL_ERROR_SYSCALL;
             }
             break;
@@ -2800,7 +2804,7 @@ _ssl_session_dup(SSL_SESSION *session) {
     /* get length */
     slen = i2d_SSL_SESSION(session, NULL);
     if (slen == 0 || slen > 0xFF00) {
-        PyErr_SetString(PyExc_ValueError, "i2d() failed.");
+        PyErr_SetString(PyExc_ValueError, "i2d() failed");
         goto error;
     }
     if ((senc = PyMem_Malloc(slen)) == NULL) {
@@ -2809,12 +2813,13 @@ _ssl_session_dup(SSL_SESSION *session) {
     }
     p = senc;
     if (!i2d_SSL_SESSION(session, &p)) {
-        PyErr_SetString(PyExc_ValueError, "i2d() failed.");
+        PyErr_SetString(PyExc_ValueError, "i2d() failed");
         goto error;
     }
     const_p = senc;
     newsession = d2i_SSL_SESSION(NULL, &const_p, slen);
-    if (session == NULL) {
+    if (newsession == NULL) {
+        PyErr_SetString(PyExc_ValueError, "d2i() failed");
         goto error;
     }
     PyMem_Free(senc);
@@ -6052,17 +6057,26 @@ sslmodule_init_errorcodes(PyObject *modu
 
     errcode = error_codes;
     while (errcode->mnemonic != NULL) {
-        PyObject *mnemo, *key;
-        mnemo = PyUnicode_FromString(errcode->mnemonic);
-        key = Py_BuildValue("ii", errcode->library, errcode->reason);
-        if (mnemo == NULL || key == NULL)
+        PyObject *mnemo = PyUnicode_FromString(errcode->mnemonic);
+        if (mnemo == NULL) {
             return -1;
-        if (PyDict_SetItem(state->err_codes_to_names, key, mnemo))
+        }
+        PyObject *key = Py_BuildValue("ii", errcode->library, errcode->reason);
+        if (key == NULL) {
+            Py_DECREF(mnemo);
             return -1;
-        if (PyDict_SetItem(state->err_names_to_codes, mnemo, key))
+        }
+        if (PyDict_SetItem(state->err_codes_to_names, key, mnemo) < 0) {
+            Py_DECREF(key);
+            Py_DECREF(mnemo);
             return -1;
+        }
+        int rc = PyDict_SetItem(state->err_names_to_codes, mnemo, key);
         Py_DECREF(key);
         Py_DECREF(mnemo);
+        if (rc < 0) {
+            return -1;
+        }
         errcode++;
     }
 
@@ -6120,22 +6134,22 @@ sslmodule_init_versioninfo(PyObject *m)
     */
     libver = OpenSSL_version_num();
     r = PyLong_FromUnsignedLong(libver);
-    if (r == NULL || PyModule_AddObject(m, "OPENSSL_VERSION_NUMBER", r))
+    if (_PyModule_Add(m, "OPENSSL_VERSION_NUMBER", r) < 0)
         return -1;
 
     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);
     r = Py_BuildValue("IIIII", major, minor, fix, patch, status);
-    if (r == NULL || PyModule_AddObject(m, "OPENSSL_VERSION_INFO", r))
+    if (_PyModule_Add(m, "OPENSSL_VERSION_INFO", r) < 0)
         return -1;
 
     r = PyUnicode_FromString(OpenSSL_version(OPENSSL_VERSION));
-    if (r == NULL || PyModule_AddObject(m, "OPENSSL_VERSION", r))
+    if (_PyModule_Add(m, "OPENSSL_VERSION", r) < 0)
         return -1;
 
     libver = OPENSSL_VERSION_NUMBER;
     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);
     r = Py_BuildValue("IIIII", major, minor, fix, patch, status);
-    if (r == NULL || PyModule_AddObject(m, "_OPENSSL_API_VERSION", r))
+    if (_PyModule_Add(m, "_OPENSSL_API_VERSION", r) < 0)
         return -1;
 
     return 0;
--- a/Modules/_stat.c
+++ b/Modules/_stat.c
@@ -592,17 +592,17 @@ stat_exec(PyObject *module)
     ADD_INT_MACRO(module, FILE_ATTRIBUTE_TEMPORARY);
     ADD_INT_MACRO(module, FILE_ATTRIBUTE_VIRTUAL);
 
-    if (PyModule_AddObject(module, "IO_REPARSE_TAG_SYMLINK",
-                           PyLong_FromUnsignedLong(IO_REPARSE_TAG_SYMLINK)) < 0) {
-            return -1;
+    if (_PyModule_Add(module, "IO_REPARSE_TAG_SYMLINK",
+            PyLong_FromUnsignedLong(IO_REPARSE_TAG_SYMLINK)) < 0) {
+        return -1;
     }
-    if (PyModule_AddObject(module, "IO_REPARSE_TAG_MOUNT_POINT",
-                           PyLong_FromUnsignedLong(IO_REPARSE_TAG_MOUNT_POINT)) < 0) {
-            return -1;
+    if (_PyModule_Add(module, "IO_REPARSE_TAG_MOUNT_POINT",
+            PyLong_FromUnsignedLong(IO_REPARSE_TAG_MOUNT_POINT)) < 0) {
+        return -1;
     }
-    if (PyModule_AddObject(module, "IO_REPARSE_TAG_APPEXECLINK",
-                           PyLong_FromUnsignedLong(IO_REPARSE_TAG_APPEXECLINK)) < 0) {
-            return -1;
+    if (_PyModule_Add(module, "IO_REPARSE_TAG_APPEXECLINK",
+            PyLong_FromUnsignedLong(IO_REPARSE_TAG_APPEXECLINK)) < 0) {
+        return -1;
     }
 #endif
 
--- a/Modules/_testcapimodule.c
+++ b/Modules/_testcapimodule.c
@@ -44,6 +44,16 @@
 #  error "The public headers should not include <stdbool.h>, see bpo-46748"
 #endif
 
+#define NULLABLE(x) do { if (x == Py_None) x = NULL; } while (0);
+
+#define RETURN_INT(value) do {          \
+        int _ret = (value);             \
+        if (_ret == -1) {               \
+            return NULL;                \
+        }                               \
+        return PyLong_FromLong(_ret);   \
+    } while (0)
+
 // Forward declarations
 static struct PyModuleDef _testcapimodule;
 static PyType_Spec HeapTypeNameType_Spec;
@@ -2307,6 +2317,40 @@ unicode_asutf8andsize(PyObject *self, Py
     return Py_BuildValue("(Nn)", result, utf8_len);
 }
 
+/* Test PyUnicode_DecodeUTF8() */
+static PyObject *
+unicode_decodeutf8(PyObject *self, PyObject *args)
+{
+    const char *data;
+    Py_ssize_t size;
+    const char *errors = NULL;
+
+    if (!PyArg_ParseTuple(args, "y#|z", &data, &size, &errors))
+        return NULL;
+
+    return PyUnicode_DecodeUTF8(data, size, errors);
+}
+
+/* Test PyUnicode_DecodeUTF8Stateful() */
+static PyObject *
+unicode_decodeutf8stateful(PyObject *self, PyObject *args)
+{
+    const char *data;
+    Py_ssize_t size;
+    const char *errors = NULL;
+    Py_ssize_t consumed = 123456789;
+    PyObject *result;
+
+    if (!PyArg_ParseTuple(args, "y#|z", &data, &size, &errors))
+        return NULL;
+
+    result = PyUnicode_DecodeUTF8Stateful(data, size, errors, &consumed);
+    if (!result) {
+        return NULL;
+    }
+    return Py_BuildValue("(Nn)", result, consumed);
+}
+
 static PyObject *
 unicode_findchar(PyObject *self, PyObject *args)
 {
@@ -6415,6 +6459,35 @@ static PyObject *getargs_s_hash_int(PyOb
 static PyObject *getargs_s_hash_int2(PyObject *, PyObject *, PyObject*);
 static PyObject *gh_99240_clear_args(PyObject *, PyObject *);
 
+static PyObject *
+sys_getobject(PyObject *Py_UNUSED(module), PyObject *arg)
+{
+    const char *name;
+    Py_ssize_t size;
+    if (!PyArg_Parse(arg, "z#", &name, &size)) {
+        return NULL;
+    }
+    PyObject *result = PySys_GetObject(name);
+    if (result == NULL) {
+        result = PyExc_AttributeError;
+    }
+    return Py_NewRef(result);
+}
+
+static PyObject *
+sys_setobject(PyObject *Py_UNUSED(module), PyObject *args)
+{
+    const char *name;
+    Py_ssize_t size;
+    PyObject *value;
+    if (!PyArg_ParseTuple(args, "z#O", &name, &size, &value)) {
+        return NULL;
+    }
+    NULLABLE(value);
+    RETURN_INT(PySys_SetObject(name, value));
+}
+
+
 static PyMethodDef TestMethods[] = {
     {"exc_set_object",          exc_set_object,                  METH_VARARGS},
     {"raise_exception",         raise_exception,                 METH_VARARGS},
@@ -6562,7 +6635,8 @@ static PyMethodDef TestMethods[] = {
     {"unicode_asucs4",          unicode_asucs4,                  METH_VARARGS},
     {"unicode_asutf8",          unicode_asutf8,                  METH_VARARGS},
     {"unicode_asutf8andsize",   unicode_asutf8andsize,           METH_VARARGS},
-    {"unicode_findchar",        unicode_findchar,                METH_VARARGS},
+    {"unicode_decodeutf8",       unicode_decodeutf8,             METH_VARARGS},
+    {"unicode_decodeutf8stateful",unicode_decodeutf8stateful,    METH_VARARGS},    {"unicode_findchar",        unicode_findchar,                METH_VARARGS},
     {"unicode_copycharacters",  unicode_copycharacters,          METH_VARARGS},
 #if USE_UNICODE_WCHAR_CACHE
     {"unicode_legacy_string",   unicode_legacy_string,           METH_VARARGS},
@@ -6726,6 +6800,8 @@ static PyMethodDef TestMethods[] = {
     {"function_get_code", function_get_code, METH_O, NULL},
     {"function_get_globals", function_get_globals, METH_O, NULL},
     {"function_get_module", function_get_module, METH_O, NULL},
+    {"sys_getobject", sys_getobject, METH_O},
+    {"sys_setobject", sys_setobject, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };
 
--- a/Modules/_testinternalcapi.c
+++ b/Modules/_testinternalcapi.c
@@ -14,6 +14,7 @@
 #include "Python.h"
 #include "pycore_atomic_funcs.h" // _Py_atomic_int_get()
 #include "pycore_bitutils.h"     // _Py_bswap32()
+#include "pycore_bytesobject.h"  // _PyBytes_Find()
 #include "pycore_fileutils.h"    // _Py_normpath
 #include "pycore_frame.h"        // _PyInterpreterFrame
 #include "pycore_gc.h"           // PyGC_Head
@@ -380,6 +381,118 @@ test_edit_cost(PyObject *self, PyObject
 }
 
 
+static int
+check_bytes_find(const char *haystack0, const char *needle0,
+                 int offset, Py_ssize_t expected)
+{
+    Py_ssize_t len_haystack = strlen(haystack0);
+    Py_ssize_t len_needle = strlen(needle0);
+    Py_ssize_t result_1 = _PyBytes_Find(haystack0, len_haystack,
+                                        needle0, len_needle, offset);
+    if (result_1 != expected) {
+        PyErr_Format(PyExc_AssertionError,
+                    "Incorrect result_1: '%s' in '%s' (offset=%zd)",
+                    needle0, haystack0, offset);
+        return -1;
+    }
+    // Allocate new buffer with no NULL terminator.
+    char *haystack = PyMem_Malloc(len_haystack);
+    if (haystack == NULL) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    char *needle = PyMem_Malloc(len_needle);
+    if (needle == NULL) {
+        PyMem_Free(haystack);
+        PyErr_NoMemory();
+        return -1;
+    }
+    memcpy(haystack, haystack0, len_haystack);
+    memcpy(needle, needle0, len_needle);
+    Py_ssize_t result_2 = _PyBytes_Find(haystack, len_haystack,
+                                        needle, len_needle, offset);
+    PyMem_Free(haystack);
+    PyMem_Free(needle);
+    if (result_2 != expected) {
+        PyErr_Format(PyExc_AssertionError,
+                    "Incorrect result_2: '%s' in '%s' (offset=%zd)",
+                    needle0, haystack0, offset);
+        return -1;
+    }
+    return 0;
+}
+
+static int
+check_bytes_find_large(Py_ssize_t len_haystack, Py_ssize_t len_needle,
+                       const char *needle)
+{
+    char *zeros = PyMem_RawCalloc(len_haystack, 1);
+    if (zeros == NULL) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    Py_ssize_t res = _PyBytes_Find(zeros, len_haystack, needle, len_needle, 0);
+    PyMem_RawFree(zeros);
+    if (res != -1) {
+        PyErr_Format(PyExc_AssertionError,
+                    "check_bytes_find_large(%zd, %zd) found %zd",
+                    len_haystack, len_needle, res);
+        return -1;
+    }
+    return 0;
+}
+
+static PyObject *
+test_bytes_find(PyObject *self, PyObject *Py_UNUSED(args))
+{
+    #define CHECK(H, N, O, E) do {               \
+        if (check_bytes_find(H, N, O, E) < 0) {  \
+            return NULL;                         \
+        }                                        \
+    } while (0)
+
+    CHECK("", "", 0, 0);
+    CHECK("Python", "", 0, 0);
+    CHECK("Python", "", 3, 3);
+    CHECK("Python", "", 6, 6);
+    CHECK("Python", "yth", 0, 1);
+    CHECK("ython", "yth", 1, 1);
+    CHECK("thon", "yth", 2, -1);
+    CHECK("Python", "thon", 0, 2);
+    CHECK("ython", "thon", 1, 2);
+    CHECK("thon", "thon", 2, 2);
+    CHECK("hon", "thon", 3, -1);
+    CHECK("Pytho", "zz", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "ab", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "ba", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bb", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab", "ab", 0, 30);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba", "ba", 0, 30);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb", "bb", 0, 30);
+    #undef CHECK
+
+    // Hunt for segfaults
+    // n, m chosen here so that (n - m) % (m + 1) == 0
+    // This would make default_find in fastsearch.h access haystack[n].
+    if (check_bytes_find_large(2048, 2, "ab") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(4096, 16, "0123456789abcdef") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(8192, 2, "ab") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(16384, 4, "abcd") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(32768, 2, "ab") < 0) {
+        return NULL;
+    }
+    Py_RETURN_NONE;
+}
+
+
 static PyObject *
 normalize_path(PyObject *self, PyObject *filename)
 {
@@ -537,6 +650,7 @@ static PyMethodDef TestMethods[] = {
     {"reset_path_config", test_reset_path_config, METH_NOARGS},
     {"test_atomic_funcs", test_atomic_funcs, METH_NOARGS},
     {"test_edit_cost", test_edit_cost, METH_NOARGS},
+    {"test_bytes_find", test_bytes_find, METH_NOARGS},
     {"normalize_path", normalize_path, METH_O, NULL},
     {"get_getpath_codeobject", get_getpath_codeobject, METH_NOARGS, NULL},
     {"EncodeLocaleEx", encode_locale_ex, METH_VARARGS},
@@ -568,7 +682,7 @@ PyInit__testinternalcapi(void)
         return NULL;
     }
 
-    if (PyModule_AddObject(module, "SIZEOF_PYGC_HEAD",
+    if (_PyModule_Add(module, "SIZEOF_PYGC_HEAD",
                            PyLong_FromSsize_t(sizeof(PyGC_Head))) < 0) {
         goto error;
     }
--- a/Modules/_threadmodule.c
+++ b/Modules/_threadmodule.c
@@ -1648,8 +1648,8 @@ thread_module_exec(PyObject *module)
     // Round towards minus infinity
     timeout_max = floor(timeout_max);
 
-    if (PyModule_AddObject(module, "TIMEOUT_MAX",
-                           PyFloat_FromDouble(timeout_max)) < 0) {
+    if (_PyModule_Add(module, "TIMEOUT_MAX",
+                        PyFloat_FromDouble(timeout_max)) < 0) {
         return -1;
     }
 
--- a/Modules/_tkinter.c
+++ b/Modules/_tkinter.c
@@ -906,8 +906,9 @@ asBignumObj(PyObject *value)
         return NULL;
     }
     hexchars += neg + 2; /* skip sign and "0x" */
-    mp_init(&bigValue);
-    if (mp_read_radix(&bigValue, hexchars, 16) != MP_OKAY) {
+    if (mp_init(&bigValue) != MP_OKAY ||
+        mp_read_radix(&bigValue, hexchars, 16) != MP_OKAY)
+    {
         mp_clear(&bigValue);
         Py_DECREF(hexstr);
         PyErr_NoMemory();
--- a/Modules/_winapi.c
+++ b/Modules/_winapi.c
@@ -805,6 +805,17 @@ getenvironment(PyObject* environment)
     }
 
     envsize = PyList_GET_SIZE(keys);
+
+    if (envsize == 0) {
+        // A environment block must be terminated by two null characters --
+        // one for the last string and one for the block.
+        buffer = PyMem_Calloc(2, sizeof(wchar_t));
+        if (!buffer) {
+            PyErr_NoMemory();
+        }
+        goto cleanup;
+    }
+
     if (PyList_GET_SIZE(values) != envsize) {
         PyErr_SetString(PyExc_RuntimeError,
             "environment changed size during iteration");
@@ -878,7 +889,8 @@ getenvironment(PyObject* environment)
     *p++ = L'\0';
     assert(p == end);
 
- error:
+cleanup:
+error:
     Py_XDECREF(keys);
     Py_XDECREF(values);
     return buffer;
--- a/Modules/_zoneinfo.c
+++ b/Modules/_zoneinfo.c
@@ -581,14 +581,19 @@ zoneinfo_fromutc(PyObject *obj_self, PyO
         }
         else {
             PyObject *replace = PyObject_GetAttrString(tmp, "replace");
+            Py_DECREF(tmp);
+            if (replace == NULL) {
+                return NULL;
+            }
             PyObject *args = PyTuple_New(0);
+            if (args == NULL) {
+                Py_DECREF(replace);
+                return NULL;
+            }
             PyObject *kwargs = PyDict_New();
-
-            Py_DECREF(tmp);
-            if (args == NULL || kwargs == NULL || replace == NULL) {
-                Py_XDECREF(args);
-                Py_XDECREF(kwargs);
-                Py_XDECREF(replace);
+            if (kwargs == NULL) {
+                Py_DECREF(replace);
+                Py_DECREF(args);
                 return NULL;
             }
 
--- a/Modules/arraymodule.c
+++ b/Modules/arraymodule.c
@@ -741,10 +741,12 @@ array_richcompare(PyObject *v, PyObject
     k = 1;
     for (i = 0; i < Py_SIZE(va) && i < Py_SIZE(wa); i++) {
         vi = getarrayitem(v, i);
+        if (vi == NULL) {
+            return NULL;
+        }
         wi = getarrayitem(w, i);
-        if (vi == NULL || wi == NULL) {
-            Py_XDECREF(vi);
-            Py_XDECREF(wi);
+        if (wi == NULL) {
+            Py_DECREF(vi);
             return NULL;
         }
         k = PyObject_RichCompareBool(vi, wi, Py_EQ);
--- a/Modules/cmathmodule.c
+++ b/Modules/cmathmodule.c
@@ -1264,30 +1264,28 @@ static PyMethodDef cmath_methods[] = {
 static int
 cmath_exec(PyObject *mod)
 {
-    if (PyModule_AddObject(mod, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
+    if (_PyModule_Add(mod, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(mod, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
+    if (_PyModule_Add(mod, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
         return -1;
     }
     // 2pi
-    if (PyModule_AddObject(mod, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
+    if (_PyModule_Add(mod, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(mod, "inf", PyFloat_FromDouble(m_inf())) < 0) {
+    if (_PyModule_Add(mod, "inf", PyFloat_FromDouble(m_inf())) < 0) {
         return -1;
     }
 
-    if (PyModule_AddObject(mod, "infj",
-                           PyComplex_FromCComplex(c_infj())) < 0) {
+    if (_PyModule_Add(mod, "infj", PyComplex_FromCComplex(c_infj())) < 0) {
         return -1;
     }
 #if _PY_SHORT_FLOAT_REPR == 1
-    if (PyModule_AddObject(mod, "nan", PyFloat_FromDouble(m_nan())) < 0) {
+    if (_PyModule_Add(mod, "nan", PyFloat_FromDouble(m_nan())) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(mod, "nanj",
-                           PyComplex_FromCComplex(c_nanj())) < 0) {
+    if (_PyModule_Add(mod, "nanj", PyComplex_FromCComplex(c_nanj())) < 0) {
         return -1;
     }
 #endif
--- a/Modules/errnomodule.c
+++ b/Modules/errnomodule.c
@@ -79,9 +79,12 @@ end:
 static int
 errno_exec(PyObject *module)
 {
-    PyObject *module_dict = PyModule_GetDict(module);
+    PyObject *module_dict = PyModule_GetDict(module);  // Borrowed ref.
+    if (module_dict == NULL) {
+        return -1;
+    }
     PyObject *error_dict = PyDict_New();
-    if (!module_dict || !error_dict) {
+    if (error_dict == NULL) {
         return -1;
     }
     if (PyDict_SetItemString(module_dict, "errorcode", error_dict) < 0) {
--- a/Modules/grpmodule.c
+++ b/Modules/grpmodule.c
@@ -65,8 +65,14 @@ mkgrent(PyObject *module, struct group *
         Py_DECREF(v);
         return NULL;
     }
-    for (member = p->gr_mem; *member != NULL; member++) {
-        PyObject *x = PyUnicode_DecodeFSDefault(*member);
+    for (member = p->gr_mem; ; member++) {
+        char *group_member;
+        // member can be misaligned
+        memcpy(&group_member, member, sizeof(group_member));
+        if (group_member == NULL) {
+            break;
+        }
+        PyObject *x = PyUnicode_DecodeFSDefault(group_member);
         if (x == NULL || PyList_Append(w, x) != 0) {
             Py_XDECREF(x);
             Py_DECREF(w);
--- a/Modules/mathmodule.c
+++ b/Modules/mathmodule.c
@@ -3825,21 +3825,21 @@ math_ulp_impl(PyObject *module, double x
 static int
 math_exec(PyObject *module)
 {
-    if (PyModule_AddObject(module, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
+    if (_PyModule_Add(module, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(module, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
+    if (_PyModule_Add(module, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
         return -1;
     }
     // 2pi
-    if (PyModule_AddObject(module, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
+    if (_PyModule_Add(module, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(module, "inf", PyFloat_FromDouble(m_inf())) < 0) {
+    if (_PyModule_Add(module, "inf", PyFloat_FromDouble(m_inf())) < 0) {
         return -1;
     }
 #if _PY_SHORT_FLOAT_REPR == 1
-    if (PyModule_AddObject(module, "nan", PyFloat_FromDouble(m_nan())) < 0) {
+    if (_PyModule_Add(module, "nan", PyFloat_FromDouble(m_nan())) < 0) {
         return -1;
     }
 #endif
--- a/Modules/mmapmodule.c
+++ b/Modules/mmapmodule.c
@@ -351,12 +351,17 @@ mmap_gfind(mmap_object *self,
 
         Py_ssize_t res;
         CHECK_VALID_OR_RELEASE(NULL, view);
-        if (reverse) {
+        if (end < start) {
+            res = -1;
+        }
+        else if (reverse) {
+            assert(0 <= start && start <= end && end <= self->size);
             res = _PyBytes_ReverseFind(
                 self->data + start, end - start,
                 view.buf, view.len, start);
         }
         else {
+            assert(0 <= start && start <= end && end <= self->size);
             res = _PyBytes_Find(
                 self->data + start, end - start,
                 view.buf, view.len, start);
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -280,7 +280,7 @@ corresponding Unix manual entries for mo
 #  undef HAVE_SCHED_SETAFFINITY
 #endif
 
-#if defined(HAVE_SYS_XATTR_H) && defined(__linux__) && !defined(__FreeBSD_kernel__) && !defined(__GNU__)
+#if defined(HAVE_SYS_XATTR_H) && defined(HAVE_LINUX_LIMITS_H) && !defined(__FreeBSD_kernel__) && !defined(__GNU__)
 #  define USE_XATTRS
 #  include <linux/limits.h>  // Needed for XATTR_SIZE_MAX on musl libc.
 #endif
@@ -5691,7 +5691,7 @@ parse_envlist(PyObject* env, Py_ssize_t
 {
     Py_ssize_t i, pos, envc;
     PyObject *keys=NULL, *vals=NULL;
-    PyObject *key, *val, *key2, *val2, *keyval;
+    PyObject *key2, *val2, *keyval;
     EXECV_CHAR **envlist;
 
     i = PyMapping_Size(env);
@@ -5716,10 +5716,14 @@ parse_envlist(PyObject* env, Py_ssize_t
     }
 
     for (pos = 0; pos < i; pos++) {
-        key = PyList_GetItem(keys, pos);
-        val = PyList_GetItem(vals, pos);
-        if (!key || !val)
+        PyObject *key = PyList_GetItem(keys, pos);  // Borrowed ref.
+        if (key == NULL) {
             goto error;
+        }
+        PyObject *val = PyList_GetItem(vals, pos);  // Borrowed ref.
+        if (val == NULL) {
+            goto error;
+        }
 
 #if defined(HAVE_WEXECV) || defined(HAVE_WSPAWNV)
         if (!PyUnicode_FSDecoder(key, &key2))
@@ -12559,7 +12563,7 @@ setup_confname_table(struct constdef *ta
         }
         Py_DECREF(o);
     }
-    return PyModule_AddObject(module, tablename, d);
+    return _PyModule_Add(module, tablename, d);
 }
 
 /* Return -1 on failure, 0 on success. */
@@ -15833,11 +15837,9 @@ posixmodule_exec(PyObject *m)
 #endif
 
     /* Initialize environ dictionary */
-    PyObject *v = convertenviron();
-    Py_XINCREF(v);
-    if (v == NULL || PyModule_AddObject(m, "environ", v) != 0)
+    if (_PyModule_Add(m, "environ", convertenviron()) != 0) {
         return -1;
-    Py_DECREF(v);
+    }
 
     if (all_ins(m))
         return -1;
@@ -15845,42 +15847,34 @@ posixmodule_exec(PyObject *m)
     if (setup_confname_tables(m))
         return -1;
 
-    Py_INCREF(PyExc_OSError);
-    PyModule_AddObject(m, "error", PyExc_OSError);
+    if (PyModule_AddObjectRef(m, "error", PyExc_OSError) < 0) {
+        return -1;
+    }
 
 #if defined(HAVE_WAITID) && !defined(__APPLE__)
     waitid_result_desc.name = MODNAME ".waitid_result";
-    PyObject *WaitidResultType = (PyObject *)PyStructSequence_NewType(&waitid_result_desc);
-    if (WaitidResultType == NULL) {
+    state->WaitidResultType = (PyObject *)PyStructSequence_NewType(&waitid_result_desc);
+    if (PyModule_AddObjectRef(m, "waitid_result", state->WaitidResultType) < 0) {
         return -1;
     }
-    Py_INCREF(WaitidResultType);
-    PyModule_AddObject(m, "waitid_result", WaitidResultType);
-    state->WaitidResultType = WaitidResultType;
 #endif
 
     stat_result_desc.name = "os.stat_result"; /* see issue #19209 */
     stat_result_desc.fields[7].name = PyStructSequence_UnnamedField;
     stat_result_desc.fields[8].name = PyStructSequence_UnnamedField;
     stat_result_desc.fields[9].name = PyStructSequence_UnnamedField;
-    PyObject *StatResultType = (PyObject *)PyStructSequence_NewType(&stat_result_desc);
-    if (StatResultType == NULL) {
+    state->StatResultType = (PyObject *)PyStructSequence_NewType(&stat_result_desc);
+    if (PyModule_AddObjectRef(m, "stat_result", state->StatResultType) < 0) {
         return -1;
     }
-    Py_INCREF(StatResultType);
-    PyModule_AddObject(m, "stat_result", StatResultType);
-    state->StatResultType = StatResultType;
-    structseq_new = ((PyTypeObject *)StatResultType)->tp_new;
-    ((PyTypeObject *)StatResultType)->tp_new = statresult_new;
+    structseq_new = ((PyTypeObject *)state->StatResultType)->tp_new;
+    ((PyTypeObject *)state->StatResultType)->tp_new = statresult_new;
 
     statvfs_result_desc.name = "os.statvfs_result"; /* see issue #19209 */
-    PyObject *StatVFSResultType = (PyObject *)PyStructSequence_NewType(&statvfs_result_desc);
-    if (StatVFSResultType == NULL) {
+    state->StatVFSResultType = (PyObject *)PyStructSequence_NewType(&statvfs_result_desc);
+    if (PyModule_AddObjectRef(m, "statvfs_result", state->StatVFSResultType) < 0) {
         return -1;
     }
-    Py_INCREF(StatVFSResultType);
-    PyModule_AddObject(m, "statvfs_result", StatVFSResultType);
-    state->StatVFSResultType = StatVFSResultType;
 #ifdef NEED_TICKS_PER_SECOND
 #  if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
     ticks_per_second = sysconf(_SC_CLK_TCK);
@@ -15893,24 +15887,18 @@ posixmodule_exec(PyObject *m)
 
 #if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)
     sched_param_desc.name = MODNAME ".sched_param";
-    PyObject *SchedParamType = (PyObject *)PyStructSequence_NewType(&sched_param_desc);
-    if (SchedParamType == NULL) {
+    state->SchedParamType = (PyObject *)PyStructSequence_NewType(&sched_param_desc);
+    if (PyModule_AddObjectRef(m, "sched_param", state->SchedParamType) < 0) {
         return -1;
     }
-    Py_INCREF(SchedParamType);
-    PyModule_AddObject(m, "sched_param", SchedParamType);
-    state->SchedParamType = SchedParamType;
-    ((PyTypeObject *)SchedParamType)->tp_new = os_sched_param;
+    ((PyTypeObject *)state->SchedParamType)->tp_new = os_sched_param;
 #endif
 
     /* initialize TerminalSize_info */
-    PyObject *TerminalSizeType = (PyObject *)PyStructSequence_NewType(&TerminalSize_desc);
-    if (TerminalSizeType == NULL) {
+    state->TerminalSizeType = (PyObject *)PyStructSequence_NewType(&TerminalSize_desc);
+    if (PyModule_AddObjectRef(m, "terminal_size", state->TerminalSizeType) < 0) {
         return -1;
     }
-    Py_INCREF(TerminalSizeType);
-    PyModule_AddObject(m, "terminal_size", TerminalSizeType);
-    state->TerminalSizeType = TerminalSizeType;
 
     /* initialize scandir types */
     PyObject *ScandirIteratorType = PyType_FromModuleAndSpec(m, &ScandirIteratorType_spec, NULL);
@@ -15919,30 +15907,21 @@ posixmodule_exec(PyObject *m)
     }
     state->ScandirIteratorType = ScandirIteratorType;
 
-    PyObject *DirEntryType = PyType_FromModuleAndSpec(m, &DirEntryType_spec, NULL);
-    if (DirEntryType == NULL) {
+    state->DirEntryType = PyType_FromModuleAndSpec(m, &DirEntryType_spec, NULL);
+    if (PyModule_AddObjectRef(m, "DirEntry", state->DirEntryType) < 0) {
         return -1;
     }
-    Py_INCREF(DirEntryType);
-    PyModule_AddObject(m, "DirEntry", DirEntryType);
-    state->DirEntryType = DirEntryType;
 
     times_result_desc.name = MODNAME ".times_result";
-    PyObject *TimesResultType = (PyObject *)PyStructSequence_NewType(&times_result_desc);
-    if (TimesResultType == NULL) {
+    state->TimesResultType = (PyObject *)PyStructSequence_NewType(&times_result_desc);
+    if (PyModule_AddObjectRef(m, "times_result", state->TimesResultType) < 0) {
         return -1;
     }
-    Py_INCREF(TimesResultType);
-    PyModule_AddObject(m, "times_result", TimesResultType);
-    state->TimesResultType = TimesResultType;
 
-    PyTypeObject *UnameResultType = PyStructSequence_NewType(&uname_result_desc);
-    if (UnameResultType == NULL) {
+    state->UnameResultType = (PyObject *)PyStructSequence_NewType(&uname_result_desc);
+    if (PyModule_AddObjectRef(m, "uname_result", state->UnameResultType) < 0) {
         return -1;
     }
-    Py_INCREF(UnameResultType);
-    PyModule_AddObject(m, "uname_result", (PyObject *)UnameResultType);
-    state->UnameResultType = (PyObject *)UnameResultType;
 
     if ((state->billion = PyLong_FromLong(1000000000)) == NULL)
         return -1;
@@ -15984,9 +15963,7 @@ posixmodule_exec(PyObject *m)
         Py_DECREF(unicode);
     }
 
-    PyModule_AddObject(m, "_have_functions", list);
-
-    return 0;
+    return _PyModule_Add(m, "_have_functions", list);
 }
 
 
--- a/Modules/pyexpat.c
+++ b/Modules/pyexpat.c
@@ -1768,14 +1768,18 @@ add_error(PyObject *errors_module, PyObj
 static int
 add_errors_module(PyObject *mod)
 {
+    // add_submodule() returns a borrowed ref.
     PyObject *errors_module = add_submodule(mod, MODULE_NAME ".errors");
     if (errors_module == NULL) {
         return -1;
     }
 
     PyObject *codes_dict = PyDict_New();
+    if (codes_dict == NULL) {
+        return -1;
+    }
     PyObject *rev_codes_dict = PyDict_New();
-    if (codes_dict == NULL || rev_codes_dict == NULL) {
+    if (rev_codes_dict == NULL) {
         goto error;
     }
 
@@ -1796,19 +1800,17 @@ add_errors_module(PyObject *mod)
         goto error;
     }
 
-    Py_INCREF(codes_dict);
-    if (PyModule_AddObject(errors_module, "codes", codes_dict) < 0) {
-        Py_DECREF(codes_dict);
+    int rc = PyModule_AddObjectRef(errors_module, "codes", codes_dict);
+    Py_CLEAR(codes_dict);
+    if (rc < 0) {
         goto error;
     }
-    Py_CLEAR(codes_dict);
 
-    Py_INCREF(rev_codes_dict);
-    if (PyModule_AddObject(errors_module, "messages", rev_codes_dict) < 0) {
-        Py_DECREF(rev_codes_dict);
+    rc = PyModule_AddObjectRef(errors_module, "messages", rev_codes_dict);
+    Py_CLEAR(rev_codes_dict);
+    if (rc < 0) {
         goto error;
     }
-    Py_CLEAR(rev_codes_dict);
 
     return 0;
 
--- a/Modules/socketmodule.c
+++ b/Modules/socketmodule.c
@@ -5657,9 +5657,15 @@ gethost_common(struct hostent *h, struct
 
     /* SF #1511317: h_aliases can be NULL */
     if (h->h_aliases) {
-        for (pch = h->h_aliases; *pch != NULL; pch++) {
+        for (pch = h->h_aliases; ; pch++) {
             int status;
-            tmp = PyUnicode_FromString(*pch);
+            char *host_alias;
+            // pch can be misaligned
+            memcpy(&host_alias, pch, sizeof(host_alias));
+            if (host_alias == NULL) {
+                break;
+            }
+            tmp = PyUnicode_FromString(host_alias);
             if (tmp == NULL)
                 goto err;
 
@@ -5671,8 +5677,14 @@ gethost_common(struct hostent *h, struct
         }
     }
 
-    for (pch = h->h_addr_list; *pch != NULL; pch++) {
+    for (pch = h->h_addr_list; ; pch++) {
         int status;
+        char *host_address;
+        // pch can be misaligned
+        memcpy(&host_address, pch, sizeof(host_address));
+        if (host_address == NULL) {
+            break;
+        }
 
         switch (af) {
 
@@ -5684,7 +5696,7 @@ gethost_common(struct hostent *h, struct
 #ifdef HAVE_SOCKADDR_SA_LEN
             sin.sin_len = sizeof(sin);
 #endif
-            memcpy(&sin.sin_addr, *pch, sizeof(sin.sin_addr));
+            memcpy(&sin.sin_addr, host_address, sizeof(sin.sin_addr));
             tmp = make_ipv4_addr(&sin);
 
             if (pch == h->h_addr_list && alen >= sizeof(sin))
@@ -5701,7 +5713,7 @@ gethost_common(struct hostent *h, struct
 #ifdef HAVE_SOCKADDR_SA_LEN
             sin6.sin6_len = sizeof(sin6);
 #endif
-            memcpy(&sin6.sin6_addr, *pch, sizeof(sin6.sin6_addr));
+            memcpy(&sin6.sin6_addr, host_address, sizeof(sin6.sin6_addr));
             tmp = make_ipv6_addr(&sin6);
 
             if (pch == h->h_addr_list && alen >= sizeof(sin6))
--- a/Modules/timemodule.c
+++ b/Modules/timemodule.c
@@ -1775,11 +1775,9 @@ init_timezone(PyObject *m)
         return -1;
     }
 #endif // MS_WINDOWS
-    PyObject *tzname_obj = Py_BuildValue("(NN)", otz0, otz1);
-    if (tzname_obj == NULL) {
+    if (_PyModule_Add(m, "tzname", Py_BuildValue("(NN)", otz0, otz1)) < 0) {
         return -1;
     }
-    PyModule_AddObject(m, "tzname", tzname_obj);
 #else // !HAVE_DECL_TZNAME
     static const time_t YEAR = (365 * 24 + 6) * 3600;
     time_t t;
@@ -1822,10 +1820,9 @@ init_timezone(PyObject *m)
         PyModule_AddIntConstant(m, "daylight", janzone != julyzone);
         tzname_obj = Py_BuildValue("(zz)", janname, julyname);
     }
-    if (tzname_obj == NULL) {
+    if (_PyModule_Add(m, "tzname", tzname_obj) < 0) {
         return -1;
     }
-    PyModule_AddObject(m, "tzname", tzname_obj);
 #endif // !HAVE_DECL_TZNAME
 
     if (PyErr_Occurred()) {
--- a/Modules/xxsubtype.c
+++ b/Modules/xxsubtype.c
@@ -279,14 +279,12 @@ xxsubtype_exec(PyObject* m)
     if (PyType_Ready(&spamdict_type) < 0)
         return -1;
 
-    Py_INCREF(&spamlist_type);
-    if (PyModule_AddObject(m, "spamlist",
-                           (PyObject *) &spamlist_type) < 0)
+    if (PyModule_AddObjectRef(m, "spamlist",
+                              (PyObject *) &spamlist_type) < 0)
         return -1;
 
-    Py_INCREF(&spamdict_type);
-    if (PyModule_AddObject(m, "spamdict",
-                           (PyObject *) &spamdict_type) < 0)
+    if (PyModule_AddObjectRef(m, "spamdict",
+                              (PyObject *) &spamdict_type) < 0)
         return -1;
     return 0;
 }
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -1283,8 +1283,25 @@ _PyBytes_Find(const char *haystack, Py_s
               const char *needle, Py_ssize_t len_needle,
               Py_ssize_t offset)
 {
-    return stringlib_find(haystack, len_haystack,
-                          needle, len_needle, offset);
+    assert(len_haystack >= 0);
+    assert(len_needle >= 0);
+    // Extra checks because stringlib_find accesses haystack[len_haystack].
+    if (len_needle == 0) {
+        return offset;
+    }
+    if (len_needle > len_haystack) {
+        return -1;
+    }
+    assert(len_haystack >= 1);
+    Py_ssize_t res = stringlib_find(haystack, len_haystack - 1,
+                                    needle, len_needle, offset);
+    if (res == -1) {
+        Py_ssize_t last_align = len_haystack - len_needle;
+        if (memcmp(haystack + last_align, needle, len_needle) == 0) {
+            return offset + last_align;
+        }
+    }
+    return res;
 }
 
 Py_ssize_t
--- a/Objects/clinic/codeobject.c.h
+++ b/Objects/clinic/codeobject.c.h
@@ -157,12 +157,7 @@ exit:
 }
 
 PyDoc_STRVAR(code_replace__doc__,
-"replace($self, /, *, co_argcount=-1, co_posonlyargcount=-1,\n"
-"        co_kwonlyargcount=-1, co_nlocals=-1, co_stacksize=-1,\n"
-"        co_flags=-1, co_firstlineno=-1, co_code=None, co_consts=None,\n"
-"        co_names=None, co_varnames=None, co_freevars=None,\n"
-"        co_cellvars=None, co_filename=None, co_name=None,\n"
-"        co_qualname=None, co_linetable=None, co_exceptiontable=None)\n"
+"replace($self, /, **changes)\n"
 "--\n"
 "\n"
 "Return a copy of the code object with new values for the specified fields.");
@@ -174,13 +169,12 @@ static PyObject *
 code_replace_impl(PyCodeObject *self, int co_argcount,
                   int co_posonlyargcount, int co_kwonlyargcount,
                   int co_nlocals, int co_stacksize, int co_flags,
-                  int co_firstlineno, PyBytesObject *co_code,
-                  PyObject *co_consts, PyObject *co_names,
-                  PyObject *co_varnames, PyObject *co_freevars,
-                  PyObject *co_cellvars, PyObject *co_filename,
-                  PyObject *co_name, PyObject *co_qualname,
-                  PyBytesObject *co_linetable,
-                  PyBytesObject *co_exceptiontable);
+                  int co_firstlineno, PyObject *co_code, PyObject *co_consts,
+                  PyObject *co_names, PyObject *co_varnames,
+                  PyObject *co_freevars, PyObject *co_cellvars,
+                  PyObject *co_filename, PyObject *co_name,
+                  PyObject *co_qualname, PyObject *co_linetable,
+                  PyObject *co_exceptiontable);
 
 static PyObject *
 code_replace(PyCodeObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
@@ -197,7 +191,7 @@ code_replace(PyCodeObject *self, PyObjec
     int co_stacksize = self->co_stacksize;
     int co_flags = self->co_flags;
     int co_firstlineno = self->co_firstlineno;
-    PyBytesObject *co_code = NULL;
+    PyObject *co_code = NULL;
     PyObject *co_consts = self->co_consts;
     PyObject *co_names = self->co_names;
     PyObject *co_varnames = NULL;
@@ -206,8 +200,8 @@ code_replace(PyCodeObject *self, PyObjec
     PyObject *co_filename = self->co_filename;
     PyObject *co_name = self->co_name;
     PyObject *co_qualname = self->co_qualname;
-    PyBytesObject *co_linetable = (PyBytesObject *)self->co_linetable;
-    PyBytesObject *co_exceptiontable = (PyBytesObject *)self->co_exceptiontable;
+    PyObject *co_linetable = self->co_linetable;
+    PyObject *co_exceptiontable = self->co_exceptiontable;
 
     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);
     if (!args) {
@@ -284,7 +278,7 @@ code_replace(PyCodeObject *self, PyObjec
             _PyArg_BadArgument("replace", "argument 'co_code'", "bytes", args[7]);
             goto exit;
         }
-        co_code = (PyBytesObject *)args[7];
+        co_code = args[7];
         if (!--noptargs) {
             goto skip_optional_kwonly;
         }
@@ -383,7 +377,7 @@ code_replace(PyCodeObject *self, PyObjec
             _PyArg_BadArgument("replace", "argument 'co_linetable'", "bytes", args[16]);
             goto exit;
         }
-        co_linetable = (PyBytesObject *)args[16];
+        co_linetable = args[16];
         if (!--noptargs) {
             goto skip_optional_kwonly;
         }
@@ -392,7 +386,7 @@ code_replace(PyCodeObject *self, PyObjec
         _PyArg_BadArgument("replace", "argument 'co_exceptiontable'", "bytes", args[17]);
         goto exit;
     }
-    co_exceptiontable = (PyBytesObject *)args[17];
+    co_exceptiontable = args[17];
 skip_optional_kwonly:
     return_value = code_replace_impl(self, co_argcount, co_posonlyargcount, co_kwonlyargcount, co_nlocals, co_stacksize, co_flags, co_firstlineno, co_code, co_consts, co_names, co_varnames, co_freevars, co_cellvars, co_filename, co_name, co_qualname, co_linetable, co_exceptiontable);
 
@@ -436,4 +430,4 @@ code__varname_from_oparg(PyCodeObject *s
 exit:
     return return_value;
 }
-/*[clinic end generated code: output=9c521b6c79f90ff7 input=a9049054013a1b77]*/
+/*[clinic end generated code: output=d1bbf51b746ca2d0 input=a9049054013a1b77]*/
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -1875,27 +1875,28 @@ code_linesiterator(PyCodeObject *code, P
 }
 
 /*[clinic input]
+@text_signature "($self, /, **changes)"
 code.replace
 
     *
-    co_argcount: int(c_default="self->co_argcount") = -1
-    co_posonlyargcount: int(c_default="self->co_posonlyargcount") = -1
-    co_kwonlyargcount: int(c_default="self->co_kwonlyargcount") = -1
-    co_nlocals: int(c_default="self->co_nlocals") = -1
-    co_stacksize: int(c_default="self->co_stacksize") = -1
-    co_flags: int(c_default="self->co_flags") = -1
-    co_firstlineno: int(c_default="self->co_firstlineno") = -1
-    co_code: PyBytesObject(c_default="NULL") = None
-    co_consts: object(subclass_of="&PyTuple_Type", c_default="self->co_consts") = None
-    co_names: object(subclass_of="&PyTuple_Type", c_default="self->co_names") = None
-    co_varnames: object(subclass_of="&PyTuple_Type", c_default="NULL") = None
-    co_freevars: object(subclass_of="&PyTuple_Type", c_default="NULL") = None
-    co_cellvars: object(subclass_of="&PyTuple_Type", c_default="NULL") = None
-    co_filename: unicode(c_default="self->co_filename") = None
-    co_name: unicode(c_default="self->co_name") = None
-    co_qualname: unicode(c_default="self->co_qualname") = None
-    co_linetable: PyBytesObject(c_default="(PyBytesObject *)self->co_linetable") = None
-    co_exceptiontable: PyBytesObject(c_default="(PyBytesObject *)self->co_exceptiontable") = None
+    co_argcount: int(c_default="self->co_argcount") = unchanged
+    co_posonlyargcount: int(c_default="self->co_posonlyargcount") = unchanged
+    co_kwonlyargcount: int(c_default="self->co_kwonlyargcount") = unchanged
+    co_nlocals: int(c_default="self->co_nlocals") = unchanged
+    co_stacksize: int(c_default="self->co_stacksize") = unchanged
+    co_flags: int(c_default="self->co_flags") = unchanged
+    co_firstlineno: int(c_default="self->co_firstlineno") = unchanged
+    co_code: object(subclass_of="&PyBytes_Type", c_default="NULL") = unchanged
+    co_consts: object(subclass_of="&PyTuple_Type", c_default="self->co_consts") = unchanged
+    co_names: object(subclass_of="&PyTuple_Type", c_default="self->co_names") = unchanged
+    co_varnames: object(subclass_of="&PyTuple_Type", c_default="NULL") = unchanged
+    co_freevars: object(subclass_of="&PyTuple_Type", c_default="NULL") = unchanged
+    co_cellvars: object(subclass_of="&PyTuple_Type", c_default="NULL") = unchanged
+    co_filename: unicode(c_default="self->co_filename") = unchanged
+    co_name: unicode(c_default="self->co_name") = unchanged
+    co_qualname: unicode(c_default="self->co_qualname") = unchanged
+    co_linetable: object(subclass_of="&PyBytes_Type", c_default="self->co_linetable") = unchanged
+    co_exceptiontable: object(subclass_of="&PyBytes_Type", c_default="self->co_exceptiontable") = unchanged
 
 Return a copy of the code object with new values for the specified fields.
 [clinic start generated code]*/
@@ -1904,14 +1905,13 @@ static PyObject *
 code_replace_impl(PyCodeObject *self, int co_argcount,
                   int co_posonlyargcount, int co_kwonlyargcount,
                   int co_nlocals, int co_stacksize, int co_flags,
-                  int co_firstlineno, PyBytesObject *co_code,
-                  PyObject *co_consts, PyObject *co_names,
-                  PyObject *co_varnames, PyObject *co_freevars,
-                  PyObject *co_cellvars, PyObject *co_filename,
-                  PyObject *co_name, PyObject *co_qualname,
-                  PyBytesObject *co_linetable,
-                  PyBytesObject *co_exceptiontable)
-/*[clinic end generated code: output=b6cd9988391d5711 input=f6f68e03571f8d7c]*/
+                  int co_firstlineno, PyObject *co_code, PyObject *co_consts,
+                  PyObject *co_names, PyObject *co_varnames,
+                  PyObject *co_freevars, PyObject *co_cellvars,
+                  PyObject *co_filename, PyObject *co_name,
+                  PyObject *co_qualname, PyObject *co_linetable,
+                  PyObject *co_exceptiontable)
+/*[clinic end generated code: output=e75c48a15def18b9 input=18e280e07846c122]*/
 {
 #define CHECK_INT_ARG(ARG) \
         if (ARG < 0) { \
@@ -1936,13 +1936,14 @@ code_replace_impl(PyCodeObject *self, in
         if (code == NULL) {
             return NULL;
         }
-        co_code = (PyBytesObject *)code;
+        co_code = code;
     }
 
     if (PySys_Audit("code.__new__", "OOOiiiiii",
                     co_code, co_filename, co_name, co_argcount,
                     co_posonlyargcount, co_kwonlyargcount, co_nlocals,
                     co_stacksize, co_flags) < 0) {
+        Py_XDECREF(code);
         return NULL;
     }
 
@@ -1974,10 +1975,10 @@ code_replace_impl(PyCodeObject *self, in
 
     co = PyCode_NewWithPosOnlyArgs(
         co_argcount, co_posonlyargcount, co_kwonlyargcount, co_nlocals,
-        co_stacksize, co_flags, (PyObject*)co_code, co_consts, co_names,
+        co_stacksize, co_flags, co_code, co_consts, co_names,
         co_varnames, co_freevars, co_cellvars, co_filename, co_name,
         co_qualname, co_firstlineno,
-        (PyObject*)co_linetable, (PyObject*)co_exceptiontable);
+        co_linetable, co_exceptiontable);
 
 error:
     Py_XDECREF(code);
--- a/Objects/exceptions.c
+++ b/Objects/exceptions.c
@@ -210,22 +210,21 @@ BaseException_add_note(PyObject *self, P
         return NULL;
     }
 
-    if (!PyObject_HasAttr(self, &_Py_ID(__notes__))) {
-        PyObject *new_notes = PyList_New(0);
-        if (new_notes == NULL) {
+    PyObject *notes;
+    if (_PyObject_LookupAttr(self, &_Py_ID(__notes__), &notes) < 0) {
+        return NULL;
+    }
+    if (notes == NULL) {
+        notes = PyList_New(0);
+        if (notes == NULL) {
             return NULL;
         }
-        if (PyObject_SetAttr(self, &_Py_ID(__notes__), new_notes) < 0) {
-            Py_DECREF(new_notes);
+        if (PyObject_SetAttr(self, &_Py_ID(__notes__), notes) < 0) {
+            Py_DECREF(notes);
             return NULL;
         }
-        Py_DECREF(new_notes);
-    }
-    PyObject *notes = PyObject_GetAttr(self, &_Py_ID(__notes__));
-    if (notes == NULL) {
-        return NULL;
     }
-    if (!PyList_Check(notes)) {
+    else if (!PyList_Check(notes)) {
         Py_DECREF(notes);
         PyErr_SetString(PyExc_TypeError, "Cannot add note: __notes__ is not a list");
         return NULL;
@@ -943,11 +942,11 @@ exceptiongroup_subset(
     PyException_SetContext(eg, PyException_GetContext(orig));
     PyException_SetCause(eg, PyException_GetCause(orig));
 
-    if (PyObject_HasAttr(orig, &_Py_ID(__notes__))) {
-        PyObject *notes = PyObject_GetAttr(orig, &_Py_ID(__notes__));
-        if (notes == NULL) {
-            goto error;
-        }
+    PyObject *notes;
+    if (_PyObject_LookupAttr(orig, &_Py_ID(__notes__), &notes) < 0) {
+        goto error;
+    }
+    if (notes) {
         if (PySequence_Check(notes)) {
             /* Make a copy so the parts have independent notes lists. */
             PyObject *notes_copy = PySequence_List(notes);
--- a/Objects/frameobject.c
+++ b/Objects/frameobject.c
@@ -851,9 +851,6 @@ frame_dealloc(PyFrameObject *f)
     /* It is the responsibility of the owning generator/coroutine
      * to have cleared the generator pointer */
 
-    assert(f->f_frame->owner != FRAME_OWNED_BY_GENERATOR ||
-        _PyFrame_GetGenerator(f->f_frame)->gi_frame_state == FRAME_CLEARED);
-
     if (_PyObject_GC_IS_TRACKED(f)) {
         _PyObject_GC_UNTRACK(f);
     }
@@ -861,10 +858,14 @@ frame_dealloc(PyFrameObject *f)
     Py_TRASHCAN_BEGIN(f, frame_dealloc);
     PyCodeObject *co = NULL;
 
+    /* GH-106092: If f->f_frame was on the stack and we reached the maximum
+     * nesting depth for deallocations, the trashcan may have delayed this
+     * deallocation until after f->f_frame is freed. Avoid dereferencing
+     * f->f_frame unless we know it still points to valid memory. */
+    _PyInterpreterFrame *frame = (_PyInterpreterFrame *)f->_f_frame_data;
+
     /* Kill all local variables including specials, if we own them */
-    if (f->f_frame->owner == FRAME_OWNED_BY_FRAME_OBJECT) {
-        assert(f->f_frame == (_PyInterpreterFrame *)f->_f_frame_data);
-        _PyInterpreterFrame *frame = (_PyInterpreterFrame *)f->_f_frame_data;
+    if (f->f_frame == frame && frame->owner == FRAME_OWNED_BY_FRAME_OBJECT) {
         /* Don't clear code object until the end */
         co = frame->f_code;
         frame->f_code = NULL;
--- a/Objects/moduleobject.c
+++ b/Objects/moduleobject.c
@@ -881,26 +881,20 @@ static PyObject *
 module_get_annotations(PyModuleObject *m, void *Py_UNUSED(ignored))
 {
     PyObject *dict = PyObject_GetAttr((PyObject *)m, &_Py_ID(__dict__));
-
-    if ((dict == NULL) || !PyDict_Check(dict)) {
+    if (dict == NULL) {
+        return NULL;
+    }
+    if (!PyDict_Check(dict)) {
         PyErr_Format(PyExc_TypeError, "<module>.__dict__ is not a dictionary");
-        Py_XDECREF(dict);
+        Py_DECREF(dict);
         return NULL;
     }
 
-    PyObject *annotations;
-    /* there's no _PyDict_GetItemId without WithError, so let's LBYL. */
-    if (PyDict_Contains(dict, &_Py_ID(__annotations__))) {
-        annotations = PyDict_GetItemWithError(dict, &_Py_ID(__annotations__));
-        /*
-        ** _PyDict_GetItemIdWithError could still fail,
-        ** for instance with a well-timed Ctrl-C or a MemoryError.
-        ** so let's be totally safe.
-        */
-        if (annotations) {
-            Py_INCREF(annotations);
-        }
-    } else {
+    PyObject *annotations = PyDict_GetItemWithError(dict, &_Py_ID(__annotations__));
+    if (annotations) {
+        Py_INCREF(annotations);
+    }
+    else if (!PyErr_Occurred()) {
         annotations = PyDict_New();
         if (annotations) {
             int result = PyDict_SetItem(
@@ -919,8 +913,10 @@ module_set_annotations(PyModuleObject *m
 {
     int ret = -1;
     PyObject *dict = PyObject_GetAttr((PyObject *)m, &_Py_ID(__dict__));
-
-    if ((dict == NULL) || !PyDict_Check(dict)) {
+    if (dict == NULL) {
+        return -1;
+    }
+    if (!PyDict_Check(dict)) {
         PyErr_Format(PyExc_TypeError, "<module>.__dict__ is not a dictionary");
         goto exit;
     }
@@ -928,19 +924,17 @@ module_set_annotations(PyModuleObject *m
     if (value != NULL) {
         /* set */
         ret = PyDict_SetItem(dict, &_Py_ID(__annotations__), value);
-        goto exit;
     }
-
-    /* delete */
-    if (!PyDict_Contains(dict, &_Py_ID(__annotations__))) {
-        PyErr_Format(PyExc_AttributeError, "__annotations__");
-        goto exit;
+    else {
+        /* delete */
+        ret = PyDict_DelItem(dict, &_Py_ID(__annotations__));
+        if (ret < 0 && PyErr_ExceptionMatches(PyExc_KeyError)) {
+            PyErr_SetString(PyExc_AttributeError, "__annotations__");
+        }
     }
 
-    ret = PyDict_DelItem(dict, &_Py_ID(__annotations__));
-
 exit:
-    Py_XDECREF(dict);
+    Py_DECREF(dict);
     return ret;
 }
 
--- a/Objects/typeobject.c
+++ b/Objects/typeobject.c
@@ -912,24 +912,16 @@ type_get_annotations(PyTypeObject *type,
     }
 
     PyObject *annotations;
-    /* there's no _PyDict_GetItemId without WithError, so let's LBYL. */
-    if (PyDict_Contains(type->tp_dict, &_Py_ID(__annotations__))) {
-        annotations = PyDict_GetItemWithError(
-                type->tp_dict, &_Py_ID(__annotations__));
-        /*
-        ** PyDict_GetItemWithError could still fail,
-        ** for instance with a well-timed Ctrl-C or a MemoryError.
-        ** so let's be totally safe.
-        */
-        if (annotations) {
-            if (Py_TYPE(annotations)->tp_descr_get) {
-                annotations = Py_TYPE(annotations)->tp_descr_get(
-                        annotations, NULL, (PyObject *)type);
-            } else {
-                Py_INCREF(annotations);
-            }
+    annotations = PyDict_GetItemWithError(type->tp_dict, &_Py_ID(__annotations__));
+    if (annotations) {
+        if (Py_TYPE(annotations)->tp_descr_get) {
+            annotations = Py_TYPE(annotations)->tp_descr_get(
+                    annotations, NULL, (PyObject *)type);
+        } else {
+            Py_INCREF(annotations);
         }
-    } else {
+    }
+    else if (!PyErr_Occurred()) {
         annotations = PyDict_New();
         if (annotations) {
             int result = PyDict_SetItem(
@@ -960,11 +952,10 @@ type_set_annotations(PyTypeObject *type,
         result = PyDict_SetItem(type->tp_dict, &_Py_ID(__annotations__), value);
     } else {
         /* delete */
-        if (!PyDict_Contains(type->tp_dict, &_Py_ID(__annotations__))) {
-            PyErr_Format(PyExc_AttributeError, "__annotations__");
-            return -1;
-        }
         result = PyDict_DelItem(type->tp_dict, &_Py_ID(__annotations__));
+        if (result < 0 && PyErr_ExceptionMatches(PyExc_KeyError)) {
+            PyErr_SetString(PyExc_AttributeError, "__annotations__");
+        }
     }
 
     if (result == 0) {
--- a/Objects/unicodeobject.c
+++ b/Objects/unicodeobject.c
@@ -5120,6 +5120,9 @@ unicode_decode_utf8(const char *s, Py_ss
     }
     s += ascii_decode(s, end, PyUnicode_1BYTE_DATA(u));
     if (s == end) {
+        if (consumed) {
+            *consumed = size;
+        }
         return u;
     }
 
@@ -8454,25 +8457,30 @@ PyUnicode_BuildEncodingMap(PyObject* str
 
     if (need_dict) {
         PyObject *result = PyDict_New();
-        PyObject *key, *value;
         if (!result)
             return NULL;
         for (i = 0; i < length; i++) {
-            key = PyLong_FromLong(PyUnicode_READ(kind, data, i));
-            value = PyLong_FromLong(i);
-            if (!key || !value)
-                goto failed1;
-            if (PyDict_SetItem(result, key, value) == -1)
-                goto failed1;
+            Py_UCS4 c = PyUnicode_READ(kind, data, i);
+            PyObject *key = PyLong_FromLong(c);
+            if (key == NULL) {
+                Py_DECREF(result);
+                return NULL;
+            }
+            PyObject *value = PyLong_FromLong(i);
+            if (value == NULL) {
+                Py_DECREF(key);
+                Py_DECREF(result);
+                return NULL;
+            }
+            int rc = PyDict_SetItem(result, key, value);
             Py_DECREF(key);
             Py_DECREF(value);
+            if (rc < 0) {
+                Py_DECREF(result);
+                return NULL;
+            }
         }
         return result;
-      failed1:
-        Py_XDECREF(key);
-        Py_XDECREF(value);
-        Py_DECREF(result);
-        return NULL;
     }
 
     /* Create a three-level trie */
--- a/Parser/asdl_c.py
+++ b/Parser/asdl_c.py
@@ -602,6 +602,7 @@ class Obj2ModVisitor(PickleVisitor):
         args = [f.name for f in prod.fields]
         args.extend([a.name for a in prod.attributes])
         self.emit("*out = %s(%s);" % (ast_func_name(name), self.buildArgs(args)), 1)
+        self.emit("if (*out == NULL) goto failed;", 1)
         self.emit("return 0;", 1)
         self.emit("failed:", 0)
         self.emit("Py_XDECREF(tmp);", 1)
--- a/Python/Python-ast.c
+++ b/Python/Python-ast.c
@@ -10309,6 +10309,7 @@ obj2ast_comprehension(struct ast_state *
         Py_CLEAR(tmp);
     }
     *out = _PyAST_comprehension(target, iter, ifs, is_async, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -10727,6 +10728,7 @@ obj2ast_arguments(struct ast_state *stat
     }
     *out = _PyAST_arguments(posonlyargs, args, vararg, kwonlyargs, kw_defaults,
                             kwarg, defaults, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -10866,6 +10868,7 @@ obj2ast_arg(struct ast_state *state, PyO
     }
     *out = _PyAST_arg(arg, annotation, type_comment, lineno, col_offset,
                       end_lineno, end_col_offset, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -10988,6 +10991,7 @@ obj2ast_keyword(struct ast_state *state,
     }
     *out = _PyAST_keyword(arg, value, lineno, col_offset, end_lineno,
                           end_col_offset, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -11110,6 +11114,7 @@ obj2ast_alias(struct ast_state *state, P
     }
     *out = _PyAST_alias(name, asname, lineno, col_offset, end_lineno,
                         end_col_offset, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -11159,6 +11164,7 @@ obj2ast_withitem(struct ast_state *state
         Py_CLEAR(tmp);
     }
     *out = _PyAST_withitem(context_expr, optional_vars, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -11246,6 +11252,7 @@ obj2ast_match_case(struct ast_state *sta
         Py_CLEAR(tmp);
     }
     *out = _PyAST_match_case(pattern, guard, body, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
--- a/Python/_warnings.c
+++ b/Python/_warnings.c
@@ -1231,25 +1231,29 @@ PyErr_WarnExplicit(PyObject *category, c
                    const char *module_str, PyObject *registry)
 {
     PyObject *message = PyUnicode_FromString(text);
+    if (message == NULL) {
+        return -1;
+    }
     PyObject *filename = PyUnicode_DecodeFSDefault(filename_str);
+    if (filename == NULL) {
+        Py_DECREF(message);
+        return -1;
+    }
     PyObject *module = NULL;
-    int ret = -1;
-
-    if (message == NULL || filename == NULL)
-        goto exit;
     if (module_str != NULL) {
         module = PyUnicode_FromString(module_str);
-        if (module == NULL)
-            goto exit;
+        if (module == NULL) {
+            Py_DECREF(filename);
+            Py_DECREF(message);
+            return -1;
+        }
     }
 
-    ret = PyErr_WarnExplicitObject(category, message, filename, lineno,
-                                   module, registry);
-
- exit:
-    Py_XDECREF(message);
+    int ret = PyErr_WarnExplicitObject(category, message, filename, lineno,
+                                       module, registry);
     Py_XDECREF(module);
-    Py_XDECREF(filename);
+    Py_DECREF(filename);
+    Py_DECREF(message);
     return ret;
 }
 
--- a/Python/bltinmodule.c
+++ b/Python/bltinmodule.c
@@ -2165,17 +2165,29 @@ builtin_input_impl(PyObject *module, PyO
 
         /* stdin is a text stream, so it must have an encoding. */
         stdin_encoding = PyObject_GetAttr(fin, &_Py_ID(encoding));
+        if (stdin_encoding == NULL) {
+            tty = 0;
+            goto _readline_errors;
+        }
         stdin_errors = PyObject_GetAttr(fin, &_Py_ID(errors));
-        if (!stdin_encoding || !stdin_errors ||
-                !PyUnicode_Check(stdin_encoding) ||
-                !PyUnicode_Check(stdin_errors)) {
+        if (stdin_errors == NULL) {
+            tty = 0;
+            goto _readline_errors;
+        }
+        if (!PyUnicode_Check(stdin_encoding) ||
+            !PyUnicode_Check(stdin_errors))
+        {
             tty = 0;
             goto _readline_errors;
         }
         stdin_encoding_str = PyUnicode_AsUTF8(stdin_encoding);
+        if (stdin_encoding_str == NULL) {
+            goto _readline_errors;
+        }
         stdin_errors_str = PyUnicode_AsUTF8(stdin_errors);
-        if (!stdin_encoding_str || !stdin_errors_str)
+        if (stdin_errors_str == NULL) {
             goto _readline_errors;
+        }
         tmp = PyObject_CallMethodNoArgs(fout, &_Py_ID(flush));
         if (tmp == NULL)
             PyErr_Clear();
@@ -2186,17 +2198,29 @@ builtin_input_impl(PyObject *module, PyO
             const char *stdout_encoding_str, *stdout_errors_str;
             PyObject *stringpo;
             stdout_encoding = PyObject_GetAttr(fout, &_Py_ID(encoding));
+            if (stdout_encoding == NULL) {
+                tty = 0;
+                goto _readline_errors;
+            }
             stdout_errors = PyObject_GetAttr(fout, &_Py_ID(errors));
-            if (!stdout_encoding || !stdout_errors ||
-                    !PyUnicode_Check(stdout_encoding) ||
-                    !PyUnicode_Check(stdout_errors)) {
+            if (stdout_errors == NULL) {
+                tty = 0;
+                goto _readline_errors;
+            }
+            if (!PyUnicode_Check(stdout_encoding) ||
+                !PyUnicode_Check(stdout_errors))
+            {
                 tty = 0;
                 goto _readline_errors;
             }
             stdout_encoding_str = PyUnicode_AsUTF8(stdout_encoding);
+            if (stdout_encoding_str == NULL) {
+                goto _readline_errors;
+            }
             stdout_errors_str = PyUnicode_AsUTF8(stdout_errors);
-            if (!stdout_encoding_str || !stdout_errors_str)
+            if (stdout_errors_str == NULL) {
                 goto _readline_errors;
+            }
             stringpo = PyObject_Str(prompt);
             if (stringpo == NULL)
                 goto _readline_errors;
--- a/Python/compile.c
+++ b/Python/compile.c
@@ -1736,8 +1736,12 @@ compiler_enter_scope(struct compiler *c,
     Py_INCREF(name);
     u->u_name = name;
     u->u_varnames = list2dict(u->u_ste->ste_varnames);
+    if (!u->u_varnames) {
+        compiler_unit_free(u);
+        return 0;
+    }
     u->u_cellvars = dictbytype(u->u_ste->ste_symbols, CELL, 0, 0);
-    if (!u->u_varnames || !u->u_cellvars) {
+    if (!u->u_cellvars) {
         compiler_unit_free(u);
         return 0;
     }
--- a/Python/import.c
+++ b/Python/import.c
@@ -1327,6 +1327,7 @@ unmarshal_frozen_code(struct frozen_info
     PyObject *co = PyMarshal_ReadObjectFromString(info->data, info->size);
     if (co == NULL) {
         /* Does not contain executable code. */
+        PyErr_Clear();
         set_frozen_error(FROZEN_INVALID, info->nameobj);
         return NULL;
     }
--- a/Python/initconfig.c
+++ b/Python/initconfig.c
@@ -49,7 +49,7 @@ Options (and corresponding environment v
          .pyc extension; also PYTHONOPTIMIZE=x\n\
 -OO    : do -O changes and also discard docstrings; add .opt-2 before\n\
          .pyc extension\n\
--P     : don't prepend a potentially unsafe path to sys.path\n\
+-P     : don't prepend a potentially unsafe path to sys.path; also PYTHONSAFEPATH\n\
 -q     : don't print version and copyright messages on interactive startup\n\
 -s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE\n\
 -S     : don't imply 'import site' on initialization\n\
@@ -132,7 +132,6 @@ static const char usage_envvars[] =
 "PYTHONSTARTUP: file executed on interactive startup (no default)\n"
 "PYTHONPATH   : '%lc'-separated list of directories prefixed to the\n"
 "               default module search path.  The result is sys.path.\n"
-"PYTHONSAFEPATH: don't prepend a potentially unsafe path to sys.path.\n"
 "PYTHONHOME   : alternate <prefix> directory (or <prefix>%lc<exec_prefix>).\n"
 "               The default module search path uses %s.\n"
 "PYTHONPLATLIBDIR : override sys.platlibdir.\n"
@@ -172,6 +171,7 @@ static const char usage_envvars[] =
 "                          (-X int_max_str_digits=number)\n"
 "PYTHONNOUSERSITE        : disable user site directory (-s)\n"
 "PYTHONOPTIMIZE          : enable level 1 optimizations (-O)\n"
+"PYTHONSAFEPATH          : don't prepend a potentially unsafe path to sys.path (-P)\n"
 "PYTHONUNBUFFERED        : disable stdout/stderr buffering (-u)\n"
 "PYTHONVERBOSE           : trace import statements (-v)\n"
 "PYTHONWARNINGS=arg      : warning control (-W arg)\n";
--- a/Python/marshal.c
+++ b/Python/marshal.c
@@ -750,23 +750,28 @@ r_string(Py_ssize_t n, RFILE *p)
 static int
 r_byte(RFILE *p)
 {
-    int c = EOF;
-
     if (p->ptr != NULL) {
-        if (p->ptr < p->end)
-            c = (unsigned char) *p->ptr++;
-        return c;
+        if (p->ptr < p->end) {
+            return (unsigned char) *p->ptr++;
+        }
     }
-    if (!p->readable) {
+    else if (!p->readable) {
         assert(p->fp);
-        c = getc(p->fp);
+        int c = getc(p->fp);
+        if (c != EOF) {
+            return c;
+        }
     }
     else {
         const char *ptr = r_string(1, p);
-        if (ptr != NULL)
-            c = *(const unsigned char *) ptr;
+        if (ptr != NULL) {
+            return *(const unsigned char *) ptr;
+        }
+        return EOF;
     }
-    return c;
+    PyErr_SetString(PyExc_EOFError,
+                    "EOF read where not expected");
+    return EOF;
 }
 
 static int
@@ -827,10 +832,11 @@ r_PyLong(RFILE *p)
     digit d;
 
     n = r_long(p);
-    if (PyErr_Occurred())
-        return NULL;
     if (n == 0)
         return (PyObject *)_PyLong_New(0);
+    if (n == -1 && PyErr_Occurred()) {
+        return NULL;
+    }
     if (n < -SIZE32_MAX || n > SIZE32_MAX) {
         PyErr_SetString(PyExc_ValueError,
                        "bad marshal data (long size out of range)");
@@ -849,10 +855,6 @@ r_PyLong(RFILE *p)
         d = 0;
         for (j=0; j < PyLong_MARSHAL_RATIO; j++) {
             md = r_short(p);
-            if (PyErr_Occurred()) {
-                Py_DECREF(ob);
-                return NULL;
-            }
             if (md < 0 || md > PyLong_MARSHAL_BASE)
                 goto bad_digit;
             d += (digit)md << j*PyLong_MARSHAL_SHIFT;
@@ -863,10 +865,6 @@ r_PyLong(RFILE *p)
     d = 0;
     for (j=0; j < shorts_in_top_digit; j++) {
         md = r_short(p);
-        if (PyErr_Occurred()) {
-            Py_DECREF(ob);
-            return NULL;
-        }
         if (md < 0 || md > PyLong_MARSHAL_BASE)
             goto bad_digit;
         /* topmost marshal digit should be nonzero */
@@ -878,18 +876,17 @@ r_PyLong(RFILE *p)
         }
         d += (digit)md << j*PyLong_MARSHAL_SHIFT;
     }
-    if (PyErr_Occurred()) {
-        Py_DECREF(ob);
-        return NULL;
-    }
+    assert(!PyErr_Occurred());
     /* top digit should be nonzero, else the resulting PyLong won't be
        normalized */
     ob->ob_digit[size-1] = d;
     return (PyObject *)ob;
   bad_digit:
     Py_DECREF(ob);
-    PyErr_SetString(PyExc_ValueError,
-                    "bad marshal data (digit out of range in long)");
+    if (!PyErr_Occurred()) {
+        PyErr_SetString(PyExc_ValueError,
+                        "bad marshal data (digit out of range in long)");
+    }
     return NULL;
 }
 
@@ -912,8 +909,6 @@ r_float_str(RFILE *p)
     const char *ptr;
     n = r_byte(p);
     if (n == EOF) {
-        PyErr_SetString(PyExc_EOFError,
-            "EOF read where object expected");
         return -1;
     }
     ptr = r_string(n, p);
@@ -992,8 +987,10 @@ r_object(RFILE *p)
     PyObject *retval = NULL;
 
     if (code == EOF) {
-        PyErr_SetString(PyExc_EOFError,
-                        "EOF read where object expected");
+        if (PyErr_ExceptionMatches(PyExc_EOFError)) {
+            PyErr_SetString(PyExc_EOFError,
+                            "EOF read where object expected");
+        }
         return NULL;
     }
 
@@ -1045,7 +1042,10 @@ r_object(RFILE *p)
 
     case TYPE_INT:
         n = r_long(p);
-        retval = PyErr_Occurred() ? NULL : PyLong_FromLong(n);
+        if (n == -1 && PyErr_Occurred()) {
+            break;
+        }
+        retval = PyLong_FromLong(n);
         R_REF(retval);
         break;
 
@@ -1111,10 +1111,11 @@ r_object(RFILE *p)
         {
             const char *ptr;
             n = r_long(p);
-            if (PyErr_Occurred())
-                break;
             if (n < 0 || n > SIZE32_MAX) {
-                PyErr_SetString(PyExc_ValueError, "bad marshal data (bytes object size out of range)");
+                if (!PyErr_Occurred()) {
+                    PyErr_SetString(PyExc_ValueError,
+                        "bad marshal data (bytes object size out of range)");
+                }
                 break;
             }
             v = PyBytes_FromStringAndSize((char *)NULL, n);
@@ -1136,10 +1137,11 @@ r_object(RFILE *p)
         /* fall through */
     case TYPE_ASCII:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (string size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (string size out of range)");
+            }
             break;
         }
         goto _read_ascii;
@@ -1150,8 +1152,6 @@ r_object(RFILE *p)
     case TYPE_SHORT_ASCII:
         n = r_byte(p);
         if (n == EOF) {
-            PyErr_SetString(PyExc_EOFError,
-                "EOF read where object expected");
             break;
         }
     _read_ascii:
@@ -1178,10 +1178,11 @@ r_object(RFILE *p)
         const char *buffer;
 
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (string size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (string size out of range)");
+            }
             break;
         }
         if (n != 0) {
@@ -1203,16 +1204,18 @@ r_object(RFILE *p)
         }
 
     case TYPE_SMALL_TUPLE:
-        n = (unsigned char) r_byte(p);
-        if (PyErr_Occurred())
+        n = r_byte(p);
+        if (n == EOF) {
             break;
+        }
         goto _read_tuple;
     case TYPE_TUPLE:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (tuple size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (tuple size out of range)");
+            }
             break;
         }
     _read_tuple:
@@ -1238,10 +1241,11 @@ r_object(RFILE *p)
 
     case TYPE_LIST:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (list size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (list size out of range)");
+            }
             break;
         }
         v = PyList_New(n);
@@ -1296,10 +1300,11 @@ r_object(RFILE *p)
     case TYPE_SET:
     case TYPE_FROZENSET:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (set size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (set size out of range)");
+            }
             break;
         }
 
@@ -1377,20 +1382,20 @@ r_object(RFILE *p)
 
             /* XXX ignore long->int overflows for now */
             argcount = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (argcount == -1 && PyErr_Occurred())
                 goto code_error;
             posonlyargcount = (int)r_long(p);
-            if (PyErr_Occurred()) {
+            if (posonlyargcount == -1 && PyErr_Occurred()) {
                 goto code_error;
             }
             kwonlyargcount = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (kwonlyargcount == -1 && PyErr_Occurred())
                 goto code_error;
             stacksize = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (stacksize == -1 && PyErr_Occurred())
                 goto code_error;
             flags = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (flags == -1 && PyErr_Occurred())
                 goto code_error;
             code = r_object(p);
             if (code == NULL)
@@ -1463,6 +1468,10 @@ r_object(RFILE *p)
             v = r_ref_insert(v, idx, flag, p);
 
           code_error:
+            if (v == NULL && !PyErr_Occurred()) {
+                PyErr_SetString(PyExc_TypeError,
+                    "NULL object in marshal data for code object");
+            }
             Py_XDECREF(code);
             Py_XDECREF(consts);
             Py_XDECREF(names);
@@ -1480,9 +1489,10 @@ r_object(RFILE *p)
     case TYPE_REF:
         n = r_long(p);
         if (n < 0 || n >= PyList_GET_SIZE(p->refs)) {
-            if (n == -1 && PyErr_Occurred())
-                break;
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (invalid reference)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (invalid reference)");
+            }
             break;
         }
         v = PyList_GET_ITEM(p->refs, n);
--- a/Python/modsupport.c
+++ b/Python/modsupport.c
@@ -658,13 +658,16 @@ PyModule_AddObjectRef(PyObject *mod, con
                      PyModule_GetName(mod));
         return -1;
     }
-
-    if (PyDict_SetItemString(dict, name, value)) {
-        return -1;
-    }
-    return 0;
+    return PyDict_SetItemString(dict, name, value);
 }
 
+int
+_PyModule_Add(PyObject *mod, const char *name, PyObject *value)
+{
+    int res = PyModule_AddObjectRef(mod, name, value);
+    Py_XDECREF(value);
+    return res;
+}
 
 int
 PyModule_AddObject(PyObject *mod, const char *name, PyObject *value)
@@ -679,25 +682,13 @@ PyModule_AddObject(PyObject *mod, const
 int
 PyModule_AddIntConstant(PyObject *m, const char *name, long value)
 {
-    PyObject *obj = PyLong_FromLong(value);
-    if (!obj) {
-        return -1;
-    }
-    int res = PyModule_AddObjectRef(m, name, obj);
-    Py_DECREF(obj);
-    return res;
+    return _PyModule_Add(m, name, PyLong_FromLong(value));
 }
 
 int
 PyModule_AddStringConstant(PyObject *m, const char *name, const char *value)
 {
-    PyObject *obj = PyUnicode_FromString(value);
-    if (!obj) {
-        return -1;
-    }
-    int res = PyModule_AddObjectRef(m, name, obj);
-    Py_DECREF(obj);
-    return res;
+    return _PyModule_Add(m, name, PyUnicode_FromString(value));
 }
 
 int
--- a/Python/pythonrun.c
+++ b/Python/pythonrun.c
@@ -1138,15 +1138,13 @@ print_exception_notes(struct exception_p
         return 0;
     }
 
-    if (!PyObject_HasAttr(value, &_Py_ID(__notes__))) {
-        return 0;
-    }
-    PyObject *notes = PyObject_GetAttr(value, &_Py_ID(__notes__));
-    if (notes == NULL) {
-        return -1;
+    PyObject *notes;
+    int res = _PyObject_LookupAttr(value, &_Py_ID(__notes__), &notes);
+    if (res <= 0) {
+        return res;
     }
     if (!PySequence_Check(notes)) {
-        int res = 0;
+        res = 0;
         if (write_indented_margin(ctx, f) < 0) {
             res = -1;
         }
--- a/Python/specialize.c
+++ b/Python/specialize.c
@@ -1500,9 +1500,9 @@ specialize_py_call(PyFunctionObject *fun
     }
     int argcount = code->co_argcount;
     int defcount = func->func_defaults == NULL ? 0 : (int)PyTuple_GET_SIZE(func->func_defaults);
-    assert(defcount <= argcount);
     int min_args = argcount-defcount;
-    if (nargs > argcount || nargs < min_args) {
+    // GH-105840: min_args is negative when somebody sets too many __defaults__!
+    if (min_args < 0 || nargs > argcount || nargs < min_args) {
         SPECIALIZATION_FAIL(CALL, SPEC_FAIL_WRONG_NUMBER_ARGUMENTS);
         return -1;
     }
--- a/Python/suggestions.c
+++ b/Python/suggestions.c
@@ -147,14 +147,14 @@ calculate_suggestions(PyObject *dir,
 
     for (int i = 0; i < dir_size; ++i) {
         PyObject *item = PyList_GET_ITEM(dir, i);
+        if (_PyUnicode_Equal(name, item)) {
+            continue;
+        }
         Py_ssize_t item_size;
         const char *item_str = PyUnicode_AsUTF8AndSize(item, &item_size);
         if (item_str == NULL) {
             return NULL;
         }
-        if (PyUnicode_CompareWithASCIIString(name, item_str) == 0) {
-            continue;
-        }
         // No more than 1/3 of the involved characters should need changed.
         Py_ssize_t max_distance = (name_size + item_size + 3) * MOVE_COST / 6;
         // Don't take matches we've already beaten.
@@ -225,19 +225,19 @@ offer_suggestions_for_name_error(PyNameE
     PyCodeObject *code = PyFrame_GetCode(frame);
     assert(code != NULL && code->co_localsplusnames != NULL);
     PyObject *varnames = _PyCode_GetVarnames(code);
+    Py_DECREF(code);
     if (varnames == NULL) {
         return NULL;
     }
     PyObject *dir = PySequence_List(varnames);
     Py_DECREF(varnames);
-    Py_DECREF(code);
     if (dir == NULL) {
         return NULL;
     }
 
     PyObject *suggestions = calculate_suggestions(dir, name);
     Py_DECREF(dir);
-    if (suggestions != NULL) {
+    if (suggestions != NULL|| PyErr_Occurred()) {
         return suggestions;
     }
 
@@ -247,7 +247,7 @@ offer_suggestions_for_name_error(PyNameE
     }
     suggestions = calculate_suggestions(dir, name);
     Py_DECREF(dir);
-    if (suggestions != NULL) {
+    if (suggestions != NULL || PyErr_Occurred()) {
         return suggestions;
     }
 
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -2360,15 +2360,21 @@ _PySys_AddXOptionWithError(const wchar_t
     const wchar_t *name_end = wcschr(s, L'=');
     if (!name_end) {
         name = PyUnicode_FromWideChar(s, -1);
+        if (name == NULL) {
+            goto error;
+        }
         value = Py_True;
         Py_INCREF(value);
     }
     else {
         name = PyUnicode_FromWideChar(s, name_end - s);
+        if (name == NULL) {
+            goto error;
+        }
         value = PyUnicode_FromWideChar(name_end + 1, -1);
-    }
-    if (name == NULL || value == NULL) {
-        goto error;
+        if (value == NULL) {
+            goto error;
+        }
     }
     if (PyDict_SetItem(opts, name, value) < 0) {
         goto error;
@@ -3014,20 +3020,26 @@ err_occurred:
 static int
 sys_add_xoption(PyObject *opts, const wchar_t *s)
 {
-    PyObject *name, *value;
+    PyObject *name, *value = NULL;
 
     const wchar_t *name_end = wcschr(s, L'=');
     if (!name_end) {
         name = PyUnicode_FromWideChar(s, -1);
+        if (name == NULL) {
+            goto error;
+        }
         value = Py_True;
         Py_INCREF(value);
     }
     else {
         name = PyUnicode_FromWideChar(s, name_end - s);
+        if (name == NULL) {
+            goto error;
+        }
         value = PyUnicode_FromWideChar(name_end + 1, -1);
-    }
-    if (name == NULL || value == NULL) {
-        goto error;
+        if (value == NULL) {
+            goto error;
+        }
     }
     if (PyDict_SetItem(opts, name, value) < 0) {
         goto error;
--- a/Tools/c-analyzer/c_parser/preprocessor/common.py
+++ b/Tools/c-analyzer/c_parser/preprocessor/common.py
@@ -1,6 +1,7 @@
 import contextlib
 import distutils.ccompiler
 import logging
+import os
 import shlex
 import subprocess
 import sys
@@ -40,7 +41,12 @@ def run_cmd(argv, *,
     kw.pop('kwargs')
     kwargs.update(kw)
 
-    proc = subprocess.run(argv, **kwargs)
+    # Remove LANG environment variable: the C parser doesn't support GCC
+    # localized messages
+    env = dict(os.environ)
+    env.pop('LANG', None)
+
+    proc = subprocess.run(argv, env=env, **kwargs)
     return proc.stdout
 
 
--- a/Tools/c-analyzer/cpython/ignored.tsv
+++ b/Tools/c-analyzer/cpython/ignored.tsv
@@ -1432,6 +1432,7 @@ Modules/_decimal/_decimal.c	-	invalid_ro
 Modules/_decimal/_decimal.c	-	invalid_signals_err	-
 Modules/_decimal/_decimal.c	-	signal_map	-
 Modules/_decimal/_decimal.c	-	ssize_constants	-
+Modules/_decimal/_decimal.c -   INVALID_SIGNALDICT_ERROR_MSG -
 Modules/_elementtree.c	-	ExpatMemoryHandler	-
 Modules/_io/_iomodule.c	-	static_types	-
 Modules/_io/textio.c	-	encodefuncs	-
--- a/Tools/clinic/clinic.py
+++ b/Tools/clinic/clinic.py
@@ -460,7 +460,7 @@ class PythonLanguage(Language):
 
 def permute_left_option_groups(l):
     """
-    Given [1, 2, 3], should yield:
+    Given [(1,), (2,), (3,)], should yield:
        ()
        (3,)
        (2, 3)
@@ -475,7 +475,7 @@ def permute_left_option_groups(l):
 
 def permute_right_option_groups(l):
     """
-    Given [1, 2, 3], should yield:
+    Given [(1,), (2,), (3,)], should yield:
       ()
       (1,)
       (1, 2)
@@ -1798,7 +1798,7 @@ class BufferSeries:
 
     def clear(self):
         for ta in self._array:
-            ta._text.clear()
+            ta.text.clear()
 
     def dump(self):
         texts = [ta.output() for ta in self._array]
@@ -4072,6 +4072,7 @@ class DSLParser:
         self.indent = IndentStack()
         self.kind = CALLABLE
         self.coexist = False
+        self.forced_text_signature: str | None = None
         self.parameter_continuation = ''
         self.preserve_output = False
 
@@ -4121,14 +4122,19 @@ class DSLParser:
 
         self.clinic.__dict__[name] = value
 
-    def directive_destination(self, name, command, *args):
-        if command == 'new':
-            self.clinic.add_destination(name, *args)
-            return
-
-        if command == 'clear':
-            self.clinic.get_destination(name).clear()
-        fail("unknown destination command", repr(command))
+    def directive_destination(
+            self,
+            name: str,
+            command: str,
+            *args
+    ) -> None:
+        match command:
+            case "new":
+                self.clinic.add_destination(name, *args)
+            case "clear":
+                self.clinic.get_destination(name).clear()
+            case _:
+                fail("unknown destination command", repr(command))
 
 
     def directive_output(self, command_or_name, destination=''):
@@ -4196,6 +4202,11 @@ class DSLParser:
             fail("Called @coexist twice!")
         self.coexist = True
 
+    def at_text_signature(self, text_signature):
+        if self.forced_text_signature:
+            fail("Called @text_signature twice!")
+        self.forced_text_signature = text_signature
+
     def parse(self, block):
         self.reset()
         self.block = block
@@ -4898,142 +4909,145 @@ class DSLParser:
             add(f.cls.name)
         else:
             add(f.name)
-        add('(')
-
-        # populate "right_bracket_count" field for every parameter
-        assert parameters, "We should always have a self parameter. " + repr(f)
-        assert isinstance(parameters[0].converter, self_converter)
-        # self is always positional-only.
-        assert parameters[0].is_positional_only()
-        parameters[0].right_bracket_count = 0
-        positional_only = True
-        for p in parameters[1:]:
-            if not p.is_positional_only():
-                positional_only = False
-            else:
-                assert positional_only
-            if positional_only:
-                p.right_bracket_count = abs(p.group)
-            else:
-                # don't put any right brackets around non-positional-only parameters, ever.
-                p.right_bracket_count = 0
+        if self.forced_text_signature:
+            add(self.forced_text_signature)
+        else:
+            add('(')
 
-        right_bracket_count = 0
+            # populate "right_bracket_count" field for every parameter
+            assert parameters, "We should always have a self parameter. " + repr(f)
+            assert isinstance(parameters[0].converter, self_converter)
+            # self is always positional-only.
+            assert parameters[0].is_positional_only()
+            parameters[0].right_bracket_count = 0
+            positional_only = True
+            for p in parameters[1:]:
+                if not p.is_positional_only():
+                    positional_only = False
+                else:
+                    assert positional_only
+                if positional_only:
+                    p.right_bracket_count = abs(p.group)
+                else:
+                    # don't put any right brackets around non-positional-only parameters, ever.
+                    p.right_bracket_count = 0
 
-        def fix_right_bracket_count(desired):
-            nonlocal right_bracket_count
-            s = ''
-            while right_bracket_count < desired:
-                s += '['
-                right_bracket_count += 1
-            while right_bracket_count > desired:
-                s += ']'
-                right_bracket_count -= 1
-            return s
+            right_bracket_count = 0
 
-        need_slash = False
-        added_slash = False
-        need_a_trailing_slash = False
-
-        # we only need a trailing slash:
-        #   * if this is not a "docstring_only" signature
-        #   * and if the last *shown* parameter is
-        #     positional only
-        if not f.docstring_only:
-            for p in reversed(parameters):
-                if not p.converter.show_in_signature:
-                    continue
-                if p.is_positional_only():
-                    need_a_trailing_slash = True
-                break
+            def fix_right_bracket_count(desired):
+                nonlocal right_bracket_count
+                s = ''
+                while right_bracket_count < desired:
+                    s += '['
+                    right_bracket_count += 1
+                while right_bracket_count > desired:
+                    s += ']'
+                    right_bracket_count -= 1
+                return s
+
+            need_slash = False
+            added_slash = False
+            need_a_trailing_slash = False
+
+            # we only need a trailing slash:
+            #   * if this is not a "docstring_only" signature
+            #   * and if the last *shown* parameter is
+            #     positional only
+            if not f.docstring_only:
+                for p in reversed(parameters):
+                    if not p.converter.show_in_signature:
+                        continue
+                    if p.is_positional_only():
+                        need_a_trailing_slash = True
+                    break
 
 
-        added_star = False
+            added_star = False
 
-        first_parameter = True
-        last_p = parameters[-1]
-        line_length = len(''.join(text))
-        indent = " " * line_length
-        def add_parameter(text):
-            nonlocal line_length
-            nonlocal first_parameter
-            if first_parameter:
-                s = text
-                first_parameter = False
-            else:
-                s = ' ' + text
-                if line_length + len(s) >= 72:
-                    add('\n')
-                    add(indent)
-                    line_length = len(indent)
+            first_parameter = True
+            last_p = parameters[-1]
+            line_length = len(''.join(text))
+            indent = " " * line_length
+            def add_parameter(text):
+                nonlocal line_length
+                nonlocal first_parameter
+                if first_parameter:
                     s = text
-            line_length += len(s)
-            add(s)
+                    first_parameter = False
+                else:
+                    s = ' ' + text
+                    if line_length + len(s) >= 72:
+                        add('\n')
+                        add(indent)
+                        line_length = len(indent)
+                        s = text
+                line_length += len(s)
+                add(s)
 
-        for p in parameters:
-            if not p.converter.show_in_signature:
-                continue
-            assert p.name
+            for p in parameters:
+                if not p.converter.show_in_signature:
+                    continue
+                assert p.name
 
-            is_self = isinstance(p.converter, self_converter)
-            if is_self and f.docstring_only:
-                # this isn't a real machine-parsable signature,
-                # so let's not print the "self" parameter
-                continue
+                is_self = isinstance(p.converter, self_converter)
+                if is_self and f.docstring_only:
+                    # this isn't a real machine-parsable signature,
+                    # so let's not print the "self" parameter
+                    continue
 
-            if p.is_positional_only():
-                need_slash = not f.docstring_only
-            elif need_slash and not (added_slash or p.is_positional_only()):
-                added_slash = True
-                add_parameter('/,')
-
-            if p.is_keyword_only() and not added_star:
-                added_star = True
-                add_parameter('*,')
-
-            p_add, p_output = text_accumulator()
-            p_add(fix_right_bracket_count(p.right_bracket_count))
-
-            if isinstance(p.converter, self_converter):
-                # annotate first parameter as being a "self".
-                #
-                # if inspect.Signature gets this function,
-                # and it's already bound, the self parameter
-                # will be stripped off.
-                #
-                # if it's not bound, it should be marked
-                # as positional-only.
-                #
-                # note: we don't print "self" for __init__,
-                # because this isn't actually the signature
-                # for __init__.  (it can't be, __init__ doesn't
-                # have a docstring.)  if this is an __init__
-                # (or __new__), then this signature is for
-                # calling the class to construct a new instance.
-                p_add('$')
+                if p.is_positional_only():
+                    need_slash = not f.docstring_only
+                elif need_slash and not (added_slash or p.is_positional_only()):
+                    added_slash = True
+                    add_parameter('/,')
+
+                if p.is_keyword_only() and not added_star:
+                    added_star = True
+                    add_parameter('*,')
+
+                p_add, p_output = text_accumulator()
+                p_add(fix_right_bracket_count(p.right_bracket_count))
+
+                if isinstance(p.converter, self_converter):
+                    # annotate first parameter as being a "self".
+                    #
+                    # if inspect.Signature gets this function,
+                    # and it's already bound, the self parameter
+                    # will be stripped off.
+                    #
+                    # if it's not bound, it should be marked
+                    # as positional-only.
+                    #
+                    # note: we don't print "self" for __init__,
+                    # because this isn't actually the signature
+                    # for __init__.  (it can't be, __init__ doesn't
+                    # have a docstring.)  if this is an __init__
+                    # (or __new__), then this signature is for
+                    # calling the class to construct a new instance.
+                    p_add('$')
 
-            if p.is_vararg():
-                p_add("*")
+                if p.is_vararg():
+                    p_add("*")
 
-            name = p.converter.signature_name or p.name
-            p_add(name)
+                name = p.converter.signature_name or p.name
+                p_add(name)
 
-            if not p.is_vararg() and p.converter.is_optional():
-                p_add('=')
-                value = p.converter.py_default
-                if not value:
-                    value = repr(p.converter.default)
-                p_add(value)
-
-            if (p != last_p) or need_a_trailing_slash:
-                p_add(',')
-
-            add_parameter(p_output())
-
-        add(fix_right_bracket_count(0))
-        if need_a_trailing_slash:
-            add_parameter('/')
-        add(')')
+                if not p.is_vararg() and p.converter.is_optional():
+                    p_add('=')
+                    value = p.converter.py_default
+                    if not value:
+                        value = repr(p.converter.default)
+                    p_add(value)
+
+                if (p != last_p) or need_a_trailing_slash:
+                    p_add(',')
+
+                add_parameter(p_output())
+
+            add(fix_right_bracket_count(0))
+            if need_a_trailing_slash:
+                add_parameter('/')
+            add(')')
 
         # PEP 8 says:
         #
@@ -5185,15 +5199,21 @@ with writing argument parsing code for b
 signatures ("docstrings") for CPython builtins.
 
 For more information see https://docs.python.org/3/howto/clinic.html""")
-    cmdline.add_argument("-f", "--force", action='store_true')
-    cmdline.add_argument("-o", "--output", type=str)
-    cmdline.add_argument("-v", "--verbose", action='store_true')
-    cmdline.add_argument("--converters", action='store_true')
+    cmdline.add_argument("-f", "--force", action='store_true',
+                         help="force output regeneration")
+    cmdline.add_argument("-o", "--output", type=str,
+                         help="redirect file output to OUTPUT")
+    cmdline.add_argument("-v", "--verbose", action='store_true',
+                         help="enable verbose mode")
+    cmdline.add_argument("--converters", action='store_true',
+                         help=("print a list of all supported converters "
+                               "and return converters"))
     cmdline.add_argument("--make", action='store_true',
-                         help="Walk --srcdir to run over all relevant files.")
+                         help="walk --srcdir to run over all relevant files")
     cmdline.add_argument("--srcdir", type=str, default=os.curdir,
-                         help="The directory tree to walk in --make mode.")
-    cmdline.add_argument("filename", type=str, nargs="*")
+                         help="the directory tree to walk in --make mode")
+    cmdline.add_argument("filename", metavar="FILE", type=str, nargs="*",
+                         help="the list of files to process")
     ns = cmdline.parse_args(argv)
 
     if ns.converters:
--- a/configure.ac
+++ b/configure.ac
@@ -2246,6 +2246,10 @@ yes)
     AS_VAR_IF([ac_cv_disable_unused_parameter_warning], [yes],
               [CFLAGS_NODIST="$CFLAGS_NODIST -Wno-unused-parameter"])
 
+    PY_CHECK_CC_WARNING([disable], [int-conversion])
+    AS_VAR_IF([ac_cv_disable_int_conversion], [yes],
+              [CFLAGS_NODIST="$CFLAGS_NODIST -Wno-int-conversion"])
+
     PY_CHECK_CC_WARNING([disable], [missing-field-initializers])
     AS_VAR_IF([ac_cv_disable_missing_field_initializers_warning], [yes],
               [CFLAGS_NODIST="$CFLAGS_NODIST -Wno-missing-field-initializers"])
@@ -2664,7 +2668,7 @@ AC_DEFINE(STDC_HEADERS, 1, [Define to 1
 # checks for header files
 AC_CHECK_HEADERS([ \
   alloca.h asm/types.h bluetooth.h conio.h crypt.h direct.h dlfcn.h endian.h errno.h fcntl.h grp.h \
-  ieeefp.h io.h langinfo.h libintl.h libutil.h linux/auxvec.h sys/auxv.h linux/memfd.h \
+  ieeefp.h io.h langinfo.h libintl.h libutil.h linux/auxvec.h sys/auxv.h linux/limits.h linux/memfd.h \
   linux/random.h linux/soundcard.h \
   linux/tipc.h linux/wait.h netdb.h netinet/in.h netpacket/packet.h poll.h process.h pthread.h pty.h \
   sched.h setjmp.h shadow.h signal.h spawn.h stropts.h sys/audioio.h sys/bsdtty.h sys/devpoll.h \
--- a/pyconfig.h.in
+++ b/pyconfig.h.in
@@ -718,6 +718,9 @@
 /* Define if compiling using Linux 4.1 or later. */
 #undef HAVE_LINUX_CAN_RAW_JOIN_FILTERS
 
+/* Define to 1 if you have the <linux/limits.h> header file. */
+#undef HAVE_LINUX_LIMITS_H
+
 /* Define to 1 if you have the <linux/memfd.h> header file. */
 #undef HAVE_LINUX_MEMFD_H
 
