#!/bin/sh
{
    git diff -p --stat v3.11.4..origin/3.11 -- Doc/data/ Doc/library/token-list.inc Doc/library/enum.rst Doc/howto/enum.rst
    git diff -p --stat v3.11.4..origin/3.11 -- ':!.*/*' ':!configure' ':!Include/patchlevel.h' ':!README.rst' ':!Mac/' ':!PC/' ':!PCbuild/' ':!Doc/' ':!Misc/NEWS.d/' ':!Lib/ensurepip/' ':!Tools/msi/' ':!Tools/wasm/' ':!Tools/ssl/multissltests.py'
} >> package/python/3.11/patches/git-branch.patch

 Doc/howto/enum.rst | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

--- a/Doc/howto/enum.rst
+++ b/Doc/howto/enum.rst
@@ -484,7 +484,16 @@ from that module.
     nested in other classes.
 
 It is possible to modify how enum members are pickled/unpickled by defining
-:meth:`__reduce_ex__` in the enumeration class.
+:meth:`__reduce_ex__` in the enumeration class.  The default method is by-value,
+but enums with complicated values may want to use by-name::
+
+    >>> class MyEnum(Enum):
+    ...     __reduce_ex__ = enum.pickle_by_enum_name
+
+.. note::
+
+    Using by-name for flags is not recommended, as unnamed aliases will
+    not unpickle.
 
 
 Functional API
--- a/Include/cpython/modsupport.h
+++ b/Include/cpython/modsupport.h
@@ -103,5 +103,6 @@ PyAPI_FUNC(PyObject * const *) _PyArg_Un
                            (minpos), (maxpos), (minkw), (buf)))
 
 PyAPI_FUNC(PyObject *) _PyModule_CreateInitialized(PyModuleDef*, int apiver);
+PyAPI_FUNC(int) _PyModule_Add(PyObject *, const char *, PyObject *);
 
 PyAPI_DATA(const char *) _Py_PackageContext;
--- a/Include/internal/pycore_fileutils.h
+++ b/Include/internal/pycore_fileutils.h
@@ -244,7 +244,8 @@ extern int _Py_add_relfile(wchar_t *dirn
                            const wchar_t *relfile,
                            size_t bufsize);
 extern size_t _Py_find_basename(const wchar_t *filename);
-PyAPI_FUNC(wchar_t *) _Py_normpath(wchar_t *path, Py_ssize_t size);
+PyAPI_FUNC(wchar_t*) _Py_normpath(wchar_t *path, Py_ssize_t size);
+extern wchar_t *_Py_normpath_and_size(wchar_t *path, Py_ssize_t size, Py_ssize_t *length);
 
 
 // Macros to protect CRT calls against instant termination when passed an
--- a/Include/modsupport.h
+++ b/Include/modsupport.h
@@ -41,10 +41,12 @@ PyAPI_FUNC(PyObject *) _Py_BuildValue_Si
 
 PyAPI_FUNC(PyObject *) Py_VaBuildValue(const char *, va_list);
 
+#if !defined(Py_LIMITED_API) || Py_LIMITED_API+0 >= 0x030a0000
 // Add an attribute with name 'name' and value 'obj' to the module 'mod.
 // On success, return 0 on success.
 // On error, raise an exception and return -1.
 PyAPI_FUNC(int) PyModule_AddObjectRef(PyObject *mod, const char *name, PyObject *value);
+#endif   /* Py_LIMITED_API */
 
 // Similar to PyModule_AddObjectRef() but steal a reference to 'obj'
 // (Py_DECREF(obj)) on success (if it returns 0).
--- a/Lib/asyncio/base_events.py
+++ b/Lib/asyncio/base_events.py
@@ -716,7 +716,7 @@ class BaseEventLoop(events.AbstractEvent
         always relative to the current time.
 
         Each callback will be called exactly once.  If two callbacks
-        are scheduled for exactly the same time, it undefined which
+        are scheduled for exactly the same time, it is undefined which
         will be called first.
 
         Any positional arguments after the callback will be passed to
--- a/Lib/asyncio/events.py
+++ b/Lib/asyncio/events.py
@@ -613,7 +613,7 @@ class AbstractEventLoopPolicy:
     def get_event_loop(self):
         """Get the event loop for the current context.
 
-        Returns an event loop object implementing the BaseEventLoop interface,
+        Returns an event loop object implementing the AbstractEventLoop interface,
         or raises an exception in case no event loop has been set for the
         current context and the current policy does not specify to create one.
 
--- a/Lib/asyncio/streams.py
+++ b/Lib/asyncio/streams.py
@@ -391,6 +391,10 @@ class StreamWriter:
         self._transport = new_transport
         protocol._replace_writer(self)
 
+    def __del__(self):
+        if not self._transport.is_closing():
+            self.close()
+
 
 class StreamReader:
 
--- a/Lib/colorsys.py
+++ b/Lib/colorsys.py
@@ -83,7 +83,7 @@ def rgb_to_hls(r, g, b):
     if l <= 0.5:
         s = rangec / sumc
     else:
-        s = rangec / (2.0-sumc)
+        s = rangec / (2.0-maxc-minc)  # Not always 2.0-sumc: gh-106498.
     rc = (maxc-r) / rangec
     gc = (maxc-g) / rangec
     bc = (maxc-b) / rangec
--- a/Lib/concurrent/futures/process.py
+++ b/Lib/concurrent/futures/process.py
@@ -497,6 +497,10 @@ class _ExecutorManagerThread(threading.T
         for p in self.processes.values():
             p.terminate()
 
+        # Prevent queue writing to a pipe which is no longer read.
+        # https://github.com/python/cpython/issues/94777
+        self.call_queue._reader.close()
+
         # clean up resources
         self.join_executor_internals()
 
--- a/Lib/configparser.py
+++ b/Lib/configparser.py
@@ -59,7 +59,7 @@ ConfigParser -- responsible for parsing
         instance. It will be used as the handler for option value
         pre-processing when using getters. RawConfigParser objects don't do
         any sort of interpolation, whereas ConfigParser uses an instance of
-        BasicInterpolation. The library also provides a ``zc.buildbot``
+        BasicInterpolation. The library also provides a ``zc.buildout``
         inspired ExtendedInterpolation implementation.
 
         When `converters` is given, it should be a dictionary where each key
--- a/Lib/ctypes/test/test_as_parameter.py
+++ b/Lib/ctypes/test/test_as_parameter.py
@@ -194,7 +194,7 @@ class BasicWrapTestCase(unittest.TestCas
     def test_recursive_as_param(self):
         from ctypes import c_int
 
-        class A(object):
+        class A:
             pass
 
         a = A()
@@ -205,7 +205,7 @@ class BasicWrapTestCase(unittest.TestCas
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-class AsParamWrapper(object):
+class AsParamWrapper:
     def __init__(self, param):
         self._as_parameter_ = param
 
@@ -214,7 +214,7 @@ class AsParamWrapperTestCase(BasicWrapTe
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
-class AsParamPropertyWrapper(object):
+class AsParamPropertyWrapper:
     def __init__(self, param):
         self._param = param
 
--- a/Lib/ctypes/test/test_byteswap.py
+++ b/Lib/ctypes/test/test_byteswap.py
@@ -14,14 +14,6 @@ def bin(s):
 # For Structures and Unions, these types are created on demand.
 
 class Test(unittest.TestCase):
-    @unittest.skip('test disabled')
-    def test_X(self):
-        print(sys.byteorder, file=sys.stderr)
-        for i in range(32):
-            bits = BITS()
-            setattr(bits, "i%s" % i, 1)
-            dump(bits)
-
     def test_slots(self):
         class BigPoint(BigEndianStructure):
             __slots__ = ()
--- a/Lib/ctypes/test/test_callbacks.py
+++ b/Lib/ctypes/test/test_callbacks.py
@@ -93,14 +93,6 @@ class Callbacks(unittest.TestCase):
         self.check_type(c_char, b"x")
         self.check_type(c_char, b"a")
 
-    # disabled: would now (correctly) raise a RuntimeWarning about
-    # a memory leak.  A callback function cannot return a non-integral
-    # C type without causing a memory leak.
-    @unittest.skip('test disabled')
-    def test_char_p(self):
-        self.check_type(c_char_p, "abc")
-        self.check_type(c_char_p, "def")
-
     def test_pyobject(self):
         o = ()
         from sys import getrefcount as grc
@@ -130,7 +122,7 @@ class Callbacks(unittest.TestCase):
     def test_issue_7959(self):
         proto = self.functype.__func__(None)
 
-        class X(object):
+        class X:
             def func(self): pass
             def __init__(self):
                 self.v = proto(self.func)
--- a/Lib/ctypes/test/test_keeprefs.py
+++ b/Lib/ctypes/test/test_keeprefs.py
@@ -93,37 +93,33 @@ class PointerTestCase(unittest.TestCase)
         x = pointer(i)
         self.assertEqual(x._objects, {'1': i})
 
-class DeletePointerTestCase(unittest.TestCase):
-    @unittest.skip('test disabled')
-    def test_X(self):
-        class X(Structure):
-            _fields_ = [("p", POINTER(c_char_p))]
-        x = X()
-        i = c_char_p("abc def")
-        from sys import getrefcount as grc
-        print("2?", grc(i))
-        x.p = pointer(i)
-        print("3?", grc(i))
-        for i in range(320):
-            c_int(99)
-            x.p[0]
-        print(x.p[0])
-##        del x
-##        print "2?", grc(i)
-##        del i
-        import gc
-        gc.collect()
-        for i in range(320):
-            c_int(99)
-            x.p[0]
-        print(x.p[0])
-        print(x.p.contents)
-##        print x._objects
-
-        x.p[0] = "spam spam"
-##        print x.p[0]
-        print("+" * 42)
-        print(x._objects)
+    def test_pp_ownership(self):
+        d = c_int(123)
+        n = c_int(456)
+
+        p = pointer(d)
+        pp = pointer(p)
+
+        self.assertIs(pp._objects['1'], p)
+        self.assertIs(pp._objects['0']['1'], d)
+
+        pp.contents.contents = n
+
+        self.assertIs(pp._objects['1'], p)
+        self.assertIs(pp._objects['0']['1'], n)
+
+        self.assertIs(p._objects['1'], n)
+        self.assertEqual(len(p._objects), 1)
+
+        del d
+        del p
+
+        self.assertIs(pp._objects['0']['1'], n)
+        self.assertEqual(len(pp._objects), 2)
+
+        del n
+
+        self.assertEqual(len(pp._objects), 2)
 
 class PointerToStructure(unittest.TestCase):
     def test(self):
--- a/Lib/ctypes/test/test_numbers.py
+++ b/Lib/ctypes/test/test_numbers.py
@@ -82,14 +82,6 @@ class NumberTestCase(unittest.TestCase):
             self.assertRaises(TypeError, t, "")
             self.assertRaises(TypeError, t, None)
 
-    @unittest.skip('test disabled')
-    def test_valid_ranges(self):
-        # invalid values of the correct type
-        # raise ValueError (not OverflowError)
-        for t, (l, h) in zip(unsigned_types, unsigned_ranges):
-            self.assertRaises(ValueError, t, l-1)
-            self.assertRaises(ValueError, t, h+1)
-
     def test_from_param(self):
         # the from_param class method attribute always
         # returns PyCArgObject instances
@@ -106,7 +98,7 @@ class NumberTestCase(unittest.TestCase):
     def test_floats(self):
         # c_float and c_double can be created from
         # Python int and float
-        class FloatLike(object):
+        class FloatLike:
             def __float__(self):
                 return 2.0
         f = FloatLike()
@@ -117,15 +109,15 @@ class NumberTestCase(unittest.TestCase):
             self.assertEqual(t(f).value, 2.0)
 
     def test_integers(self):
-        class FloatLike(object):
+        class FloatLike:
             def __float__(self):
                 return 2.0
         f = FloatLike()
-        class IntLike(object):
+        class IntLike:
             def __int__(self):
                 return 2
         d = IntLike()
-        class IndexLike(object):
+        class IndexLike:
             def __index__(self):
                 return 2
         i = IndexLike()
@@ -205,19 +197,6 @@ class NumberTestCase(unittest.TestCase):
         a[0] = ord('?')
         self.assertEqual(v.value, b'?')
 
-    # array does not support c_bool / 't'
-    @unittest.skip('test disabled')
-    def test_bool_from_address(self):
-        from ctypes import c_bool
-        from array import array
-        a = array(c_bool._type_, [True])
-        v = t.from_address(a.buffer_info()[0])
-        self.assertEqual(v.value, a[0])
-        self.assertEqual(type(v) is t)
-        a[0] = False
-        self.assertEqual(v.value, a[0])
-        self.assertEqual(type(v) is t)
-
     def test_init(self):
         # c_int() can be initialized from Python's int, and c_int.
         # Not from c_long or so, which seems strange, abc should
@@ -234,62 +213,6 @@ class NumberTestCase(unittest.TestCase):
             if (hasattr(t, "__ctype_le__")):
                 self.assertRaises(OverflowError, t.__ctype_le__, big_int)
 
-    @unittest.skip('test disabled')
-    def test_perf(self):
-        check_perf()
-
-from ctypes import _SimpleCData
-class c_int_S(_SimpleCData):
-    _type_ = "i"
-    __slots__ = []
-
-def run_test(rep, msg, func, arg=None):
-##    items = [None] * rep
-    items = range(rep)
-    from time import perf_counter as clock
-    if arg is not None:
-        start = clock()
-        for i in items:
-            func(arg); func(arg); func(arg); func(arg); func(arg)
-        stop = clock()
-    else:
-        start = clock()
-        for i in items:
-            func(); func(); func(); func(); func()
-        stop = clock()
-    print("%15s: %.2f us" % (msg, ((stop-start)*1e6/5/rep)))
-
-def check_perf():
-    # Construct 5 objects
-    from ctypes import c_int
-
-    REP = 200000
-
-    run_test(REP, "int()", int)
-    run_test(REP, "int(999)", int)
-    run_test(REP, "c_int()", c_int)
-    run_test(REP, "c_int(999)", c_int)
-    run_test(REP, "c_int_S()", c_int_S)
-    run_test(REP, "c_int_S(999)", c_int_S)
-
-# Python 2.3 -OO, win2k, P4 700 MHz:
-#
-#          int(): 0.87 us
-#       int(999): 0.87 us
-#        c_int(): 3.35 us
-#     c_int(999): 3.34 us
-#      c_int_S(): 3.23 us
-#   c_int_S(999): 3.24 us
-
-# Python 2.2 -OO, win2k, P4 700 MHz:
-#
-#          int(): 0.89 us
-#       int(999): 0.89 us
-#        c_int(): 9.99 us
-#     c_int(999): 10.02 us
-#      c_int_S(): 9.87 us
-#   c_int_S(999): 9.85 us
 
 if __name__ == '__main__':
-##    check_perf()
     unittest.main()
--- a/Lib/ctypes/test/test_parameters.py
+++ b/Lib/ctypes/test/test_parameters.py
@@ -145,7 +145,7 @@ class SimpleTypesTestCase(unittest.TestC
         # TypeError: has no from_param method
         self.assertRaises(TypeError, setattr, func, "argtypes", (object,))
 
-        class Adapter(object):
+        class Adapter:
             def from_param(cls, obj):
                 return None
 
@@ -153,7 +153,7 @@ class SimpleTypesTestCase(unittest.TestC
         self.assertEqual(func(None), None)
         self.assertEqual(func(object()), None)
 
-        class Adapter(object):
+        class Adapter:
             def from_param(cls, obj):
                 return obj
 
@@ -162,7 +162,7 @@ class SimpleTypesTestCase(unittest.TestC
         self.assertRaises(ArgumentError, func, object())
         self.assertEqual(func(c_void_p(42)), 42)
 
-        class Adapter(object):
+        class Adapter:
             def from_param(cls, obj):
                 raise ValueError(obj)
 
--- a/Lib/ctypes/test/test_structures.py
+++ b/Lib/ctypes/test/test_structures.py
@@ -359,15 +359,6 @@ class StructureTestCase(unittest.TestCas
         except Exception as detail:
             return detail.__class__, str(detail)
 
-    @unittest.skip('test disabled')
-    def test_subclass_creation(self):
-        meta = type(Structure)
-        # same as 'class X(Structure): pass'
-        # fails, since we need either a _fields_ or a _abstract_ attribute
-        cls, msg = self.get_except(meta, "X", (Structure,), {})
-        self.assertEqual((cls, msg),
-                (AttributeError, "class must define a '_fields_' attribute"))
-
     def test_abstract_class(self):
         class X(Structure):
             _abstract_ = "something"
--- a/Lib/doctest.py
+++ b/Lib/doctest.py
@@ -1104,7 +1104,7 @@ class DocTestFinder:
             if source_lines is None:
                 return None
             pat = re.compile(r'^\s*class\s*%s\b' %
-                             getattr(obj, '__name__', '-'))
+                             re.escape(getattr(obj, '__name__', '-')))
             for i, line in enumerate(source_lines):
                 if pat.match(line):
                     lineno = i
--- a/Lib/email/feedparser.py
+++ b/Lib/email/feedparser.py
@@ -189,7 +189,7 @@ class FeedParser:
         assert not self._msgstack
         # Look for final set of defects
         if root.get_content_maintype() == 'multipart' \
-               and not root.is_multipart():
+               and not root.is_multipart() and not self._headersonly:
             defect = errors.MultipartInvariantViolationDefect()
             self.policy.handle_defect(root, defect)
         return root
--- a/Lib/enum.py
+++ b/Lib/enum.py
@@ -12,6 +12,7 @@ __all__ = [
         'FlagBoundary', 'STRICT', 'CONFORM', 'EJECT', 'KEEP',
         'global_flag_repr', 'global_enum_repr', 'global_str', 'global_enum',
         'EnumCheck', 'CONTINUOUS', 'NAMED_FLAGS', 'UNIQUE',
+        'pickle_by_global_name', 'pickle_by_enum_name',
         ]
 
 
@@ -918,7 +919,6 @@ class EnumType(type):
         body['__module__'] = module
         tmp_cls = type(name, (object, ), body)
         cls = _simple_enum(etype=cls, boundary=boundary or KEEP)(tmp_cls)
-        cls.__reduce_ex__ = _reduce_ex_by_global_name
         if as_global:
             global_enum(cls)
         else:
@@ -1225,7 +1225,13 @@ class Enum(metaclass=EnumType):
         return hash(self._name_)
 
     def __reduce_ex__(self, proto):
-        return getattr, (self.__class__, self._name_)
+        return self.__class__, (self._value_, )
+
+    def __deepcopy__(self,memo):
+        return self
+
+    def __copy__(self):
+        return self
 
     # enum.property is used to provide access to the `name` and
     # `value` attributes of enum members while keeping some measure of
@@ -1291,8 +1297,14 @@ class StrEnum(str, ReprEnum):
         return name.lower()
 
 
-def _reduce_ex_by_global_name(self, proto):
+def pickle_by_global_name(self, proto):
+    # should not be used with Flag-type enums
     return self.name
+_reduce_ex_by_global_name = pickle_by_global_name
+
+def pickle_by_enum_name(self, proto):
+    # should not be used with Flag-type enums
+    return getattr, (self.__class__, self._name_)
 
 class FlagBoundary(StrEnum):
     """
@@ -1314,23 +1326,6 @@ class Flag(Enum, boundary=STRICT):
     Support for flags
     """
 
-    def __reduce_ex__(self, proto):
-        cls = self.__class__
-        unknown = self._value_ & ~cls._flag_mask_
-        member_value = self._value_ & cls._flag_mask_
-        if unknown and member_value:
-            return _or_, (cls(member_value), unknown)
-        for val in _iter_bits_lsb(member_value):
-            rest = member_value & ~val
-            if rest:
-                return _or_, (cls(rest), cls._value2member_map_.get(val))
-            else:
-                break
-        if self._name_ is None:
-            return cls, (self._value_,)
-        else:
-            return getattr, (cls, self._name_)
-
     _numeric_repr_ = repr
 
     def _generate_next_value_(name, start, count, last_values):
@@ -1457,12 +1452,11 @@ class Flag(Enum, boundary=STRICT):
         else:
             pseudo_member._name_ = None
         # use setdefault in case another thread already created a composite
-        # with this value, but only if all members are known
-        # note: zero is a special case -- add it
-        if not unknown:
-            pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
-            if neg_value is not None:
-                cls._value2member_map_[neg_value] = pseudo_member
+        # with this value
+        # note: zero is a special case -- always add it
+        pseudo_member = cls._value2member_map_.setdefault(value, pseudo_member)
+        if neg_value is not None:
+            cls._value2member_map_[neg_value] = pseudo_member
         return pseudo_member
 
     def __contains__(self, other):
@@ -1534,14 +1528,10 @@ class Flag(Enum, boundary=STRICT):
 
     def __invert__(self):
         if self._inverted_ is None:
-            if self._boundary_ is KEEP:
-                # use all bits
+            if self._boundary_ in (EJECT, KEEP):
                 self._inverted_ = self.__class__(~self._value_)
             else:
-                # calculate flags not in this member
-                self._inverted_ = self.__class__(self._flag_mask_ ^ self._value_)
-            if isinstance(self._inverted_, self.__class__):
-                self._inverted_._inverted_ = self
+                self._inverted_ = self.__class__(self._singles_mask_ & ~self._value_)
         return self._inverted_
 
     __rand__ = __and__
@@ -2047,7 +2037,6 @@ def _old_convert_(etype, name, module, f
         # unless some values aren't comparable, in which case sort by name
         members.sort(key=lambda t: t[0])
     cls = etype(name, members, module=module, boundary=boundary or KEEP)
-    cls.__reduce_ex__ = _reduce_ex_by_global_name
     return cls
 
 _stdlib_enums = IntEnum, StrEnum, IntFlag
--- a/Lib/gettext.py
+++ b/Lib/gettext.py
@@ -422,10 +422,12 @@ class GNUTranslations(NullTranslations):
         missing = object()
         tmsg = self._catalog.get(message, missing)
         if tmsg is missing:
-            if self._fallback:
-                return self._fallback.gettext(message)
-            return message
-        return tmsg
+            tmsg = self._catalog.get((message, self.plural(1)), missing)
+        if tmsg is not missing:
+            return tmsg
+        if self._fallback:
+            return self._fallback.gettext(message)
+        return message
 
     def ngettext(self, msgid1, msgid2, n):
         try:
@@ -444,10 +446,12 @@ class GNUTranslations(NullTranslations):
         missing = object()
         tmsg = self._catalog.get(ctxt_msg_id, missing)
         if tmsg is missing:
-            if self._fallback:
-                return self._fallback.pgettext(context, message)
-            return message
-        return tmsg
+            tmsg = self._catalog.get((ctxt_msg_id, self.plural(1)), missing)
+        if tmsg is not missing:
+            return tmsg
+        if self._fallback:
+            return self._fallback.pgettext(context, message)
+        return message
 
     def npgettext(self, context, msgid1, msgid2, n):
         ctxt_msg_id = self.CONTEXT % (context, msgid1)
--- a/Lib/idlelib/idle_test/test_stackviewer.py
+++ b/Lib/idlelib/idle_test/test_stackviewer.py
@@ -6,19 +6,12 @@ from test.support import requires
 from tkinter import Tk
 
 from idlelib.tree import TreeNode, ScrolledCanvas
-import sys
 
 
 class StackBrowserTest(unittest.TestCase):
 
     @classmethod
     def setUpClass(cls):
-        svs = stackviewer.sys
-        try:
-            abc
-        except NameError:
-            svs.last_type, svs.last_value, svs.last_traceback = (
-                sys.exc_info())
 
         requires('gui')
         cls.root = Tk()
@@ -26,8 +19,6 @@ class StackBrowserTest(unittest.TestCase
 
     @classmethod
     def tearDownClass(cls):
-        svs = stackviewer.sys
-        del svs.last_traceback, svs.last_type, svs.last_value
 
         cls.root.update_idletasks()
 ##        for id in cls.root.tk.call('after', 'info'):
@@ -36,7 +27,10 @@ class StackBrowserTest(unittest.TestCase
         del cls.root
 
     def test_init(self):
-        sb = stackviewer.StackBrowser(self.root)
+        try:
+            abc
+        except NameError as exc:
+            sb = stackviewer.StackBrowser(self.root, exc)
         isi = self.assertIsInstance
         isi(stackviewer.sc, ScrolledCanvas)
         isi(stackviewer.item, stackviewer.StackTreeItem)
--- a/Lib/idlelib/pyshell.py
+++ b/Lib/idlelib/pyshell.py
@@ -1363,19 +1363,19 @@ class PyShell(OutputWindow):
                 self.text.tag_remove(self.user_input_insert_tags, index_before)
             self.shell_sidebar.update_sidebar()
 
-    def open_stack_viewer(self, event=None):
+    def open_stack_viewer(self, event=None):  # -n mode only
         if self.interp.rpcclt:
             return self.interp.remote_stack_viewer()
+
+        from idlelib.stackviewer import StackBrowser
         try:
-            sys.last_traceback
+            StackBrowser(self.root, sys.last_value, self.flist)
         except:
             messagebox.showerror("No stack trace",
                 "There is no stack trace yet.\n"
-                "(sys.last_traceback is not defined)",
+                "(sys.last_value is not defined)",
                 parent=self.text)
-            return
-        from idlelib.stackviewer import StackBrowser
-        StackBrowser(self.root, self.flist)
+        return None
 
     def view_restart_mark(self, event=None):
         self.text.see("iomark")
--- a/Lib/idlelib/run.py
+++ b/Lib/idlelib/run.py
@@ -140,11 +140,12 @@ def main(del_exitfunc=False):
 
     capture_warnings(True)
     sys.argv[:] = [""]
-    sockthread = threading.Thread(target=manage_socket,
-                                  name='SockThread',
-                                  args=((LOCALHOST, port),))
-    sockthread.daemon = True
-    sockthread.start()
+    threading.Thread(target=manage_socket,
+                     name='SockThread',
+                     args=((LOCALHOST, port),),
+                     daemon=True,
+                    ).start()
+
     while True:
         try:
             if exit_now:
@@ -621,7 +622,7 @@ class Executive:
 
     def stackviewer(self, flist_oid=None):
         if self.user_exc_info:
-            typ, val, tb = self.user_exc_info
+            _, exc, tb = self.user_exc_info
         else:
             return None
         flist = None
@@ -629,9 +630,8 @@ class Executive:
             flist = self.rpchandler.get_remote_proxy(flist_oid)
         while tb and tb.tb_frame.f_globals["__name__"] in ["rpc", "run"]:
             tb = tb.tb_next
-        sys.last_type = typ
-        sys.last_value = val
-        item = stackviewer.StackTreeItem(flist, tb)
+        exc.__traceback__ = tb
+        item = stackviewer.StackTreeItem(exc, flist)
         return debugobj_r.remote_object_tree_item(item)
 
 
--- a/Lib/idlelib/stackviewer.py
+++ b/Lib/idlelib/stackviewer.py
@@ -1,33 +1,30 @@
 import linecache
 import os
-import sys
 
 import tkinter as tk
 
 from idlelib.debugobj import ObjectTreeItem, make_objecttreeitem
 from idlelib.tree import TreeNode, TreeItem, ScrolledCanvas
 
-def StackBrowser(root, flist=None, tb=None, top=None):
+def StackBrowser(root, exc, flist=None, top=None):
     global sc, item, node  # For testing.
     if top is None:
         top = tk.Toplevel(root)
     sc = ScrolledCanvas(top, bg="white", highlightthickness=0)
     sc.frame.pack(expand=1, fill="both")
-    item = StackTreeItem(flist, tb)
+    item = StackTreeItem(exc, flist)
     node = TreeNode(sc.canvas, None, item)
     node.expand()
 
 
 class StackTreeItem(TreeItem):
 
-    def __init__(self, flist=None, tb=None):
+    def __init__(self, exc, flist=None):
         self.flist = flist
-        self.stack = self.get_stack(tb)
-        self.text = self.get_exception()
+        self.stack = self.get_stack(None if exc is None else exc.__traceback__)
+        self.text = f"{type(exc).__name__}: {str(exc)}"
 
     def get_stack(self, tb):
-        if tb is None:
-            tb = sys.last_traceback
         stack = []
         if tb and tb.tb_frame is None:
             tb = tb.tb_next
@@ -36,17 +33,7 @@ class StackTreeItem(TreeItem):
             tb = tb.tb_next
         return stack
 
-    def get_exception(self):
-        type = sys.last_type
-        value = sys.last_value
-        if hasattr(type, "__name__"):
-            type = type.__name__
-        s = str(type)
-        if value is not None:
-            s = s + ": " + str(value)
-        return s
-
-    def GetText(self):
+    def GetText(self):  # Titlecase names are overrides.
         return self.text
 
     def GetSubList(self):
@@ -133,19 +120,9 @@ def _stack_viewer(parent):  # htest #
     flist = PyShellFileList(top)
     try: # to obtain a traceback object
         intentional_name_error
-    except NameError:
-        exc_type, exc_value, exc_tb = sys.exc_info()
-    # inject stack trace to sys
-    sys.last_type = exc_type
-    sys.last_value = exc_value
-    sys.last_traceback = exc_tb
-
-    StackBrowser(top, flist=flist, top=top, tb=exc_tb)
-
-    # restore sys to original state
-    del sys.last_type
-    del sys.last_value
-    del sys.last_traceback
+    except NameError as e:
+        StackBrowser(top, e, flist=flist, top=top)
+
 
 if __name__ == '__main__':
     from unittest import main
--- a/Lib/logging/handlers.py
+++ b/Lib/logging/handlers.py
@@ -1399,7 +1399,7 @@ class MemoryHandler(BufferingHandler):
         records to the target, if there is one. Override if you want
         different behaviour.
 
-        The record buffer is also cleared by this operation.
+        The record buffer is only cleared if a target has been set.
         """
         self.acquire()
         try:
--- a/Lib/multiprocessing/forkserver.py
+++ b/Lib/multiprocessing/forkserver.py
@@ -61,7 +61,7 @@ class ForkServer(object):
 
     def set_forkserver_preload(self, modules_names):
         '''Set list of module names to try to load in forkserver process.'''
-        if not all(type(mod) is str for mod in self._preload_modules):
+        if not all(type(mod) is str for mod in modules_names):
             raise TypeError('module_names must be a list of strings')
         self._preload_modules = modules_names
 
--- a/Lib/multiprocessing/spawn.py
+++ b/Lib/multiprocessing/spawn.py
@@ -31,11 +31,13 @@ if sys.platform != 'win32':
     WINSERVICE = False
 else:
     WINEXE = getattr(sys, 'frozen', False)
-    WINSERVICE = sys.executable.lower().endswith("pythonservice.exe")
+    WINSERVICE = sys.executable and sys.executable.lower().endswith("pythonservice.exe")
 
 def set_executable(exe):
     global _python_exe
-    if sys.platform == 'win32':
+    if exe is None:
+        _python_exe = exe
+    elif sys.platform == 'win32':
         _python_exe = os.fsdecode(exe)
     else:
         _python_exe = os.fsencode(exe)
@@ -148,7 +150,11 @@ def _check_not_importing_main():
                 ...
 
         The "freeze_support()" line can be omitted if the program
-        is not going to be frozen to produce an executable.''')
+        is not going to be frozen to produce an executable.
+
+        To fix this issue, refer to the "Safe importing of main module"
+        section in https://docs.python.org/3/library/multiprocessing.html
+        ''')
 
 
 def get_preparation_data(name):
--- a/Lib/pydoc.py
+++ b/Lib/pydoc.py
@@ -1778,12 +1778,21 @@ def render_doc(thing, title='Python Libr
     return title % desc + '\n\n' + renderer.document(object, name)
 
 def doc(thing, title='Python Library Documentation: %s', forceload=0,
-        output=None):
+        output=None, is_cli=False):
     """Display text documentation, given an object or a path to an object."""
     if output is None:
-        pager(render_doc(thing, title, forceload))
+        try:
+            pager(render_doc(thing, title, forceload))
+        except ImportError as exc:
+            if is_cli:
+                raise
+            print(exc)
     else:
-        output.write(render_doc(thing, title, forceload, plaintext))
+        try:
+            s = render_doc(thing, title, forceload, plaintext)
+        except ImportError as exc:
+            s = str(exc)
+        output.write(s)
 
 def writedoc(thing, forceload=0):
     """Write HTML documentation to a file in the current directory."""
@@ -2042,8 +2051,8 @@ has the same effect as typing a particul
             self.output.flush()
             return self.input.readline()
 
-    def help(self, request):
-        if type(request) is type(''):
+    def help(self, request, is_cli=False):
+        if isinstance(request, str):
             request = request.strip()
             if request == 'keywords': self.listkeywords()
             elif request == 'symbols': self.listsymbols()
@@ -2054,13 +2063,13 @@ has the same effect as typing a particul
             elif request in self.symbols: self.showsymbol(request)
             elif request in ['True', 'False', 'None']:
                 # special case these keywords since they are objects too
-                doc(eval(request), 'Help on %s:')
+                doc(eval(request), 'Help on %s:', is_cli=is_cli)
             elif request in self.keywords: self.showtopic(request)
             elif request in self.topics: self.showtopic(request)
-            elif request: doc(request, 'Help on %s:', output=self._output)
-            else: doc(str, 'Help on %s:', output=self._output)
+            elif request: doc(request, 'Help on %s:', output=self._output, is_cli=is_cli)
+            else: doc(str, 'Help on %s:', output=self._output, is_cli=is_cli)
         elif isinstance(request, Helper): self()
-        else: doc(request, 'Help on %s:', output=self._output)
+        else: doc(request, 'Help on %s:', output=self._output, is_cli=is_cli)
         self.output.write('\n')
 
     def intro(self):
@@ -2798,7 +2807,7 @@ def cli():
                     else:
                         writedoc(arg)
                 else:
-                    help.help(arg)
+                    help.help(arg, is_cli=True)
             except (ImportError, ErrorDuringImport) as value:
                 print(value)
                 sys.exit(1)
--- a/Lib/re/_parser.py
+++ b/Lib/re/_parser.py
@@ -114,7 +114,6 @@ class SubPattern:
         self.width = None
 
     def dump(self, level=0):
-        nl = True
         seqtypes = (tuple, list)
         for op, av in self.data:
             print(level*"  " + str(op), end='')
@@ -136,6 +135,9 @@ class SubPattern:
                 if item_no:
                     print(level*"  " + "ELSE")
                     item_no.dump(level+1)
+            elif isinstance(av, SubPattern):
+                print()
+                av.dump(level+1)
             elif isinstance(av, seqtypes):
                 nl = False
                 for a in av:
--- a/Lib/shutil.py
+++ b/Lib/shutil.py
@@ -1114,10 +1114,14 @@ def make_archive(base_name, format, root
     if base_dir is None:
         base_dir = os.curdir
 
-    support_root_dir = format_info[3]
+    supports_root_dir = format_info[3]
     save_cwd = None
     if root_dir is not None:
-        if support_root_dir:
+        stmd = os.stat(root_dir).st_mode
+        if not stat.S_ISDIR(stmd):
+            raise NotADirectoryError(errno.ENOTDIR, 'Not a directory', root_dir)
+
+        if supports_root_dir:
             # Support path-like base_name here for backwards-compatibility.
             base_name = os.fspath(base_name)
             kwargs['root_dir'] = root_dir
--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -346,7 +346,7 @@ def _args_from_interpreter_flags():
     if dev_mode:
         args.extend(('-X', 'dev'))
     for opt in ('faulthandler', 'tracemalloc', 'importtime',
-                'showrefcount', 'utf8'):
+                'frozen_modules', 'showrefcount', 'utf8'):
         if opt in xoptions:
             value = xoptions[opt]
             if value is True:
--- a/Lib/test/_test_multiprocessing.py
+++ b/Lib/test/_test_multiprocessing.py
@@ -13,6 +13,7 @@ import sys
 import os
 import gc
 import errno
+import functools
 import signal
 import array
 import socket
@@ -31,6 +32,7 @@ from test import support
 from test.support import hashlib_helper
 from test.support import import_helper
 from test.support import os_helper
+from test.support import script_helper
 from test.support import socket_helper
 from test.support import threading_helper
 from test.support import warnings_helper
@@ -170,6 +172,59 @@ def check_enough_semaphores():
                             "to run the test (required: %d)." % nsems_min)
 
 
+def only_run_in_spawn_testsuite(reason):
+    """Returns a decorator: raises SkipTest when SM != spawn at test time.
+
+    This can be useful to save overall Python test suite execution time.
+    "spawn" is the universal mode available on all platforms so this limits the
+    decorated test to only execute within test_multiprocessing_spawn.
+
+    This would not be necessary if we refactored our test suite to split things
+    into other test files when they are not start method specific to be rerun
+    under all start methods.
+    """
+
+    def decorator(test_item):
+
+        @functools.wraps(test_item)
+        def spawn_check_wrapper(*args, **kwargs):
+            if (start_method := multiprocessing.get_start_method()) != "spawn":
+                raise unittest.SkipTest(f"{start_method=}, not 'spawn'; {reason}")
+            return test_item(*args, **kwargs)
+
+        return spawn_check_wrapper
+
+    return decorator
+
+
+class TestInternalDecorators(unittest.TestCase):
+    """Logic within a test suite that could errantly skip tests? Test it!"""
+
+    @unittest.skipIf(sys.platform == "win32", "test requires that fork exists.")
+    def test_only_run_in_spawn_testsuite(self):
+        if multiprocessing.get_start_method() != "spawn":
+            raise unittest.SkipTest("only run in test_multiprocessing_spawn.")
+
+        try:
+            @only_run_in_spawn_testsuite("testing this decorator")
+            def return_four_if_spawn():
+                return 4
+        except Exception as err:
+            self.fail(f"expected decorated `def` not to raise; caught {err}")
+
+        orig_start_method = multiprocessing.get_start_method(allow_none=True)
+        try:
+            multiprocessing.set_start_method("spawn", force=True)
+            self.assertEqual(return_four_if_spawn(), 4)
+            multiprocessing.set_start_method("fork", force=True)
+            with self.assertRaises(unittest.SkipTest) as ctx:
+                return_four_if_spawn()
+            self.assertIn("testing this decorator", str(ctx.exception))
+            self.assertIn("start_method=", str(ctx.exception))
+        finally:
+            multiprocessing.set_start_method(orig_start_method, force=True)
+
+
 #
 # Creates a wrapper for a function which records the time it takes to finish
 #
@@ -5238,6 +5293,14 @@ class TestStartMethod(unittest.TestCase)
             self.assertRaises(ValueError, ctx.set_start_method, None)
             self.check_context(ctx)
 
+    def test_context_check_module_types(self):
+        try:
+            ctx = multiprocessing.get_context('forkserver')
+        except ValueError:
+            raise unittest.SkipTest('forkserver should be available')
+        with self.assertRaisesRegex(TypeError, 'module_names must be a list of strings'):
+            ctx.set_forkserver_preload([1, 2, 3])
+
     def test_set_get(self):
         multiprocessing.set_forkserver_preload(PRELOAD)
         count = 0
@@ -5775,6 +5838,7 @@ class TestSyncManagerTypes(unittest.Test
 
 
 class TestNamedResource(unittest.TestCase):
+    @only_run_in_spawn_testsuite("spawn specific test.")
     def test_global_named_resource_spawn(self):
         #
         # gh-90549: Check that global named resources in main module
@@ -5785,22 +5849,18 @@ class TestNamedResource(unittest.TestCas
         with open(testfn, 'w', encoding='utf-8') as f:
             f.write(textwrap.dedent('''\
                 import multiprocessing as mp
-
                 ctx = mp.get_context('spawn')
-
                 global_resource = ctx.Semaphore()
-
                 def submain(): pass
-
                 if __name__ == '__main__':
                     p = ctx.Process(target=submain)
                     p.start()
                     p.join()
             '''))
-        rc, out, err = test.support.script_helper.assert_python_ok(testfn)
+        rc, out, err = script_helper.assert_python_ok(testfn)
         # on error, err = 'UserWarning: resource_tracker: There appear to
         # be 1 leaked semaphore objects to clean up at shutdown'
-        self.assertEqual(err, b'')
+        self.assertFalse(err, msg=err.decode('utf-8'))
 
 
 class MiscTestCase(unittest.TestCase):
@@ -5809,6 +5869,24 @@ class MiscTestCase(unittest.TestCase):
         support.check__all__(self, multiprocessing, extra=multiprocessing.__all__,
                              not_exported=['SUBDEBUG', 'SUBWARNING'])
 
+    @only_run_in_spawn_testsuite("avoids redundant testing.")
+    def test_spawn_sys_executable_none_allows_import(self):
+        # Regression test for a bug introduced in
+        # https://github.com/python/cpython/issues/90876 that caused an
+        # ImportError in multiprocessing when sys.executable was None.
+        # This can be true in embedded environments.
+        rc, out, err = script_helper.assert_python_ok(
+            "-c",
+            """if 1:
+            import sys
+            sys.executable = None
+            assert "multiprocessing" not in sys.modules, "already imported!"
+            import multiprocessing
+            import multiprocessing.spawn  # This should not fail\n""",
+        )
+        self.assertEqual(rc, 0)
+        self.assertFalse(err, msg=err.decode('utf-8'))
+
 
 #
 # Mixins
--- a/Lib/test/clinic.test
+++ /dev/null
@@ -1,3558 +0,0 @@
-/*[clinic input]
-output preset block
-[clinic start generated code]*/
-/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3c81ac2402d06a8b]*/
-
-
-/*[clinic input]
-test_object_converter
-
-    a: object
-    b: object(converter="PyUnicode_FSConverter")
-    c: object(subclass_of="&PyUnicode_Type")
-    d: object(type="PyUnicode_Object *")
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_object_converter__doc__,
-"test_object_converter($module, a, b, c, d, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECT_CONVERTER_METHODDEF    \
-    {"test_object_converter", _PyCFunction_CAST(test_object_converter), METH_FASTCALL, test_object_converter__doc__},
-
-static PyObject *
-test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
-                           PyObject *c, PyUnicode_Object *d);
-
-static PyObject *
-test_object_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-    PyUnicode_Object *d;
-
-    if (!_PyArg_CheckPositional("test_object_converter", nargs, 4, 4)) {
-        goto exit;
-    }
-    a = args[0];
-    if (!PyUnicode_FSConverter(args[1], &b)) {
-        goto exit;
-    }
-    if (!PyUnicode_Check(args[2])) {
-        _PyArg_BadArgument("test_object_converter", "argument 3", "str", args[2]);
-        goto exit;
-    }
-    c = args[2];
-    d = (PyUnicode_Object *)args[3];
-    return_value = test_object_converter_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
-                           PyObject *c, PyUnicode_Object *d)
-/*[clinic end generated code: output=886f4f9b598726b6 input=005e6a8a711a869b]*/
-
-
-/*[clinic input]
-test_object_converter_one_arg
-
-    a: object
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_object_converter_one_arg__doc__,
-"test_object_converter_one_arg($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECT_CONVERTER_ONE_ARG_METHODDEF    \
-    {"test_object_converter_one_arg", (PyCFunction)test_object_converter_one_arg, METH_O, test_object_converter_one_arg__doc__},
-
-static PyObject *
-test_object_converter_one_arg(PyObject *module, PyObject *a)
-/*[clinic end generated code: output=6da755f8502139df input=d635d92a421f1ca3]*/
-
-
-/*[clinic input]
-test_objects_converter
-
-    a: object
-    b: object = NULL
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_objects_converter__doc__,
-"test_objects_converter($module, a, b=<unrepresentable>, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECTS_CONVERTER_METHODDEF    \
-    {"test_objects_converter", _PyCFunction_CAST(test_objects_converter), METH_FASTCALL, test_objects_converter__doc__},
-
-static PyObject *
-test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_objects_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *b = NULL;
-
-    if (!_PyArg_CheckPositional("test_objects_converter", nargs, 1, 2)) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    b = args[1];
-skip_optional:
-    return_value = test_objects_converter_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=fc26328b79d46bb7 input=4cbb3d9edd2a36f3]*/
-
-
-/*[clinic input]
-test_object_converter_subclass_of
-
-    a: object(subclass_of="&PyLong_Type")
-    b: object(subclass_of="&PyTuple_Type")
-    c: object(subclass_of="&PyList_Type")
-    d: object(subclass_of="&PySet_Type")
-    e: object(subclass_of="&PyFrozenSet_Type")
-    f: object(subclass_of="&PyDict_Type")
-    g: object(subclass_of="&PyUnicode_Type")
-    h: object(subclass_of="&PyBytes_Type")
-    i: object(subclass_of="&PyByteArray_Type")
-    j: object(subclass_of="&MyType")
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_object_converter_subclass_of__doc__,
-"test_object_converter_subclass_of($module, a, b, c, d, e, f, g, h, i,\n"
-"                                  j, /)\n"
-"--\n"
-"\n");
-
-#define TEST_OBJECT_CONVERTER_SUBCLASS_OF_METHODDEF    \
-    {"test_object_converter_subclass_of", _PyCFunction_CAST(test_object_converter_subclass_of), METH_FASTCALL, test_object_converter_subclass_of__doc__},
-
-static PyObject *
-test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d,
-                                       PyObject *e, PyObject *f, PyObject *g,
-                                       PyObject *h, PyObject *i, PyObject *j);
-
-static PyObject *
-test_object_converter_subclass_of(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-    PyObject *d;
-    PyObject *e;
-    PyObject *f;
-    PyObject *g;
-    PyObject *h;
-    PyObject *i;
-    PyObject *j;
-
-    if (!_PyArg_CheckPositional("test_object_converter_subclass_of", nargs, 10, 10)) {
-        goto exit;
-    }
-    if (!PyLong_Check(args[0])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 1", "int", args[0]);
-        goto exit;
-    }
-    a = args[0];
-    if (!PyTuple_Check(args[1])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 2", "tuple", args[1]);
-        goto exit;
-    }
-    b = args[1];
-    if (!PyList_Check(args[2])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 3", "list", args[2]);
-        goto exit;
-    }
-    c = args[2];
-    if (!PySet_Check(args[3])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 4", "set", args[3]);
-        goto exit;
-    }
-    d = args[3];
-    if (!PyFrozenSet_Check(args[4])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 5", "frozenset", args[4]);
-        goto exit;
-    }
-    e = args[4];
-    if (!PyDict_Check(args[5])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 6", "dict", args[5]);
-        goto exit;
-    }
-    f = args[5];
-    if (!PyUnicode_Check(args[6])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 7", "str", args[6]);
-        goto exit;
-    }
-    g = args[6];
-    if (!PyBytes_Check(args[7])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 8", "bytes", args[7]);
-        goto exit;
-    }
-    h = args[7];
-    if (!PyByteArray_Check(args[8])) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 9", "bytearray", args[8]);
-        goto exit;
-    }
-    i = args[8];
-    if (!PyObject_TypeCheck(args[9], &MyType)) {
-        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 10", (&MyType)->tp_name, args[9]);
-        goto exit;
-    }
-    j = args[9];
-    return_value = test_object_converter_subclass_of_impl(module, a, b, c, d, e, f, g, h, i, j);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d,
-                                       PyObject *e, PyObject *f, PyObject *g,
-                                       PyObject *h, PyObject *i, PyObject *j)
-/*[clinic end generated code: output=e4b07c9a54479a40 input=31b06b772d5f983e]*/
-
-
-/*[clinic input]
-test_PyBytesObject_converter
-
-    a: PyBytesObject
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_PyBytesObject_converter__doc__,
-"test_PyBytesObject_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PYBYTESOBJECT_CONVERTER_METHODDEF    \
-    {"test_PyBytesObject_converter", (PyCFunction)test_PyBytesObject_converter, METH_O, test_PyBytesObject_converter__doc__},
-
-static PyObject *
-test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a);
-
-static PyObject *
-test_PyBytesObject_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    PyBytesObject *a;
-
-    if (!PyBytes_Check(arg)) {
-        _PyArg_BadArgument("test_PyBytesObject_converter", "argument", "bytes", arg);
-        goto exit;
-    }
-    a = (PyBytesObject *)arg;
-    return_value = test_PyBytesObject_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a)
-/*[clinic end generated code: output=7539d628e6fceace input=12b10c7cb5750400]*/
-
-
-/*[clinic input]
-test_PyByteArrayObject_converter
-
-    a: PyByteArrayObject
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_PyByteArrayObject_converter__doc__,
-"test_PyByteArrayObject_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PYBYTEARRAYOBJECT_CONVERTER_METHODDEF    \
-    {"test_PyByteArrayObject_converter", (PyCFunction)test_PyByteArrayObject_converter, METH_O, test_PyByteArrayObject_converter__doc__},
-
-static PyObject *
-test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a);
-
-static PyObject *
-test_PyByteArrayObject_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    PyByteArrayObject *a;
-
-    if (!PyByteArray_Check(arg)) {
-        _PyArg_BadArgument("test_PyByteArrayObject_converter", "argument", "bytearray", arg);
-        goto exit;
-    }
-    a = (PyByteArrayObject *)arg;
-    return_value = test_PyByteArrayObject_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a)
-/*[clinic end generated code: output=1245af9f5b3e355e input=5a657da535d194ae]*/
-
-
-/*[clinic input]
-test_unicode_converter
-
-    a: unicode
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unicode_converter__doc__,
-"test_unicode_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNICODE_CONVERTER_METHODDEF    \
-    {"test_unicode_converter", (PyCFunction)test_unicode_converter, METH_O, test_unicode_converter__doc__},
-
-static PyObject *
-test_unicode_converter_impl(PyObject *module, PyObject *a);
-
-static PyObject *
-test_unicode_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-
-    if (!PyUnicode_Check(arg)) {
-        _PyArg_BadArgument("test_unicode_converter", "argument", "str", arg);
-        goto exit;
-    }
-    if (PyUnicode_READY(arg) == -1) {
-        goto exit;
-    }
-    a = arg;
-    return_value = test_unicode_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unicode_converter_impl(PyObject *module, PyObject *a)
-/*[clinic end generated code: output=18f1e3880c862611 input=aa33612df92aa9c5]*/
-
-
-/*[clinic input]
-test_bool_converter
-
-    a: bool = True
-    b: bool(accept={object}) = True
-    c: bool(accept={int}) = True
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_bool_converter__doc__,
-"test_bool_converter($module, a=True, b=True, c=True, /)\n"
-"--\n"
-"\n");
-
-#define TEST_BOOL_CONVERTER_METHODDEF    \
-    {"test_bool_converter", _PyCFunction_CAST(test_bool_converter), METH_FASTCALL, test_bool_converter__doc__},
-
-static PyObject *
-test_bool_converter_impl(PyObject *module, int a, int b, int c);
-
-static PyObject *
-test_bool_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    int a = 1;
-    int b = 1;
-    int c = 1;
-
-    if (!_PyArg_CheckPositional("test_bool_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = PyObject_IsTrue(args[0]);
-    if (a < 0) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    b = PyObject_IsTrue(args[1]);
-    if (b < 0) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    c = _PyLong_AsInt(args[2]);
-    if (c == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_bool_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_bool_converter_impl(PyObject *module, int a, int b, int c)
-/*[clinic end generated code: output=27f0e653a70b9be3 input=939854fa9f248c60]*/
-
-
-/*[clinic input]
-test_char_converter
-
-    a: char = b'A'
-    b: char = b'\a'
-    c: char = b'\b'
-    d: char = b'\t'
-    e: char = b'\n'
-    f: char = b'\v'
-    g: char = b'\f'
-    h: char = b'\r'
-    i: char = b'"'
-    j: char = b"'"
-    k: char = b'?'
-    l: char = b'\\'
-    m: char = b'\000'
-    n: char = b'\377'
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_char_converter__doc__,
-"test_char_converter($module, a=b\'A\', b=b\'\\x07\', c=b\'\\x08\', d=b\'\\t\',\n"
-"                    e=b\'\\n\', f=b\'\\x0b\', g=b\'\\x0c\', h=b\'\\r\', i=b\'\"\',\n"
-"                    j=b\"\'\", k=b\'?\', l=b\'\\\\\', m=b\'\\x00\', n=b\'\\xff\', /)\n"
-"--\n"
-"\n");
-
-#define TEST_CHAR_CONVERTER_METHODDEF    \
-    {"test_char_converter", _PyCFunction_CAST(test_char_converter), METH_FASTCALL, test_char_converter__doc__},
-
-static PyObject *
-test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
-                         char e, char f, char g, char h, char i, char j,
-                         char k, char l, char m, char n);
-
-static PyObject *
-test_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    char a = 'A';
-    char b = '\x07';
-    char c = '\x08';
-    char d = '\t';
-    char e = '\n';
-    char f = '\x0b';
-    char g = '\x0c';
-    char h = '\r';
-    char i = '"';
-    char j = '\'';
-    char k = '?';
-    char l = '\\';
-    char m = '\x00';
-    char n = '\xff';
-
-    if (!_PyArg_CheckPositional("test_char_converter", nargs, 0, 14)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[0]) && PyBytes_GET_SIZE(args[0]) == 1) {
-        a = PyBytes_AS_STRING(args[0])[0];
-    }
-    else if (PyByteArray_Check(args[0]) && PyByteArray_GET_SIZE(args[0]) == 1) {
-        a = PyByteArray_AS_STRING(args[0])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 1", "a byte string of length 1", args[0]);
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[1]) && PyBytes_GET_SIZE(args[1]) == 1) {
-        b = PyBytes_AS_STRING(args[1])[0];
-    }
-    else if (PyByteArray_Check(args[1]) && PyByteArray_GET_SIZE(args[1]) == 1) {
-        b = PyByteArray_AS_STRING(args[1])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 2", "a byte string of length 1", args[1]);
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[2]) && PyBytes_GET_SIZE(args[2]) == 1) {
-        c = PyBytes_AS_STRING(args[2])[0];
-    }
-    else if (PyByteArray_Check(args[2]) && PyByteArray_GET_SIZE(args[2]) == 1) {
-        c = PyByteArray_AS_STRING(args[2])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 3", "a byte string of length 1", args[2]);
-        goto exit;
-    }
-    if (nargs < 4) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[3]) && PyBytes_GET_SIZE(args[3]) == 1) {
-        d = PyBytes_AS_STRING(args[3])[0];
-    }
-    else if (PyByteArray_Check(args[3]) && PyByteArray_GET_SIZE(args[3]) == 1) {
-        d = PyByteArray_AS_STRING(args[3])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 4", "a byte string of length 1", args[3]);
-        goto exit;
-    }
-    if (nargs < 5) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[4]) && PyBytes_GET_SIZE(args[4]) == 1) {
-        e = PyBytes_AS_STRING(args[4])[0];
-    }
-    else if (PyByteArray_Check(args[4]) && PyByteArray_GET_SIZE(args[4]) == 1) {
-        e = PyByteArray_AS_STRING(args[4])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 5", "a byte string of length 1", args[4]);
-        goto exit;
-    }
-    if (nargs < 6) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[5]) && PyBytes_GET_SIZE(args[5]) == 1) {
-        f = PyBytes_AS_STRING(args[5])[0];
-    }
-    else if (PyByteArray_Check(args[5]) && PyByteArray_GET_SIZE(args[5]) == 1) {
-        f = PyByteArray_AS_STRING(args[5])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 6", "a byte string of length 1", args[5]);
-        goto exit;
-    }
-    if (nargs < 7) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[6]) && PyBytes_GET_SIZE(args[6]) == 1) {
-        g = PyBytes_AS_STRING(args[6])[0];
-    }
-    else if (PyByteArray_Check(args[6]) && PyByteArray_GET_SIZE(args[6]) == 1) {
-        g = PyByteArray_AS_STRING(args[6])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 7", "a byte string of length 1", args[6]);
-        goto exit;
-    }
-    if (nargs < 8) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[7]) && PyBytes_GET_SIZE(args[7]) == 1) {
-        h = PyBytes_AS_STRING(args[7])[0];
-    }
-    else if (PyByteArray_Check(args[7]) && PyByteArray_GET_SIZE(args[7]) == 1) {
-        h = PyByteArray_AS_STRING(args[7])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 8", "a byte string of length 1", args[7]);
-        goto exit;
-    }
-    if (nargs < 9) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[8]) && PyBytes_GET_SIZE(args[8]) == 1) {
-        i = PyBytes_AS_STRING(args[8])[0];
-    }
-    else if (PyByteArray_Check(args[8]) && PyByteArray_GET_SIZE(args[8]) == 1) {
-        i = PyByteArray_AS_STRING(args[8])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 9", "a byte string of length 1", args[8]);
-        goto exit;
-    }
-    if (nargs < 10) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[9]) && PyBytes_GET_SIZE(args[9]) == 1) {
-        j = PyBytes_AS_STRING(args[9])[0];
-    }
-    else if (PyByteArray_Check(args[9]) && PyByteArray_GET_SIZE(args[9]) == 1) {
-        j = PyByteArray_AS_STRING(args[9])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 10", "a byte string of length 1", args[9]);
-        goto exit;
-    }
-    if (nargs < 11) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[10]) && PyBytes_GET_SIZE(args[10]) == 1) {
-        k = PyBytes_AS_STRING(args[10])[0];
-    }
-    else if (PyByteArray_Check(args[10]) && PyByteArray_GET_SIZE(args[10]) == 1) {
-        k = PyByteArray_AS_STRING(args[10])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 11", "a byte string of length 1", args[10]);
-        goto exit;
-    }
-    if (nargs < 12) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[11]) && PyBytes_GET_SIZE(args[11]) == 1) {
-        l = PyBytes_AS_STRING(args[11])[0];
-    }
-    else if (PyByteArray_Check(args[11]) && PyByteArray_GET_SIZE(args[11]) == 1) {
-        l = PyByteArray_AS_STRING(args[11])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 12", "a byte string of length 1", args[11]);
-        goto exit;
-    }
-    if (nargs < 13) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[12]) && PyBytes_GET_SIZE(args[12]) == 1) {
-        m = PyBytes_AS_STRING(args[12])[0];
-    }
-    else if (PyByteArray_Check(args[12]) && PyByteArray_GET_SIZE(args[12]) == 1) {
-        m = PyByteArray_AS_STRING(args[12])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 13", "a byte string of length 1", args[12]);
-        goto exit;
-    }
-    if (nargs < 14) {
-        goto skip_optional;
-    }
-    if (PyBytes_Check(args[13]) && PyBytes_GET_SIZE(args[13]) == 1) {
-        n = PyBytes_AS_STRING(args[13])[0];
-    }
-    else if (PyByteArray_Check(args[13]) && PyByteArray_GET_SIZE(args[13]) == 1) {
-        n = PyByteArray_AS_STRING(args[13])[0];
-    }
-    else {
-        _PyArg_BadArgument("test_char_converter", "argument 14", "a byte string of length 1", args[13]);
-        goto exit;
-    }
-skip_optional:
-    return_value = test_char_converter_impl(module, a, b, c, d, e, f, g, h, i, j, k, l, m, n);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
-                         char e, char f, char g, char h, char i, char j,
-                         char k, char l, char m, char n)
-/*[clinic end generated code: output=98589f02422fe6b1 input=e42330417a44feac]*/
-
-
-/*[clinic input]
-test_unsigned_char_converter
-
-    a: unsigned_char = 12
-    b: unsigned_char(bitwise=False) = 34
-    c: unsigned_char(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_char_converter__doc__,
-"test_unsigned_char_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_CHAR_CONVERTER_METHODDEF    \
-    {"test_unsigned_char_converter", _PyCFunction_CAST(test_unsigned_char_converter), METH_FASTCALL, test_unsigned_char_converter__doc__},
-
-static PyObject *
-test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
-                                  unsigned char b, unsigned char c);
-
-static PyObject *
-test_unsigned_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned char a = 12;
-    unsigned char b = 34;
-    unsigned char c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_char_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    {
-        long ival = PyLong_AsLong(args[0]);
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else if (ival < 0) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is less than minimum");
-            goto exit;
-        }
-        else if (ival > UCHAR_MAX) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is greater than maximum");
-            goto exit;
-        }
-        else {
-            a = (unsigned char) ival;
-        }
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    {
-        long ival = PyLong_AsLong(args[1]);
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else if (ival < 0) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is less than minimum");
-            goto exit;
-        }
-        else if (ival > UCHAR_MAX) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "unsigned byte integer is greater than maximum");
-            goto exit;
-        }
-        else {
-            b = (unsigned char) ival;
-        }
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    {
-        unsigned long ival = PyLong_AsUnsignedLongMask(args[2]);
-        if (ival == (unsigned long)-1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else {
-            c = (unsigned char) ival;
-        }
-    }
-skip_optional:
-    return_value = test_unsigned_char_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
-                                  unsigned char b, unsigned char c)
-/*[clinic end generated code: output=45920dbedc22eb55 input=021414060993e289]*/
-
-
-/*[clinic input]
-test_short_converter
-
-    a: short = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_short_converter__doc__,
-"test_short_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_SHORT_CONVERTER_METHODDEF    \
-    {"test_short_converter", _PyCFunction_CAST(test_short_converter), METH_FASTCALL, test_short_converter__doc__},
-
-static PyObject *
-test_short_converter_impl(PyObject *module, short a);
-
-static PyObject *
-test_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    short a = 12;
-
-    if (!_PyArg_CheckPositional("test_short_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    {
-        long ival = PyLong_AsLong(args[0]);
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        else if (ival < SHRT_MIN) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "signed short integer is less than minimum");
-            goto exit;
-        }
-        else if (ival > SHRT_MAX) {
-            PyErr_SetString(PyExc_OverflowError,
-                            "signed short integer is greater than maximum");
-            goto exit;
-        }
-        else {
-            a = (short) ival;
-        }
-    }
-skip_optional:
-    return_value = test_short_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_short_converter_impl(PyObject *module, short a)
-/*[clinic end generated code: output=a580945bd6963d45 input=6a8a7a509a498ff4]*/
-
-
-/*[clinic input]
-test_unsigned_short_converter
-
-    a: unsigned_short = 12
-    b: unsigned_short(bitwise=False) = 34
-    c: unsigned_short(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_short_converter__doc__,
-"test_unsigned_short_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_SHORT_CONVERTER_METHODDEF    \
-    {"test_unsigned_short_converter", _PyCFunction_CAST(test_unsigned_short_converter), METH_FASTCALL, test_unsigned_short_converter__doc__},
-
-static PyObject *
-test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
-                                   unsigned short b, unsigned short c);
-
-static PyObject *
-test_unsigned_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned short a = 12;
-    unsigned short b = 34;
-    unsigned short c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_short_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedShort_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedShort_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    c = (unsigned short)PyLong_AsUnsignedLongMask(args[2]);
-    if (c == (unsigned short)-1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_unsigned_short_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
-                                   unsigned short b, unsigned short c)
-/*[clinic end generated code: output=e6e990df729114fc input=cdfd8eff3d9176b4]*/
-
-
-/*[clinic input]
-test_int_converter
-
-    a: int = 12
-    b: int(accept={int}) = 34
-    c: int(accept={str}) = 45
-    d: int(type='myenum') = 67
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_int_converter__doc__,
-"test_int_converter($module, a=12, b=34, c=45, d=67, /)\n"
-"--\n"
-"\n");
-
-#define TEST_INT_CONVERTER_METHODDEF    \
-    {"test_int_converter", _PyCFunction_CAST(test_int_converter), METH_FASTCALL, test_int_converter__doc__},
-
-static PyObject *
-test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d);
-
-static PyObject *
-test_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    int a = 12;
-    int b = 34;
-    int c = 45;
-    myenum d = 67;
-
-    if (!_PyArg_CheckPositional("test_int_converter", nargs, 0, 4)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = _PyLong_AsInt(args[0]);
-    if (a == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    b = _PyLong_AsInt(args[1]);
-    if (b == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!PyUnicode_Check(args[2])) {
-        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
-        goto exit;
-    }
-    if (PyUnicode_READY(args[2])) {
-        goto exit;
-    }
-    if (PyUnicode_GET_LENGTH(args[2]) != 1) {
-        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
-        goto exit;
-    }
-    c = PyUnicode_READ_CHAR(args[2], 0);
-    if (nargs < 4) {
-        goto skip_optional;
-    }
-    d = _PyLong_AsInt(args[3]);
-    if (d == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_int_converter_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d)
-/*[clinic end generated code: output=800993036e078c07 input=d20541fc1ca0553e]*/
-
-
-/*[clinic input]
-test_unsigned_int_converter
-
-    a: unsigned_int = 12
-    b: unsigned_int(bitwise=False) = 34
-    c: unsigned_int(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_int_converter__doc__,
-"test_unsigned_int_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_INT_CONVERTER_METHODDEF    \
-    {"test_unsigned_int_converter", _PyCFunction_CAST(test_unsigned_int_converter), METH_FASTCALL, test_unsigned_int_converter__doc__},
-
-static PyObject *
-test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
-                                 unsigned int b, unsigned int c);
-
-static PyObject *
-test_unsigned_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned int a = 12;
-    unsigned int b = 34;
-    unsigned int c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_int_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedInt_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedInt_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    c = (unsigned int)PyLong_AsUnsignedLongMask(args[2]);
-    if (c == (unsigned int)-1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_unsigned_int_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
-                                 unsigned int b, unsigned int c)
-/*[clinic end generated code: output=f9cdbe410ccc98a3 input=5533534828b62fc0]*/
-
-
-/*[clinic input]
-test_long_converter
-
-    a: long = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_long_converter__doc__,
-"test_long_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_LONG_CONVERTER_METHODDEF    \
-    {"test_long_converter", _PyCFunction_CAST(test_long_converter), METH_FASTCALL, test_long_converter__doc__},
-
-static PyObject *
-test_long_converter_impl(PyObject *module, long a);
-
-static PyObject *
-test_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    long a = 12;
-
-    if (!_PyArg_CheckPositional("test_long_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = PyLong_AsLong(args[0]);
-    if (a == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_long_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_long_converter_impl(PyObject *module, long a)
-/*[clinic end generated code: output=02b3a83495c1d236 input=d2179e3c9cdcde89]*/
-
-
-/*[clinic input]
-test_unsigned_long_converter
-
-    a: unsigned_long = 12
-    b: unsigned_long(bitwise=False) = 34
-    c: unsigned_long(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_long_converter__doc__,
-"test_unsigned_long_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_LONG_CONVERTER_METHODDEF    \
-    {"test_unsigned_long_converter", _PyCFunction_CAST(test_unsigned_long_converter), METH_FASTCALL, test_unsigned_long_converter__doc__},
-
-static PyObject *
-test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
-                                  unsigned long b, unsigned long c);
-
-static PyObject *
-test_unsigned_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned long a = 12;
-    unsigned long b = 34;
-    unsigned long c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_long_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLong_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLong_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!PyLong_Check(args[2])) {
-        _PyArg_BadArgument("test_unsigned_long_converter", "argument 3", "int", args[2]);
-        goto exit;
-    }
-    c = PyLong_AsUnsignedLongMask(args[2]);
-skip_optional:
-    return_value = test_unsigned_long_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
-                                  unsigned long b, unsigned long c)
-/*[clinic end generated code: output=540bb0ba2894e1fe input=f450d94cae1ef73b]*/
-
-
-/*[clinic input]
-test_long_long_converter
-
-    a: long_long = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_long_long_converter__doc__,
-"test_long_long_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_LONG_LONG_CONVERTER_METHODDEF    \
-    {"test_long_long_converter", _PyCFunction_CAST(test_long_long_converter), METH_FASTCALL, test_long_long_converter__doc__},
-
-static PyObject *
-test_long_long_converter_impl(PyObject *module, long long a);
-
-static PyObject *
-test_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    long long a = 12;
-
-    if (!_PyArg_CheckPositional("test_long_long_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    a = PyLong_AsLongLong(args[0]);
-    if (a == -1 && PyErr_Occurred()) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_long_long_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_long_long_converter_impl(PyObject *module, long long a)
-/*[clinic end generated code: output=f9d4ed79ad2db857 input=d5fc81577ff4dd02]*/
-
-
-/*[clinic input]
-test_unsigned_long_long_converter
-
-    a: unsigned_long_long = 12
-    b: unsigned_long_long(bitwise=False) = 34
-    c: unsigned_long_long(bitwise=True) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_unsigned_long_long_converter__doc__,
-"test_unsigned_long_long_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_UNSIGNED_LONG_LONG_CONVERTER_METHODDEF    \
-    {"test_unsigned_long_long_converter", _PyCFunction_CAST(test_unsigned_long_long_converter), METH_FASTCALL, test_unsigned_long_long_converter__doc__},
-
-static PyObject *
-test_unsigned_long_long_converter_impl(PyObject *module,
-                                       unsigned long long a,
-                                       unsigned long long b,
-                                       unsigned long long c);
-
-static PyObject *
-test_unsigned_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    unsigned long long a = 12;
-    unsigned long long b = 34;
-    unsigned long long c = 56;
-
-    if (!_PyArg_CheckPositional("test_unsigned_long_long_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLongLong_Converter(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyLong_UnsignedLongLong_Converter(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!PyLong_Check(args[2])) {
-        _PyArg_BadArgument("test_unsigned_long_long_converter", "argument 3", "int", args[2]);
-        goto exit;
-    }
-    c = PyLong_AsUnsignedLongLongMask(args[2]);
-skip_optional:
-    return_value = test_unsigned_long_long_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_unsigned_long_long_converter_impl(PyObject *module,
-                                       unsigned long long a,
-                                       unsigned long long b,
-                                       unsigned long long c)
-/*[clinic end generated code: output=3d69994f618b46bb input=a15115dc41866ff4]*/
-
-
-/*[clinic input]
-test_Py_ssize_t_converter
-
-    a: Py_ssize_t = 12
-    b: Py_ssize_t(accept={int}) = 34
-    c: Py_ssize_t(accept={int, NoneType}) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_ssize_t_converter__doc__,
-"test_Py_ssize_t_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_SSIZE_T_CONVERTER_METHODDEF    \
-    {"test_Py_ssize_t_converter", _PyCFunction_CAST(test_Py_ssize_t_converter), METH_FASTCALL, test_Py_ssize_t_converter__doc__},
-
-static PyObject *
-test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                               Py_ssize_t c);
-
-static PyObject *
-test_Py_ssize_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    Py_ssize_t a = 12;
-    Py_ssize_t b = 34;
-    Py_ssize_t c = 56;
-
-    if (!_PyArg_CheckPositional("test_Py_ssize_t_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    {
-        Py_ssize_t ival = -1;
-        PyObject *iobj = _PyNumber_Index(args[0]);
-        if (iobj != NULL) {
-            ival = PyLong_AsSsize_t(iobj);
-            Py_DECREF(iobj);
-        }
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        a = ival;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    {
-        Py_ssize_t ival = -1;
-        PyObject *iobj = _PyNumber_Index(args[1]);
-        if (iobj != NULL) {
-            ival = PyLong_AsSsize_t(iobj);
-            Py_DECREF(iobj);
-        }
-        if (ival == -1 && PyErr_Occurred()) {
-            goto exit;
-        }
-        b = ival;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!_Py_convert_optional_to_ssize_t(args[2], &c)) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_Py_ssize_t_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                               Py_ssize_t c)
-/*[clinic end generated code: output=48214bc3d01f4dd7 input=3855f184bb3f299d]*/
-
-
-/*[clinic input]
-test_slice_index_converter
-
-    a: slice_index = 12
-    b: slice_index(accept={int}) = 34
-    c: slice_index(accept={int, NoneType}) = 56
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_slice_index_converter__doc__,
-"test_slice_index_converter($module, a=12, b=34, c=56, /)\n"
-"--\n"
-"\n");
-
-#define TEST_SLICE_INDEX_CONVERTER_METHODDEF    \
-    {"test_slice_index_converter", _PyCFunction_CAST(test_slice_index_converter), METH_FASTCALL, test_slice_index_converter__doc__},
-
-static PyObject *
-test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                                Py_ssize_t c);
-
-static PyObject *
-test_slice_index_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    Py_ssize_t a = 12;
-    Py_ssize_t b = 34;
-    Py_ssize_t c = 56;
-
-    if (!_PyArg_CheckPositional("test_slice_index_converter", nargs, 0, 3)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyEval_SliceIndex(args[0], &a)) {
-        goto exit;
-    }
-    if (nargs < 2) {
-        goto skip_optional;
-    }
-    if (!_PyEval_SliceIndexNotNone(args[1], &b)) {
-        goto exit;
-    }
-    if (nargs < 3) {
-        goto skip_optional;
-    }
-    if (!_PyEval_SliceIndex(args[2], &c)) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_slice_index_converter_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
-                                Py_ssize_t c)
-/*[clinic end generated code: output=67506ed999361212 input=edeadb0ee126f531]*/
-
-
-/*[clinic input]
-test_size_t_converter
-
-    a: size_t = 12
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_size_t_converter__doc__,
-"test_size_t_converter($module, a=12, /)\n"
-"--\n"
-"\n");
-
-#define TEST_SIZE_T_CONVERTER_METHODDEF    \
-    {"test_size_t_converter", _PyCFunction_CAST(test_size_t_converter), METH_FASTCALL, test_size_t_converter__doc__},
-
-static PyObject *
-test_size_t_converter_impl(PyObject *module, size_t a);
-
-static PyObject *
-test_size_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    size_t a = 12;
-
-    if (!_PyArg_CheckPositional("test_size_t_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (!_PyLong_Size_t_Converter(args[0], &a)) {
-        goto exit;
-    }
-skip_optional:
-    return_value = test_size_t_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_size_t_converter_impl(PyObject *module, size_t a)
-/*[clinic end generated code: output=1653ecb5cbf775aa input=52e93a0fed0f1fb3]*/
-
-
-/*[clinic input]
-test_float_converter
-
-    a: float = 12.5
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_float_converter__doc__,
-"test_float_converter($module, a=12.5, /)\n"
-"--\n"
-"\n");
-
-#define TEST_FLOAT_CONVERTER_METHODDEF    \
-    {"test_float_converter", _PyCFunction_CAST(test_float_converter), METH_FASTCALL, test_float_converter__doc__},
-
-static PyObject *
-test_float_converter_impl(PyObject *module, float a);
-
-static PyObject *
-test_float_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    float a = 12.5;
-
-    if (!_PyArg_CheckPositional("test_float_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (PyFloat_CheckExact(args[0])) {
-        a = (float) (PyFloat_AS_DOUBLE(args[0]));
-    }
-    else
-    {
-        a = (float) PyFloat_AsDouble(args[0]);
-        if (a == -1.0 && PyErr_Occurred()) {
-            goto exit;
-        }
-    }
-skip_optional:
-    return_value = test_float_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_float_converter_impl(PyObject *module, float a)
-/*[clinic end generated code: output=36ad006990a8a91e input=259c0d98eca35034]*/
-
-
-/*[clinic input]
-test_double_converter
-
-    a: double = 12.5
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_double_converter__doc__,
-"test_double_converter($module, a=12.5, /)\n"
-"--\n"
-"\n");
-
-#define TEST_DOUBLE_CONVERTER_METHODDEF    \
-    {"test_double_converter", _PyCFunction_CAST(test_double_converter), METH_FASTCALL, test_double_converter__doc__},
-
-static PyObject *
-test_double_converter_impl(PyObject *module, double a);
-
-static PyObject *
-test_double_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    double a = 12.5;
-
-    if (!_PyArg_CheckPositional("test_double_converter", nargs, 0, 1)) {
-        goto exit;
-    }
-    if (nargs < 1) {
-        goto skip_optional;
-    }
-    if (PyFloat_CheckExact(args[0])) {
-        a = PyFloat_AS_DOUBLE(args[0]);
-    }
-    else
-    {
-        a = PyFloat_AsDouble(args[0]);
-        if (a == -1.0 && PyErr_Occurred()) {
-            goto exit;
-        }
-    }
-skip_optional:
-    return_value = test_double_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_double_converter_impl(PyObject *module, double a)
-/*[clinic end generated code: output=7435925592bac795 input=c6a9945706a41c27]*/
-
-
-/*[clinic input]
-test_Py_complex_converter
-
-    a: Py_complex
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_complex_converter__doc__,
-"test_Py_complex_converter($module, a, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_COMPLEX_CONVERTER_METHODDEF    \
-    {"test_Py_complex_converter", (PyCFunction)test_Py_complex_converter, METH_O, test_Py_complex_converter__doc__},
-
-static PyObject *
-test_Py_complex_converter_impl(PyObject *module, Py_complex a);
-
-static PyObject *
-test_Py_complex_converter(PyObject *module, PyObject *arg)
-{
-    PyObject *return_value = NULL;
-    Py_complex a;
-
-    a = PyComplex_AsCComplex(arg);
-    if (PyErr_Occurred()) {
-        goto exit;
-    }
-    return_value = test_Py_complex_converter_impl(module, a);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_Py_complex_converter_impl(PyObject *module, Py_complex a)
-/*[clinic end generated code: output=c2ecbec2144ca540 input=070f216a515beb79]*/
-
-
-/*[clinic input]
-test_str_converter
-
-    a: str = NULL
-    b: str = "ab"
-    c: str(accept={str}) = "cd"
-    d: str(accept={robuffer}) = "cef"
-    e: str(accept={str, NoneType}) = "gh"
-    f: str(accept={robuffer}, zeroes=True) = "ij"
-    g: str(accept={robuffer, str}, zeroes=True) = "kl"
-    h: str(accept={robuffer, str, NoneType}, zeroes=True) = "mn"
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_str_converter__doc__,
-"test_str_converter($module, a=<unrepresentable>, b=\'ab\', c=\'cd\',\n"
-"                   d=\'cef\', e=\'gh\', f=\'ij\', g=\'kl\', h=\'mn\', /)\n"
-"--\n"
-"\n");
-
-#define TEST_STR_CONVERTER_METHODDEF    \
-    {"test_str_converter", _PyCFunction_CAST(test_str_converter), METH_FASTCALL, test_str_converter__doc__},
-
-static PyObject *
-test_str_converter_impl(PyObject *module, const char *a, const char *b,
-                        const char *c, const char *d, const char *e,
-                        const char *f, Py_ssize_t f_length, const char *g,
-                        Py_ssize_t g_length, const char *h,
-                        Py_ssize_t h_length);
-
-static PyObject *
-test_str_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    const char *a = NULL;
-    const char *b = "ab";
-    const char *c = "cd";
-    const char *d = "cef";
-    const char *e = "gh";
-    const char *f = "ij";
-    Py_ssize_t f_length;
-    const char *g = "kl";
-    Py_ssize_t g_length;
-    const char *h = "mn";
-    Py_ssize_t h_length;
-
-    if (!_PyArg_ParseStack(args, nargs, "|sssyzy#s#z#:test_str_converter",
-        &a, &b, &c, &d, &e, &f, &f_length, &g, &g_length, &h, &h_length)) {
-        goto exit;
-    }
-    return_value = test_str_converter_impl(module, a, b, c, d, e, f, f_length, g, g_length, h, h_length);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_str_converter_impl(PyObject *module, const char *a, const char *b,
-                        const char *c, const char *d, const char *e,
-                        const char *f, Py_ssize_t f_length, const char *g,
-                        Py_ssize_t g_length, const char *h,
-                        Py_ssize_t h_length)
-/*[clinic end generated code: output=82cb06d5237ef062 input=8afe9da8185cd38c]*/
-
-
-/*[clinic input]
-test_str_converter_encoding
-
-    a: str(encoding="idna")
-    b: str(encoding="idna", accept={str})
-    c: str(encoding="idna", accept={bytes, bytearray, str})
-    d: str(encoding="idna", zeroes=True)
-    e: str(encoding="idna", accept={bytes, bytearray, str}, zeroes=True)
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_str_converter_encoding__doc__,
-"test_str_converter_encoding($module, a, b, c, d, e, /)\n"
-"--\n"
-"\n");
-
-#define TEST_STR_CONVERTER_ENCODING_METHODDEF    \
-    {"test_str_converter_encoding", _PyCFunction_CAST(test_str_converter_encoding), METH_FASTCALL, test_str_converter_encoding__doc__},
-
-static PyObject *
-test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
-                                 char *d, Py_ssize_t d_length, char *e,
-                                 Py_ssize_t e_length);
-
-static PyObject *
-test_str_converter_encoding(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    char *a = NULL;
-    char *b = NULL;
-    char *c = NULL;
-    char *d = NULL;
-    Py_ssize_t d_length;
-    char *e = NULL;
-    Py_ssize_t e_length;
-
-    if (!_PyArg_ParseStack(args, nargs, "esesetes#et#:test_str_converter_encoding",
-        "idna", &a, "idna", &b, "idna", &c, "idna", &d, &d_length, "idna", &e, &e_length)) {
-        goto exit;
-    }
-    return_value = test_str_converter_encoding_impl(module, a, b, c, d, d_length, e, e_length);
-    /* Post parse cleanup for a */
-    PyMem_FREE(a);
-    /* Post parse cleanup for b */
-    PyMem_FREE(b);
-    /* Post parse cleanup for c */
-    PyMem_FREE(c);
-    /* Post parse cleanup for d */
-    PyMem_FREE(d);
-    /* Post parse cleanup for e */
-    PyMem_FREE(e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
-                                 char *d, Py_ssize_t d_length, char *e,
-                                 Py_ssize_t e_length)
-/*[clinic end generated code: output=999c1deecfa15b0a input=eb4c38e1f898f402]*/
-
-
-/*[clinic input]
-test_Py_UNICODE_converter
-
-    a: Py_UNICODE
-    b: Py_UNICODE(accept={str})
-    c: Py_UNICODE(accept={str, NoneType})
-    d: Py_UNICODE(zeroes=True)
-    e: Py_UNICODE(accept={str, NoneType}, zeroes=True)
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_UNICODE_converter__doc__,
-"test_Py_UNICODE_converter($module, a, b, c, d, e, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_UNICODE_CONVERTER_METHODDEF    \
-    {"test_Py_UNICODE_converter", _PyCFunction_CAST(test_Py_UNICODE_converter), METH_FASTCALL, test_Py_UNICODE_converter__doc__},
-
-static PyObject *
-test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
-                               const Py_UNICODE *b, const Py_UNICODE *c,
-                               const Py_UNICODE *d, Py_ssize_t d_length,
-                               const Py_UNICODE *e, Py_ssize_t e_length);
-
-static PyObject *
-test_Py_UNICODE_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    const Py_UNICODE *a = NULL;
-    const Py_UNICODE *b = NULL;
-    const Py_UNICODE *c = NULL;
-    const Py_UNICODE *d = NULL;
-    Py_ssize_t d_length;
-    const Py_UNICODE *e = NULL;
-    Py_ssize_t e_length;
-
-    if (!_PyArg_ParseStack(args, nargs, "O&O&O&u#Z#:test_Py_UNICODE_converter",
-        _PyUnicode_WideCharString_Converter, &a, _PyUnicode_WideCharString_Converter, &b, _PyUnicode_WideCharString_Opt_Converter, &c, &d, &d_length, &e, &e_length)) {
-        goto exit;
-    }
-    return_value = test_Py_UNICODE_converter_impl(module, a, b, c, d, d_length, e, e_length);
-
-exit:
-    /* Cleanup for a */
-    #if !USE_UNICODE_WCHAR_CACHE
-    PyMem_Free((void *)a);
-    #endif /* USE_UNICODE_WCHAR_CACHE */
-    /* Cleanup for b */
-    #if !USE_UNICODE_WCHAR_CACHE
-    PyMem_Free((void *)b);
-    #endif /* USE_UNICODE_WCHAR_CACHE */
-    /* Cleanup for c */
-    #if !USE_UNICODE_WCHAR_CACHE
-    PyMem_Free((void *)c);
-    #endif /* USE_UNICODE_WCHAR_CACHE */
-
-    return return_value;
-}
-
-static PyObject *
-test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
-                               const Py_UNICODE *b, const Py_UNICODE *c,
-                               const Py_UNICODE *d, Py_ssize_t d_length,
-                               const Py_UNICODE *e, Py_ssize_t e_length)
-/*[clinic end generated code: output=9d41b3a38a0f6f2f input=064a3b68ad7f04b0]*/
-
-
-/*[clinic input]
-test_Py_buffer_converter
-
-    a: Py_buffer
-    b: Py_buffer(accept={buffer})
-    c: Py_buffer(accept={str, buffer})
-    d: Py_buffer(accept={str, buffer, NoneType})
-    e: Py_buffer(accept={rwbuffer})
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_Py_buffer_converter__doc__,
-"test_Py_buffer_converter($module, a, b, c, d, e, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PY_BUFFER_CONVERTER_METHODDEF    \
-    {"test_Py_buffer_converter", _PyCFunction_CAST(test_Py_buffer_converter), METH_FASTCALL, test_Py_buffer_converter__doc__},
-
-static PyObject *
-test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
-                              Py_buffer *c, Py_buffer *d, Py_buffer *e);
-
-static PyObject *
-test_Py_buffer_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    Py_buffer a = {NULL, NULL};
-    Py_buffer b = {NULL, NULL};
-    Py_buffer c = {NULL, NULL};
-    Py_buffer d = {NULL, NULL};
-    Py_buffer e = {NULL, NULL};
-
-    if (!_PyArg_ParseStack(args, nargs, "y*y*s*z*w*:test_Py_buffer_converter",
-        &a, &b, &c, &d, &e)) {
-        goto exit;
-    }
-    return_value = test_Py_buffer_converter_impl(module, &a, &b, &c, &d, &e);
-
-exit:
-    /* Cleanup for a */
-    if (a.obj) {
-       PyBuffer_Release(&a);
-    }
-    /* Cleanup for b */
-    if (b.obj) {
-       PyBuffer_Release(&b);
-    }
-    /* Cleanup for c */
-    if (c.obj) {
-       PyBuffer_Release(&c);
-    }
-    /* Cleanup for d */
-    if (d.obj) {
-       PyBuffer_Release(&d);
-    }
-    /* Cleanup for e */
-    if (e.obj) {
-       PyBuffer_Release(&e);
-    }
-
-    return return_value;
-}
-
-static PyObject *
-test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
-                              Py_buffer *c, Py_buffer *d, Py_buffer *e)
-/*[clinic end generated code: output=a153b71b4f45f952 input=6a9da0f56f9525fd]*/
-
-
-/*[clinic input]
-test_keywords
-
-    a: object
-    b: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords__doc__,
-"test_keywords($module, /, a, b)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_METHODDEF    \
-    {"test_keywords", _PyCFunction_CAST(test_keywords), METH_FASTCALL|METH_KEYWORDS, test_keywords__doc__},
-
-static PyObject *
-test_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *b;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    return_value = test_keywords_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=c03a52cfca192d3b input=0d3484844749c05b]*/
-
-
-/*[clinic input]
-test_keywords_kwonly
-
-    a: object
-    *
-    b: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_kwonly__doc__,
-"test_keywords_kwonly($module, /, a, *, b)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_KWONLY_METHODDEF    \
-    {"test_keywords_kwonly", _PyCFunction_CAST(test_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly__doc__},
-
-static PyObject *
-test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *b;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    return_value = test_keywords_kwonly_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=4704adcb6c7df928 input=384adc78bfa0bff7]*/
-
-
-/*[clinic input]
-test_keywords_opt
-
-    a: object
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_opt__doc__,
-"test_keywords_opt($module, /, a, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_OPT_METHODDEF    \
-    {"test_keywords_opt", _PyCFunction_CAST(test_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt__doc__},
-
-static PyObject *
-test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                       PyObject *c);
-
-static PyObject *
-test_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    c = args[2];
-skip_optional_pos:
-    return_value = test_keywords_opt_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                       PyObject *c)
-/*[clinic end generated code: output=de3ee1039da35fa1 input=eda7964f784f4607]*/
-
-
-/*[clinic input]
-test_keywords_opt_kwonly
-
-    a: object
-    b: object = None
-    *
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_opt_kwonly__doc__,
-"test_keywords_opt_kwonly($module, /, a, b=None, *, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_OPT_KWONLY_METHODDEF    \
-    {"test_keywords_opt_kwonly", _PyCFunction_CAST(test_keywords_opt_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt_kwonly__doc__},
-
-static PyObject *
-test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c, PyObject *d);
-
-static PyObject *
-test_keywords_opt_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt_kwonly", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_keywords_opt_kwonly_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c, PyObject *d)
-/*[clinic end generated code: output=996394678586854e input=209387a4815e5082]*/
-
-
-/*[clinic input]
-test_keywords_kwonly_opt
-
-    a: object
-    *
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keywords_kwonly_opt__doc__,
-"test_keywords_kwonly_opt($module, /, a, *, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORDS_KWONLY_OPT_METHODDEF    \
-    {"test_keywords_kwonly_opt", _PyCFunction_CAST(test_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly_opt__doc__},
-
-static PyObject *
-test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c);
-
-static PyObject *
-test_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly_opt", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    c = args[2];
-skip_optional_kwonly:
-    return_value = test_keywords_kwonly_opt_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c)
-/*[clinic end generated code: output=4ea9947a903a2f24 input=18393cc64fa000f4]*/
-
-
-/*[clinic input]
-test_posonly_keywords
-
-    a: object
-    /
-    b: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords__doc__,
-"test_posonly_keywords($module, a, /, b)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_METHODDEF    \
-    {"test_posonly_keywords", _PyCFunction_CAST(test_posonly_keywords), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords__doc__},
-
-static PyObject *
-test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
-
-static PyObject *
-test_posonly_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *b;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    return_value = test_posonly_keywords_impl(module, a, b);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
-/*[clinic end generated code: output=478aad346a188a80 input=1767b0ebdf06060e]*/
-
-
-/*[clinic input]
-test_posonly_kwonly
-
-    a: object
-    /
-    *
-    c: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_kwonly__doc__,
-"test_posonly_kwonly($module, a, /, *, c)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KWONLY_METHODDEF    \
-    {"test_posonly_kwonly", _PyCFunction_CAST(test_posonly_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly__doc__},
-
-static PyObject *
-test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c);
-
-static PyObject *
-test_posonly_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *c;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    c = args[1];
-    return_value = test_posonly_kwonly_impl(module, a, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c)
-/*[clinic end generated code: output=d747975a0b28e9c2 input=9042f2818f664839]*/
-
-
-/*[clinic input]
-test_posonly_keywords_kwonly
-
-    a: object
-    /
-    b: object
-    *
-    c: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_kwonly__doc__,
-"test_posonly_keywords_kwonly($module, a, /, b, *, c)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_KWONLY_METHODDEF    \
-    {"test_posonly_keywords_kwonly", _PyCFunction_CAST(test_posonly_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly__doc__},
-
-static PyObject *
-test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                                  PyObject *c);
-
-static PyObject *
-test_posonly_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly", 0};
-    PyObject *argsbuf[3];
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    c = args[2];
-    return_value = test_posonly_keywords_kwonly_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
-                                  PyObject *c)
-/*[clinic end generated code: output=5b99f692f8ddaa4a input=29546ebdca492fea]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt
-
-    a: object
-    /
-    b: object
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt__doc__,
-"test_posonly_keywords_opt($module, a, /, b, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT_METHODDEF    \
-    {"test_posonly_keywords_opt", _PyCFunction_CAST(test_posonly_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                               PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 4, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    d = args[3];
-skip_optional_pos:
-    return_value = test_posonly_keywords_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                               PyObject *c, PyObject *d)
-/*[clinic end generated code: output=fd5dfbac5727aebb input=cdf5a9625e554e9b]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt2
-
-    a: object
-    /
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt2__doc__,
-"test_posonly_keywords_opt2($module, a, /, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT2_METHODDEF    \
-    {"test_posonly_keywords_opt2", _PyCFunction_CAST(test_posonly_keywords_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2__doc__},
-
-static PyObject *
-test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                                PyObject *c);
-
-static PyObject *
-test_posonly_keywords_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    c = args[2];
-skip_optional_pos:
-    return_value = test_posonly_keywords_opt2_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                                PyObject *c)
-/*[clinic end generated code: output=777f58ac70775420 input=1581299d21d16f14]*/
-
-
-/*[clinic input]
-test_posonly_opt_keywords_opt
-
-    a: object
-    b: object = None
-    /
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_opt_keywords_opt__doc__,
-"test_posonly_opt_keywords_opt($module, a, b=None, /, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_OPT_KEYWORDS_OPT_METHODDEF    \
-    {"test_posonly_opt_keywords_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt__doc__},
-
-static PyObject *
-test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
-                                   PyObject *b, PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_opt_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional_posonly;
-    }
-    noptargs--;
-    b = args[1];
-skip_optional_posonly:
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    d = args[3];
-skip_optional_pos:
-    return_value = test_posonly_opt_keywords_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
-                                   PyObject *b, PyObject *c, PyObject *d)
-/*[clinic end generated code: output=2c18b8edff78ed22 input=408798ec3d42949f]*/
-
-
-/*[clinic input]
-test_posonly_kwonly_opt
-
-    a: object
-    /
-    *
-    b: object
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_kwonly_opt__doc__,
-"test_posonly_kwonly_opt($module, a, /, *, b, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_kwonly_opt", _PyCFunction_CAST(test_posonly_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                             PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_posonly_kwonly_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                             PyObject *c, PyObject *d)
-/*[clinic end generated code: output=8db9ab5602e1efaf input=8d8e5643bbbc2309]*/
-
-
-/*[clinic input]
-test_posonly_kwonly_opt2
-
-    a: object
-    /
-    *
-    b: object = None
-    c: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_kwonly_opt2__doc__,
-"test_posonly_kwonly_opt2($module, a, /, *, b=None, c=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KWONLY_OPT2_METHODDEF    \
-    {"test_posonly_kwonly_opt2", _PyCFunction_CAST(test_posonly_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt2__doc__},
-
-static PyObject *
-test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c);
-
-static PyObject *
-test_posonly_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt2", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    c = args[2];
-skip_optional_kwonly:
-    return_value = test_posonly_kwonly_opt2_impl(module, a, b, c);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
-                              PyObject *c)
-/*[clinic end generated code: output=6cfe546265d85d2c input=f7e5eed94f75fff0]*/
-
-
-/*[clinic input]
-test_posonly_opt_kwonly_opt
-
-    a: object
-    b: object = None
-    /
-    *
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_opt_kwonly_opt__doc__,
-"test_posonly_opt_kwonly_opt($module, a, b=None, /, *, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_OPT_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                                 PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_kwonly_opt", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional_posonly;
-    }
-    noptargs--;
-    b = args[1];
-skip_optional_posonly:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_posonly_opt_kwonly_opt_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
-                                 PyObject *c, PyObject *d)
-/*[clinic end generated code: output=8b5e21a30cad22b7 input=1e557dc979d120fd]*/
-
-
-/*[clinic input]
-test_posonly_keywords_kwonly_opt
-
-    a: object
-    /
-    b: object
-    *
-    c: object
-    d: object = None
-    e: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_kwonly_opt__doc__,
-"test_posonly_keywords_kwonly_opt($module, a, /, b, *, c, d=None, e=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_keywords_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                      PyObject *b, PyObject *c, PyObject *d,
-                                      PyObject *e);
-
-static PyObject *
-test_posonly_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt", 0};
-    PyObject *argsbuf[5];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    c = args[2];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    e = args[4];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_kwonly_opt_impl(module, a, b, c, d, e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                      PyObject *b, PyObject *c, PyObject *d,
-                                      PyObject *e)
-/*[clinic end generated code: output=950b9ace38b8b4a7 input=c3884a4f956fdc89]*/
-
-
-/*[clinic input]
-test_posonly_keywords_kwonly_opt2
-
-    a: object
-    /
-    b: object
-    *
-    c: object = None
-    d: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_kwonly_opt2__doc__,
-"test_posonly_keywords_kwonly_opt2($module, a, /, b, *, c=None, d=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_KWONLY_OPT2_METHODDEF    \
-    {"test_posonly_keywords_kwonly_opt2", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt2__doc__},
-
-static PyObject *
-test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d);
-
-static PyObject *
-test_posonly_keywords_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt2", 0};
-    PyObject *argsbuf[4];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    d = args[3];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_kwonly_opt2_impl(module, a, b, c, d);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
-                                       PyObject *b, PyObject *c, PyObject *d)
-/*[clinic end generated code: output=fb6951a21b517317 input=68d01d7c0f6dafb0]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt_kwonly_opt
-
-    a: object
-    /
-    b: object
-    c: object = None
-    *
-    d: object = None
-    e: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt_kwonly_opt__doc__,
-"test_posonly_keywords_opt_kwonly_opt($module, a, /, b, c=None, *,\n"
-"                                     d=None, e=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                          PyObject *b, PyObject *c,
-                                          PyObject *d, PyObject *e);
-
-static PyObject *
-test_posonly_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt_kwonly_opt", 0};
-    PyObject *argsbuf[5];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
-    PyObject *a;
-    PyObject *b;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    b = args[1];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    e = args[4];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                          PyObject *b, PyObject *c,
-                                          PyObject *d, PyObject *e)
-/*[clinic end generated code: output=4db10815a99a857e input=d0883d45876f186c]*/
-
-
-/*[clinic input]
-test_posonly_keywords_opt2_kwonly_opt
-
-    a: object
-    /
-    b: object = None
-    c: object = None
-    *
-    d: object = None
-    e: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_keywords_opt2_kwonly_opt__doc__,
-"test_posonly_keywords_opt2_kwonly_opt($module, a, /, b=None, c=None, *,\n"
-"                                      d=None, e=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_KEYWORDS_OPT2_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_keywords_opt2_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt2_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                           PyObject *b, PyObject *c,
-                                           PyObject *d, PyObject *e);
-
-static PyObject *
-test_posonly_keywords_opt2_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2_kwonly_opt", 0};
-    PyObject *argsbuf[5];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[1]) {
-        b = args[1];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    e = args[4];
-skip_optional_kwonly:
-    return_value = test_posonly_keywords_opt2_kwonly_opt_impl(module, a, b, c, d, e);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                           PyObject *b, PyObject *c,
-                                           PyObject *d, PyObject *e)
-/*[clinic end generated code: output=0416689b23ebf66e input=c95e2e1ec93035ad]*/
-
-
-/*[clinic input]
-test_posonly_opt_keywords_opt_kwonly_opt
-
-    a: object
-    b: object = None
-    /
-    c: object = None
-    d: object = None
-    *
-    e: object = None
-    f: object = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_posonly_opt_keywords_opt_kwonly_opt__doc__,
-"test_posonly_opt_keywords_opt_kwonly_opt($module, a, b=None, /, c=None,\n"
-"                                         d=None, *, e=None, f=None)\n"
-"--\n"
-"\n");
-
-#define TEST_POSONLY_OPT_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
-    {"test_posonly_opt_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt_kwonly_opt__doc__},
-
-static PyObject *
-test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                              PyObject *b, PyObject *c,
-                                              PyObject *d, PyObject *e,
-                                              PyObject *f);
-
-static PyObject *
-test_posonly_opt_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"", "", "c", "d", "e", "f", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt_kwonly_opt", 0};
-    PyObject *argsbuf[6];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *b = Py_None;
-    PyObject *c = Py_None;
-    PyObject *d = Py_None;
-    PyObject *e = Py_None;
-    PyObject *f = Py_None;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    if (nargs < 2) {
-        goto skip_optional_posonly;
-    }
-    noptargs--;
-    b = args[1];
-skip_optional_posonly:
-    if (!noptargs) {
-        goto skip_optional_pos;
-    }
-    if (args[2]) {
-        c = args[2];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-    if (args[3]) {
-        d = args[3];
-        if (!--noptargs) {
-            goto skip_optional_pos;
-        }
-    }
-skip_optional_pos:
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[4]) {
-        e = args[4];
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    f = args[5];
-skip_optional_kwonly:
-    return_value = test_posonly_opt_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e, f);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
-                                              PyObject *b, PyObject *c,
-                                              PyObject *d, PyObject *e,
-                                              PyObject *f)
-/*[clinic end generated code: output=8892a137a8c8f46f input=9914857713c5bbf8]*/
-
-/*[clinic input]
-test_keyword_only_parameter
-
-
-    *
-    co_lnotab: PyBytesObject(c_default="(PyBytesObject *)self->co_lnotab") = None
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_keyword_only_parameter__doc__,
-"test_keyword_only_parameter($module, /, *, co_lnotab=None)\n"
-"--\n"
-"\n");
-
-#define TEST_KEYWORD_ONLY_PARAMETER_METHODDEF    \
-    {"test_keyword_only_parameter", _PyCFunction_CAST(test_keyword_only_parameter), METH_FASTCALL|METH_KEYWORDS, test_keyword_only_parameter__doc__},
-
-static PyObject *
-test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab);
-
-static PyObject *
-test_keyword_only_parameter(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"co_lnotab", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_keyword_only_parameter", 0};
-    PyObject *argsbuf[1];
-    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
-    PyBytesObject *co_lnotab = (PyBytesObject *)self->co_lnotab;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (!PyBytes_Check(args[0])) {
-        _PyArg_BadArgument("test_keyword_only_parameter", "argument 'co_lnotab'", "bytes", args[0]);
-        goto exit;
-    }
-    co_lnotab = (PyBytesObject *)args[0];
-skip_optional_kwonly:
-    return_value = test_keyword_only_parameter_impl(module, co_lnotab);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab)
-/*[clinic end generated code: output=332b5f4b444c5d55 input=303df5046c7e37a3]*/
-
-
-/*[clinic input]
-output push
-output preset buffer
-[clinic start generated code]*/
-/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5bff3376ee0df0b5]*/
-
-#ifdef CONDITION_A
-/*[clinic input]
-test_preprocessor_guarded_condition_a
-[clinic start generated code]*/
-
-static PyObject *
-test_preprocessor_guarded_condition_a_impl(PyObject *module)
-/*[clinic end generated code: output=ad012af18085add6 input=8edb8706a98cda7e]*/
-#elif CONDITION_B
-/*[clinic input]
-test_preprocessor_guarded_elif_condition_b
-[clinic start generated code]*/
-
-static PyObject *
-test_preprocessor_guarded_elif_condition_b_impl(PyObject *module)
-/*[clinic end generated code: output=615f2dee82b138d1 input=53777cebbf7fee32]*/
-#else
-/*[clinic input]
-test_preprocessor_guarded_else
-[clinic start generated code]*/
-
-static PyObject *
-test_preprocessor_guarded_else_impl(PyObject *module)
-/*[clinic end generated code: output=13af7670aac51b12 input=6657ab31d74c29fc]*/
-#endif
-
-/*[clinic input]
-dump buffer
-output pop
-[clinic start generated code]*/
-
-#if defined(CONDITION_A)
-
-PyDoc_STRVAR(test_preprocessor_guarded_condition_a__doc__,
-"test_preprocessor_guarded_condition_a($module, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF    \
-    {"test_preprocessor_guarded_condition_a", (PyCFunction)test_preprocessor_guarded_condition_a, METH_NOARGS, test_preprocessor_guarded_condition_a__doc__},
-
-static PyObject *
-test_preprocessor_guarded_condition_a(PyObject *module, PyObject *Py_UNUSED(ignored))
-{
-    return test_preprocessor_guarded_condition_a_impl(module);
-}
-
-#endif /* defined(CONDITION_A) */
-
-#if !defined(CONDITION_A) && (CONDITION_B)
-
-PyDoc_STRVAR(test_preprocessor_guarded_elif_condition_b__doc__,
-"test_preprocessor_guarded_elif_condition_b($module, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF    \
-    {"test_preprocessor_guarded_elif_condition_b", (PyCFunction)test_preprocessor_guarded_elif_condition_b, METH_NOARGS, test_preprocessor_guarded_elif_condition_b__doc__},
-
-static PyObject *
-test_preprocessor_guarded_elif_condition_b(PyObject *module, PyObject *Py_UNUSED(ignored))
-{
-    return test_preprocessor_guarded_elif_condition_b_impl(module);
-}
-
-#endif /* !defined(CONDITION_A) && (CONDITION_B) */
-
-#if !defined(CONDITION_A) && !(CONDITION_B)
-
-PyDoc_STRVAR(test_preprocessor_guarded_else__doc__,
-"test_preprocessor_guarded_else($module, /)\n"
-"--\n"
-"\n");
-
-#define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF    \
-    {"test_preprocessor_guarded_else", (PyCFunction)test_preprocessor_guarded_else, METH_NOARGS, test_preprocessor_guarded_else__doc__},
-
-static PyObject *
-test_preprocessor_guarded_else(PyObject *module, PyObject *Py_UNUSED(ignored))
-{
-    return test_preprocessor_guarded_else_impl(module);
-}
-
-#endif /* !defined(CONDITION_A) && !(CONDITION_B) */
-
-#ifndef TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
-    #define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
-#endif /* !defined(TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF) */
-
-#ifndef TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
-    #define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
-#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF) */
-
-#ifndef TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
-    #define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
-#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF) */
-/*[clinic end generated code: output=3804bb18d454038c input=3fc80c9989d2f2e1]*/
-
-/*[clinic input]
-test_vararg_and_posonly
-
-
-    a: object
-    *args: object
-    /
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg_and_posonly__doc__,
-"test_vararg_and_posonly($module, a, /, *args)\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_AND_POSONLY_METHODDEF    \
-    {"test_vararg_and_posonly", _PyCFunction_CAST(test_vararg_and_posonly), METH_FASTCALL, test_vararg_and_posonly__doc__},
-
-static PyObject *
-test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args);
-
-static PyObject *
-test_vararg_and_posonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
-{
-    PyObject *return_value = NULL;
-    PyObject *a;
-    PyObject *__clinic_args = NULL;
-
-    if (!_PyArg_CheckPositional("test_vararg_and_posonly", nargs, 1, PY_SSIZE_T_MAX)) {
-        goto exit;
-    }
-    a = args[0];
-    __clinic_args = PyTuple_New(nargs - 1);
-    if (!__clinic_args) {
-        goto exit;
-    }
-    for (Py_ssize_t i = 0; i < nargs - 1; ++i) {
-        PyTuple_SET_ITEM(__clinic_args, i, Py_NewRef(args[1 + i]));
-    }
-    return_value = test_vararg_and_posonly_impl(module, a, __clinic_args);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args)
-/*[clinic end generated code: output=79b75dc07decc8d6 input=08dc2bf7afbf1613]*/
-
-/*[clinic input]
-test_vararg
-
-
-    a: object
-    *args: object
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg__doc__,
-"test_vararg($module, /, a, *args)\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_METHODDEF    \
-    {"test_vararg", _PyCFunction_CAST(test_vararg), METH_FASTCALL|METH_KEYWORDS, test_vararg__doc__},
-
-static PyObject *
-test_vararg_impl(PyObject *module, PyObject *a, PyObject *args);
-
-static PyObject *
-test_vararg(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg", 0};
-    PyObject *argsbuf[2];
-    PyObject *a;
-    PyObject *__clinic_args = NULL;
-
-    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    __clinic_args = args[1];
-    return_value = test_vararg_impl(module, a, __clinic_args);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_impl(PyObject *module, PyObject *a, PyObject *args)
-/*[clinic end generated code: output=ce9334333757f6ea input=81d33815ad1bae6e]*/
-
-/*[clinic input]
-test_vararg_with_default
-
-
-    a: object
-    *args: object
-    b: bool = False
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg_with_default__doc__,
-"test_vararg_with_default($module, /, a, *args, b=False)\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_WITH_DEFAULT_METHODDEF    \
-    {"test_vararg_with_default", _PyCFunction_CAST(test_vararg_with_default), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_default__doc__},
-
-static PyObject *
-test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
-                              int b);
-
-static PyObject *
-test_vararg_with_default(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"a", "b", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_default", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = Py_MIN(nargs, 1) + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
-    PyObject *a;
-    PyObject *__clinic_args = NULL;
-    int b = 0;
-
-    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    a = args[0];
-    __clinic_args = args[1];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    b = PyObject_IsTrue(args[2]);
-    if (b < 0) {
-        goto exit;
-    }
-skip_optional_kwonly:
-    return_value = test_vararg_with_default_impl(module, a, __clinic_args, b);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
-                              int b)
-/*[clinic end generated code: output=32fb19dd6bcf9185 input=6e110b54acd9b22d]*/
-
-/*[clinic input]
-test_vararg_with_only_defaults
-
-
-    *args: object
-    b: bool = False
-    c: object = ' '
-
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_vararg_with_only_defaults__doc__,
-"test_vararg_with_only_defaults($module, /, *args, b=False, c=\' \')\n"
-"--\n"
-"\n");
-
-#define TEST_VARARG_WITH_ONLY_DEFAULTS_METHODDEF    \
-    {"test_vararg_with_only_defaults", _PyCFunction_CAST(test_vararg_with_only_defaults), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_only_defaults__doc__},
-
-static PyObject *
-test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
-                                    PyObject *c);
-
-static PyObject *
-test_vararg_with_only_defaults(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"b", "c", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_only_defaults", 0};
-    PyObject *argsbuf[3];
-    Py_ssize_t noptargs = 0 + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
-    PyObject *__clinic_args = NULL;
-    int b = 0;
-    PyObject *c = " ";
-
-    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    __clinic_args = args[0];
-    if (!noptargs) {
-        goto skip_optional_kwonly;
-    }
-    if (args[1]) {
-        b = PyObject_IsTrue(args[1]);
-        if (b < 0) {
-            goto exit;
-        }
-        if (!--noptargs) {
-            goto skip_optional_kwonly;
-        }
-    }
-    c = args[2];
-skip_optional_kwonly:
-    return_value = test_vararg_with_only_defaults_impl(module, __clinic_args, b, c);
-
-exit:
-    Py_XDECREF(__clinic_args);
-    return return_value;
-}
-
-static PyObject *
-test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
-                                    PyObject *c)
-/*[clinic end generated code: output=7e393689e6ce61a3 input=fa56a709a035666e]*/
-
-/*[clinic input]
-test_paramname_module
-
-    module as mod: object
-[clinic start generated code]*/
-
-PyDoc_STRVAR(test_paramname_module__doc__,
-"test_paramname_module($module, /, module)\n"
-"--\n"
-"\n");
-
-#define TEST_PARAMNAME_MODULE_METHODDEF    \
-    {"test_paramname_module", _PyCFunction_CAST(test_paramname_module), METH_FASTCALL|METH_KEYWORDS, test_paramname_module__doc__},
-
-static PyObject *
-test_paramname_module_impl(PyObject *module, PyObject *mod);
-
-static PyObject *
-test_paramname_module(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
-{
-    PyObject *return_value = NULL;
-    static const char * const _keywords[] = {"module", NULL};
-    static _PyArg_Parser _parser = {NULL, _keywords, "test_paramname_module", 0};
-    PyObject *argsbuf[1];
-    PyObject *mod;
-
-    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
-    if (!args) {
-        goto exit;
-    }
-    mod = args[0];
-    return_value = test_paramname_module_impl(module, mod);
-
-exit:
-    return return_value;
-}
-
-static PyObject *
-test_paramname_module_impl(PyObject *module, PyObject *mod)
-/*[clinic end generated code: output=23379a7ffa65c514 input=afefe259667f13ba]*/
--- /dev/null
+++ b/Lib/test/clinic.test.c
@@ -0,0 +1,4250 @@
+/*[clinic input]
+output preset block
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=3c81ac2402d06a8b]*/
+
+/*[clinic input]
+class Test "TestObj *" "TestType"
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=fc7e50384d12b83f]*/
+
+/*[clinic input]
+test_object_converter
+
+    a: object
+    b: object(converter="PyUnicode_FSConverter")
+    c: object(subclass_of="&PyUnicode_Type")
+    d: object(type="PyUnicode_Object *")
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_object_converter__doc__,
+"test_object_converter($module, a, b, c, d, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECT_CONVERTER_METHODDEF    \
+    {"test_object_converter", _PyCFunction_CAST(test_object_converter), METH_FASTCALL, test_object_converter__doc__},
+
+static PyObject *
+test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
+                           PyObject *c, PyUnicode_Object *d);
+
+static PyObject *
+test_object_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyUnicode_Object *d;
+
+    if (!_PyArg_CheckPositional("test_object_converter", nargs, 4, 4)) {
+        goto exit;
+    }
+    a = args[0];
+    if (!PyUnicode_FSConverter(args[1], &b)) {
+        goto exit;
+    }
+    if (!PyUnicode_Check(args[2])) {
+        _PyArg_BadArgument("test_object_converter", "argument 3", "str", args[2]);
+        goto exit;
+    }
+    c = args[2];
+    d = (PyUnicode_Object *)args[3];
+    return_value = test_object_converter_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_object_converter_impl(PyObject *module, PyObject *a, PyObject *b,
+                           PyObject *c, PyUnicode_Object *d)
+/*[clinic end generated code: output=886f4f9b598726b6 input=005e6a8a711a869b]*/
+
+
+/*[clinic input]
+cloned = test_object_converter
+Check the clone feature.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(cloned__doc__,
+"cloned($module, a, b, c, d, /)\n"
+"--\n"
+"\n"
+"Check the clone feature.");
+
+#define CLONED_METHODDEF    \
+    {"cloned", _PyCFunction_CAST(cloned), METH_FASTCALL, cloned__doc__},
+
+static PyObject *
+cloned_impl(PyObject *module, PyObject *a, PyObject *b, PyObject *c,
+            PyUnicode_Object *d);
+
+static PyObject *
+cloned(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyUnicode_Object *d;
+
+    if (!_PyArg_CheckPositional("cloned", nargs, 4, 4)) {
+        goto exit;
+    }
+    a = args[0];
+    if (!PyUnicode_FSConverter(args[1], &b)) {
+        goto exit;
+    }
+    if (!PyUnicode_Check(args[2])) {
+        _PyArg_BadArgument("cloned", "argument 3", "str", args[2]);
+        goto exit;
+    }
+    c = args[2];
+    d = (PyUnicode_Object *)args[3];
+    return_value = cloned_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+cloned_impl(PyObject *module, PyObject *a, PyObject *b, PyObject *c,
+            PyUnicode_Object *d)
+/*[clinic end generated code: output=026b483e27c38065 input=0543614019d6fcc7]*/
+
+
+/*[clinic input]
+test_object_converter_one_arg
+
+    a: object
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_object_converter_one_arg__doc__,
+"test_object_converter_one_arg($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECT_CONVERTER_ONE_ARG_METHODDEF    \
+    {"test_object_converter_one_arg", (PyCFunction)test_object_converter_one_arg, METH_O, test_object_converter_one_arg__doc__},
+
+static PyObject *
+test_object_converter_one_arg(PyObject *module, PyObject *a)
+/*[clinic end generated code: output=6da755f8502139df input=d635d92a421f1ca3]*/
+
+
+/*[clinic input]
+test_objects_converter
+
+    a: object
+    b: object = NULL
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_objects_converter__doc__,
+"test_objects_converter($module, a, b=<unrepresentable>, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECTS_CONVERTER_METHODDEF    \
+    {"test_objects_converter", _PyCFunction_CAST(test_objects_converter), METH_FASTCALL, test_objects_converter__doc__},
+
+static PyObject *
+test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_objects_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b = NULL;
+
+    if (!_PyArg_CheckPositional("test_objects_converter", nargs, 1, 2)) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    b = args[1];
+skip_optional:
+    return_value = test_objects_converter_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_objects_converter_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=fc26328b79d46bb7 input=4cbb3d9edd2a36f3]*/
+
+
+/*[clinic input]
+test_object_converter_subclass_of
+
+    a: object(subclass_of="&PyLong_Type")
+    b: object(subclass_of="&PyTuple_Type")
+    c: object(subclass_of="&PyList_Type")
+    d: object(subclass_of="&PySet_Type")
+    e: object(subclass_of="&PyFrozenSet_Type")
+    f: object(subclass_of="&PyDict_Type")
+    g: object(subclass_of="&PyUnicode_Type")
+    h: object(subclass_of="&PyBytes_Type")
+    i: object(subclass_of="&PyByteArray_Type")
+    j: object(subclass_of="&MyType")
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_object_converter_subclass_of__doc__,
+"test_object_converter_subclass_of($module, a, b, c, d, e, f, g, h, i,\n"
+"                                  j, /)\n"
+"--\n"
+"\n");
+
+#define TEST_OBJECT_CONVERTER_SUBCLASS_OF_METHODDEF    \
+    {"test_object_converter_subclass_of", _PyCFunction_CAST(test_object_converter_subclass_of), METH_FASTCALL, test_object_converter_subclass_of__doc__},
+
+static PyObject *
+test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d,
+                                       PyObject *e, PyObject *f, PyObject *g,
+                                       PyObject *h, PyObject *i, PyObject *j);
+
+static PyObject *
+test_object_converter_subclass_of(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyObject *d;
+    PyObject *e;
+    PyObject *f;
+    PyObject *g;
+    PyObject *h;
+    PyObject *i;
+    PyObject *j;
+
+    if (!_PyArg_CheckPositional("test_object_converter_subclass_of", nargs, 10, 10)) {
+        goto exit;
+    }
+    if (!PyLong_Check(args[0])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 1", "int", args[0]);
+        goto exit;
+    }
+    a = args[0];
+    if (!PyTuple_Check(args[1])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 2", "tuple", args[1]);
+        goto exit;
+    }
+    b = args[1];
+    if (!PyList_Check(args[2])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 3", "list", args[2]);
+        goto exit;
+    }
+    c = args[2];
+    if (!PySet_Check(args[3])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 4", "set", args[3]);
+        goto exit;
+    }
+    d = args[3];
+    if (!PyFrozenSet_Check(args[4])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 5", "frozenset", args[4]);
+        goto exit;
+    }
+    e = args[4];
+    if (!PyDict_Check(args[5])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 6", "dict", args[5]);
+        goto exit;
+    }
+    f = args[5];
+    if (!PyUnicode_Check(args[6])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 7", "str", args[6]);
+        goto exit;
+    }
+    g = args[6];
+    if (!PyBytes_Check(args[7])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 8", "bytes", args[7]);
+        goto exit;
+    }
+    h = args[7];
+    if (!PyByteArray_Check(args[8])) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 9", "bytearray", args[8]);
+        goto exit;
+    }
+    i = args[8];
+    if (!PyObject_TypeCheck(args[9], &MyType)) {
+        _PyArg_BadArgument("test_object_converter_subclass_of", "argument 10", (&MyType)->tp_name, args[9]);
+        goto exit;
+    }
+    j = args[9];
+    return_value = test_object_converter_subclass_of_impl(module, a, b, c, d, e, f, g, h, i, j);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_object_converter_subclass_of_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d,
+                                       PyObject *e, PyObject *f, PyObject *g,
+                                       PyObject *h, PyObject *i, PyObject *j)
+/*[clinic end generated code: output=e4b07c9a54479a40 input=31b06b772d5f983e]*/
+
+
+/*[clinic input]
+test_PyBytesObject_converter
+
+    a: PyBytesObject
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_PyBytesObject_converter__doc__,
+"test_PyBytesObject_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PYBYTESOBJECT_CONVERTER_METHODDEF    \
+    {"test_PyBytesObject_converter", (PyCFunction)test_PyBytesObject_converter, METH_O, test_PyBytesObject_converter__doc__},
+
+static PyObject *
+test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a);
+
+static PyObject *
+test_PyBytesObject_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    PyBytesObject *a;
+
+    if (!PyBytes_Check(arg)) {
+        _PyArg_BadArgument("test_PyBytesObject_converter", "argument", "bytes", arg);
+        goto exit;
+    }
+    a = (PyBytesObject *)arg;
+    return_value = test_PyBytesObject_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_PyBytesObject_converter_impl(PyObject *module, PyBytesObject *a)
+/*[clinic end generated code: output=7539d628e6fceace input=12b10c7cb5750400]*/
+
+
+/*[clinic input]
+test_PyByteArrayObject_converter
+
+    a: PyByteArrayObject
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_PyByteArrayObject_converter__doc__,
+"test_PyByteArrayObject_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PYBYTEARRAYOBJECT_CONVERTER_METHODDEF    \
+    {"test_PyByteArrayObject_converter", (PyCFunction)test_PyByteArrayObject_converter, METH_O, test_PyByteArrayObject_converter__doc__},
+
+static PyObject *
+test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a);
+
+static PyObject *
+test_PyByteArrayObject_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    PyByteArrayObject *a;
+
+    if (!PyByteArray_Check(arg)) {
+        _PyArg_BadArgument("test_PyByteArrayObject_converter", "argument", "bytearray", arg);
+        goto exit;
+    }
+    a = (PyByteArrayObject *)arg;
+    return_value = test_PyByteArrayObject_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_PyByteArrayObject_converter_impl(PyObject *module, PyByteArrayObject *a)
+/*[clinic end generated code: output=1245af9f5b3e355e input=5a657da535d194ae]*/
+
+
+/*[clinic input]
+test_unicode_converter
+
+    a: unicode
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unicode_converter__doc__,
+"test_unicode_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNICODE_CONVERTER_METHODDEF    \
+    {"test_unicode_converter", (PyCFunction)test_unicode_converter, METH_O, test_unicode_converter__doc__},
+
+static PyObject *
+test_unicode_converter_impl(PyObject *module, PyObject *a);
+
+static PyObject *
+test_unicode_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+
+    if (!PyUnicode_Check(arg)) {
+        _PyArg_BadArgument("test_unicode_converter", "argument", "str", arg);
+        goto exit;
+    }
+    if (PyUnicode_READY(arg) == -1) {
+        goto exit;
+    }
+    a = arg;
+    return_value = test_unicode_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unicode_converter_impl(PyObject *module, PyObject *a)
+/*[clinic end generated code: output=18f1e3880c862611 input=aa33612df92aa9c5]*/
+
+
+/*[clinic input]
+test_bool_converter
+
+    a: bool = True
+    b: bool(accept={object}) = True
+    c: bool(accept={int}) = True
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_bool_converter__doc__,
+"test_bool_converter($module, a=True, b=True, c=True, /)\n"
+"--\n"
+"\n");
+
+#define TEST_BOOL_CONVERTER_METHODDEF    \
+    {"test_bool_converter", _PyCFunction_CAST(test_bool_converter), METH_FASTCALL, test_bool_converter__doc__},
+
+static PyObject *
+test_bool_converter_impl(PyObject *module, int a, int b, int c);
+
+static PyObject *
+test_bool_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    int a = 1;
+    int b = 1;
+    int c = 1;
+
+    if (!_PyArg_CheckPositional("test_bool_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = PyObject_IsTrue(args[0]);
+    if (a < 0) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    b = PyObject_IsTrue(args[1]);
+    if (b < 0) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    c = _PyLong_AsInt(args[2]);
+    if (c == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_bool_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_bool_converter_impl(PyObject *module, int a, int b, int c)
+/*[clinic end generated code: output=27f0e653a70b9be3 input=939854fa9f248c60]*/
+
+
+/*[clinic input]
+test_char_converter
+
+    a: char = b'A'
+    b: char = b'\a'
+    c: char = b'\b'
+    d: char = b'\t'
+    e: char = b'\n'
+    f: char = b'\v'
+    g: char = b'\f'
+    h: char = b'\r'
+    i: char = b'"'
+    j: char = b"'"
+    k: char = b'?'
+    l: char = b'\\'
+    m: char = b'\000'
+    n: char = b'\377'
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_char_converter__doc__,
+"test_char_converter($module, a=b\'A\', b=b\'\\x07\', c=b\'\\x08\', d=b\'\\t\',\n"
+"                    e=b\'\\n\', f=b\'\\x0b\', g=b\'\\x0c\', h=b\'\\r\', i=b\'\"\',\n"
+"                    j=b\"\'\", k=b\'?\', l=b\'\\\\\', m=b\'\\x00\', n=b\'\\xff\', /)\n"
+"--\n"
+"\n");
+
+#define TEST_CHAR_CONVERTER_METHODDEF    \
+    {"test_char_converter", _PyCFunction_CAST(test_char_converter), METH_FASTCALL, test_char_converter__doc__},
+
+static PyObject *
+test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
+                         char e, char f, char g, char h, char i, char j,
+                         char k, char l, char m, char n);
+
+static PyObject *
+test_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    char a = 'A';
+    char b = '\x07';
+    char c = '\x08';
+    char d = '\t';
+    char e = '\n';
+    char f = '\x0b';
+    char g = '\x0c';
+    char h = '\r';
+    char i = '"';
+    char j = '\'';
+    char k = '?';
+    char l = '\\';
+    char m = '\x00';
+    char n = '\xff';
+
+    if (!_PyArg_CheckPositional("test_char_converter", nargs, 0, 14)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[0]) && PyBytes_GET_SIZE(args[0]) == 1) {
+        a = PyBytes_AS_STRING(args[0])[0];
+    }
+    else if (PyByteArray_Check(args[0]) && PyByteArray_GET_SIZE(args[0]) == 1) {
+        a = PyByteArray_AS_STRING(args[0])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 1", "a byte string of length 1", args[0]);
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[1]) && PyBytes_GET_SIZE(args[1]) == 1) {
+        b = PyBytes_AS_STRING(args[1])[0];
+    }
+    else if (PyByteArray_Check(args[1]) && PyByteArray_GET_SIZE(args[1]) == 1) {
+        b = PyByteArray_AS_STRING(args[1])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 2", "a byte string of length 1", args[1]);
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[2]) && PyBytes_GET_SIZE(args[2]) == 1) {
+        c = PyBytes_AS_STRING(args[2])[0];
+    }
+    else if (PyByteArray_Check(args[2]) && PyByteArray_GET_SIZE(args[2]) == 1) {
+        c = PyByteArray_AS_STRING(args[2])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 3", "a byte string of length 1", args[2]);
+        goto exit;
+    }
+    if (nargs < 4) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[3]) && PyBytes_GET_SIZE(args[3]) == 1) {
+        d = PyBytes_AS_STRING(args[3])[0];
+    }
+    else if (PyByteArray_Check(args[3]) && PyByteArray_GET_SIZE(args[3]) == 1) {
+        d = PyByteArray_AS_STRING(args[3])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 4", "a byte string of length 1", args[3]);
+        goto exit;
+    }
+    if (nargs < 5) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[4]) && PyBytes_GET_SIZE(args[4]) == 1) {
+        e = PyBytes_AS_STRING(args[4])[0];
+    }
+    else if (PyByteArray_Check(args[4]) && PyByteArray_GET_SIZE(args[4]) == 1) {
+        e = PyByteArray_AS_STRING(args[4])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 5", "a byte string of length 1", args[4]);
+        goto exit;
+    }
+    if (nargs < 6) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[5]) && PyBytes_GET_SIZE(args[5]) == 1) {
+        f = PyBytes_AS_STRING(args[5])[0];
+    }
+    else if (PyByteArray_Check(args[5]) && PyByteArray_GET_SIZE(args[5]) == 1) {
+        f = PyByteArray_AS_STRING(args[5])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 6", "a byte string of length 1", args[5]);
+        goto exit;
+    }
+    if (nargs < 7) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[6]) && PyBytes_GET_SIZE(args[6]) == 1) {
+        g = PyBytes_AS_STRING(args[6])[0];
+    }
+    else if (PyByteArray_Check(args[6]) && PyByteArray_GET_SIZE(args[6]) == 1) {
+        g = PyByteArray_AS_STRING(args[6])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 7", "a byte string of length 1", args[6]);
+        goto exit;
+    }
+    if (nargs < 8) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[7]) && PyBytes_GET_SIZE(args[7]) == 1) {
+        h = PyBytes_AS_STRING(args[7])[0];
+    }
+    else if (PyByteArray_Check(args[7]) && PyByteArray_GET_SIZE(args[7]) == 1) {
+        h = PyByteArray_AS_STRING(args[7])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 8", "a byte string of length 1", args[7]);
+        goto exit;
+    }
+    if (nargs < 9) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[8]) && PyBytes_GET_SIZE(args[8]) == 1) {
+        i = PyBytes_AS_STRING(args[8])[0];
+    }
+    else if (PyByteArray_Check(args[8]) && PyByteArray_GET_SIZE(args[8]) == 1) {
+        i = PyByteArray_AS_STRING(args[8])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 9", "a byte string of length 1", args[8]);
+        goto exit;
+    }
+    if (nargs < 10) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[9]) && PyBytes_GET_SIZE(args[9]) == 1) {
+        j = PyBytes_AS_STRING(args[9])[0];
+    }
+    else if (PyByteArray_Check(args[9]) && PyByteArray_GET_SIZE(args[9]) == 1) {
+        j = PyByteArray_AS_STRING(args[9])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 10", "a byte string of length 1", args[9]);
+        goto exit;
+    }
+    if (nargs < 11) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[10]) && PyBytes_GET_SIZE(args[10]) == 1) {
+        k = PyBytes_AS_STRING(args[10])[0];
+    }
+    else if (PyByteArray_Check(args[10]) && PyByteArray_GET_SIZE(args[10]) == 1) {
+        k = PyByteArray_AS_STRING(args[10])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 11", "a byte string of length 1", args[10]);
+        goto exit;
+    }
+    if (nargs < 12) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[11]) && PyBytes_GET_SIZE(args[11]) == 1) {
+        l = PyBytes_AS_STRING(args[11])[0];
+    }
+    else if (PyByteArray_Check(args[11]) && PyByteArray_GET_SIZE(args[11]) == 1) {
+        l = PyByteArray_AS_STRING(args[11])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 12", "a byte string of length 1", args[11]);
+        goto exit;
+    }
+    if (nargs < 13) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[12]) && PyBytes_GET_SIZE(args[12]) == 1) {
+        m = PyBytes_AS_STRING(args[12])[0];
+    }
+    else if (PyByteArray_Check(args[12]) && PyByteArray_GET_SIZE(args[12]) == 1) {
+        m = PyByteArray_AS_STRING(args[12])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 13", "a byte string of length 1", args[12]);
+        goto exit;
+    }
+    if (nargs < 14) {
+        goto skip_optional;
+    }
+    if (PyBytes_Check(args[13]) && PyBytes_GET_SIZE(args[13]) == 1) {
+        n = PyBytes_AS_STRING(args[13])[0];
+    }
+    else if (PyByteArray_Check(args[13]) && PyByteArray_GET_SIZE(args[13]) == 1) {
+        n = PyByteArray_AS_STRING(args[13])[0];
+    }
+    else {
+        _PyArg_BadArgument("test_char_converter", "argument 14", "a byte string of length 1", args[13]);
+        goto exit;
+    }
+skip_optional:
+    return_value = test_char_converter_impl(module, a, b, c, d, e, f, g, h, i, j, k, l, m, n);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_char_converter_impl(PyObject *module, char a, char b, char c, char d,
+                         char e, char f, char g, char h, char i, char j,
+                         char k, char l, char m, char n)
+/*[clinic end generated code: output=98589f02422fe6b1 input=e42330417a44feac]*/
+
+
+/*[clinic input]
+test_unsigned_char_converter
+
+    a: unsigned_char = 12
+    b: unsigned_char(bitwise=False) = 34
+    c: unsigned_char(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_char_converter__doc__,
+"test_unsigned_char_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_CHAR_CONVERTER_METHODDEF    \
+    {"test_unsigned_char_converter", _PyCFunction_CAST(test_unsigned_char_converter), METH_FASTCALL, test_unsigned_char_converter__doc__},
+
+static PyObject *
+test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
+                                  unsigned char b, unsigned char c);
+
+static PyObject *
+test_unsigned_char_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned char a = 12;
+    unsigned char b = 34;
+    unsigned char c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_char_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    {
+        long ival = PyLong_AsLong(args[0]);
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else if (ival < 0) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is less than minimum");
+            goto exit;
+        }
+        else if (ival > UCHAR_MAX) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is greater than maximum");
+            goto exit;
+        }
+        else {
+            a = (unsigned char) ival;
+        }
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    {
+        long ival = PyLong_AsLong(args[1]);
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else if (ival < 0) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is less than minimum");
+            goto exit;
+        }
+        else if (ival > UCHAR_MAX) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "unsigned byte integer is greater than maximum");
+            goto exit;
+        }
+        else {
+            b = (unsigned char) ival;
+        }
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    {
+        unsigned long ival = PyLong_AsUnsignedLongMask(args[2]);
+        if (ival == (unsigned long)-1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else {
+            c = (unsigned char) ival;
+        }
+    }
+skip_optional:
+    return_value = test_unsigned_char_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_char_converter_impl(PyObject *module, unsigned char a,
+                                  unsigned char b, unsigned char c)
+/*[clinic end generated code: output=45920dbedc22eb55 input=021414060993e289]*/
+
+
+/*[clinic input]
+test_short_converter
+
+    a: short = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_short_converter__doc__,
+"test_short_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_SHORT_CONVERTER_METHODDEF    \
+    {"test_short_converter", _PyCFunction_CAST(test_short_converter), METH_FASTCALL, test_short_converter__doc__},
+
+static PyObject *
+test_short_converter_impl(PyObject *module, short a);
+
+static PyObject *
+test_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    short a = 12;
+
+    if (!_PyArg_CheckPositional("test_short_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    {
+        long ival = PyLong_AsLong(args[0]);
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        else if (ival < SHRT_MIN) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "signed short integer is less than minimum");
+            goto exit;
+        }
+        else if (ival > SHRT_MAX) {
+            PyErr_SetString(PyExc_OverflowError,
+                            "signed short integer is greater than maximum");
+            goto exit;
+        }
+        else {
+            a = (short) ival;
+        }
+    }
+skip_optional:
+    return_value = test_short_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_short_converter_impl(PyObject *module, short a)
+/*[clinic end generated code: output=a580945bd6963d45 input=6a8a7a509a498ff4]*/
+
+
+/*[clinic input]
+test_unsigned_short_converter
+
+    a: unsigned_short = 12
+    b: unsigned_short(bitwise=False) = 34
+    c: unsigned_short(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_short_converter__doc__,
+"test_unsigned_short_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_SHORT_CONVERTER_METHODDEF    \
+    {"test_unsigned_short_converter", _PyCFunction_CAST(test_unsigned_short_converter), METH_FASTCALL, test_unsigned_short_converter__doc__},
+
+static PyObject *
+test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
+                                   unsigned short b, unsigned short c);
+
+static PyObject *
+test_unsigned_short_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned short a = 12;
+    unsigned short b = 34;
+    unsigned short c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_short_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedShort_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedShort_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    c = (unsigned short)PyLong_AsUnsignedLongMask(args[2]);
+    if (c == (unsigned short)-1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_unsigned_short_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_short_converter_impl(PyObject *module, unsigned short a,
+                                   unsigned short b, unsigned short c)
+/*[clinic end generated code: output=e6e990df729114fc input=cdfd8eff3d9176b4]*/
+
+
+/*[clinic input]
+test_int_converter
+
+    a: int = 12
+    b: int(accept={int}) = 34
+    c: int(accept={str}) = 45
+    d: int(type='myenum') = 67
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_int_converter__doc__,
+"test_int_converter($module, a=12, b=34, c=45, d=67, /)\n"
+"--\n"
+"\n");
+
+#define TEST_INT_CONVERTER_METHODDEF    \
+    {"test_int_converter", _PyCFunction_CAST(test_int_converter), METH_FASTCALL, test_int_converter__doc__},
+
+static PyObject *
+test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d);
+
+static PyObject *
+test_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    int a = 12;
+    int b = 34;
+    int c = 45;
+    myenum d = 67;
+
+    if (!_PyArg_CheckPositional("test_int_converter", nargs, 0, 4)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = _PyLong_AsInt(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    b = _PyLong_AsInt(args[1]);
+    if (b == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!PyUnicode_Check(args[2])) {
+        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
+        goto exit;
+    }
+    if (PyUnicode_READY(args[2])) {
+        goto exit;
+    }
+    if (PyUnicode_GET_LENGTH(args[2]) != 1) {
+        _PyArg_BadArgument("test_int_converter", "argument 3", "a unicode character", args[2]);
+        goto exit;
+    }
+    c = PyUnicode_READ_CHAR(args[2], 0);
+    if (nargs < 4) {
+        goto skip_optional;
+    }
+    d = _PyLong_AsInt(args[3]);
+    if (d == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_int_converter_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_int_converter_impl(PyObject *module, int a, int b, int c, myenum d)
+/*[clinic end generated code: output=800993036e078c07 input=d20541fc1ca0553e]*/
+
+
+/*[clinic input]
+test_unsigned_int_converter
+
+    a: unsigned_int = 12
+    b: unsigned_int(bitwise=False) = 34
+    c: unsigned_int(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_int_converter__doc__,
+"test_unsigned_int_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_INT_CONVERTER_METHODDEF    \
+    {"test_unsigned_int_converter", _PyCFunction_CAST(test_unsigned_int_converter), METH_FASTCALL, test_unsigned_int_converter__doc__},
+
+static PyObject *
+test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
+                                 unsigned int b, unsigned int c);
+
+static PyObject *
+test_unsigned_int_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned int a = 12;
+    unsigned int b = 34;
+    unsigned int c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_int_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedInt_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedInt_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    c = (unsigned int)PyLong_AsUnsignedLongMask(args[2]);
+    if (c == (unsigned int)-1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_unsigned_int_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_int_converter_impl(PyObject *module, unsigned int a,
+                                 unsigned int b, unsigned int c)
+/*[clinic end generated code: output=f9cdbe410ccc98a3 input=5533534828b62fc0]*/
+
+
+/*[clinic input]
+test_long_converter
+
+    a: long = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_long_converter__doc__,
+"test_long_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_LONG_CONVERTER_METHODDEF    \
+    {"test_long_converter", _PyCFunction_CAST(test_long_converter), METH_FASTCALL, test_long_converter__doc__},
+
+static PyObject *
+test_long_converter_impl(PyObject *module, long a);
+
+static PyObject *
+test_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    long a = 12;
+
+    if (!_PyArg_CheckPositional("test_long_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = PyLong_AsLong(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_long_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_long_converter_impl(PyObject *module, long a)
+/*[clinic end generated code: output=02b3a83495c1d236 input=d2179e3c9cdcde89]*/
+
+
+/*[clinic input]
+test_unsigned_long_converter
+
+    a: unsigned_long = 12
+    b: unsigned_long(bitwise=False) = 34
+    c: unsigned_long(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_long_converter__doc__,
+"test_unsigned_long_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_LONG_CONVERTER_METHODDEF    \
+    {"test_unsigned_long_converter", _PyCFunction_CAST(test_unsigned_long_converter), METH_FASTCALL, test_unsigned_long_converter__doc__},
+
+static PyObject *
+test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
+                                  unsigned long b, unsigned long c);
+
+static PyObject *
+test_unsigned_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned long a = 12;
+    unsigned long b = 34;
+    unsigned long c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_long_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLong_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLong_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!PyLong_Check(args[2])) {
+        _PyArg_BadArgument("test_unsigned_long_converter", "argument 3", "int", args[2]);
+        goto exit;
+    }
+    c = PyLong_AsUnsignedLongMask(args[2]);
+skip_optional:
+    return_value = test_unsigned_long_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_long_converter_impl(PyObject *module, unsigned long a,
+                                  unsigned long b, unsigned long c)
+/*[clinic end generated code: output=540bb0ba2894e1fe input=f450d94cae1ef73b]*/
+
+
+/*[clinic input]
+test_long_long_converter
+
+    a: long_long = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_long_long_converter__doc__,
+"test_long_long_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_LONG_LONG_CONVERTER_METHODDEF    \
+    {"test_long_long_converter", _PyCFunction_CAST(test_long_long_converter), METH_FASTCALL, test_long_long_converter__doc__},
+
+static PyObject *
+test_long_long_converter_impl(PyObject *module, long long a);
+
+static PyObject *
+test_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    long long a = 12;
+
+    if (!_PyArg_CheckPositional("test_long_long_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    a = PyLong_AsLongLong(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_long_long_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_long_long_converter_impl(PyObject *module, long long a)
+/*[clinic end generated code: output=f9d4ed79ad2db857 input=d5fc81577ff4dd02]*/
+
+
+/*[clinic input]
+test_unsigned_long_long_converter
+
+    a: unsigned_long_long = 12
+    b: unsigned_long_long(bitwise=False) = 34
+    c: unsigned_long_long(bitwise=True) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_unsigned_long_long_converter__doc__,
+"test_unsigned_long_long_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_UNSIGNED_LONG_LONG_CONVERTER_METHODDEF    \
+    {"test_unsigned_long_long_converter", _PyCFunction_CAST(test_unsigned_long_long_converter), METH_FASTCALL, test_unsigned_long_long_converter__doc__},
+
+static PyObject *
+test_unsigned_long_long_converter_impl(PyObject *module,
+                                       unsigned long long a,
+                                       unsigned long long b,
+                                       unsigned long long c);
+
+static PyObject *
+test_unsigned_long_long_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    unsigned long long a = 12;
+    unsigned long long b = 34;
+    unsigned long long c = 56;
+
+    if (!_PyArg_CheckPositional("test_unsigned_long_long_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLongLong_Converter(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyLong_UnsignedLongLong_Converter(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!PyLong_Check(args[2])) {
+        _PyArg_BadArgument("test_unsigned_long_long_converter", "argument 3", "int", args[2]);
+        goto exit;
+    }
+    c = PyLong_AsUnsignedLongLongMask(args[2]);
+skip_optional:
+    return_value = test_unsigned_long_long_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_unsigned_long_long_converter_impl(PyObject *module,
+                                       unsigned long long a,
+                                       unsigned long long b,
+                                       unsigned long long c)
+/*[clinic end generated code: output=3d69994f618b46bb input=a15115dc41866ff4]*/
+
+
+/*[clinic input]
+test_Py_ssize_t_converter
+
+    a: Py_ssize_t = 12
+    b: Py_ssize_t(accept={int}) = 34
+    c: Py_ssize_t(accept={int, NoneType}) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_ssize_t_converter__doc__,
+"test_Py_ssize_t_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_SSIZE_T_CONVERTER_METHODDEF    \
+    {"test_Py_ssize_t_converter", _PyCFunction_CAST(test_Py_ssize_t_converter), METH_FASTCALL, test_Py_ssize_t_converter__doc__},
+
+static PyObject *
+test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                               Py_ssize_t c);
+
+static PyObject *
+test_Py_ssize_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    Py_ssize_t a = 12;
+    Py_ssize_t b = 34;
+    Py_ssize_t c = 56;
+
+    if (!_PyArg_CheckPositional("test_Py_ssize_t_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    {
+        Py_ssize_t ival = -1;
+        PyObject *iobj = _PyNumber_Index(args[0]);
+        if (iobj != NULL) {
+            ival = PyLong_AsSsize_t(iobj);
+            Py_DECREF(iobj);
+        }
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        a = ival;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    {
+        Py_ssize_t ival = -1;
+        PyObject *iobj = _PyNumber_Index(args[1]);
+        if (iobj != NULL) {
+            ival = PyLong_AsSsize_t(iobj);
+            Py_DECREF(iobj);
+        }
+        if (ival == -1 && PyErr_Occurred()) {
+            goto exit;
+        }
+        b = ival;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!_Py_convert_optional_to_ssize_t(args[2], &c)) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_Py_ssize_t_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_Py_ssize_t_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                               Py_ssize_t c)
+/*[clinic end generated code: output=48214bc3d01f4dd7 input=3855f184bb3f299d]*/
+
+
+/*[clinic input]
+test_slice_index_converter
+
+    a: slice_index = 12
+    b: slice_index(accept={int}) = 34
+    c: slice_index(accept={int, NoneType}) = 56
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_slice_index_converter__doc__,
+"test_slice_index_converter($module, a=12, b=34, c=56, /)\n"
+"--\n"
+"\n");
+
+#define TEST_SLICE_INDEX_CONVERTER_METHODDEF    \
+    {"test_slice_index_converter", _PyCFunction_CAST(test_slice_index_converter), METH_FASTCALL, test_slice_index_converter__doc__},
+
+static PyObject *
+test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                                Py_ssize_t c);
+
+static PyObject *
+test_slice_index_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    Py_ssize_t a = 12;
+    Py_ssize_t b = 34;
+    Py_ssize_t c = 56;
+
+    if (!_PyArg_CheckPositional("test_slice_index_converter", nargs, 0, 3)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyEval_SliceIndex(args[0], &a)) {
+        goto exit;
+    }
+    if (nargs < 2) {
+        goto skip_optional;
+    }
+    if (!_PyEval_SliceIndexNotNone(args[1], &b)) {
+        goto exit;
+    }
+    if (nargs < 3) {
+        goto skip_optional;
+    }
+    if (!_PyEval_SliceIndex(args[2], &c)) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_slice_index_converter_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_slice_index_converter_impl(PyObject *module, Py_ssize_t a, Py_ssize_t b,
+                                Py_ssize_t c)
+/*[clinic end generated code: output=67506ed999361212 input=edeadb0ee126f531]*/
+
+
+/*[clinic input]
+test_size_t_converter
+
+    a: size_t = 12
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_size_t_converter__doc__,
+"test_size_t_converter($module, a=12, /)\n"
+"--\n"
+"\n");
+
+#define TEST_SIZE_T_CONVERTER_METHODDEF    \
+    {"test_size_t_converter", _PyCFunction_CAST(test_size_t_converter), METH_FASTCALL, test_size_t_converter__doc__},
+
+static PyObject *
+test_size_t_converter_impl(PyObject *module, size_t a);
+
+static PyObject *
+test_size_t_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    size_t a = 12;
+
+    if (!_PyArg_CheckPositional("test_size_t_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (!_PyLong_Size_t_Converter(args[0], &a)) {
+        goto exit;
+    }
+skip_optional:
+    return_value = test_size_t_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_size_t_converter_impl(PyObject *module, size_t a)
+/*[clinic end generated code: output=1653ecb5cbf775aa input=52e93a0fed0f1fb3]*/
+
+
+/*[clinic input]
+test_float_converter
+
+    a: float = 12.5
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_float_converter__doc__,
+"test_float_converter($module, a=12.5, /)\n"
+"--\n"
+"\n");
+
+#define TEST_FLOAT_CONVERTER_METHODDEF    \
+    {"test_float_converter", _PyCFunction_CAST(test_float_converter), METH_FASTCALL, test_float_converter__doc__},
+
+static PyObject *
+test_float_converter_impl(PyObject *module, float a);
+
+static PyObject *
+test_float_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    float a = 12.5;
+
+    if (!_PyArg_CheckPositional("test_float_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (PyFloat_CheckExact(args[0])) {
+        a = (float) (PyFloat_AS_DOUBLE(args[0]));
+    }
+    else
+    {
+        a = (float) PyFloat_AsDouble(args[0]);
+        if (a == -1.0 && PyErr_Occurred()) {
+            goto exit;
+        }
+    }
+skip_optional:
+    return_value = test_float_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_float_converter_impl(PyObject *module, float a)
+/*[clinic end generated code: output=36ad006990a8a91e input=259c0d98eca35034]*/
+
+
+/*[clinic input]
+test_double_converter
+
+    a: double = 12.5
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_double_converter__doc__,
+"test_double_converter($module, a=12.5, /)\n"
+"--\n"
+"\n");
+
+#define TEST_DOUBLE_CONVERTER_METHODDEF    \
+    {"test_double_converter", _PyCFunction_CAST(test_double_converter), METH_FASTCALL, test_double_converter__doc__},
+
+static PyObject *
+test_double_converter_impl(PyObject *module, double a);
+
+static PyObject *
+test_double_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    double a = 12.5;
+
+    if (!_PyArg_CheckPositional("test_double_converter", nargs, 0, 1)) {
+        goto exit;
+    }
+    if (nargs < 1) {
+        goto skip_optional;
+    }
+    if (PyFloat_CheckExact(args[0])) {
+        a = PyFloat_AS_DOUBLE(args[0]);
+    }
+    else
+    {
+        a = PyFloat_AsDouble(args[0]);
+        if (a == -1.0 && PyErr_Occurred()) {
+            goto exit;
+        }
+    }
+skip_optional:
+    return_value = test_double_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_double_converter_impl(PyObject *module, double a)
+/*[clinic end generated code: output=7435925592bac795 input=c6a9945706a41c27]*/
+
+
+/*[clinic input]
+test_Py_complex_converter
+
+    a: Py_complex
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_complex_converter__doc__,
+"test_Py_complex_converter($module, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_COMPLEX_CONVERTER_METHODDEF    \
+    {"test_Py_complex_converter", (PyCFunction)test_Py_complex_converter, METH_O, test_Py_complex_converter__doc__},
+
+static PyObject *
+test_Py_complex_converter_impl(PyObject *module, Py_complex a);
+
+static PyObject *
+test_Py_complex_converter(PyObject *module, PyObject *arg)
+{
+    PyObject *return_value = NULL;
+    Py_complex a;
+
+    a = PyComplex_AsCComplex(arg);
+    if (PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = test_Py_complex_converter_impl(module, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_Py_complex_converter_impl(PyObject *module, Py_complex a)
+/*[clinic end generated code: output=c2ecbec2144ca540 input=070f216a515beb79]*/
+
+
+/*[clinic input]
+test_str_converter
+
+    a: str = NULL
+    b: str = "ab"
+    c: str(accept={str}) = "cd"
+    d: str(accept={robuffer}) = "cef"
+    e: str(accept={str, NoneType}) = "gh"
+    f: str(accept={robuffer}, zeroes=True) = "ij"
+    g: str(accept={robuffer, str}, zeroes=True) = "kl"
+    h: str(accept={robuffer, str, NoneType}, zeroes=True) = "mn"
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_str_converter__doc__,
+"test_str_converter($module, a=<unrepresentable>, b=\'ab\', c=\'cd\',\n"
+"                   d=\'cef\', e=\'gh\', f=\'ij\', g=\'kl\', h=\'mn\', /)\n"
+"--\n"
+"\n");
+
+#define TEST_STR_CONVERTER_METHODDEF    \
+    {"test_str_converter", _PyCFunction_CAST(test_str_converter), METH_FASTCALL, test_str_converter__doc__},
+
+static PyObject *
+test_str_converter_impl(PyObject *module, const char *a, const char *b,
+                        const char *c, const char *d, const char *e,
+                        const char *f, Py_ssize_t f_length, const char *g,
+                        Py_ssize_t g_length, const char *h,
+                        Py_ssize_t h_length);
+
+static PyObject *
+test_str_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    const char *a = NULL;
+    const char *b = "ab";
+    const char *c = "cd";
+    const char *d = "cef";
+    const char *e = "gh";
+    const char *f = "ij";
+    Py_ssize_t f_length;
+    const char *g = "kl";
+    Py_ssize_t g_length;
+    const char *h = "mn";
+    Py_ssize_t h_length;
+
+    if (!_PyArg_ParseStack(args, nargs, "|sssyzy#s#z#:test_str_converter",
+        &a, &b, &c, &d, &e, &f, &f_length, &g, &g_length, &h, &h_length)) {
+        goto exit;
+    }
+    return_value = test_str_converter_impl(module, a, b, c, d, e, f, f_length, g, g_length, h, h_length);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_str_converter_impl(PyObject *module, const char *a, const char *b,
+                        const char *c, const char *d, const char *e,
+                        const char *f, Py_ssize_t f_length, const char *g,
+                        Py_ssize_t g_length, const char *h,
+                        Py_ssize_t h_length)
+/*[clinic end generated code: output=82cb06d5237ef062 input=8afe9da8185cd38c]*/
+
+
+/*[clinic input]
+test_str_converter_encoding
+
+    a: str(encoding="idna")
+    b: str(encoding="idna", accept={str})
+    c: str(encoding="idna", accept={bytes, bytearray, str})
+    d: str(encoding="idna", zeroes=True)
+    e: str(encoding="idna", accept={bytes, bytearray, str}, zeroes=True)
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_str_converter_encoding__doc__,
+"test_str_converter_encoding($module, a, b, c, d, e, /)\n"
+"--\n"
+"\n");
+
+#define TEST_STR_CONVERTER_ENCODING_METHODDEF    \
+    {"test_str_converter_encoding", _PyCFunction_CAST(test_str_converter_encoding), METH_FASTCALL, test_str_converter_encoding__doc__},
+
+static PyObject *
+test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
+                                 char *d, Py_ssize_t d_length, char *e,
+                                 Py_ssize_t e_length);
+
+static PyObject *
+test_str_converter_encoding(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    char *a = NULL;
+    char *b = NULL;
+    char *c = NULL;
+    char *d = NULL;
+    Py_ssize_t d_length;
+    char *e = NULL;
+    Py_ssize_t e_length;
+
+    if (!_PyArg_ParseStack(args, nargs, "esesetes#et#:test_str_converter_encoding",
+        "idna", &a, "idna", &b, "idna", &c, "idna", &d, &d_length, "idna", &e, &e_length)) {
+        goto exit;
+    }
+    return_value = test_str_converter_encoding_impl(module, a, b, c, d, d_length, e, e_length);
+    /* Post parse cleanup for a */
+    PyMem_FREE(a);
+    /* Post parse cleanup for b */
+    PyMem_FREE(b);
+    /* Post parse cleanup for c */
+    PyMem_FREE(c);
+    /* Post parse cleanup for d */
+    PyMem_FREE(d);
+    /* Post parse cleanup for e */
+    PyMem_FREE(e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_str_converter_encoding_impl(PyObject *module, char *a, char *b, char *c,
+                                 char *d, Py_ssize_t d_length, char *e,
+                                 Py_ssize_t e_length)
+/*[clinic end generated code: output=999c1deecfa15b0a input=eb4c38e1f898f402]*/
+
+
+/*[clinic input]
+test_Py_UNICODE_converter
+
+    a: Py_UNICODE
+    b: Py_UNICODE(accept={str})
+    c: Py_UNICODE(accept={str, NoneType})
+    d: Py_UNICODE(zeroes=True)
+    e: Py_UNICODE(accept={str, NoneType}, zeroes=True)
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_UNICODE_converter__doc__,
+"test_Py_UNICODE_converter($module, a, b, c, d, e, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_UNICODE_CONVERTER_METHODDEF    \
+    {"test_Py_UNICODE_converter", _PyCFunction_CAST(test_Py_UNICODE_converter), METH_FASTCALL, test_Py_UNICODE_converter__doc__},
+
+static PyObject *
+test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
+                               const Py_UNICODE *b, const Py_UNICODE *c,
+                               const Py_UNICODE *d, Py_ssize_t d_length,
+                               const Py_UNICODE *e, Py_ssize_t e_length);
+
+static PyObject *
+test_Py_UNICODE_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    const Py_UNICODE *a = NULL;
+    const Py_UNICODE *b = NULL;
+    const Py_UNICODE *c = NULL;
+    const Py_UNICODE *d = NULL;
+    Py_ssize_t d_length;
+    const Py_UNICODE *e = NULL;
+    Py_ssize_t e_length;
+
+    if (!_PyArg_ParseStack(args, nargs, "O&O&O&u#Z#:test_Py_UNICODE_converter",
+        _PyUnicode_WideCharString_Converter, &a, _PyUnicode_WideCharString_Converter, &b, _PyUnicode_WideCharString_Opt_Converter, &c, &d, &d_length, &e, &e_length)) {
+        goto exit;
+    }
+    return_value = test_Py_UNICODE_converter_impl(module, a, b, c, d, d_length, e, e_length);
+
+exit:
+    /* Cleanup for a */
+    #if !USE_UNICODE_WCHAR_CACHE
+    PyMem_Free((void *)a);
+    #endif /* USE_UNICODE_WCHAR_CACHE */
+    /* Cleanup for b */
+    #if !USE_UNICODE_WCHAR_CACHE
+    PyMem_Free((void *)b);
+    #endif /* USE_UNICODE_WCHAR_CACHE */
+    /* Cleanup for c */
+    #if !USE_UNICODE_WCHAR_CACHE
+    PyMem_Free((void *)c);
+    #endif /* USE_UNICODE_WCHAR_CACHE */
+
+    return return_value;
+}
+
+static PyObject *
+test_Py_UNICODE_converter_impl(PyObject *module, const Py_UNICODE *a,
+                               const Py_UNICODE *b, const Py_UNICODE *c,
+                               const Py_UNICODE *d, Py_ssize_t d_length,
+                               const Py_UNICODE *e, Py_ssize_t e_length)
+/*[clinic end generated code: output=9d41b3a38a0f6f2f input=064a3b68ad7f04b0]*/
+
+
+/*[clinic input]
+test_Py_buffer_converter
+
+    a: Py_buffer
+    b: Py_buffer(accept={buffer})
+    c: Py_buffer(accept={str, buffer})
+    d: Py_buffer(accept={str, buffer, NoneType})
+    e: Py_buffer(accept={rwbuffer})
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_Py_buffer_converter__doc__,
+"test_Py_buffer_converter($module, a, b, c, d, e, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PY_BUFFER_CONVERTER_METHODDEF    \
+    {"test_Py_buffer_converter", _PyCFunction_CAST(test_Py_buffer_converter), METH_FASTCALL, test_Py_buffer_converter__doc__},
+
+static PyObject *
+test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
+                              Py_buffer *c, Py_buffer *d, Py_buffer *e);
+
+static PyObject *
+test_Py_buffer_converter(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    Py_buffer a = {NULL, NULL};
+    Py_buffer b = {NULL, NULL};
+    Py_buffer c = {NULL, NULL};
+    Py_buffer d = {NULL, NULL};
+    Py_buffer e = {NULL, NULL};
+
+    if (!_PyArg_ParseStack(args, nargs, "y*y*s*z*w*:test_Py_buffer_converter",
+        &a, &b, &c, &d, &e)) {
+        goto exit;
+    }
+    return_value = test_Py_buffer_converter_impl(module, &a, &b, &c, &d, &e);
+
+exit:
+    /* Cleanup for a */
+    if (a.obj) {
+       PyBuffer_Release(&a);
+    }
+    /* Cleanup for b */
+    if (b.obj) {
+       PyBuffer_Release(&b);
+    }
+    /* Cleanup for c */
+    if (c.obj) {
+       PyBuffer_Release(&c);
+    }
+    /* Cleanup for d */
+    if (d.obj) {
+       PyBuffer_Release(&d);
+    }
+    /* Cleanup for e */
+    if (e.obj) {
+       PyBuffer_Release(&e);
+    }
+
+    return return_value;
+}
+
+static PyObject *
+test_Py_buffer_converter_impl(PyObject *module, Py_buffer *a, Py_buffer *b,
+                              Py_buffer *c, Py_buffer *d, Py_buffer *e)
+/*[clinic end generated code: output=a153b71b4f45f952 input=6a9da0f56f9525fd]*/
+
+
+/*[clinic input]
+test_keywords
+
+    a: object
+    b: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords__doc__,
+"test_keywords($module, /, a, b)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_METHODDEF    \
+    {"test_keywords", _PyCFunction_CAST(test_keywords), METH_FASTCALL|METH_KEYWORDS, test_keywords__doc__},
+
+static PyObject *
+test_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *b;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    return_value = test_keywords_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=c03a52cfca192d3b input=0d3484844749c05b]*/
+
+
+/*[clinic input]
+test_keywords_kwonly
+
+    a: object
+    *
+    b: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_kwonly__doc__,
+"test_keywords_kwonly($module, /, a, *, b)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_KWONLY_METHODDEF    \
+    {"test_keywords_kwonly", _PyCFunction_CAST(test_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly__doc__},
+
+static PyObject *
+test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *b;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    return_value = test_keywords_kwonly_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=4704adcb6c7df928 input=384adc78bfa0bff7]*/
+
+
+/*[clinic input]
+test_keywords_opt
+
+    a: object
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_opt__doc__,
+"test_keywords_opt($module, /, a, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_OPT_METHODDEF    \
+    {"test_keywords_opt", _PyCFunction_CAST(test_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt__doc__},
+
+static PyObject *
+test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                       PyObject *c);
+
+static PyObject *
+test_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    c = args[2];
+skip_optional_pos:
+    return_value = test_keywords_opt_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                       PyObject *c)
+/*[clinic end generated code: output=de3ee1039da35fa1 input=eda7964f784f4607]*/
+
+
+/*[clinic input]
+test_keywords_opt_kwonly
+
+    a: object
+    b: object = None
+    *
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_opt_kwonly__doc__,
+"test_keywords_opt_kwonly($module, /, a, b=None, *, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_OPT_KWONLY_METHODDEF    \
+    {"test_keywords_opt_kwonly", _PyCFunction_CAST(test_keywords_opt_kwonly), METH_FASTCALL|METH_KEYWORDS, test_keywords_opt_kwonly__doc__},
+
+static PyObject *
+test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c, PyObject *d);
+
+static PyObject *
+test_keywords_opt_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_opt_kwonly", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_keywords_opt_kwonly_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_opt_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c, PyObject *d)
+/*[clinic end generated code: output=996394678586854e input=209387a4815e5082]*/
+
+
+/*[clinic input]
+test_keywords_kwonly_opt
+
+    a: object
+    *
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keywords_kwonly_opt__doc__,
+"test_keywords_kwonly_opt($module, /, a, *, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORDS_KWONLY_OPT_METHODDEF    \
+    {"test_keywords_kwonly_opt", _PyCFunction_CAST(test_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_keywords_kwonly_opt__doc__},
+
+static PyObject *
+test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c);
+
+static PyObject *
+test_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keywords_kwonly_opt", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    c = args[2];
+skip_optional_kwonly:
+    return_value = test_keywords_kwonly_opt_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keywords_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c)
+/*[clinic end generated code: output=4ea9947a903a2f24 input=18393cc64fa000f4]*/
+
+
+/*[clinic input]
+test_posonly_keywords
+
+    a: object
+    /
+    b: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords__doc__,
+"test_posonly_keywords($module, a, /, b)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_METHODDEF    \
+    {"test_posonly_keywords", _PyCFunction_CAST(test_posonly_keywords), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords__doc__},
+
+static PyObject *
+test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b);
+
+static PyObject *
+test_posonly_keywords(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *b;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    return_value = test_posonly_keywords_impl(module, a, b);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_impl(PyObject *module, PyObject *a, PyObject *b)
+/*[clinic end generated code: output=478aad346a188a80 input=1767b0ebdf06060e]*/
+
+
+/*[clinic input]
+test_posonly_kwonly
+
+    a: object
+    /
+    *
+    c: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_kwonly__doc__,
+"test_posonly_kwonly($module, a, /, *, c)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KWONLY_METHODDEF    \
+    {"test_posonly_kwonly", _PyCFunction_CAST(test_posonly_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly__doc__},
+
+static PyObject *
+test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c);
+
+static PyObject *
+test_posonly_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *c;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    c = args[1];
+    return_value = test_posonly_kwonly_impl(module, a, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_kwonly_impl(PyObject *module, PyObject *a, PyObject *c)
+/*[clinic end generated code: output=d747975a0b28e9c2 input=9042f2818f664839]*/
+
+
+/*[clinic input]
+test_posonly_keywords_kwonly
+
+    a: object
+    /
+    b: object
+    *
+    c: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_kwonly__doc__,
+"test_posonly_keywords_kwonly($module, a, /, b, *, c)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_KWONLY_METHODDEF    \
+    {"test_posonly_keywords_kwonly", _PyCFunction_CAST(test_posonly_keywords_kwonly), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly__doc__},
+
+static PyObject *
+test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                                  PyObject *c);
+
+static PyObject *
+test_posonly_keywords_kwonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly", 0};
+    PyObject *argsbuf[3];
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    c = args[2];
+    return_value = test_posonly_keywords_kwonly_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_kwonly_impl(PyObject *module, PyObject *a, PyObject *b,
+                                  PyObject *c)
+/*[clinic end generated code: output=5b99f692f8ddaa4a input=29546ebdca492fea]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt
+
+    a: object
+    /
+    b: object
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt__doc__,
+"test_posonly_keywords_opt($module, a, /, b, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT_METHODDEF    \
+    {"test_posonly_keywords_opt", _PyCFunction_CAST(test_posonly_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                               PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 4, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    d = args[3];
+skip_optional_pos:
+    return_value = test_posonly_keywords_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                               PyObject *c, PyObject *d)
+/*[clinic end generated code: output=fd5dfbac5727aebb input=cdf5a9625e554e9b]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt2
+
+    a: object
+    /
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt2__doc__,
+"test_posonly_keywords_opt2($module, a, /, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT2_METHODDEF    \
+    {"test_posonly_keywords_opt2", _PyCFunction_CAST(test_posonly_keywords_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2__doc__},
+
+static PyObject *
+test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                                PyObject *c);
+
+static PyObject *
+test_posonly_keywords_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    c = args[2];
+skip_optional_pos:
+    return_value = test_posonly_keywords_opt2_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                                PyObject *c)
+/*[clinic end generated code: output=777f58ac70775420 input=1581299d21d16f14]*/
+
+
+/*[clinic input]
+test_posonly_opt_keywords_opt
+
+    a: object
+    b: object = None
+    /
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_opt_keywords_opt__doc__,
+"test_posonly_opt_keywords_opt($module, a, b=None, /, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_OPT_KEYWORDS_OPT_METHODDEF    \
+    {"test_posonly_opt_keywords_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt__doc__},
+
+static PyObject *
+test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
+                                   PyObject *b, PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_opt_keywords_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional_posonly;
+    }
+    noptargs--;
+    b = args[1];
+skip_optional_posonly:
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    d = args[3];
+skip_optional_pos:
+    return_value = test_posonly_opt_keywords_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_opt_keywords_opt_impl(PyObject *module, PyObject *a,
+                                   PyObject *b, PyObject *c, PyObject *d)
+/*[clinic end generated code: output=2c18b8edff78ed22 input=408798ec3d42949f]*/
+
+
+/*[clinic input]
+test_posonly_kwonly_opt
+
+    a: object
+    /
+    *
+    b: object
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_kwonly_opt__doc__,
+"test_posonly_kwonly_opt($module, a, /, *, b, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_kwonly_opt", _PyCFunction_CAST(test_posonly_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                             PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_posonly_kwonly_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                             PyObject *c, PyObject *d)
+/*[clinic end generated code: output=8db9ab5602e1efaf input=8d8e5643bbbc2309]*/
+
+
+/*[clinic input]
+test_posonly_kwonly_opt2
+
+    a: object
+    /
+    *
+    b: object = None
+    c: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_kwonly_opt2__doc__,
+"test_posonly_kwonly_opt2($module, a, /, *, b=None, c=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KWONLY_OPT2_METHODDEF    \
+    {"test_posonly_kwonly_opt2", _PyCFunction_CAST(test_posonly_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_kwonly_opt2__doc__},
+
+static PyObject *
+test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c);
+
+static PyObject *
+test_posonly_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_kwonly_opt2", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    c = args[2];
+skip_optional_kwonly:
+    return_value = test_posonly_kwonly_opt2_impl(module, a, b, c);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_kwonly_opt2_impl(PyObject *module, PyObject *a, PyObject *b,
+                              PyObject *c)
+/*[clinic end generated code: output=6cfe546265d85d2c input=f7e5eed94f75fff0]*/
+
+
+/*[clinic input]
+test_posonly_opt_kwonly_opt
+
+    a: object
+    b: object = None
+    /
+    *
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_opt_kwonly_opt__doc__,
+"test_posonly_opt_kwonly_opt($module, a, b=None, /, *, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_OPT_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                                 PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_kwonly_opt", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional_posonly;
+    }
+    noptargs--;
+    b = args[1];
+skip_optional_posonly:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_posonly_opt_kwonly_opt_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_opt_kwonly_opt_impl(PyObject *module, PyObject *a, PyObject *b,
+                                 PyObject *c, PyObject *d)
+/*[clinic end generated code: output=8b5e21a30cad22b7 input=1e557dc979d120fd]*/
+
+
+/*[clinic input]
+test_posonly_keywords_kwonly_opt
+
+    a: object
+    /
+    b: object
+    *
+    c: object
+    d: object = None
+    e: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_kwonly_opt__doc__,
+"test_posonly_keywords_kwonly_opt($module, a, /, b, *, c, d=None, e=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_keywords_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                      PyObject *b, PyObject *c, PyObject *d,
+                                      PyObject *e);
+
+static PyObject *
+test_posonly_keywords_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt", 0};
+    PyObject *argsbuf[5];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 3;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    c = args[2];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    e = args[4];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_kwonly_opt_impl(module, a, b, c, d, e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                      PyObject *b, PyObject *c, PyObject *d,
+                                      PyObject *e)
+/*[clinic end generated code: output=950b9ace38b8b4a7 input=c3884a4f956fdc89]*/
+
+
+/*[clinic input]
+test_posonly_keywords_kwonly_opt2
+
+    a: object
+    /
+    b: object
+    *
+    c: object = None
+    d: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_kwonly_opt2__doc__,
+"test_posonly_keywords_kwonly_opt2($module, a, /, b, *, c=None, d=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_KWONLY_OPT2_METHODDEF    \
+    {"test_posonly_keywords_kwonly_opt2", _PyCFunction_CAST(test_posonly_keywords_kwonly_opt2), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_kwonly_opt2__doc__},
+
+static PyObject *
+test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d);
+
+static PyObject *
+test_posonly_keywords_kwonly_opt2(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_kwonly_opt2", 0};
+    PyObject *argsbuf[4];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    d = args[3];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_kwonly_opt2_impl(module, a, b, c, d);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_kwonly_opt2_impl(PyObject *module, PyObject *a,
+                                       PyObject *b, PyObject *c, PyObject *d)
+/*[clinic end generated code: output=fb6951a21b517317 input=68d01d7c0f6dafb0]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt_kwonly_opt
+
+    a: object
+    /
+    b: object
+    c: object = None
+    *
+    d: object = None
+    e: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt_kwonly_opt__doc__,
+"test_posonly_keywords_opt_kwonly_opt($module, a, /, b, c=None, *,\n"
+"                                     d=None, e=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                          PyObject *b, PyObject *c,
+                                          PyObject *d, PyObject *e);
+
+static PyObject *
+test_posonly_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt_kwonly_opt", 0};
+    PyObject *argsbuf[5];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
+    PyObject *a;
+    PyObject *b;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    b = args[1];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    e = args[4];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                          PyObject *b, PyObject *c,
+                                          PyObject *d, PyObject *e)
+/*[clinic end generated code: output=4db10815a99a857e input=d0883d45876f186c]*/
+
+
+/*[clinic input]
+test_posonly_keywords_opt2_kwonly_opt
+
+    a: object
+    /
+    b: object = None
+    c: object = None
+    *
+    d: object = None
+    e: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_keywords_opt2_kwonly_opt__doc__,
+"test_posonly_keywords_opt2_kwonly_opt($module, a, /, b=None, c=None, *,\n"
+"                                      d=None, e=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_KEYWORDS_OPT2_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_keywords_opt2_kwonly_opt", _PyCFunction_CAST(test_posonly_keywords_opt2_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_keywords_opt2_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                           PyObject *b, PyObject *c,
+                                           PyObject *d, PyObject *e);
+
+static PyObject *
+test_posonly_keywords_opt2_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "b", "c", "d", "e", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_keywords_opt2_kwonly_opt", 0};
+    PyObject *argsbuf[5];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 3, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[1]) {
+        b = args[1];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    e = args[4];
+skip_optional_kwonly:
+    return_value = test_posonly_keywords_opt2_kwonly_opt_impl(module, a, b, c, d, e);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_keywords_opt2_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                           PyObject *b, PyObject *c,
+                                           PyObject *d, PyObject *e)
+/*[clinic end generated code: output=0416689b23ebf66e input=c95e2e1ec93035ad]*/
+
+
+/*[clinic input]
+test_posonly_opt_keywords_opt_kwonly_opt
+
+    a: object
+    b: object = None
+    /
+    c: object = None
+    d: object = None
+    *
+    e: object = None
+    f: object = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_posonly_opt_keywords_opt_kwonly_opt__doc__,
+"test_posonly_opt_keywords_opt_kwonly_opt($module, a, b=None, /, c=None,\n"
+"                                         d=None, *, e=None, f=None)\n"
+"--\n"
+"\n");
+
+#define TEST_POSONLY_OPT_KEYWORDS_OPT_KWONLY_OPT_METHODDEF    \
+    {"test_posonly_opt_keywords_opt_kwonly_opt", _PyCFunction_CAST(test_posonly_opt_keywords_opt_kwonly_opt), METH_FASTCALL|METH_KEYWORDS, test_posonly_opt_keywords_opt_kwonly_opt__doc__},
+
+static PyObject *
+test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                              PyObject *b, PyObject *c,
+                                              PyObject *d, PyObject *e,
+                                              PyObject *f);
+
+static PyObject *
+test_posonly_opt_keywords_opt_kwonly_opt(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"", "", "c", "d", "e", "f", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_posonly_opt_keywords_opt_kwonly_opt", 0};
+    PyObject *argsbuf[6];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *b = Py_None;
+    PyObject *c = Py_None;
+    PyObject *d = Py_None;
+    PyObject *e = Py_None;
+    PyObject *f = Py_None;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 4, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    if (nargs < 2) {
+        goto skip_optional_posonly;
+    }
+    noptargs--;
+    b = args[1];
+skip_optional_posonly:
+    if (!noptargs) {
+        goto skip_optional_pos;
+    }
+    if (args[2]) {
+        c = args[2];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+    if (args[3]) {
+        d = args[3];
+        if (!--noptargs) {
+            goto skip_optional_pos;
+        }
+    }
+skip_optional_pos:
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[4]) {
+        e = args[4];
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    f = args[5];
+skip_optional_kwonly:
+    return_value = test_posonly_opt_keywords_opt_kwonly_opt_impl(module, a, b, c, d, e, f);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_posonly_opt_keywords_opt_kwonly_opt_impl(PyObject *module, PyObject *a,
+                                              PyObject *b, PyObject *c,
+                                              PyObject *d, PyObject *e,
+                                              PyObject *f)
+/*[clinic end generated code: output=8892a137a8c8f46f input=9914857713c5bbf8]*/
+
+/*[clinic input]
+test_keyword_only_parameter
+
+
+    *
+    co_lnotab: PyBytesObject(c_default="(PyBytesObject *)self->co_lnotab") = None
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_keyword_only_parameter__doc__,
+"test_keyword_only_parameter($module, /, *, co_lnotab=None)\n"
+"--\n"
+"\n");
+
+#define TEST_KEYWORD_ONLY_PARAMETER_METHODDEF    \
+    {"test_keyword_only_parameter", _PyCFunction_CAST(test_keyword_only_parameter), METH_FASTCALL|METH_KEYWORDS, test_keyword_only_parameter__doc__},
+
+static PyObject *
+test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab);
+
+static PyObject *
+test_keyword_only_parameter(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"co_lnotab", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_keyword_only_parameter", 0};
+    PyObject *argsbuf[1];
+    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
+    PyBytesObject *co_lnotab = (PyBytesObject *)self->co_lnotab;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (!PyBytes_Check(args[0])) {
+        _PyArg_BadArgument("test_keyword_only_parameter", "argument 'co_lnotab'", "bytes", args[0]);
+        goto exit;
+    }
+    co_lnotab = (PyBytesObject *)args[0];
+skip_optional_kwonly:
+    return_value = test_keyword_only_parameter_impl(module, co_lnotab);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_keyword_only_parameter_impl(PyObject *module, PyBytesObject *co_lnotab)
+/*[clinic end generated code: output=332b5f4b444c5d55 input=303df5046c7e37a3]*/
+
+
+/*[clinic input]
+output push
+output preset buffer
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5bff3376ee0df0b5]*/
+
+#ifdef CONDITION_A
+/*[clinic input]
+test_preprocessor_guarded_condition_a
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_condition_a_impl(PyObject *module)
+/*[clinic end generated code: output=ad012af18085add6 input=8edb8706a98cda7e]*/
+#elif CONDITION_B
+/*[clinic input]
+test_preprocessor_guarded_elif_condition_b
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_elif_condition_b_impl(PyObject *module)
+/*[clinic end generated code: output=615f2dee82b138d1 input=53777cebbf7fee32]*/
+#else
+/*[clinic input]
+test_preprocessor_guarded_else
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_else_impl(PyObject *module)
+/*[clinic end generated code: output=13af7670aac51b12 input=6657ab31d74c29fc]*/
+#endif
+
+#ifndef CONDITION_C
+/*[clinic input]
+test_preprocessor_guarded_ifndef_condition_c
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_ifndef_condition_c_impl(PyObject *module)
+/*[clinic end generated code: output=ed422e8c895bb0a5 input=e9b50491cea2b668]*/
+#else
+/*[clinic input]
+test_preprocessor_guarded_ifndef_not_condition_c
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_ifndef_not_condition_c_impl(PyObject *module)
+/*[clinic end generated code: output=de6f4c6a67f8c536 input=da74e30e01c6f2c5]*/
+#endif
+
+#if \
+CONDITION_D
+/*[clinic input]
+test_preprocessor_guarded_if_with_continuation
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_if_with_continuation_impl(PyObject *module)
+/*[clinic end generated code: output=3d0712ca9e2d15b9 input=4a956fd91be30284]*/
+#endif
+
+#if CONDITION_E ||CONDITION_F
+#warning "different type of CPP directive"
+/*[clinic input]
+test_preprocessor_guarded_if_e_or_f
+Makes sure cpp.Monitor handles other directives than preprocessor conditionals.
+[clinic start generated code]*/
+
+static PyObject *
+test_preprocessor_guarded_if_e_or_f_impl(PyObject *module)
+/*[clinic end generated code: output=e49d24ff64ad88bc input=57b9c37f938bc4f1]*/
+#endif
+
+/*[clinic input]
+dump buffer
+output pop
+[clinic start generated code]*/
+
+#if defined(CONDITION_A)
+
+PyDoc_STRVAR(test_preprocessor_guarded_condition_a__doc__,
+"test_preprocessor_guarded_condition_a($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF    \
+    {"test_preprocessor_guarded_condition_a", (PyCFunction)test_preprocessor_guarded_condition_a, METH_NOARGS, test_preprocessor_guarded_condition_a__doc__},
+
+static PyObject *
+test_preprocessor_guarded_condition_a(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_condition_a_impl(module);
+}
+
+#endif /* defined(CONDITION_A) */
+
+#if !defined(CONDITION_A) && (CONDITION_B)
+
+PyDoc_STRVAR(test_preprocessor_guarded_elif_condition_b__doc__,
+"test_preprocessor_guarded_elif_condition_b($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF    \
+    {"test_preprocessor_guarded_elif_condition_b", (PyCFunction)test_preprocessor_guarded_elif_condition_b, METH_NOARGS, test_preprocessor_guarded_elif_condition_b__doc__},
+
+static PyObject *
+test_preprocessor_guarded_elif_condition_b(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_elif_condition_b_impl(module);
+}
+
+#endif /* !defined(CONDITION_A) && (CONDITION_B) */
+
+#if !defined(CONDITION_A) && !(CONDITION_B)
+
+PyDoc_STRVAR(test_preprocessor_guarded_else__doc__,
+"test_preprocessor_guarded_else($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF    \
+    {"test_preprocessor_guarded_else", (PyCFunction)test_preprocessor_guarded_else, METH_NOARGS, test_preprocessor_guarded_else__doc__},
+
+static PyObject *
+test_preprocessor_guarded_else(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_else_impl(module);
+}
+
+#endif /* !defined(CONDITION_A) && !(CONDITION_B) */
+
+#if !defined(CONDITION_C)
+
+PyDoc_STRVAR(test_preprocessor_guarded_ifndef_condition_c__doc__,
+"test_preprocessor_guarded_ifndef_condition_c($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF    \
+    {"test_preprocessor_guarded_ifndef_condition_c", (PyCFunction)test_preprocessor_guarded_ifndef_condition_c, METH_NOARGS, test_preprocessor_guarded_ifndef_condition_c__doc__},
+
+static PyObject *
+test_preprocessor_guarded_ifndef_condition_c(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_ifndef_condition_c_impl(module);
+}
+
+#endif /* !defined(CONDITION_C) */
+
+#if defined(CONDITION_C)
+
+PyDoc_STRVAR(test_preprocessor_guarded_ifndef_not_condition_c__doc__,
+"test_preprocessor_guarded_ifndef_not_condition_c($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF    \
+    {"test_preprocessor_guarded_ifndef_not_condition_c", (PyCFunction)test_preprocessor_guarded_ifndef_not_condition_c, METH_NOARGS, test_preprocessor_guarded_ifndef_not_condition_c__doc__},
+
+static PyObject *
+test_preprocessor_guarded_ifndef_not_condition_c(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_ifndef_not_condition_c_impl(module);
+}
+
+#endif /* defined(CONDITION_C) */
+
+#if (CONDITION_D)
+
+PyDoc_STRVAR(test_preprocessor_guarded_if_with_continuation__doc__,
+"test_preprocessor_guarded_if_with_continuation($module, /)\n"
+"--\n"
+"\n");
+
+#define TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF    \
+    {"test_preprocessor_guarded_if_with_continuation", (PyCFunction)test_preprocessor_guarded_if_with_continuation, METH_NOARGS, test_preprocessor_guarded_if_with_continuation__doc__},
+
+static PyObject *
+test_preprocessor_guarded_if_with_continuation(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_if_with_continuation_impl(module);
+}
+
+#endif /* (CONDITION_D) */
+
+#if (CONDITION_E || CONDITION_F)
+
+PyDoc_STRVAR(test_preprocessor_guarded_if_e_or_f__doc__,
+"test_preprocessor_guarded_if_e_or_f($module, /)\n"
+"--\n"
+"\n"
+"Makes sure cpp.Monitor handles other directives than preprocessor conditionals.");
+
+#define TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF    \
+    {"test_preprocessor_guarded_if_e_or_f", (PyCFunction)test_preprocessor_guarded_if_e_or_f, METH_NOARGS, test_preprocessor_guarded_if_e_or_f__doc__},
+
+static PyObject *
+test_preprocessor_guarded_if_e_or_f(PyObject *module, PyObject *Py_UNUSED(ignored))
+{
+    return test_preprocessor_guarded_if_e_or_f_impl(module);
+}
+
+#endif /* (CONDITION_E || CONDITION_F) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_CONDITION_A_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELIF_CONDITION_B_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_ELSE_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IFNDEF_CONDITION_C_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IFNDEF_NOT_CONDITION_C_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IF_WITH_CONTINUATION_METHODDEF) */
+
+#ifndef TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF
+    #define TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF
+#endif /* !defined(TEST_PREPROCESSOR_GUARDED_IF_E_OR_F_METHODDEF) */
+/*[clinic end generated code: output=fcfae7cac7a99e62 input=3fc80c9989d2f2e1]*/
+
+/*[clinic input]
+test_vararg_and_posonly
+
+
+    a: object
+    *args: object
+    /
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg_and_posonly__doc__,
+"test_vararg_and_posonly($module, a, /, *args)\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_AND_POSONLY_METHODDEF    \
+    {"test_vararg_and_posonly", _PyCFunction_CAST(test_vararg_and_posonly), METH_FASTCALL, test_vararg_and_posonly__doc__},
+
+static PyObject *
+test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args);
+
+static PyObject *
+test_vararg_and_posonly(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *a;
+    PyObject *__clinic_args = NULL;
+
+    if (!_PyArg_CheckPositional("test_vararg_and_posonly", nargs, 1, PY_SSIZE_T_MAX)) {
+        goto exit;
+    }
+    a = args[0];
+    __clinic_args = PyTuple_New(nargs - 1);
+    if (!__clinic_args) {
+        goto exit;
+    }
+    for (Py_ssize_t i = 0; i < nargs - 1; ++i) {
+        PyTuple_SET_ITEM(__clinic_args, i, Py_NewRef(args[1 + i]));
+    }
+    return_value = test_vararg_and_posonly_impl(module, a, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_and_posonly_impl(PyObject *module, PyObject *a, PyObject *args)
+/*[clinic end generated code: output=79b75dc07decc8d6 input=08dc2bf7afbf1613]*/
+
+/*[clinic input]
+test_vararg
+
+
+    a: object
+    *args: object
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg__doc__,
+"test_vararg($module, /, a, *args)\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_METHODDEF    \
+    {"test_vararg", _PyCFunction_CAST(test_vararg), METH_FASTCALL|METH_KEYWORDS, test_vararg__doc__},
+
+static PyObject *
+test_vararg_impl(PyObject *module, PyObject *a, PyObject *args);
+
+static PyObject *
+test_vararg(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg", 0};
+    PyObject *argsbuf[2];
+    PyObject *a;
+    PyObject *__clinic_args = NULL;
+
+    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    __clinic_args = args[1];
+    return_value = test_vararg_impl(module, a, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_impl(PyObject *module, PyObject *a, PyObject *args)
+/*[clinic end generated code: output=ce9334333757f6ea input=81d33815ad1bae6e]*/
+
+/*[clinic input]
+test_vararg_with_default
+
+
+    a: object
+    *args: object
+    b: bool = False
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg_with_default__doc__,
+"test_vararg_with_default($module, /, a, *args, b=False)\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_WITH_DEFAULT_METHODDEF    \
+    {"test_vararg_with_default", _PyCFunction_CAST(test_vararg_with_default), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_default__doc__},
+
+static PyObject *
+test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
+                              int b);
+
+static PyObject *
+test_vararg_with_default(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", "b", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_default", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = Py_MIN(nargs, 1) + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
+    PyObject *a;
+    PyObject *__clinic_args = NULL;
+    int b = 0;
+
+    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, 1, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = args[0];
+    __clinic_args = args[1];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    b = PyObject_IsTrue(args[2]);
+    if (b < 0) {
+        goto exit;
+    }
+skip_optional_kwonly:
+    return_value = test_vararg_with_default_impl(module, a, __clinic_args, b);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_with_default_impl(PyObject *module, PyObject *a, PyObject *args,
+                              int b)
+/*[clinic end generated code: output=32fb19dd6bcf9185 input=6e110b54acd9b22d]*/
+
+/*[clinic input]
+test_vararg_with_only_defaults
+
+
+    *args: object
+    b: bool = False
+    c: object = ' '
+
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_vararg_with_only_defaults__doc__,
+"test_vararg_with_only_defaults($module, /, *args, b=False, c=\' \')\n"
+"--\n"
+"\n");
+
+#define TEST_VARARG_WITH_ONLY_DEFAULTS_METHODDEF    \
+    {"test_vararg_with_only_defaults", _PyCFunction_CAST(test_vararg_with_only_defaults), METH_FASTCALL|METH_KEYWORDS, test_vararg_with_only_defaults__doc__},
+
+static PyObject *
+test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
+                                    PyObject *c);
+
+static PyObject *
+test_vararg_with_only_defaults(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"b", "c", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_vararg_with_only_defaults", 0};
+    PyObject *argsbuf[3];
+    Py_ssize_t noptargs = 0 + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
+    PyObject *__clinic_args = NULL;
+    int b = 0;
+    PyObject *c = " ";
+
+    args = _PyArg_UnpackKeywordsWithVararg(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    __clinic_args = args[0];
+    if (!noptargs) {
+        goto skip_optional_kwonly;
+    }
+    if (args[1]) {
+        b = PyObject_IsTrue(args[1]);
+        if (b < 0) {
+            goto exit;
+        }
+        if (!--noptargs) {
+            goto skip_optional_kwonly;
+        }
+    }
+    c = args[2];
+skip_optional_kwonly:
+    return_value = test_vararg_with_only_defaults_impl(module, __clinic_args, b, c);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+test_vararg_with_only_defaults_impl(PyObject *module, PyObject *args, int b,
+                                    PyObject *c)
+/*[clinic end generated code: output=7e393689e6ce61a3 input=fa56a709a035666e]*/
+
+/*[clinic input]
+test_paramname_module
+
+    module as mod: object
+[clinic start generated code]*/
+
+PyDoc_STRVAR(test_paramname_module__doc__,
+"test_paramname_module($module, /, module)\n"
+"--\n"
+"\n");
+
+#define TEST_PARAMNAME_MODULE_METHODDEF    \
+    {"test_paramname_module", _PyCFunction_CAST(test_paramname_module), METH_FASTCALL|METH_KEYWORDS, test_paramname_module__doc__},
+
+static PyObject *
+test_paramname_module_impl(PyObject *module, PyObject *mod);
+
+static PyObject *
+test_paramname_module(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"module", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "test_paramname_module", 0};
+    PyObject *argsbuf[1];
+    PyObject *mod;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    mod = args[0];
+    return_value = test_paramname_module_impl(module, mod);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+test_paramname_module_impl(PyObject *module, PyObject *mod)
+/*[clinic end generated code: output=23379a7ffa65c514 input=afefe259667f13ba]*/
+
+
+/*[clinic input]
+Test.cls_with_param
+    cls: defining_class
+    /
+    a: int
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_cls_with_param__doc__,
+"cls_with_param($self, /, a)\n"
+"--\n"
+"\n");
+
+#define TEST_CLS_WITH_PARAM_METHODDEF    \
+    {"cls_with_param", _PyCFunction_CAST(Test_cls_with_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, Test_cls_with_param__doc__},
+
+static PyObject *
+Test_cls_with_param_impl(TestObj *self, PyTypeObject *cls, int a);
+
+static PyObject *
+Test_cls_with_param(TestObj *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    PyObject *return_value = NULL;
+    static const char * const _keywords[] = {"a", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "cls_with_param", 0};
+    PyObject *argsbuf[1];
+    int a;
+
+    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
+    if (!args) {
+        goto exit;
+    }
+    a = _PyLong_AsInt(args[0]);
+    if (a == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = Test_cls_with_param_impl(self, cls, a);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+Test_cls_with_param_impl(TestObj *self, PyTypeObject *cls, int a)
+/*[clinic end generated code: output=9c06a8cfc495b4d1 input=af158077bd237ef9]*/
+
+
+/*[clinic input]
+Test.__init__
+Empty init method.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test___init____doc__,
+"Test()\n"
+"--\n"
+"\n"
+"Empty init method.");
+
+static int
+Test___init___impl(TestObj *self);
+
+static int
+Test___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    int return_value = -1;
+
+    if ((Py_IS_TYPE(self, TestType) ||
+         Py_TYPE(self)->tp_new == TestType->tp_new) &&
+        !_PyArg_NoPositional("Test", args)) {
+        goto exit;
+    }
+    if ((Py_IS_TYPE(self, TestType) ||
+         Py_TYPE(self)->tp_new == TestType->tp_new) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    return_value = Test___init___impl((TestObj *)self);
+
+exit:
+    return return_value;
+}
+
+static int
+Test___init___impl(TestObj *self)
+/*[clinic end generated code: output=f02b7d23eec3dc47 input=4ea79fee54d0c3ff]*/
+
+
+/*[clinic input]
+@classmethod
+Test.__new__
+Empty new method.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test__doc__,
+"Test()\n"
+"--\n"
+"\n"
+"Empty new method.");
+
+static PyObject *
+Test_impl(PyTypeObject *type);
+
+static PyObject *
+Test(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyObject *return_value = NULL;
+
+    if ((type == TestType ||
+         type->tp_init == TestType->tp_init) &&
+        !_PyArg_NoPositional("Test", args)) {
+        goto exit;
+    }
+    if ((type == TestType ||
+         type->tp_init == TestType->tp_init) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    return_value = Test_impl(type);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+Test_impl(PyTypeObject *type)
+/*[clinic end generated code: output=3a8a564e799cf5ce input=6fe98a19f097907f]*/
+
+
+/*[clinic input]
+Test.cls_no_params
+    cls: defining_class
+    /
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_cls_no_params__doc__,
+"cls_no_params($self, /)\n"
+"--\n"
+"\n");
+
+#define TEST_CLS_NO_PARAMS_METHODDEF    \
+    {"cls_no_params", _PyCFunction_CAST(Test_cls_no_params), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, Test_cls_no_params__doc__},
+
+static PyObject *
+Test_cls_no_params_impl(TestObj *self, PyTypeObject *cls);
+
+static PyObject *
+Test_cls_no_params(TestObj *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
+{
+    if (nargs) {
+        PyErr_SetString(PyExc_TypeError, "cls_no_params() takes no arguments");
+        return NULL;
+    }
+    return Test_cls_no_params_impl(self, cls);
+}
+
+static PyObject *
+Test_cls_no_params_impl(TestObj *self, PyTypeObject *cls)
+/*[clinic end generated code: output=cc8845f22cff3dcb input=e7e2e4e344e96a11]*/
+
+
+/*[clinic input]
+Test.metho_not_default_return_converter -> int
+    a: object
+    /
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_metho_not_default_return_converter__doc__,
+"metho_not_default_return_converter($self, a, /)\n"
+"--\n"
+"\n");
+
+#define TEST_METHO_NOT_DEFAULT_RETURN_CONVERTER_METHODDEF    \
+    {"metho_not_default_return_converter", (PyCFunction)Test_metho_not_default_return_converter, METH_O, Test_metho_not_default_return_converter__doc__},
+
+static int
+Test_metho_not_default_return_converter_impl(TestObj *self, PyObject *a);
+
+static PyObject *
+Test_metho_not_default_return_converter(TestObj *self, PyObject *a)
+{
+    PyObject *return_value = NULL;
+    int _return_value;
+
+    _return_value = Test_metho_not_default_return_converter_impl(self, a);
+    if ((_return_value == -1) && PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = PyLong_FromLong((long)_return_value);
+
+exit:
+    return return_value;
+}
+
+static int
+Test_metho_not_default_return_converter_impl(TestObj *self, PyObject *a)
+/*[clinic end generated code: output=3350de11bd538007 input=428657129b521177]*/
+
+
+/*[clinic input]
+Test.an_metho_arg_named_arg
+    arg: int
+        Name should be mangled to 'arg_' in generated output.
+    /
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_an_metho_arg_named_arg__doc__,
+"an_metho_arg_named_arg($self, arg, /)\n"
+"--\n"
+"\n"
+"\n"
+"\n"
+"  arg\n"
+"    Name should be mangled to \'arg_\' in generated output.");
+
+#define TEST_AN_METHO_ARG_NAMED_ARG_METHODDEF    \
+    {"an_metho_arg_named_arg", (PyCFunction)Test_an_metho_arg_named_arg, METH_O, Test_an_metho_arg_named_arg__doc__},
+
+static PyObject *
+Test_an_metho_arg_named_arg_impl(TestObj *self, int arg);
+
+static PyObject *
+Test_an_metho_arg_named_arg(TestObj *self, PyObject *arg_)
+{
+    PyObject *return_value = NULL;
+    int arg;
+
+    arg = _PyLong_AsInt(arg_);
+    if (arg == -1 && PyErr_Occurred()) {
+        goto exit;
+    }
+    return_value = Test_an_metho_arg_named_arg_impl(self, arg);
+
+exit:
+    return return_value;
+}
+
+static PyObject *
+Test_an_metho_arg_named_arg_impl(TestObj *self, int arg)
+/*[clinic end generated code: output=7d590626642194ae input=2a53a57cf5624f95]*/
+
+
+/*[clinic input]
+Test.__init__
+    *args: object
+    /
+Varargs init method. For example, nargs is translated to PyTuple_GET_SIZE.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test___init____doc__,
+"Test(*args)\n"
+"--\n"
+"\n"
+"Varargs init method. For example, nargs is translated to PyTuple_GET_SIZE.");
+
+static int
+Test___init___impl(TestObj *self, PyObject *args);
+
+static int
+Test___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    int return_value = -1;
+    PyObject *__clinic_args = NULL;
+
+    if ((Py_IS_TYPE(self, TestType) ||
+         Py_TYPE(self)->tp_new == TestType->tp_new) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    if (!_PyArg_CheckPositional("Test", PyTuple_GET_SIZE(args), 0, PY_SSIZE_T_MAX)) {
+        goto exit;
+    }
+    __clinic_args = PyTuple_GetSlice(0, -1);
+    return_value = Test___init___impl((TestObj *)self, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static int
+Test___init___impl(TestObj *self, PyObject *args)
+/*[clinic end generated code: output=126ad63fc2e5139e input=96c3ddc0cd38fc0c]*/
+
+
+/*[clinic input]
+@classmethod
+Test.__new__
+    *args: object
+    /
+Varargs new method. For example, nargs is translated to PyTuple_GET_SIZE.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test__doc__,
+"Test(*args)\n"
+"--\n"
+"\n"
+"Varargs new method. For example, nargs is translated to PyTuple_GET_SIZE.");
+
+static PyObject *
+Test_impl(PyTypeObject *type, PyObject *args);
+
+static PyObject *
+Test(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyObject *return_value = NULL;
+    PyObject *__clinic_args = NULL;
+
+    if ((type == TestType ||
+         type->tp_init == TestType->tp_init) &&
+        !_PyArg_NoKeywords("Test", kwargs)) {
+        goto exit;
+    }
+    if (!_PyArg_CheckPositional("Test", PyTuple_GET_SIZE(args), 0, PY_SSIZE_T_MAX)) {
+        goto exit;
+    }
+    __clinic_args = PyTuple_GetSlice(0, -1);
+    return_value = Test_impl(type, __clinic_args);
+
+exit:
+    Py_XDECREF(__clinic_args);
+    return return_value;
+}
+
+static PyObject *
+Test_impl(PyTypeObject *type, PyObject *args)
+/*[clinic end generated code: output=4f01d446cfe4aeb9 input=26a672e2e9750120]*/
+
+
+/*[clinic input]
+Test.__init__
+    a: object
+Init method with positional or keyword arguments.
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test___init____doc__,
+"Test(a)\n"
+"--\n"
+"\n"
+"Init method with positional or keyword arguments.");
+
+static int
+Test___init___impl(TestObj *self, PyObject *a);
+
+static int
+Test___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    int return_value = -1;
+    static const char * const _keywords[] = {"a", NULL};
+    static _PyArg_Parser _parser = {NULL, _keywords, "Test", 0};
+    PyObject *argsbuf[1];
+    PyObject * const *fastargs;
+    Py_ssize_t nargs = PyTuple_GET_SIZE(args);
+    PyObject *a;
+
+    fastargs = _PyArg_UnpackKeywords(_PyTuple_CAST(args)->ob_item, nargs, kwargs, NULL, &_parser, 1, 1, 0, argsbuf);
+    if (!fastargs) {
+        goto exit;
+    }
+    a = fastargs[0];
+    return_value = Test___init___impl((TestObj *)self, a);
+
+exit:
+    return return_value;
+}
+
+static int
+Test___init___impl(TestObj *self, PyObject *a)
+/*[clinic end generated code: output=5afcf1a525211a09 input=a8f9222a6ab35c59]*/
+
+
+/*[clinic input]
+@classmethod
+Test.class_method
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_class_method__doc__,
+"class_method($type, /)\n"
+"--\n"
+"\n");
+
+#define TEST_CLASS_METHOD_METHODDEF    \
+    {"class_method", (PyCFunction)Test_class_method, METH_NOARGS|METH_CLASS, Test_class_method__doc__},
+
+static PyObject *
+Test_class_method_impl(PyTypeObject *type);
+
+static PyObject *
+Test_class_method(PyTypeObject *type, PyObject *Py_UNUSED(ignored))
+{
+    return Test_class_method_impl(type);
+}
+
+static PyObject *
+Test_class_method_impl(PyTypeObject *type)
+/*[clinic end generated code: output=47fb7ecca1abcaaa input=43bc4a0494547b80]*/
+
+
+/*[clinic input]
+@staticmethod
+Test.static_method
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_static_method__doc__,
+"static_method()\n"
+"--\n"
+"\n");
+
+#define TEST_STATIC_METHOD_METHODDEF    \
+    {"static_method", (PyCFunction)Test_static_method, METH_NOARGS|METH_STATIC, Test_static_method__doc__},
+
+static PyObject *
+Test_static_method_impl();
+
+static PyObject *
+Test_static_method(void *null, PyObject *Py_UNUSED(ignored))
+{
+    return Test_static_method_impl();
+}
+
+static PyObject *
+Test_static_method_impl()
+/*[clinic end generated code: output=82524a63025cf7ab input=dae892fac55ae72b]*/
+
+
+/*[clinic input]
+@coexist
+Test.meth_coexist
+[clinic start generated code]*/
+
+PyDoc_STRVAR(Test_meth_coexist__doc__,
+"meth_coexist($self, /)\n"
+"--\n"
+"\n");
+
+#define TEST_METH_COEXIST_METHODDEF    \
+    {"meth_coexist", (PyCFunction)Test_meth_coexist, METH_NOARGS|METH_COEXIST, Test_meth_coexist__doc__},
+
+static PyObject *
+Test_meth_coexist_impl(TestObj *self);
+
+static PyObject *
+Test_meth_coexist(TestObj *self, PyObject *Py_UNUSED(ignored))
+{
+    return Test_meth_coexist_impl(self);
+}
+
+static PyObject *
+Test_meth_coexist_impl(TestObj *self)
+/*[clinic end generated code: output=808a293d0cd27439 input=2a1d75b5e6fec6dd]*/
+
+
+/*[clinic input]
+output push
+output preset buffer
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5bff3376ee0df0b5]*/
+
+/*[clinic input]
+buffer_clear
+  a: int
+We'll call 'destination buffer clear' after this.
+
+Argument Clinic's buffer preset puts most generated code into the
+'buffer' destination, except from 'impl_definition', which is put into
+the 'block' destination, so we should expect everything but
+'impl_definition' to be cleared.
+[clinic start generated code]*/
+
+static PyObject *
+buffer_clear_impl(PyObject *module, int a)
+/*[clinic end generated code: output=f14bba74677e1846 input=a4c308a6fdab043c]*/
+
+/*[clinic input]
+destination buffer clear
+output pop
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=f20d06adb8252084]*/
+
+
+/*[clinic input]
+output push
+destination test1 new buffer
+output everything suppress
+output docstring_definition test1
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=5a77c454970992fc]*/
+
+/*[clinic input]
+new_dest
+  a: int
+Only this docstring should be outputted to test1.
+[clinic start generated code]*/
+/*[clinic end generated code: output=da39a3ee5e6b4b0d input=da5af421ed8996ed]*/
+
+/*[clinic input]
+dump test1
+output pop
+[clinic start generated code]*/
+
+PyDoc_STRVAR(new_dest__doc__,
+"new_dest($module, /, a)\n"
+"--\n"
+"\n"
+"Only this docstring should be outputted to test1.");
+/*[clinic end generated code: output=9cac703f51d90e84 input=090db8df4945576d]*/
--- a/Lib/test/libregrtest/runtest_mp.py
+++ b/Lib/test/libregrtest/runtest_mp.py
@@ -269,6 +269,7 @@ class TestWorkerProcess(threading.Thread
             encoding = locale.getencoding()
         else:
             encoding = sys.stdout.encoding
+
         # gh-94026: Write stdout+stderr to a tempfile as workaround for
         # non-blocking pipes on Emscripten with NodeJS.
         with tempfile.TemporaryFile('w+', encoding=encoding) as stdout_fh:
@@ -277,7 +278,14 @@ class TestWorkerProcess(threading.Thread
             # Python finalization: too late for libregrtest.
             retcode = self._run_process(test_name, stdout_fh)
             stdout_fh.seek(0)
-            stdout = stdout_fh.read().strip()
+
+            try:
+                stdout = stdout_fh.read().strip()
+            except Exception as exc:
+                # gh-101634: Catch UnicodeDecodeError if stdout cannot be
+                # decoded from encoding
+                err_msg = f"Cannot read process stdout: {exc}"
+                return self.mp_result_error(ChildError(test_name), '', err_msg)
 
         if retcode is None:
             return self.mp_result_error(Timeout(test_name), stdout)
@@ -452,6 +460,8 @@ class MultiprocessTestRunner:
             # Thread got an exception
             format_exc = item[1]
             print_warning(f"regrtest worker thread failed: {format_exc}")
+            result = ChildError("<regrtest worker>")
+            self.regrtest.accumulate_result(result)
             return True
 
         self.test_index += 1
--- a/Lib/test/test_abc.py
+++ b/Lib/test/test_abc.py
@@ -448,15 +448,16 @@ def test_factory(abc_ABCMeta, abc_get_ca
 
             # Also check that issubclass() propagates exceptions raised by
             # __subclasses__.
+            class CustomError(Exception): ...
             exc_msg = "exception from __subclasses__"
 
             def raise_exc():
-                raise Exception(exc_msg)
+                raise CustomError(exc_msg)
 
             class S(metaclass=abc_ABCMeta):
                 __subclasses__ = raise_exc
 
-            with self.assertRaisesRegex(Exception, exc_msg):
+            with self.assertRaisesRegex(CustomError, exc_msg):
                 issubclass(int, S)
 
         def test_subclasshook(self):
--- a/Lib/test/test_ast.py
+++ b/Lib/test/test_ast.py
@@ -3,6 +3,7 @@ import builtins
 import dis
 import enum
 import os
+import re
 import sys
 import types
 import unittest
@@ -862,6 +863,32 @@ class AST_Tests(unittest.TestCase):
             msg="source code string cannot contain null bytes"):
             ast.parse("a\0b")
 
+    def assert_none_check(self, node: type[ast.AST], attr: str, source: str) -> None:
+        with self.subTest(f"{node.__name__}.{attr}"):
+            tree = ast.parse(source)
+            found = 0
+            for child in ast.walk(tree):
+                if isinstance(child, node):
+                    setattr(child, attr, None)
+                    found += 1
+            self.assertEqual(found, 1)
+            e = re.escape(f"field '{attr}' is required for {node.__name__}")
+            with self.assertRaisesRegex(ValueError, f"^{e}$"):
+                compile(tree, "<test>", "exec")
+
+    def test_none_checks(self) -> None:
+        tests = [
+            (ast.alias, "name", "import spam as SPAM"),
+            (ast.arg, "arg", "def spam(SPAM): spam"),
+            (ast.comprehension, "target", "[spam for SPAM in spam]"),
+            (ast.comprehension, "iter", "[spam for spam in SPAM]"),
+            (ast.keyword, "value", "spam(**SPAM)"),
+            (ast.match_case, "pattern", "match spam:\n case SPAM: spam"),
+            (ast.withitem, "context_expr", "with SPAM: spam"),
+        ]
+        for node, attr, source in tests:
+            self.assert_none_check(node, attr, source)
+
 class ASTHelpers_Test(unittest.TestCase):
     maxDiff = None
 
--- /dev/null
+++ b/Lib/test/test_capi/test_codecs.py
@@ -0,0 +1,54 @@
+import unittest
+from test.support import import_helper
+
+_testcapi = import_helper.import_module('_testcapi')
+
+
+class CAPITest(unittest.TestCase):
+
+    def test_decodeutf8(self):
+        """Test PyUnicode_DecodeUTF8()"""
+        decodeutf8 = _testcapi.unicode_decodeutf8
+
+        for s in ['abc', '\xa1\xa2', '\u4f60\u597d', 'a\U0001f600']:
+            b = s.encode('utf-8')
+            self.assertEqual(decodeutf8(b), s)
+            self.assertEqual(decodeutf8(b, 'strict'), s)
+
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'\x80')
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'\xc0')
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'\xff')
+        self.assertRaises(UnicodeDecodeError, decodeutf8, b'a\xf0\x9f')
+        self.assertEqual(decodeutf8(b'a\xf0\x9f', 'replace'), 'a\ufffd')
+        self.assertEqual(decodeutf8(b'a\xf0\x9fb', 'replace'), 'a\ufffdb')
+
+        self.assertRaises(LookupError, decodeutf8, b'a\x80', 'foo')
+        # TODO: Test PyUnicode_DecodeUTF8() with NULL as data and
+        # negative size.
+
+    def test_decodeutf8stateful(self):
+        """Test PyUnicode_DecodeUTF8Stateful()"""
+        decodeutf8stateful = _testcapi.unicode_decodeutf8stateful
+
+        for s in ['abc', '\xa1\xa2', '\u4f60\u597d', 'a\U0001f600']:
+            b = s.encode('utf-8')
+            self.assertEqual(decodeutf8stateful(b), (s, len(b)))
+            self.assertEqual(decodeutf8stateful(b, 'strict'), (s, len(b)))
+
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'\x80')
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'\xc0')
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'\xff')
+        self.assertEqual(decodeutf8stateful(b'a\xf0\x9f'), ('a', 1))
+        self.assertEqual(decodeutf8stateful(b'a\xf0\x9f', 'replace'), ('a', 1))
+        self.assertRaises(UnicodeDecodeError, decodeutf8stateful, b'a\xf0\x9fb')
+        self.assertEqual(decodeutf8stateful(b'a\xf0\x9fb', 'replace'), ('a\ufffdb', 4))
+
+        self.assertRaises(LookupError, decodeutf8stateful, b'a\x80', 'foo')
+        # TODO: Test PyUnicode_DecodeUTF8Stateful() with NULL as data and
+        # negative size.
+        # TODO: Test PyUnicode_DecodeUTF8Stateful() with NULL as the address of
+        # "consumed".
+
+
+if __name__ == "__main__":
+    unittest.main()
--- a/Lib/test/test_capi/test_misc.py
+++ b/Lib/test/test_capi/test_misc.py
@@ -3,6 +3,7 @@
 
 from collections import OrderedDict
 import _thread
+import contextlib
 import importlib.machinery
 import importlib.util
 import os
@@ -40,6 +41,8 @@ import _testinternalcapi
 Py_DEBUG = hasattr(sys, 'gettotalrefcount')
 
 
+NULL = None
+
 def decode_stderr(err):
     return err.decode('utf-8', 'replace').replace('\r', '')
 
@@ -910,6 +913,46 @@ class CAPITest(unittest.TestCase):
         with self.assertRaises(SystemError):
             _testcapi.function_get_module(None)  # not a function
 
+    def test_sys_getobject(self):
+        getobject = _testcapi.sys_getobject
+
+        self.assertIs(getobject(b'stdout'), sys.stdout)
+        with support.swap_attr(sys, '\U0001f40d', 42):
+            self.assertEqual(getobject('\U0001f40d'.encode()), 42)
+
+        self.assertIs(getobject(b'nonexisting'), AttributeError)
+        self.assertIs(getobject(b'\xff'), AttributeError)
+        # CRASHES getobject(NULL)
+
+    def test_sys_setobject(self):
+        setobject = _testcapi.sys_setobject
+
+        value = ['value']
+        value2 = ['value2']
+        try:
+            self.assertEqual(setobject(b'newattr', value), 0)
+            self.assertIs(sys.newattr, value)
+            self.assertEqual(setobject(b'newattr', value2), 0)
+            self.assertIs(sys.newattr, value2)
+            self.assertEqual(setobject(b'newattr', NULL), 0)
+            self.assertFalse(hasattr(sys, 'newattr'))
+            self.assertEqual(setobject(b'newattr', NULL), 0)
+        finally:
+            with contextlib.suppress(AttributeError):
+                del sys.newattr
+        try:
+            self.assertEqual(setobject('\U0001f40d'.encode(), value), 0)
+            self.assertIs(getattr(sys, '\U0001f40d'), value)
+            self.assertEqual(setobject('\U0001f40d'.encode(), NULL), 0)
+            self.assertFalse(hasattr(sys, '\U0001f40d'))
+        finally:
+            with contextlib.suppress(AttributeError):
+                delattr(sys, '\U0001f40d')
+
+        with self.assertRaises(UnicodeDecodeError):
+            setobject(b'\xff', value)
+        # CRASHES setobject(NULL, value)
+
 
 class TestPendingCalls(unittest.TestCase):
 
--- a/Lib/test/test_clinic.py
+++ b/Lib/test/test_clinic.py
@@ -3,11 +3,15 @@
 # Licensed to the PSF under a contributor agreement.
 
 from test import support, test_tools
-from test.support import import_helper, os_helper
+from test.support import os_helper
+from test.support import SHORT_TIMEOUT, requires_subprocess
+from test.support.os_helper import TESTFN, unlink
+from textwrap import dedent
 from unittest import TestCase
 import collections
 import inspect
 import os.path
+import subprocess
 import sys
 import unittest
 
@@ -17,6 +21,19 @@ with test_tools.imports_under_tool('clin
     from clinic import DSLParser
 
 
+class _ParserBase(TestCase):
+    maxDiff = None
+
+    def expect_parser_failure(self, parser, _input):
+        with support.captured_stdout() as stdout:
+            with self.assertRaises(SystemExit):
+                parser(_input)
+        return stdout.getvalue()
+
+    def parse_function_should_fail(self, _input):
+        return self.expect_parser_failure(self.parse_function, _input)
+
+
 class FakeConverter:
     def __init__(self, name, args):
         self.name = name
@@ -87,7 +104,15 @@ class FakeClinic:
 
     _module_and_class = clinic.Clinic._module_and_class
 
-class ClinicWholeFileTest(TestCase):
+
+class ClinicWholeFileTest(_ParserBase):
+    def setUp(self):
+        self.clinic = clinic.Clinic(clinic.CLanguage(None), filename="test.c")
+
+    def expect_failure(self, raw):
+        _input = dedent(raw).strip()
+        return self.expect_parser_failure(self.clinic.parse, _input)
+
     def test_eol(self):
         # regression test:
         # clinic's block parser didn't recognize
@@ -97,15 +122,217 @@ class ClinicWholeFileTest(TestCase):
         # so it would spit out an end line for you.
         # and since you really already had one,
         # the last line of the block got corrupted.
-        c = clinic.Clinic(clinic.CLanguage(None), filename="file")
         raw = "/*[clinic]\nfoo\n[clinic]*/"
-        cooked = c.parse(raw).splitlines()
+        cooked = self.clinic.parse(raw).splitlines()
         end_line = cooked[2].rstrip()
         # this test is redundant, it's just here explicitly to catch
         # the regression test so we don't forget what it looked like
         self.assertNotEqual(end_line, "[clinic]*/[clinic]*/")
         self.assertEqual(end_line, "[clinic]*/")
 
+    def test_mangled_marker_line(self):
+        raw = """
+            /*[clinic input]
+            [clinic start generated code]*/
+            /*[clinic end generated code: foo]*/
+        """
+        msg = (
+            'Error in file "test.c" on line 3:\n'
+            "Mangled Argument Clinic marker line: '/*[clinic end generated code: foo]*/'\n"
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_checksum_mismatch(self):
+        raw = """
+            /*[clinic input]
+            [clinic start generated code]*/
+            /*[clinic end generated code: output=0123456789abcdef input=fedcba9876543210]*/
+        """
+        msg = (
+            'Error in file "test.c" on line 3:\n'
+            'Checksum mismatch!\n'
+            'Expected: 0123456789abcdef\n'
+            'Computed: da39a3ee5e6b4b0d\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertIn(msg, out)
+
+    def test_garbage_after_stop_line(self):
+        raw = """
+            /*[clinic input]
+            [clinic start generated code]*/foobarfoobar!
+        """
+        msg = (
+            'Error in file "test.c" on line 2:\n'
+            "Garbage after stop line: 'foobarfoobar!'\n"
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_whitespace_before_stop_line(self):
+        raw = """
+            /*[clinic input]
+             [clinic start generated code]*/
+        """
+        msg = (
+            'Error in file "test.c" on line 2:\n'
+            "Whitespace is not allowed before the stop line: ' [clinic start generated code]*/'\n"
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_parse_with_body_prefix(self):
+        clang = clinic.CLanguage(None)
+        clang.body_prefix = "//"
+        clang.start_line = "//[{dsl_name} start]"
+        clang.stop_line = "//[{dsl_name} stop]"
+        cl = clinic.Clinic(clang, filename="test.c")
+        raw = dedent("""
+            //[clinic start]
+            //module test
+            //[clinic stop]
+        """).strip()
+        out = cl.parse(raw)
+        expected = dedent("""
+            //[clinic start]
+            //module test
+            //
+            //[clinic stop]
+            /*[clinic end generated code: output=da39a3ee5e6b4b0d input=65fab8adff58cf08]*/
+        """).lstrip()  # Note, lstrip() because of the newline
+        self.assertEqual(out, expected)
+
+    def test_cpp_monitor_fail_nested_block_comment(self):
+        raw = """
+            /* start
+            /* nested
+            */
+            */
+        """
+        msg = (
+            'Error in file "test.c" on line 2:\n'
+            'Nested block comment!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_cpp_monitor_fail_invalid_format_noarg(self):
+        raw = """
+            #if
+            a()
+            #endif
+        """
+        msg = (
+            'Error in file "test.c" on line 1:\n'
+            'Invalid format for #if line: no argument!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_cpp_monitor_fail_invalid_format_toomanyargs(self):
+        raw = """
+            #ifdef A B
+            a()
+            #endif
+        """
+        msg = (
+            'Error in file "test.c" on line 1:\n'
+            'Invalid format for #ifdef line: should be exactly one argument!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_cpp_monitor_fail_no_matching_if(self):
+        raw = '#else'
+        msg = (
+            'Error in file "test.c" on line 1:\n'
+            '#else without matching #if / #ifdef / #ifndef!\n'
+        )
+        out = self.expect_failure(raw)
+        self.assertEqual(out, msg)
+
+    def test_directive_output_unknown_preset(self):
+        out = self.expect_failure("""
+            /*[clinic input]
+            output preset nosuchpreset
+            [clinic start generated code]*/
+        """)
+        msg = "Unknown preset 'nosuchpreset'"
+        self.assertIn(msg, out)
+
+    def test_directive_output_cant_pop(self):
+        out = self.expect_failure("""
+            /*[clinic input]
+            output pop
+            [clinic start generated code]*/
+        """)
+        msg = "Can't 'output pop', stack is empty"
+        self.assertIn(msg, out)
+
+    def test_directive_output_print(self):
+        raw = dedent("""
+            /*[clinic input]
+            output print 'I told you once.'
+            [clinic start generated code]*/
+        """)
+        out = self.clinic.parse(raw)
+        # The generated output will differ for every run, but we can check that
+        # it starts with the clinic block, we check that it contains all the
+        # expected fields, and we check that it contains the checksum line.
+        self.assertTrue(out.startswith(dedent("""
+            /*[clinic input]
+            output print 'I told you once.'
+            [clinic start generated code]*/
+        """)))
+        fields = {
+            "cpp_endif",
+            "cpp_if",
+            "docstring_definition",
+            "docstring_prototype",
+            "impl_definition",
+            "impl_prototype",
+            "methoddef_define",
+            "methoddef_ifndef",
+            "parser_definition",
+            "parser_prototype",
+        }
+        for field in fields:
+            with self.subTest(field=field):
+                self.assertIn(field, out)
+        last_line = out.rstrip().split("\n")[-1]
+        self.assertTrue(
+            last_line.startswith("/*[clinic end generated code: output=")
+        )
+
+    def test_unknown_destination_command(self):
+        out = self.expect_failure("""
+            /*[clinic input]
+            destination buffer nosuchcommand
+            [clinic start generated code]*/
+        """)
+        msg = "unknown destination command 'nosuchcommand'"
+        self.assertIn(msg, out)
+
+    def test_no_access_to_members_in_converter_init(self):
+        out = self.expect_failure("""
+            /*[python input]
+            class Custom_converter(CConverter):
+                converter = "some_c_function"
+                def converter_init(self):
+                    self.function.noaccess
+            [python start generated code]*/
+            /*[clinic input]
+            module test
+            test.fn
+                a: Custom
+            [clinic start generated code]*/
+        """)
+        msg = (
+            "Stepped on a land mine, trying to access attribute 'noaccess':\n"
+            "Don't access members of self.function inside converter_init!"
+        )
+        self.assertIn(msg, out)
 
 
 class ClinicGroupPermuterTest(TestCase):
@@ -170,43 +397,43 @@ class ClinicLinearFormatTest(TestCase):
     def test_no_substitution(self):
         self._test("""
           abc
-          """, """
+        """, """
           abc
-          """)
+        """)
 
     def test_empty_substitution(self):
         self._test("""
           abc
           {name}
           def
-          """, """
+        """, """
           abc
           def
-          """, name='')
+        """, name='')
 
     def test_single_line_substitution(self):
         self._test("""
           abc
           {name}
           def
-          """, """
+        """, """
           abc
           GARGLE
           def
-          """, name='GARGLE')
+        """, name='GARGLE')
 
     def test_multiline_substitution(self):
         self._test("""
           abc
           {name}
           def
-          """, """
+        """, """
           abc
           bingle
           bungle
 
           def
-          """, name='bingle\nbungle\n')
+        """, name='bingle\nbungle\n')
 
 class InertParser:
     def __init__(self, clinic):
@@ -239,9 +466,9 @@ class ClinicBlockParserTest(TestCase):
 
     def test_round_trip_1(self):
         self.round_trip("""
-    verbatim text here
-    lah dee dah
-""")
+            verbatim text here
+            lah dee dah
+        """)
     def test_round_trip_2(self):
         self.round_trip("""
     verbatim text here
@@ -284,23 +511,39 @@ xyz
 """)
 
 
-class ClinicParserTest(TestCase):
+class ClinicParserTest(_ParserBase):
+    def checkDocstring(self, fn, expected):
+        self.assertTrue(hasattr(fn, "docstring"))
+        self.assertEqual(fn.docstring.strip(),
+                         dedent(expected).strip())
+
     def test_trivial(self):
         parser = DSLParser(FakeClinic())
-        block = clinic.Block("module os\nos.access")
+        block = clinic.Block("""
+            module os
+            os.access
+        """)
         parser.parse(block)
         module, function = block.signatures
         self.assertEqual("access", function.name)
         self.assertEqual("os", module.name)
 
     def test_ignore_line(self):
-        block = self.parse("#\nmodule os\nos.access")
+        block = self.parse(dedent("""
+            #
+            module os
+            os.access
+        """))
         module, function = block.signatures
         self.assertEqual("access", function.name)
         self.assertEqual("os", module.name)
 
     def test_param(self):
-        function = self.parse_function("module os\nos.access\n   path: int")
+        function = self.parse_function("""
+            module os
+            os.access
+                path: int
+        """)
         self.assertEqual("access", function.name)
         self.assertEqual(2, len(function.parameters))
         p = function.parameters['path']
@@ -308,236 +551,296 @@ class ClinicParserTest(TestCase):
         self.assertIsInstance(p.converter, clinic.int_converter)
 
     def test_param_default(self):
-        function = self.parse_function("module os\nos.access\n    follow_symlinks: bool = True")
+        function = self.parse_function("""
+            module os
+            os.access
+                follow_symlinks: bool = True
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(True, p.default)
 
     def test_param_with_continuations(self):
-        function = self.parse_function("module os\nos.access\n    follow_symlinks: \\\n   bool \\\n   =\\\n    True")
+        function = self.parse_function(r"""
+            module os
+            os.access
+                follow_symlinks: \
+                bool \
+                = \
+                True
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(True, p.default)
 
     def test_param_default_expression(self):
-        function = self.parse_function("module os\nos.access\n    follow_symlinks: int(c_default='MAXSIZE') = sys.maxsize")
+        function = self.parse_function("""
+            module os
+            os.access
+                follow_symlinks: int(c_default='MAXSIZE') = sys.maxsize
+            """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(sys.maxsize, p.default)
         self.assertEqual("MAXSIZE", p.converter.c_default)
 
-        s = self.parse_function_should_fail("module os\nos.access\n    follow_symlinks: int = sys.maxsize")
-        self.assertEqual(s, "Error on line 0:\nWhen you specify a named constant ('sys.maxsize') as your default value,\nyou MUST specify a valid c_default.\n")
+        expected_msg = (
+            "Error on line 0:\n"
+            "When you specify a named constant ('sys.maxsize') as your default value,\n"
+            "you MUST specify a valid c_default.\n"
+        )
+        out = self.parse_function_should_fail("""
+            module os
+            os.access
+                follow_symlinks: int = sys.maxsize
+        """)
+        self.assertEqual(out, expected_msg)
 
     def test_param_no_docstring(self):
         function = self.parse_function("""
-module os
-os.access
-    follow_symlinks: bool = True
-    something_else: str = ''""")
+            module os
+            os.access
+                follow_symlinks: bool = True
+                something_else: str = ''
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(3, len(function.parameters))
-        self.assertIsInstance(function.parameters['something_else'].converter, clinic.str_converter)
+        conv = function.parameters['something_else'].converter
+        self.assertIsInstance(conv, clinic.str_converter)
 
     def test_param_default_parameters_out_of_order(self):
-        s = self.parse_function_should_fail("""
-module os
-os.access
-    follow_symlinks: bool = True
-    something_else: str""")
-        self.assertEqual(s, """Error on line 0:
-Can't have a parameter without a default ('something_else')
-after a parameter with a default!
-""")
+        expected_msg = (
+            "Error on line 0:\n"
+            "Can't have a parameter without a default ('something_else')\n"
+            "after a parameter with a default!\n"
+        )
+        out = self.parse_function_should_fail("""
+            module os
+            os.access
+                follow_symlinks: bool = True
+                something_else: str""")
+        self.assertEqual(out, expected_msg)
 
     def disabled_test_converter_arguments(self):
-        function = self.parse_function("module os\nos.access\n    path: path_t(allow_fd=1)")
+        function = self.parse_function("""
+            module os
+            os.access
+                path: path_t(allow_fd=1)
+        """)
         p = function.parameters['path']
         self.assertEqual(1, p.converter.args['allow_fd'])
 
     def test_function_docstring(self):
         function = self.parse_function("""
-module os
-os.stat as os_stat_fn
+            module os
+            os.stat as os_stat_fn
 
-   path: str
-       Path to be examined
+               path: str
+                   Path to be examined
 
-Perform a stat system call on the given path.""")
-        self.assertEqual("""
-stat($module, /, path)
---
-
-Perform a stat system call on the given path.
-
-  path
-    Path to be examined
-""".strip(), function.docstring)
+            Perform a stat system call on the given path.
+        """)
+        self.checkDocstring(function, """
+            stat($module, /, path)
+            --
+
+            Perform a stat system call on the given path.
+
+              path
+                Path to be examined
+        """)
 
     def test_explicit_parameters_in_docstring(self):
-        function = self.parse_function("""
-module foo
-foo.bar
-  x: int
-     Documentation for x.
-  y: int
+        function = self.parse_function(dedent("""
+            module foo
+            foo.bar
+              x: int
+                 Documentation for x.
+              y: int
+
+            This is the documentation for foo.
+
+            Okay, we're done here.
+        """))
+        self.checkDocstring(function, """
+            bar($module, /, x, y)
+            --
 
-This is the documentation for foo.
+            This is the documentation for foo.
 
-Okay, we're done here.
-""")
-        self.assertEqual("""
-bar($module, /, x, y)
---
+              x
+                Documentation for x.
 
-This is the documentation for foo.
-
-  x
-    Documentation for x.
-
-Okay, we're done here.
-""".strip(), function.docstring)
+            Okay, we're done here.
+        """)
 
     def test_parser_regression_special_character_in_parameter_column_of_docstring_first_line(self):
-        function = self.parse_function("""
-module os
-os.stat
-    path: str
-This/used to break Clinic!
-""")
-        self.assertEqual("stat($module, /, path)\n--\n\nThis/used to break Clinic!", function.docstring)
+        function = self.parse_function(dedent("""
+            module os
+            os.stat
+                path: str
+            This/used to break Clinic!
+        """))
+        self.checkDocstring(function, """
+            stat($module, /, path)
+            --
+
+            This/used to break Clinic!
+        """)
 
     def test_c_name(self):
-        function = self.parse_function("module os\nos.stat as os_stat_fn")
+        function = self.parse_function("""
+            module os
+            os.stat as os_stat_fn
+        """)
         self.assertEqual("os_stat_fn", function.c_basename)
 
     def test_return_converter(self):
-        function = self.parse_function("module os\nos.stat -> int")
+        function = self.parse_function("""
+            module os
+            os.stat -> int
+        """)
         self.assertIsInstance(function.return_converter, clinic.int_return_converter)
 
     def test_star(self):
-        function = self.parse_function("module os\nos.access\n    *\n    follow_symlinks: bool = True")
+        function = self.parse_function("""
+            module os
+            os.access
+                *
+                follow_symlinks: bool = True
+        """)
         p = function.parameters['follow_symlinks']
         self.assertEqual(inspect.Parameter.KEYWORD_ONLY, p.kind)
         self.assertEqual(0, p.group)
 
     def test_group(self):
-        function = self.parse_function("module window\nwindow.border\n [\n ls : int\n ]\n /\n")
+        function = self.parse_function("""
+            module window
+            window.border
+                [
+                ls: int
+                ]
+                /
+        """)
         p = function.parameters['ls']
         self.assertEqual(1, p.group)
 
     def test_left_group(self):
         function = self.parse_function("""
-module curses
-curses.addch
-   [
-   y: int
-     Y-coordinate.
-   x: int
-     X-coordinate.
-   ]
-   ch: char
-     Character to add.
-   [
-   attr: long
-     Attributes for the character.
-   ]
-   /
-""")
-        for name, group in (
+            module curses
+            curses.addch
+                [
+                y: int
+                    Y-coordinate.
+                x: int
+                    X-coordinate.
+                ]
+                ch: char
+                    Character to add.
+                [
+                attr: long
+                    Attributes for the character.
+                ]
+                /
+        """)
+        dataset = (
             ('y', -1), ('x', -1),
             ('ch', 0),
             ('attr', 1),
-            ):
-            p = function.parameters[name]
-            self.assertEqual(p.group, group)
-            self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
-        self.assertEqual(function.docstring.strip(), """
-addch([y, x,] ch, [attr])
-
-
-  y
-    Y-coordinate.
-  x
-    X-coordinate.
-  ch
-    Character to add.
-  attr
-    Attributes for the character.
-            """.strip())
+        )
+        for name, group in dataset:
+            with self.subTest(name=name, group=group):
+                p = function.parameters[name]
+                self.assertEqual(p.group, group)
+                self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
+        self.checkDocstring(function, """
+            addch([y, x,] ch, [attr])
+
+
+              y
+                Y-coordinate.
+              x
+                X-coordinate.
+              ch
+                Character to add.
+              attr
+                Attributes for the character.
+        """)
 
     def test_nested_groups(self):
         function = self.parse_function("""
-module curses
-curses.imaginary
-   [
-   [
-   y1: int
-     Y-coordinate.
-   y2: int
-     Y-coordinate.
-   ]
-   x1: int
-     X-coordinate.
-   x2: int
-     X-coordinate.
-   ]
-   ch: char
-     Character to add.
-   [
-   attr1: long
-     Attributes for the character.
-   attr2: long
-     Attributes for the character.
-   attr3: long
-     Attributes for the character.
-   [
-   attr4: long
-     Attributes for the character.
-   attr5: long
-     Attributes for the character.
-   attr6: long
-     Attributes for the character.
-   ]
-   ]
-   /
-""")
-        for name, group in (
+            module curses
+            curses.imaginary
+               [
+               [
+               y1: int
+                 Y-coordinate.
+               y2: int
+                 Y-coordinate.
+               ]
+               x1: int
+                 X-coordinate.
+               x2: int
+                 X-coordinate.
+               ]
+               ch: char
+                 Character to add.
+               [
+               attr1: long
+                 Attributes for the character.
+               attr2: long
+                 Attributes for the character.
+               attr3: long
+                 Attributes for the character.
+               [
+               attr4: long
+                 Attributes for the character.
+               attr5: long
+                 Attributes for the character.
+               attr6: long
+                 Attributes for the character.
+               ]
+               ]
+               /
+        """)
+        dataset = (
             ('y1', -2), ('y2', -2),
             ('x1', -1), ('x2', -1),
             ('ch', 0),
             ('attr1', 1), ('attr2', 1), ('attr3', 1),
             ('attr4', 2), ('attr5', 2), ('attr6', 2),
-            ):
-            p = function.parameters[name]
-            self.assertEqual(p.group, group)
-            self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
-
-        self.assertEqual(function.docstring.strip(), """
-imaginary([[y1, y2,] x1, x2,] ch, [attr1, attr2, attr3, [attr4, attr5,
-          attr6]])
-
-
-  y1
-    Y-coordinate.
-  y2
-    Y-coordinate.
-  x1
-    X-coordinate.
-  x2
-    X-coordinate.
-  ch
-    Character to add.
-  attr1
-    Attributes for the character.
-  attr2
-    Attributes for the character.
-  attr3
-    Attributes for the character.
-  attr4
-    Attributes for the character.
-  attr5
-    Attributes for the character.
-  attr6
-    Attributes for the character.
-                """.strip())
+        )
+        for name, group in dataset:
+            with self.subTest(name=name, group=group):
+                p = function.parameters[name]
+                self.assertEqual(p.group, group)
+                self.assertEqual(p.kind, inspect.Parameter.POSITIONAL_ONLY)
+
+        self.checkDocstring(function, """
+            imaginary([[y1, y2,] x1, x2,] ch, [attr1, attr2, attr3, [attr4, attr5,
+                      attr6]])
+
+
+              y1
+                Y-coordinate.
+              y2
+                Y-coordinate.
+              x1
+                X-coordinate.
+              x2
+                X-coordinate.
+              ch
+                Character to add.
+              attr1
+                Attributes for the character.
+              attr2
+                Attributes for the character.
+              attr3
+                Attributes for the character.
+              attr4
+                Attributes for the character.
+              attr5
+                Attributes for the character.
+              attr6
+                Attributes for the character.
+        """)
 
     def parse_function_should_fail(self, s):
         with support.captured_stdout() as stdout:
@@ -546,218 +849,295 @@ imaginary([[y1, y2,] x1, x2,] ch, [attr1
         return stdout.getvalue()
 
     def test_disallowed_grouping__two_top_groups_on_left(self):
-        s = self.parse_function_should_fail("""
-module foo
-foo.two_top_groups_on_left
-    [
-    group1 : int
-    ]
-    [
-    group2 : int
-    ]
-    param: int
-            """)
-        self.assertEqual(s,
-            ('Error on line 0:\n'
-            'Function two_top_groups_on_left has an unsupported group configuration. (Unexpected state 2.b)\n'))
+        expected_msg = (
+            'Error on line 0:\n'
+            'Function two_top_groups_on_left has an unsupported group '
+            'configuration. (Unexpected state 2.b)\n'
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.two_top_groups_on_left
+                [
+                group1 : int
+                ]
+                [
+                group2 : int
+                ]
+                param: int
+        """)
+        self.assertEqual(out, expected_msg)
 
     def test_disallowed_grouping__two_top_groups_on_right(self):
-        self.parse_function_should_fail("""
-module foo
-foo.two_top_groups_on_right
-    param: int
-    [
-    group1 : int
-    ]
-    [
-    group2 : int
-    ]
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.two_top_groups_on_right
+                param: int
+                [
+                group1 : int
+                ]
+                [
+                group2 : int
+                ]
+        """)
+        msg = (
+            "Function two_top_groups_on_right has an unsupported group "
+            "configuration. (Unexpected state 6.b)"
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__parameter_after_group_on_right(self):
-        self.parse_function_should_fail("""
-module foo
-foo.parameter_after_group_on_right
-    param: int
-    [
-    [
-    group1 : int
-    ]
-    group2 : int
-    ]
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.parameter_after_group_on_right
+                param: int
+                [
+                [
+                group1 : int
+                ]
+                group2 : int
+                ]
+        """)
+        msg = (
+            "Function parameter_after_group_on_right has an unsupported group "
+            "configuration. (Unexpected state 6.a)"
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__group_after_parameter_on_left(self):
-        self.parse_function_should_fail("""
-module foo
-foo.group_after_parameter_on_left
-    [
-    group2 : int
-    [
-    group1 : int
-    ]
-    ]
-    param: int
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.group_after_parameter_on_left
+                [
+                group2 : int
+                [
+                group1 : int
+                ]
+                ]
+                param: int
+        """)
+        msg = (
+            "Function group_after_parameter_on_left has an unsupported group "
+            "configuration. (Unexpected state 2.b)"
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__empty_group_on_left(self):
-        self.parse_function_should_fail("""
-module foo
-foo.empty_group
-    [
-    [
-    ]
-    group2 : int
-    ]
-    param: int
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.empty_group
+                [
+                [
+                ]
+                group2 : int
+                ]
+                param: int
+        """)
+        msg = (
+            "Function empty_group has an empty group.\n"
+            "All groups must contain at least one parameter."
+        )
+        self.assertIn(msg, out)
 
     def test_disallowed_grouping__empty_group_on_right(self):
-        self.parse_function_should_fail("""
-module foo
-foo.empty_group
-    param: int
-    [
-    [
-    ]
-    group2 : int
-    ]
-            """)
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.empty_group
+                param: int
+                [
+                [
+                ]
+                group2 : int
+                ]
+        """)
+        msg = (
+            "Function empty_group has an empty group.\n"
+            "All groups must contain at least one parameter."
+        )
+        self.assertIn(msg, out)
+
+    def test_disallowed_grouping__no_matching_bracket(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.empty_group
+                param: int
+                ]
+                group2: int
+                ]
+        """)
+        msg = "Function empty_group has a ] without a matching [."
+        self.assertIn(msg, out)
 
     def test_no_parameters(self):
         function = self.parse_function("""
-module foo
-foo.bar
+            module foo
+            foo.bar
 
-Docstring
+            Docstring
 
-""")
+        """)
         self.assertEqual("bar($module, /)\n--\n\nDocstring", function.docstring)
         self.assertEqual(1, len(function.parameters)) # self!
 
     def test_init_with_no_parameters(self):
         function = self.parse_function("""
-module foo
-class foo.Bar "unused" "notneeded"
-foo.Bar.__init__
+            module foo
+            class foo.Bar "unused" "notneeded"
+            foo.Bar.__init__
+
+            Docstring
 
-Docstring
+        """, signatures_in_block=3, function_index=2)
 
-""", signatures_in_block=3, function_index=2)
         # self is not in the signature
         self.assertEqual("Bar()\n--\n\nDocstring", function.docstring)
         # but it *is* a parameter
         self.assertEqual(1, len(function.parameters))
 
     def test_illegal_module_line(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar => int
-    /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar => int
+                /
+        """)
+        msg = "Illegal function name: foo.bar => int"
+        self.assertIn(msg, out)
 
     def test_illegal_c_basename(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar as 935
-    /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar as 935
+                /
+        """)
+        msg = "Illegal C basename: 935"
+        self.assertIn(msg, out)
 
     def test_single_star(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    *
-    *
-""")
-
-    def test_parameters_required_after_star_without_initial_parameters_or_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    *
-""")
-
-    def test_parameters_required_after_star_without_initial_parameters_with_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    *
-Docstring here.
-""")
-
-    def test_parameters_required_after_star_with_initial_parameters_without_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    this: int
-    *
-""")
-
-    def test_parameters_required_after_star_with_initial_parameters_and_docstring(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    this: int
-    *
-Docstring.
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                *
+                *
+        """)
+        self.assertIn("Function bar uses '*' more than once.", out)
+
+    def test_parameters_required_after_star(self):
+        dataset = (
+            "module foo\nfoo.bar\n  *",
+            "module foo\nfoo.bar\n  *\nDocstring here.",
+            "module foo\nfoo.bar\n  this: int\n  *",
+            "module foo\nfoo.bar\n  this: int\n  *\nDocstring.",
+        )
+        msg = "Function bar specifies '*' without any parameters afterwards."
+        for block in dataset:
+            with self.subTest(block=block):
+                out = self.parse_function_should_fail(block)
+                self.assertIn(msg, out)
 
     def test_single_slash(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    /
-    /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                /
+                /
+        """)
+        msg = (
+            "Function bar has an unsupported group configuration. "
+            "(Unexpected state 0.d)"
+        )
+        self.assertIn(msg, out)
+
+    def test_double_slash(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                a: int
+                /
+                b: int
+                /
+        """)
+        msg = "Function bar uses '/' more than once."
+        self.assertIn(msg, out)
 
     def test_mix_star_and_slash(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-   x: int
-   y: int
-   *
-   z: int
-   /
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+               x: int
+               y: int
+               *
+               z: int
+               /
+        """)
+        msg = (
+            "Function bar mixes keyword-only and positional-only parameters, "
+            "which is unsupported."
+        )
+        self.assertIn(msg, out)
 
     def test_parameters_not_permitted_after_slash_for_now(self):
-        self.parse_function_should_fail("""
-module foo
-foo.bar
-    /
-    x: int
-""")
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+                /
+                x: int
+        """)
+        msg = (
+            "Function bar has an unsupported group configuration. "
+            "(Unexpected state 0.d)"
+        )
+        self.assertIn(msg, out)
 
     def test_parameters_no_more_than_one_vararg(self):
-        s = self.parse_function_should_fail("""
-module foo
-foo.bar
-   *vararg1: object
-   *vararg2: object
-""")
-        self.assertEqual(s, "Error on line 0:\nToo many var args\n")
+        expected_msg = (
+            "Error on line 0:\n"
+            "Too many var args\n"
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+               *vararg1: object
+               *vararg2: object
+        """)
+        self.assertEqual(out, expected_msg)
 
     def test_function_not_at_column_0(self):
         function = self.parse_function("""
-  module foo
-  foo.bar
-    x: int
-      Nested docstring here, goeth.
-    *
-    y: str
-  Not at column 0!
-""")
-        self.assertEqual("""
-bar($module, /, x, *, y)
---
-
-Not at column 0!
-
-  x
-    Nested docstring here, goeth.
-""".strip(), function.docstring)
+              module foo
+              foo.bar
+                x: int
+                  Nested docstring here, goeth.
+                *
+                y: str
+              Not at column 0!
+        """)
+        self.checkDocstring(function, """
+            bar($module, /, x, *, y)
+            --
+
+            Not at column 0!
+
+              x
+                Nested docstring here, goeth.
+        """)
+
+    def test_indent_stack_no_tabs(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+               *vararg1: object
+            \t*vararg2: object
+        """)
+        msg = "Tab characters are illegal in the Clinic DSL."
+        self.assertIn(msg, out)
+
+    def test_indent_stack_illegal_outdent(self):
+        out = self.parse_function_should_fail("""
+            module foo
+            foo.bar
+              a: object
+             b: object
+        """)
+        self.assertIn("Illegal outdent", out)
 
     def test_directive(self):
         c = FakeClinic()
@@ -771,46 +1151,133 @@ Not at column 0!
     def test_legacy_converters(self):
         block = self.parse('module os\nos.access\n   path: "s"')
         module, function = block.signatures
-        self.assertIsInstance((function.parameters['path']).converter, clinic.str_converter)
+        conv = (function.parameters['path']).converter
+        self.assertIsInstance(conv, clinic.str_converter)
 
     def test_legacy_converters_non_string_constant_annotation(self):
-        expected_failure_message = """\
-Error on line 0:
-Annotations must be either a name, a function call, or a string.
-"""
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: 42')
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: 42.42')
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: 42j')
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail('module os\nos.access\n   path: b"42"')
-        self.assertEqual(s, expected_failure_message)
+        expected_failure_message = (
+            "Error on line 0:\n"
+            "Annotations must be either a name, a function call, or a string.\n"
+        )
+        dataset = (
+            'module os\nos.access\n   path: 42',
+            'module os\nos.access\n   path: 42.42',
+            'module os\nos.access\n   path: 42j',
+            'module os\nos.access\n   path: b"42"',
+        )
+        for block in dataset:
+            with self.subTest(block=block):
+                out = self.parse_function_should_fail(block)
+                self.assertEqual(out, expected_failure_message)
 
     def test_other_bizarre_things_in_annotations_fail(self):
-        expected_failure_message = """\
-Error on line 0:
-Annotations must be either a name, a function call, or a string.
-"""
-
-        s = self.parse_function_should_fail(
-            'module os\nos.access\n   path: {"some": "dictionary"}'
+        expected_failure_message = (
+            "Error on line 0:\n"
+            "Annotations must be either a name, a function call, or a string.\n"
         )
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail(
-            'module os\nos.access\n   path: ["list", "of", "strings"]'
+        dataset = (
+            'module os\nos.access\n   path: {"some": "dictionary"}',
+            'module os\nos.access\n   path: ["list", "of", "strings"]',
+            'module os\nos.access\n   path: (x for x in range(42))',
         )
-        self.assertEqual(s, expected_failure_message)
-
-        s = self.parse_function_should_fail(
-            'module os\nos.access\n   path: (x for x in range(42))'
+        for block in dataset:
+            with self.subTest(block=block):
+                out = self.parse_function_should_fail(block)
+                self.assertEqual(out, expected_failure_message)
+
+    def test_self_param_placement(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'self' parameter, if specified, must be the very first thing "
+            "in the parameter block.\n"
+        )
+        block = """
+            module foo
+            foo.func
+                a: int
+                self: self(type="PyObject *")
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_self_param_cannot_be_optional(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'self' parameter cannot be marked optional.\n"
         )
-        self.assertEqual(s, expected_failure_message)
+        block = """
+            module foo
+            foo.func
+                self: self(type="PyObject *") = None
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_defining_class_param_placement(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'defining_class' parameter, if specified, must either be the "
+            "first thing in the parameter block, or come just after 'self'.\n"
+        )
+        block = """
+            module foo
+            foo.func
+                self: self(type="PyObject *")
+                a: int
+                cls: defining_class
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_defining_class_param_cannot_be_optional(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "A 'defining_class' parameter cannot be marked optional.\n"
+        )
+        block = """
+            module foo
+            foo.func
+                cls: defining_class(type="PyObject *") = None
+        """
+        out = self.parse_function_should_fail(block)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_slot_methods_cannot_access_defining_class(self):
+        block = """
+            module foo
+            class Foo "" ""
+            Foo.__init__
+                cls: defining_class
+                a: object
+        """
+        msg = "Slot methods cannot access their defining class."
+        with self.assertRaisesRegex(ValueError, msg):
+            self.parse_function(block)
+
+    def test_new_must_be_a_class_method(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "__new__ must be a class method!\n"
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            class Foo "" ""
+            Foo.__new__
+        """)
+        self.assertEqual(out, expected_error_msg)
+
+    def test_init_must_be_a_normal_method(self):
+        expected_error_msg = (
+            "Error on line 0:\n"
+            "__init__ must be a normal method, not a class or static method!\n"
+        )
+        out = self.parse_function_should_fail("""
+            module foo
+            class Foo "" ""
+            @classmethod
+            Foo.__init__
+        """)
+        self.assertEqual(out, expected_error_msg)
 
     def parse(self, text):
         c = FakeClinic()
@@ -833,39 +1300,278 @@ Annotations must be either a name, a fun
         self.assertEqual(repr(clinic.NULL), '<Null>')
 
         # test that fail fails
+        expected = (
+            'Error in file "clown.txt" on line 69:\n'
+            'The igloos are melting!\n'
+        )
         with support.captured_stdout() as stdout:
             with self.assertRaises(SystemExit):
-                clinic.fail('The igloos are melting!', filename='clown.txt', line_number=69)
-        self.assertEqual(stdout.getvalue(), 'Error in file "clown.txt" on line 69:\nThe igloos are melting!\n')
+                clinic.fail('The igloos are melting!',
+                            filename='clown.txt', line_number=69)
+        actual = stdout.getvalue()
+        self.assertEqual(actual, expected)
 
 
 class ClinicExternalTest(TestCase):
     maxDiff = None
+    clinic_py = os.path.join(test_tools.toolsdir, "clinic", "clinic.py")
+
+    def _do_test(self, *args, expect_success=True):
+        with subprocess.Popen(
+            [sys.executable, "-Xutf8", self.clinic_py, *args],
+            encoding="utf-8",
+            bufsize=0,
+            stdout=subprocess.PIPE,
+            stderr=subprocess.PIPE,
+        ) as proc:
+            proc.wait()
+            if expect_success and proc.returncode:
+                self.fail("".join([*proc.stdout, *proc.stderr]))
+            stdout = proc.stdout.read()
+            stderr = proc.stderr.read()
+            # Clinic never writes to stderr.
+            self.assertEqual(stderr, "")
+            return stdout
+
+    def expect_success(self, *args):
+        return self._do_test(*args)
+
+    def expect_failure(self, *args):
+        return self._do_test(*args, expect_success=False)
 
     def test_external(self):
-        # bpo-42398: Test that the destination file is left unchanged if the
-        # content does not change. Moreover, check also that the file
-        # modification time does not change in this case.
-        source = support.findfile('clinic.test')
+        CLINIC_TEST = 'clinic.test.c'
+        source = support.findfile(CLINIC_TEST)
         with open(source, 'r', encoding='utf-8') as f:
             orig_contents = f.read()
 
-        with os_helper.temp_dir() as tmp_dir:
-            testfile = os.path.join(tmp_dir, 'clinic.test.c')
-            with open(testfile, 'w', encoding='utf-8') as f:
-                f.write(orig_contents)
-            old_mtime_ns = os.stat(testfile).st_mtime_ns
-
-            clinic.parse_file(testfile)
-
-            with open(testfile, 'r', encoding='utf-8') as f:
-                new_contents = f.read()
-            new_mtime_ns = os.stat(testfile).st_mtime_ns
+        # Run clinic CLI and verify that it does not complain.
+        self.addCleanup(unlink, TESTFN)
+        out = self.expect_success("-f", "-o", TESTFN, source)
+        self.assertEqual(out, "")
+
+        with open(TESTFN, 'r', encoding='utf-8') as f:
+            new_contents = f.read()
 
         self.assertEqual(new_contents, orig_contents)
+
+    def test_no_change(self):
+        # bpo-42398: Test that the destination file is left unchanged if the
+        # content does not change. Moreover, check also that the file
+        # modification time does not change in this case.
+        code = dedent("""
+            /*[clinic input]
+            [clinic start generated code]*/
+            /*[clinic end generated code: output=da39a3ee5e6b4b0d input=da39a3ee5e6b4b0d]*/
+        """)
+        with os_helper.temp_dir() as tmp_dir:
+            fn = os.path.join(tmp_dir, "test.c")
+            with open(fn, "w", encoding="utf-8") as f:
+                f.write(code)
+            pre_mtime = os.stat(fn).st_mtime_ns
+            self.expect_success(fn)
+            post_mtime = os.stat(fn).st_mtime_ns
         # Don't change the file modification time
         # if the content does not change
-        self.assertEqual(new_mtime_ns, old_mtime_ns)
+        self.assertEqual(pre_mtime, post_mtime)
+
+    def test_cli_force(self):
+        invalid_input = dedent("""
+            /*[clinic input]
+            output preset block
+            module test
+            test.fn
+                a: int
+            [clinic start generated code]*/
+
+            const char *hand_edited = "output block is overwritten";
+            /*[clinic end generated code: output=bogus input=bogus]*/
+        """)
+        fail_msg = dedent("""
+            Checksum mismatch!
+            Expected: bogus
+            Computed: 2ed19
+            Suggested fix: remove all generated code including the end marker,
+            or use the '-f' option.
+        """)
+        with os_helper.temp_dir() as tmp_dir:
+            fn = os.path.join(tmp_dir, "test.c")
+            with open(fn, "w", encoding="utf-8") as f:
+                f.write(invalid_input)
+            # First, run the CLI without -f and expect failure.
+            # Note, we cannot check the entire fail msg, because the path to
+            # the tmp file will change for every run.
+            out = self.expect_failure(fn)
+            self.assertTrue(out.endswith(fail_msg))
+            # Then, force regeneration; success expected.
+            out = self.expect_success("-f", fn)
+            self.assertEqual(out, "")
+            # Verify by checking the checksum.
+            checksum = (
+                "/*[clinic end generated code: "
+                "output=6c2289b73f32bc19 input=9543a8d2da235301]*/\n"
+            )
+            with open(fn, 'r', encoding='utf-8') as f:
+                generated = f.read()
+            self.assertTrue(generated.endswith(checksum))
+
+    def test_cli_make(self):
+        c_code = dedent("""
+            /*[clinic input]
+            [clinic start generated code]*/
+        """)
+        py_code = "pass"
+        c_files = "file1.c", "file2.c"
+        py_files = "file1.py", "file2.py"
+
+        def create_files(files, srcdir, code):
+            for fn in files:
+                path = os.path.join(srcdir, fn)
+                with open(path, "w", encoding="utf-8") as f:
+                    f.write(code)
+
+        with os_helper.temp_dir() as tmp_dir:
+            # add some folders, some C files and a Python file
+            create_files(c_files, tmp_dir, c_code)
+            create_files(py_files, tmp_dir, py_code)
+
+            # create C files in externals/ dir
+            ext_path = os.path.join(tmp_dir, "externals")
+            with os_helper.temp_dir(path=ext_path) as externals:
+                create_files(c_files, externals, c_code)
+
+                # run clinic in verbose mode with --make on tmpdir
+                out = self.expect_success("-v", "--make", "--srcdir", tmp_dir)
+
+            # expect verbose mode to only mention the C files in tmp_dir
+            for filename in c_files:
+                with self.subTest(filename=filename):
+                    path = os.path.join(tmp_dir, filename)
+                    self.assertIn(path, out)
+            for filename in py_files:
+                with self.subTest(filename=filename):
+                    path = os.path.join(tmp_dir, filename)
+                    self.assertNotIn(path, out)
+            # don't expect C files from the externals dir
+            for filename in c_files:
+                with self.subTest(filename=filename):
+                    path = os.path.join(ext_path, filename)
+                    self.assertNotIn(path, out)
+
+    def test_cli_verbose(self):
+        with os_helper.temp_dir() as tmp_dir:
+            fn = os.path.join(tmp_dir, "test.c")
+            with open(fn, "w", encoding="utf-8") as f:
+                f.write("")
+            out = self.expect_success("-v", fn)
+            self.assertEqual(out.strip(), fn)
+
+    def test_cli_help(self):
+        out = self.expect_success("-h")
+        self.assertIn("usage: clinic.py", out)
+
+    def test_cli_converters(self):
+        prelude = dedent("""
+            Legacy converters:
+                B C D L O S U Y Z Z#
+                b c d f h i l p s s# s* u u# w* y y# y* z z# z*
+
+            Converters:
+        """)
+        expected_converters = (
+            "bool",
+            "byte",
+            "char",
+            "defining_class",
+            "double",
+            "fildes",
+            "float",
+            "int",
+            "long",
+            "long_long",
+            "object",
+            "Py_buffer",
+            "Py_complex",
+            "Py_ssize_t",
+            "Py_UNICODE",
+            "PyByteArrayObject",
+            "PyBytesObject",
+            "self",
+            "short",
+            "size_t",
+            "slice_index",
+            "str",
+            "unicode",
+            "unsigned_char",
+            "unsigned_int",
+            "unsigned_long",
+            "unsigned_long_long",
+            "unsigned_short",
+        )
+        finale = dedent("""
+            Return converters:
+                bool()
+                double()
+                float()
+                init()
+                int()
+                long()
+                NoneType()
+                Py_ssize_t()
+                size_t()
+                unsigned_int()
+                unsigned_long()
+
+            All converters also accept (c_default=None, py_default=None, annotation=None).
+            All return converters also accept (py_default=None).
+        """)
+        out = self.expect_success("--converters")
+        # We cannot simply compare the output, because the repr of the *accept*
+        # param may change (it's a set, thus unordered). So, let's compare the
+        # start and end of the expected output, and then assert that the
+        # converters appear lined up in alphabetical order.
+        self.assertTrue(out.startswith(prelude), out)
+        self.assertTrue(out.endswith(finale), out)
+
+        out = out.removeprefix(prelude)
+        out = out.removesuffix(finale)
+        lines = out.split("\n")
+        for converter, line in zip(expected_converters, lines):
+            line = line.lstrip()
+            with self.subTest(converter=converter):
+                self.assertTrue(
+                    line.startswith(converter),
+                    f"expected converter {converter!r}, got {line!r}"
+                )
+
+    def test_cli_fail_converters_and_filename(self):
+        out = self.expect_failure("--converters", "test.c")
+        msg = (
+            "Usage error: can't specify --converters "
+            "and a filename at the same time"
+        )
+        self.assertIn(msg, out)
+
+    def test_cli_fail_no_filename(self):
+        out = self.expect_failure()
+        self.assertIn("usage: clinic.py", out)
+
+    def test_cli_fail_output_and_multiple_files(self):
+        out = self.expect_failure("-o", "out.c", "input.c", "moreinput.c")
+        msg = "Usage error: can't use -o with multiple filenames"
+        self.assertIn(msg, out)
+
+    def test_cli_fail_filename_or_output_and_make(self):
+        for opts in ("-o", "out.c"), ("filename.c",):
+            with self.subTest(opts=opts):
+                out = self.expect_failure("--make", *opts)
+                msg = "Usage error: can't use -o or filenames with --make"
+                self.assertIn(msg, out)
+
+    def test_cli_fail_make_without_srcdir(self):
+        out = self.expect_failure("--make", "--srcdir", "")
+        msg = "Usage error: --srcdir must not be empty with --make"
+        self.assertIn(msg, out)
 
 
 try:
@@ -1327,5 +2033,111 @@ class ClinicFunctionalTest(unittest.Test
             ac_tester.gh_99240_double_free('a', '\0b')
 
 
+class PermutationTests(unittest.TestCase):
+    """Test permutation support functions."""
+
+    def test_permute_left_option_groups(self):
+        expected = (
+            (),
+            (3,),
+            (2, 3),
+            (1, 2, 3),
+        )
+        data = list(zip([1, 2, 3]))  # Generate a list of 1-tuples.
+        actual = tuple(clinic.permute_left_option_groups(data))
+        self.assertEqual(actual, expected)
+
+    def test_permute_right_option_groups(self):
+        expected = (
+            (),
+            (1,),
+            (1, 2),
+            (1, 2, 3),
+        )
+        data = list(zip([1, 2, 3]))  # Generate a list of 1-tuples.
+        actual = tuple(clinic.permute_right_option_groups(data))
+        self.assertEqual(actual, expected)
+
+    def test_permute_optional_groups(self):
+        empty = {
+            "left": (), "required": (), "right": (),
+            "expected": ((),),
+        }
+        noleft1 = {
+            "left": (), "required": ("b",), "right": ("c",),
+            "expected": (
+                ("b",),
+                ("b", "c"),
+            ),
+        }
+        noleft2 = {
+            "left": (), "required": ("b", "c",), "right": ("d",),
+            "expected": (
+                ("b", "c"),
+                ("b", "c", "d"),
+            ),
+        }
+        noleft3 = {
+            "left": (), "required": ("b", "c",), "right": ("d", "e"),
+            "expected": (
+                ("b", "c"),
+                ("b", "c", "d"),
+                ("b", "c", "d", "e"),
+            ),
+        }
+        noright1 = {
+            "left": ("a",), "required": ("b",), "right": (),
+            "expected": (
+                ("b",),
+                ("a", "b"),
+            ),
+        }
+        noright2 = {
+            "left": ("a",), "required": ("b", "c"), "right": (),
+            "expected": (
+                ("b", "c"),
+                ("a", "b", "c"),
+            ),
+        }
+        noright3 = {
+            "left": ("a", "b"), "required": ("c",), "right": (),
+            "expected": (
+                ("c",),
+                ("b", "c"),
+                ("a", "b", "c"),
+            ),
+        }
+        leftandright1 = {
+            "left": ("a",), "required": ("b",), "right": ("c",),
+            "expected": (
+                ("b",),
+                ("a", "b"),  # Prefer left.
+                ("a", "b", "c"),
+            ),
+        }
+        leftandright2 = {
+            "left": ("a", "b"), "required": ("c", "d"), "right": ("e", "f"),
+            "expected": (
+                ("c", "d"),
+                ("b", "c", "d"),       # Prefer left.
+                ("a", "b", "c", "d"),  # Prefer left.
+                ("a", "b", "c", "d", "e"),
+                ("a", "b", "c", "d", "e", "f"),
+            ),
+        }
+        dataset = (
+            empty,
+            noleft1, noleft2, noleft3,
+            noright1, noright2, noright3,
+            leftandright1, leftandright2,
+        )
+        for params in dataset:
+            with self.subTest(**params):
+                left, required, right, expected = params.values()
+                permutations = clinic.permute_optional_groups(left, required, right)
+                actual = tuple(permutations)
+                self.assertEqual(actual, expected)
+
+
 if __name__ == "__main__":
     unittest.main()
--- a/Lib/test/test_cmd_line_script.py
+++ b/Lib/test/test_cmd_line_script.py
@@ -777,7 +777,7 @@ class CmdLineTest(unittest.TestCase):
         with os_helper.temp_dir() as work_dir:
             script_name = _make_test_script(work_dir, 'script.py', script)
             with open(script_name, "r") as fp:
-                p = spawn_python(f"/dev/fd/{fp.fileno()}", close_fds=False, pass_fds=(0,1,2,fp.fileno()))
+                p = spawn_python(f"/dev/fd/{fp.fileno()}", close_fds=True, pass_fds=(0,1,2,fp.fileno()))
                 out, err = p.communicate()
                 self.assertEqual(out, b"12345678912345678912345\n")
 
--- a/Lib/test/test_codecs.py
+++ b/Lib/test/test_codecs.py
@@ -2823,15 +2823,16 @@ class TransformCodecTest(unittest.TestCa
     def test_custom_zlib_error_is_wrapped(self):
         # Check zlib codec gives a good error for malformed input
         msg = "^decoding with 'zlib_codec' codec failed"
-        with self.assertRaisesRegex(Exception, msg) as failure:
+        with self.assertRaises(zlib.error) as failure:
             codecs.decode(b"hello", "zlib_codec")
         self.assertIsInstance(failure.exception.__cause__,
                                                 type(failure.exception))
 
     def test_custom_hex_error_is_wrapped(self):
         # Check hex codec gives a good error for malformed input
+        import binascii
         msg = "^decoding with 'hex_codec' codec failed"
-        with self.assertRaisesRegex(Exception, msg) as failure:
+        with self.assertRaises(binascii.Error) as failure:
             codecs.decode(b"hello", "hex_codec")
         self.assertIsInstance(failure.exception.__cause__,
                                                 type(failure.exception))
--- a/Lib/test/test_colorsys.py
+++ b/Lib/test/test_colorsys.py
@@ -69,6 +69,16 @@ class ColorsysTest(unittest.TestCase):
             self.assertTripleEqual(hls, colorsys.rgb_to_hls(*rgb))
             self.assertTripleEqual(rgb, colorsys.hls_to_rgb(*hls))
 
+    def test_hls_nearwhite(self):  # gh-106498
+        values = (
+            # rgb, hls: these do not work in reverse
+            ((0.9999999999999999, 1, 1), (0.5, 1.0, 1.0)),
+            ((1, 0.9999999999999999, 0.9999999999999999), (0.0, 1.0, 1.0)),
+        )
+        for rgb, hls in values:
+            self.assertTripleEqual(hls, colorsys.rgb_to_hls(*rgb))
+            self.assertTripleEqual((1.0, 1.0, 1.0), colorsys.hls_to_rgb(*hls))
+
     def test_yiq_roundtrip(self):
         for r in frange(0.0, 1.0, 0.2):
             for g in frange(0.0, 1.0, 0.2):
--- a/Lib/test/test_concurrent_futures.py
+++ b/Lib/test/test_concurrent_futures.py
@@ -1167,6 +1167,11 @@ def _crash(delay=None):
     faulthandler._sigsegv()
 
 
+def _crash_with_data(data):
+    """Induces a segfault with dummy data in input."""
+    _crash()
+
+
 def _exit():
     """Induces a sys exit with exitcode 1."""
     sys.exit(1)
@@ -1366,6 +1371,19 @@ class ExecutorDeadlockTest:
         # dangling threads
         executor_manager.join()
 
+    def test_crash_big_data(self):
+        # Test that there is a clean exception instad of a deadlock when a
+        # child process crashes while some data is being written into the
+        # queue.
+        # https://github.com/python/cpython/issues/94777
+        self.executor.shutdown(wait=True)
+        data = "a" * support.PIPE_MAX_SIZE
+        with self.executor_type(max_workers=2,
+                                mp_context=self.get_context()) as executor:
+            self.executor = executor  # Allow clean up in fail_on_deadlock
+            with self.assertRaises(BrokenProcessPool):
+                list(executor.map(_crash_with_data, [data] * 10))
+
 
 create_executor_tests(ExecutorDeadlockTest,
                       executor_mixins=(ProcessPoolForkMixin,
--- a/Lib/test/test_decimal.py
+++ b/Lib/test/test_decimal.py
@@ -20,7 +20,7 @@ Cowlishaw's tests can be downloaded from
 
 This test module can be called from command line with one parameter (Arithmetic
 or Behaviour) to test each part, or without parameter to test both parts. If
-you're working through IDLE, you can import this test module and call test_main()
+you're working through IDLE, you can import this test module and call test()
 with the corresponding argument.
 """
 
@@ -32,7 +32,7 @@ import pickle, copy
 import unittest
 import numbers
 import locale
-from test.support import (run_unittest, run_doctest, is_resource_enabled,
+from test.support import (is_resource_enabled,
                           requires_IEEE_754, requires_docstrings,
                           requires_legacy_unicode_capi, check_sanitizer)
 from test.support import (TestFailed,
@@ -62,6 +62,7 @@ sys.modules['decimal'] = C
 fractions = {C:cfractions, P:pfractions}
 sys.modules['decimal'] = orig_sys_decimal
 
+requires_cdecimal = unittest.skipUnless(C, "test requires C version")
 
 # Useful Test Constant
 Signals = {
@@ -99,7 +100,7 @@ RoundingModes = [
 ]
 
 # Tests are built around these assumed context defaults.
-# test_main() restores the original context.
+# test() restores the original context.
 ORIGINAL_CONTEXT = {
   C: C.getcontext().copy() if C else None,
   P: P.getcontext().copy()
@@ -133,7 +134,7 @@ skip_if_extra_functionality = unittest.s
   EXTRA_FUNCTIONALITY, "test requires regular build")
 
 
-class IBMTestCases(unittest.TestCase):
+class IBMTestCases:
     """Class which tests the Decimal class against the IBM test cases."""
 
     def setUp(self):
@@ -488,14 +489,10 @@ class IBMTestCases(unittest.TestCase):
     def change_clamp(self, clamp):
         self.context.clamp = clamp
 
-class CIBMTestCases(IBMTestCases):
-    decimal = C
-class PyIBMTestCases(IBMTestCases):
-    decimal = P
 
 # The following classes test the behaviour of Decimal according to PEP 327
 
-class ExplicitConstructionTest(unittest.TestCase):
+class ExplicitConstructionTest:
     '''Unit tests for Explicit Construction cases of Decimal.'''
 
     def test_explicit_empty(self):
@@ -838,12 +835,13 @@ class ExplicitConstructionTest(unittest.
         for input, expected in test_values.items():
             self.assertEqual(str(Decimal(input)), expected)
 
-class CExplicitConstructionTest(ExplicitConstructionTest):
+@requires_cdecimal
+class CExplicitConstructionTest(ExplicitConstructionTest, unittest.TestCase):
     decimal = C
-class PyExplicitConstructionTest(ExplicitConstructionTest):
+class PyExplicitConstructionTest(ExplicitConstructionTest, unittest.TestCase):
     decimal = P
 
-class ImplicitConstructionTest(unittest.TestCase):
+class ImplicitConstructionTest:
     '''Unit tests for Implicit Construction cases of Decimal.'''
 
     def test_implicit_from_None(self):
@@ -920,12 +918,13 @@ class ImplicitConstructionTest(unittest.
             self.assertEqual(eval('Decimal(10)' + sym + 'E()'),
                              '10' + rop + 'str')
 
-class CImplicitConstructionTest(ImplicitConstructionTest):
+@requires_cdecimal
+class CImplicitConstructionTest(ImplicitConstructionTest, unittest.TestCase):
     decimal = C
-class PyImplicitConstructionTest(ImplicitConstructionTest):
+class PyImplicitConstructionTest(ImplicitConstructionTest, unittest.TestCase):
     decimal = P
 
-class FormatTest(unittest.TestCase):
+class FormatTest:
     '''Unit tests for the format function.'''
     def test_formatting(self):
         Decimal = self.decimal.Decimal
@@ -1262,12 +1261,13 @@ class FormatTest(unittest.TestCase):
         a = A.from_float(42)
         self.assertEqual(self.decimal.Decimal, a.a_type)
 
-class CFormatTest(FormatTest):
+@requires_cdecimal
+class CFormatTest(FormatTest, unittest.TestCase):
     decimal = C
-class PyFormatTest(FormatTest):
+class PyFormatTest(FormatTest, unittest.TestCase):
     decimal = P
 
-class ArithmeticOperatorsTest(unittest.TestCase):
+class ArithmeticOperatorsTest:
     '''Unit tests for all arithmetic operators, binary and unary.'''
 
     def test_addition(self):
@@ -1523,14 +1523,17 @@ class ArithmeticOperatorsTest(unittest.T
         equality_ops = operator.eq, operator.ne
 
         # results when InvalidOperation is not trapped
-        for x, y in qnan_pairs + snan_pairs:
-            for op in order_ops + equality_ops:
-                got = op(x, y)
-                expected = True if op is operator.ne else False
-                self.assertIs(expected, got,
-                              "expected {0!r} for operator.{1}({2!r}, {3!r}); "
-                              "got {4!r}".format(
-                        expected, op.__name__, x, y, got))
+        with localcontext() as ctx:
+            ctx.traps[InvalidOperation] = 0
+
+            for x, y in qnan_pairs + snan_pairs:
+                for op in order_ops + equality_ops:
+                    got = op(x, y)
+                    expected = True if op is operator.ne else False
+                    self.assertIs(expected, got,
+                                "expected {0!r} for operator.{1}({2!r}, {3!r}); "
+                                "got {4!r}".format(
+                            expected, op.__name__, x, y, got))
 
         # repeat the above, but this time trap the InvalidOperation
         with localcontext() as ctx:
@@ -1562,9 +1565,10 @@ class ArithmeticOperatorsTest(unittest.T
         self.assertEqual(Decimal(1).copy_sign(-2), d)
         self.assertRaises(TypeError, Decimal(1).copy_sign, '-2')
 
-class CArithmeticOperatorsTest(ArithmeticOperatorsTest):
+@requires_cdecimal
+class CArithmeticOperatorsTest(ArithmeticOperatorsTest, unittest.TestCase):
     decimal = C
-class PyArithmeticOperatorsTest(ArithmeticOperatorsTest):
+class PyArithmeticOperatorsTest(ArithmeticOperatorsTest, unittest.TestCase):
     decimal = P
 
 # The following are two functions used to test threading in the next class
@@ -1654,7 +1658,7 @@ def thfunc2(cls):
 
 
 @threading_helper.requires_working_threading()
-class ThreadingTest(unittest.TestCase):
+class ThreadingTest:
     '''Unit tests for thread local contexts in Decimal.'''
 
     # Take care executing this test from IDLE, there's an issue in threading
@@ -1699,13 +1703,14 @@ class ThreadingTest(unittest.TestCase):
         DefaultContext.Emin = save_emin
 
 
-class CThreadingTest(ThreadingTest):
+@requires_cdecimal
+class CThreadingTest(ThreadingTest, unittest.TestCase):
     decimal = C
 
-class PyThreadingTest(ThreadingTest):
+class PyThreadingTest(ThreadingTest, unittest.TestCase):
     decimal = P
 
-class UsabilityTest(unittest.TestCase):
+class UsabilityTest:
     '''Unit tests for Usability cases of Decimal.'''
 
     def test_comparison_operators(self):
@@ -2521,9 +2526,10 @@ class UsabilityTest(unittest.TestCase):
         self.assertEqual(Decimal(-12).fma(45, Decimal(67)),
                          Decimal(-12).fma(Decimal(45), Decimal(67)))
 
-class CUsabilityTest(UsabilityTest):
+@requires_cdecimal
+class CUsabilityTest(UsabilityTest, unittest.TestCase):
     decimal = C
-class PyUsabilityTest(UsabilityTest):
+class PyUsabilityTest(UsabilityTest, unittest.TestCase):
     decimal = P
 
     def setUp(self):
@@ -2535,7 +2541,7 @@ class PyUsabilityTest(UsabilityTest):
         sys.set_int_max_str_digits(self._previous_int_limit)
         super().tearDown()
 
-class PythonAPItests(unittest.TestCase):
+class PythonAPItests:
 
     def test_abc(self):
         Decimal = self.decimal.Decimal
@@ -2884,12 +2890,13 @@ class PythonAPItests(unittest.TestCase):
         self.assertTrue(issubclass(decimal.DivisionUndefined, ZeroDivisionError))
         self.assertTrue(issubclass(decimal.InvalidContext, InvalidOperation))
 
-class CPythonAPItests(PythonAPItests):
+@requires_cdecimal
+class CPythonAPItests(PythonAPItests, unittest.TestCase):
     decimal = C
-class PyPythonAPItests(PythonAPItests):
+class PyPythonAPItests(PythonAPItests, unittest.TestCase):
     decimal = P
 
-class ContextAPItests(unittest.TestCase):
+class ContextAPItests:
 
     def test_none_args(self):
         Context = self.decimal.Context
@@ -3635,12 +3642,13 @@ class ContextAPItests(unittest.TestCase)
         self.assertRaises(TypeError, c.to_integral_value, '10')
         self.assertRaises(TypeError, c.to_integral_value, 10, 'x')
 
-class CContextAPItests(ContextAPItests):
+@requires_cdecimal
+class CContextAPItests(ContextAPItests, unittest.TestCase):
     decimal = C
-class PyContextAPItests(ContextAPItests):
+class PyContextAPItests(ContextAPItests, unittest.TestCase):
     decimal = P
 
-class ContextWithStatement(unittest.TestCase):
+class ContextWithStatement:
     # Can't do these as docstrings until Python 2.6
     # as doctest can't handle __future__ statements
 
@@ -3704,9 +3712,13 @@ class ContextWithStatement(unittest.Test
 
     def test_local_context_kwargs_does_not_overwrite_existing_argument(self):
         ctx = self.decimal.getcontext()
-        ctx.prec = 28
+        orig_prec = ctx.prec
         with self.decimal.localcontext(prec=10) as ctx2:
-            self.assertEqual(ctx.prec, 28)
+            self.assertEqual(ctx2.prec, 10)
+            self.assertEqual(ctx.prec, orig_prec)
+        with self.decimal.localcontext(prec=20) as ctx2:
+            self.assertEqual(ctx2.prec, 20)
+            self.assertEqual(ctx.prec, orig_prec)
 
     def test_nested_with_statements(self):
         # Use a copy of the supplied context in the block
@@ -3800,12 +3812,13 @@ class ContextWithStatement(unittest.Test
                         self.assertEqual(c4.prec, 4)
                         del c4
 
-class CContextWithStatement(ContextWithStatement):
+@requires_cdecimal
+class CContextWithStatement(ContextWithStatement, unittest.TestCase):
     decimal = C
-class PyContextWithStatement(ContextWithStatement):
+class PyContextWithStatement(ContextWithStatement, unittest.TestCase):
     decimal = P
 
-class ContextFlags(unittest.TestCase):
+class ContextFlags:
 
     def test_flags_irrelevant(self):
         # check that the result (numeric result + flags raised) of an
@@ -4072,12 +4085,13 @@ class ContextFlags(unittest.TestCase):
         self.assertTrue(context.traps[FloatOperation])
         self.assertTrue(context.traps[Inexact])
 
-class CContextFlags(ContextFlags):
+@requires_cdecimal
+class CContextFlags(ContextFlags, unittest.TestCase):
     decimal = C
-class PyContextFlags(ContextFlags):
+class PyContextFlags(ContextFlags, unittest.TestCase):
     decimal = P
 
-class SpecialContexts(unittest.TestCase):
+class SpecialContexts:
     """Test the context templates."""
 
     def test_context_templates(self):
@@ -4157,12 +4171,13 @@ class SpecialContexts(unittest.TestCase)
             if ex:
                 raise ex
 
-class CSpecialContexts(SpecialContexts):
+@requires_cdecimal
+class CSpecialContexts(SpecialContexts, unittest.TestCase):
     decimal = C
-class PySpecialContexts(SpecialContexts):
+class PySpecialContexts(SpecialContexts, unittest.TestCase):
     decimal = P
 
-class ContextInputValidation(unittest.TestCase):
+class ContextInputValidation:
 
     def test_invalid_context(self):
         Context = self.decimal.Context
@@ -4224,12 +4239,13 @@ class ContextInputValidation(unittest.Te
         self.assertRaises(TypeError, Context, flags=(0,1))
         self.assertRaises(TypeError, Context, traps=(1,0))
 
-class CContextInputValidation(ContextInputValidation):
+@requires_cdecimal
+class CContextInputValidation(ContextInputValidation, unittest.TestCase):
     decimal = C
-class PyContextInputValidation(ContextInputValidation):
+class PyContextInputValidation(ContextInputValidation, unittest.TestCase):
     decimal = P
 
-class ContextSubclassing(unittest.TestCase):
+class ContextSubclassing:
 
     def test_context_subclassing(self):
         decimal = self.decimal
@@ -4338,12 +4354,14 @@ class ContextSubclassing(unittest.TestCa
         for signal in OrderedSignals[decimal]:
             self.assertFalse(c.traps[signal])
 
-class CContextSubclassing(ContextSubclassing):
+@requires_cdecimal
+class CContextSubclassing(ContextSubclassing, unittest.TestCase):
     decimal = C
-class PyContextSubclassing(ContextSubclassing):
+class PyContextSubclassing(ContextSubclassing, unittest.TestCase):
     decimal = P
 
 @skip_if_extra_functionality
+@requires_cdecimal
 class CheckAttributes(unittest.TestCase):
 
     def test_module_attributes(self):
@@ -4373,7 +4391,7 @@ class CheckAttributes(unittest.TestCase)
         y = [s for s in dir(C.Decimal(9)) if '__' in s or not s.startswith('_')]
         self.assertEqual(set(x) - set(y), set())
 
-class Coverage(unittest.TestCase):
+class Coverage:
 
     def test_adjusted(self):
         Decimal = self.decimal.Decimal
@@ -4630,9 +4648,10 @@ class Coverage(unittest.TestCase):
         y = c.copy_sign(x, 1)
         self.assertEqual(y, -x)
 
-class CCoverage(Coverage):
+@requires_cdecimal
+class CCoverage(Coverage, unittest.TestCase):
     decimal = C
-class PyCoverage(Coverage):
+class PyCoverage(Coverage, unittest.TestCase):
     decimal = P
 
     def setUp(self):
@@ -4885,6 +4904,7 @@ class CFunctionality(unittest.TestCase):
         self.assertEqual(C.DecTraps,
                          C.DecErrors|C.DecOverflow|C.DecUnderflow)
 
+@requires_cdecimal
 class CWhitebox(unittest.TestCase):
     """Whitebox testing for _decimal"""
 
@@ -5662,8 +5682,38 @@ class CWhitebox(unittest.TestCase):
             self.assertEqual(Decimal(400) ** -1, Decimal('0.0025'))
 
 
+    def test_c_signaldict_segfault(self):
+        # See gh-106263 for details.
+        SignalDict = type(C.Context().flags)
+        sd = SignalDict()
+        err_msg = "invalid signal dict"
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            len(sd)
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            iter(sd)
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            repr(sd)
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd[C.InvalidOperation] = True
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd[C.InvalidOperation]
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd == C.Context().flags
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            C.Context().flags == sd
+
+        with self.assertRaisesRegex(ValueError, err_msg):
+            sd.copy()
+
 @requires_docstrings
-@unittest.skipUnless(C, "test requires C version")
+@requires_cdecimal
 class SignatureTest(unittest.TestCase):
     """Function signatures"""
 
@@ -5799,52 +5849,10 @@ class SignatureTest(unittest.TestCase):
         doit('Context')
 
 
-all_tests = [
-  CExplicitConstructionTest, PyExplicitConstructionTest,
-  CImplicitConstructionTest, PyImplicitConstructionTest,
-  CFormatTest,               PyFormatTest,
-  CArithmeticOperatorsTest,  PyArithmeticOperatorsTest,
-  CThreadingTest,            PyThreadingTest,
-  CUsabilityTest,            PyUsabilityTest,
-  CPythonAPItests,           PyPythonAPItests,
-  CContextAPItests,          PyContextAPItests,
-  CContextWithStatement,     PyContextWithStatement,
-  CContextFlags,             PyContextFlags,
-  CSpecialContexts,          PySpecialContexts,
-  CContextInputValidation,   PyContextInputValidation,
-  CContextSubclassing,       PyContextSubclassing,
-  CCoverage,                 PyCoverage,
-  CFunctionality,            PyFunctionality,
-  CWhitebox,                 PyWhitebox,
-  CIBMTestCases,             PyIBMTestCases,
-]
-
-# Delete C tests if _decimal.so is not present.
-if not C:
-    all_tests = all_tests[1::2]
-else:
-    all_tests.insert(0, CheckAttributes)
-    all_tests.insert(1, SignatureTest)
-
-
-def test_main(arith=None, verbose=None, todo_tests=None, debug=None):
-    """ Execute the tests.
-
-    Runs all arithmetic tests if arith is True or if the "decimal" resource
-    is enabled in regrtest.py
-    """
-
-    init(C)
-    init(P)
-    global TEST_ALL, DEBUG
-    TEST_ALL = arith if arith is not None else is_resource_enabled('decimal')
-    DEBUG = debug
-
-    if todo_tests is None:
-        test_classes = all_tests
-    else:
-        test_classes = [CIBMTestCases, PyIBMTestCases]
-
+def load_tests(loader, tests, pattern):
+    if TODO_TESTS is not None:
+        # Run only Arithmetic tests
+        tests = loader.suiteClass()
     # Dynamically build custom test definition for each file in the test
     # directory and add the definitions to the DecimalTest class.  This
     # procedure insures that new files do not get skipped.
@@ -5852,34 +5860,69 @@ def test_main(arith=None, verbose=None,
         if '.decTest' not in filename or filename.startswith("."):
             continue
         head, tail = filename.split('.')
-        if todo_tests is not None and head not in todo_tests:
+        if TODO_TESTS is not None and head not in TODO_TESTS:
             continue
         tester = lambda self, f=filename: self.eval_file(directory + f)
-        setattr(CIBMTestCases, 'test_' + head, tester)
-        setattr(PyIBMTestCases, 'test_' + head, tester)
+        setattr(IBMTestCases, 'test_' + head, tester)
         del filename, head, tail, tester
+    for prefix, mod in ('C', C), ('Py', P):
+        if not mod:
+            continue
+        test_class = type(prefix + 'IBMTestCases',
+                          (IBMTestCases, unittest.TestCase),
+                          {'decimal': mod})
+        tests.addTest(loader.loadTestsFromTestCase(test_class))
+
+    if TODO_TESTS is None:
+        from doctest import DocTestSuite, IGNORE_EXCEPTION_DETAIL
+        for mod in C, P:
+            if not mod:
+                continue
+            def setUp(slf, mod=mod):
+                sys.modules['decimal'] = mod
+            def tearDown(slf):
+                sys.modules['decimal'] = orig_sys_decimal
+            optionflags = IGNORE_EXCEPTION_DETAIL if mod is C else 0
+            sys.modules['decimal'] = mod
+            tests.addTest(DocTestSuite(mod, setUp=setUp, tearDown=tearDown,
+                                   optionflags=optionflags))
+            sys.modules['decimal'] = orig_sys_decimal
+    return tests
 
+def setUpModule():
+    init(C)
+    init(P)
+    global TEST_ALL
+    TEST_ALL = ARITH if ARITH is not None else is_resource_enabled('decimal')
 
-    try:
-        run_unittest(*test_classes)
-        if todo_tests is None:
-            from doctest import IGNORE_EXCEPTION_DETAIL
-            savedecimal = sys.modules['decimal']
-            if C:
-                sys.modules['decimal'] = C
-                run_doctest(C, verbose, optionflags=IGNORE_EXCEPTION_DETAIL)
-            sys.modules['decimal'] = P
-            run_doctest(P, verbose)
-            sys.modules['decimal'] = savedecimal
-    finally:
-        if C: C.setcontext(ORIGINAL_CONTEXT[C])
-        P.setcontext(ORIGINAL_CONTEXT[P])
-        if not C:
-            warnings.warn('C tests skipped: no module named _decimal.',
-                          UserWarning)
-        if not orig_sys_decimal is sys.modules['decimal']:
-            raise TestFailed("Internal error: unbalanced number of changes to "
-                             "sys.modules['decimal'].")
+def tearDownModule():
+    if C: C.setcontext(ORIGINAL_CONTEXT[C])
+    P.setcontext(ORIGINAL_CONTEXT[P])
+    if not C:
+        warnings.warn('C tests skipped: no module named _decimal.',
+                      UserWarning)
+    if not orig_sys_decimal is sys.modules['decimal']:
+        raise TestFailed("Internal error: unbalanced number of changes to "
+                         "sys.modules['decimal'].")
+
+
+ARITH = None
+TEST_ALL = True
+TODO_TESTS = None
+DEBUG = False
+
+def test(arith=None, verbose=None, todo_tests=None, debug=None):
+    """ Execute the tests.
+
+    Runs all arithmetic tests if arith is True or if the "decimal" resource
+    is enabled in regrtest.py
+    """
+
+    global ARITH, TODO_TESTS, DEBUG
+    ARITH = arith
+    TODO_TESTS = todo_tests
+    DEBUG = debug
+    unittest.main(__name__, verbosity=2 if verbose else 1, exit=False, argv=[__name__])
 
 
 if __name__ == '__main__':
@@ -5890,8 +5933,8 @@ if __name__ == '__main__':
     (opt, args) = p.parse_args()
 
     if opt.skip:
-        test_main(arith=False, verbose=True)
+        test(arith=False, verbose=True)
     elif args:
-        test_main(arith=True, verbose=True, todo_tests=args, debug=opt.debug)
+        test(arith=True, verbose=True, todo_tests=args, debug=opt.debug)
     else:
-        test_main(arith=True, verbose=True)
+        test(arith=True, verbose=True)
--- a/Lib/test/test_dtrace.py
+++ b/Lib/test/test_dtrace.py
@@ -3,6 +3,7 @@ import os.path
 import re
 import subprocess
 import sys
+import sysconfig
 import types
 import unittest
 
@@ -173,6 +174,75 @@ class SystemTapOptimizedTests(TraceTests
     backend = SystemTapBackend()
     optimize_python = 2
 
+class CheckDtraceProbes(unittest.TestCase):
+    @classmethod
+    def setUpClass(cls):
+        if sysconfig.get_config_var('WITH_DTRACE'):
+            readelf_major_version, readelf_minor_version = cls.get_readelf_version()
+            if support.verbose:
+                print(f"readelf version: {readelf_major_version}.{readelf_minor_version}")
+        else:
+            raise unittest.SkipTest("CPython must be configured with the --with-dtrace option.")
+
+
+    @staticmethod
+    def get_readelf_version():
+        try:
+            cmd = ["readelf", "--version"]
+            proc = subprocess.Popen(
+                cmd,
+                stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE,
+                universal_newlines=True,
+            )
+            with proc:
+                version, stderr = proc.communicate()
+
+            if proc.returncode:
+                raise Exception(
+                    f"Command {' '.join(cmd)!r} failed "
+                    f"with exit code {proc.returncode}: "
+                    f"stdout={version!r} stderr={stderr!r}"
+                )
+        except OSError:
+            raise unittest.SkipTest("Couldn't find readelf on the path")
+
+        # Regex to parse:
+        # 'GNU readelf (GNU Binutils) 2.40.0\n' -> 2.40
+        match = re.search(r"^(?:GNU) readelf.*?\b(\d+)\.(\d+)", version)
+        if match is None:
+            raise unittest.SkipTest(f"Unable to parse readelf version: {version}")
+
+        return int(match.group(1)), int(match.group(2))
+
+    def get_readelf_output(self):
+        command = ["readelf", "-n", sys.executable]
+        stdout, _ = subprocess.Popen(
+            command,
+            stdout=subprocess.PIPE,
+            stderr=subprocess.STDOUT,
+            universal_newlines=True,
+        ).communicate()
+        return stdout
+
+    def test_check_probes(self):
+        readelf_output = self.get_readelf_output()
+
+        available_probe_names = [
+            "Name: import__find__load__done",
+            "Name: import__find__load__start",
+            "Name: audit",
+            "Name: gc__start",
+            "Name: gc__done",
+            "Name: function__entry",
+            "Name: function__return",
+            "Name: line",
+        ]
+
+        for probe_name in available_probe_names:
+            with self.subTest(probe_name=probe_name):
+                self.assertIn(probe_name, readelf_output)
+
 
 if __name__ == '__main__':
     unittest.main()
--- /dev/null
+++ b/Lib/test/test_email/data/msg_47.txt
@@ -0,0 +1,14 @@
+Date: 01 Jan 2001 00:01+0000
+From: arthur@example.example
+MIME-Version: 1.0
+Content-Type: multipart/mixed; boundary=foo
+
+--foo
+Content-Type: text/plain
+bar
+
+--foo
+Content-Type: text/html
+<html><body><p>baz</p></body></html>
+
+--foo--
\ No newline at end of file
--- a/Lib/test/test_email/test_email.py
+++ b/Lib/test/test_email/test_email.py
@@ -3696,6 +3696,16 @@ class TestParsers(TestEmailBase):
         self.assertIsInstance(msg.get_payload(), str)
         self.assertIsInstance(msg.get_payload(decode=True), bytes)
 
+    def test_header_parser_multipart_is_valid(self):
+        # Don't flag valid multipart emails as having defects
+        with openfile('msg_47.txt', encoding="utf-8") as fp:
+            msgdata = fp.read()
+
+        parser = email.parser.Parser(policy=email.policy.default)
+        parsed_msg = parser.parsestr(msgdata, headersonly=True)
+
+        self.assertEqual(parsed_msg.defects, [])
+
     def test_bytes_parser_does_not_close_file(self):
         with openfile('msg_02.txt', 'rb') as fp:
             email.parser.BytesParser().parse(fp)
--- a/Lib/test/test_email/test_message.py
+++ b/Lib/test/test_email/test_message.py
@@ -696,14 +696,16 @@ class TestEmailMessageBase:
             self.assertIsNone(part['Content-Disposition'])
 
     class _TestSetRaisingContentManager:
+        class CustomError(Exception):
+            pass
         def set_content(self, msg, content, *args, **kw):
-            raise Exception('test')
+            raise self.CustomError('test')
 
     def test_default_content_manager_for_add_comes_from_policy(self):
         cm = self._TestSetRaisingContentManager()
         m = self.message(policy=self.policy.clone(content_manager=cm))
         for method in ('add_related', 'add_alternative', 'add_attachment'):
-            with self.assertRaises(Exception) as ar:
+            with self.assertRaises(self._TestSetRaisingContentManager.CustomError) as ar:
                 getattr(m, method)('')
             self.assertEqual(str(ar.exception), 'test')
 
--- a/Lib/test/test_enum.py
+++ b/Lib/test/test_enum.py
@@ -32,6 +32,11 @@ def load_tests(loader, tests, ignore):
                 '../../Doc/library/enum.rst',
                 optionflags=doctest.ELLIPSIS|doctest.NORMALIZE_WHITESPACE,
                 ))
+    if os.path.exists('Doc/howto/enum.rst'):
+        tests.addTests(doctest.DocFileSuite(
+                '../../Doc/howto/enum.rst',
+                optionflags=doctest.ELLIPSIS|doctest.NORMALIZE_WHITESPACE,
+                ))
     return tests
 
 MODULE = __name__
@@ -67,6 +72,7 @@ try:
         LARRY = 1
         CURLY = 2
         MOE = 4
+        BIG = 389
 except Exception as exc:
     FlagStooges = exc
 
@@ -75,17 +81,20 @@ class FlagStoogesWithZero(Flag):
     LARRY = 1
     CURLY = 2
     MOE = 4
+    BIG = 389
 
 class IntFlagStooges(IntFlag):
     LARRY = 1
     CURLY = 2
     MOE = 4
+    BIG = 389
 
 class IntFlagStoogesWithZero(IntFlag):
     NOFLAG = 0
     LARRY = 1
     CURLY = 2
     MOE = 4
+    BIG = 389
 
 # for pickle test and subclass tests
 class Name(StrEnum):
@@ -766,9 +775,17 @@ class _MinimalOutputTests:
         TE = self.MainEnum
         copied = copy.copy(TE)
         self.assertEqual(copied, TE)
+        self.assertIs(copied, TE)
         deep = copy.deepcopy(TE)
         self.assertEqual(deep, TE)
+        self.assertIs(deep, TE)
 
+    def test_copy_member(self):
+        TE = self.MainEnum
+        copied = copy.copy(TE.first)
+        self.assertIs(copied, TE.first)
+        deep = copy.deepcopy(TE.first)
+        self.assertIs(deep, TE.first)
 
 class _FlagTests:
 
@@ -780,6 +797,89 @@ class _FlagTests:
             self.MainEnum('RED')
         self.assertIs(ctx.exception.__context__, None)
 
+    def test_closed_invert_expectations(self):
+        class ClosedAB(self.enum_type):
+            A = 1
+            B = 2
+            MASK = 3
+        A, B = ClosedAB
+        AB_MASK = ClosedAB.MASK
+        #
+        self.assertIs(~A, B)
+        self.assertIs(~B, A)
+        self.assertIs(~(A|B), ClosedAB(0))
+        self.assertIs(~AB_MASK, ClosedAB(0))
+        self.assertIs(~ClosedAB(0), (A|B))
+        #
+        class ClosedXYZ(self.enum_type):
+            X = 4
+            Y = 2
+            Z = 1
+            MASK = 7
+        X, Y, Z = ClosedXYZ
+        XYZ_MASK = ClosedXYZ.MASK
+        #
+        self.assertIs(~X, Y|Z)
+        self.assertIs(~Y, X|Z)
+        self.assertIs(~Z, X|Y)
+        self.assertIs(~(X|Y), Z)
+        self.assertIs(~(X|Z), Y)
+        self.assertIs(~(Y|Z), X)
+        self.assertIs(~(X|Y|Z), ClosedXYZ(0))
+        self.assertIs(~XYZ_MASK, ClosedXYZ(0))
+        self.assertIs(~ClosedXYZ(0), (X|Y|Z))
+
+    def test_open_invert_expectations(self):
+        class OpenAB(self.enum_type):
+            A = 1
+            B = 2
+            MASK = 255
+        A, B = OpenAB
+        AB_MASK = OpenAB.MASK
+        #
+        if OpenAB._boundary_ in (EJECT, KEEP):
+            self.assertIs(~A, OpenAB(254))
+            self.assertIs(~B, OpenAB(253))
+            self.assertIs(~(A|B), OpenAB(252))
+            self.assertIs(~AB_MASK, OpenAB(0))
+            self.assertIs(~OpenAB(0), AB_MASK)
+        else:
+            self.assertIs(~A, B)
+            self.assertIs(~B, A)
+            self.assertIs(~(A|B), OpenAB(0))
+            self.assertIs(~AB_MASK, OpenAB(0))
+            self.assertIs(~OpenAB(0), (A|B))
+        #
+        class OpenXYZ(self.enum_type):
+            X = 4
+            Y = 2
+            Z = 1
+            MASK = 31
+        X, Y, Z = OpenXYZ
+        XYZ_MASK = OpenXYZ.MASK
+        #
+        if OpenXYZ._boundary_ in (EJECT, KEEP):
+            self.assertIs(~X, OpenXYZ(27))
+            self.assertIs(~Y, OpenXYZ(29))
+            self.assertIs(~Z, OpenXYZ(30))
+            self.assertIs(~(X|Y), OpenXYZ(25))
+            self.assertIs(~(X|Z), OpenXYZ(26))
+            self.assertIs(~(Y|Z), OpenXYZ(28))
+            self.assertIs(~(X|Y|Z), OpenXYZ(24))
+            self.assertIs(~XYZ_MASK, OpenXYZ(0))
+            self.assertTrue(~OpenXYZ(0), XYZ_MASK)
+        else:
+            self.assertIs(~X, Y|Z)
+            self.assertIs(~Y, X|Z)
+            self.assertIs(~Z, X|Y)
+            self.assertIs(~(X|Y), Z)
+            self.assertIs(~(X|Z), Y)
+            self.assertIs(~(Y|Z), X)
+            self.assertIs(~(X|Y|Z), OpenXYZ(0))
+            self.assertIs(~XYZ_MASK, OpenXYZ(0))
+            self.assertTrue(~OpenXYZ(0), (X|Y|Z))
+
+
 class TestPlainEnum(_EnumTests, _PlainOutputTests, unittest.TestCase):
     enum_type = Enum
 
@@ -1860,7 +1960,6 @@ class TestSpecial(unittest.TestCase):
             __qualname__ = 'NEI'
             x = ('the-x', 1)
             y = ('the-y', 2)
-
         self.assertIs(NEI.__new__, Enum.__new__)
         self.assertEqual(repr(NEI.x + NEI.y), "NamedInt('(the-x + the-y)', 3)")
         globals()['NamedInt'] = NamedInt
@@ -1868,6 +1967,10 @@ class TestSpecial(unittest.TestCase):
         NI5 = NamedInt('test', 5)
         self.assertEqual(NI5, 5)
         self.assertEqual(NEI.y.value, 2)
+        with self.assertRaisesRegex(TypeError, "name and value must be specified"):
+            test_pickle_dump_load(self.assertIs, NEI.y)
+        # fix pickle support and try again
+        NEI.__reduce_ex__ = enum.pickle_by_enum_name
         test_pickle_dump_load(self.assertIs, NEI.y)
         test_pickle_dump_load(self.assertIs, NEI)
 
@@ -2944,22 +3047,6 @@ class OldTestFlag(unittest.TestCase):
         self.assertIs(Open.RO ^ Open.CE, Open.CE)
         self.assertIs(Open.CE ^ Open.CE, Open.RO)
 
-    def test_invert(self):
-        Perm = self.Perm
-        RW = Perm.R | Perm.W
-        RX = Perm.R | Perm.X
-        WX = Perm.W | Perm.X
-        RWX = Perm.R | Perm.W | Perm.X
-        values = list(Perm) + [RW, RX, WX, RWX, Perm(0)]
-        for i in values:
-            self.assertIs(type(~i), Perm)
-            self.assertEqual(~~i, i)
-        for i in Perm:
-            self.assertIs(~~i, i)
-        Open = self.Open
-        self.assertIs(Open.WO & ~Open.WO, Open.RO)
-        self.assertIs((Open.WO|Open.CE) & ~Open.WO, Open.CE)
-
     def test_bool(self):
         Perm = self.Perm
         for f in Perm:
@@ -3120,11 +3207,17 @@ class OldTestFlag(unittest.TestCase):
         test_pickle_dump_load(self.assertEqual,
                         FlagStooges.CURLY&~FlagStooges.CURLY)
         test_pickle_dump_load(self.assertIs, FlagStooges)
+        test_pickle_dump_load(self.assertEqual, FlagStooges.BIG)
+        test_pickle_dump_load(self.assertEqual,
+                        FlagStooges.CURLY|FlagStooges.BIG)
 
         test_pickle_dump_load(self.assertIs, FlagStoogesWithZero.CURLY)
         test_pickle_dump_load(self.assertEqual,
                         FlagStoogesWithZero.CURLY|FlagStoogesWithZero.MOE)
         test_pickle_dump_load(self.assertIs, FlagStoogesWithZero.NOFLAG)
+        test_pickle_dump_load(self.assertEqual, FlagStoogesWithZero.BIG)
+        test_pickle_dump_load(self.assertEqual,
+                        FlagStoogesWithZero.CURLY|FlagStoogesWithZero.BIG)
 
         test_pickle_dump_load(self.assertIs, IntFlagStooges.CURLY)
         test_pickle_dump_load(self.assertEqual,
@@ -3134,11 +3227,19 @@ class OldTestFlag(unittest.TestCase):
         test_pickle_dump_load(self.assertEqual, IntFlagStooges(0))
         test_pickle_dump_load(self.assertEqual, IntFlagStooges(0x30))
         test_pickle_dump_load(self.assertIs, IntFlagStooges)
+        test_pickle_dump_load(self.assertEqual, IntFlagStooges.BIG)
+        test_pickle_dump_load(self.assertEqual, IntFlagStooges.BIG|1)
+        test_pickle_dump_load(self.assertEqual,
+                        IntFlagStooges.CURLY|IntFlagStooges.BIG)
 
         test_pickle_dump_load(self.assertIs, IntFlagStoogesWithZero.CURLY)
         test_pickle_dump_load(self.assertEqual,
                         IntFlagStoogesWithZero.CURLY|IntFlagStoogesWithZero.MOE)
         test_pickle_dump_load(self.assertIs, IntFlagStoogesWithZero.NOFLAG)
+        test_pickle_dump_load(self.assertEqual, IntFlagStoogesWithZero.BIG)
+        test_pickle_dump_load(self.assertEqual, IntFlagStoogesWithZero.BIG|1)
+        test_pickle_dump_load(self.assertEqual,
+                        IntFlagStoogesWithZero.CURLY|IntFlagStoogesWithZero.BIG)
 
     @unittest.skipIf(
             python_version >= (3, 12),
--- a/Lib/test/test_genericpath.py
+++ b/Lib/test/test_genericpath.py
@@ -460,6 +460,10 @@ class CommonTest(GenericTest):
         for path in ('', '.', '/', '\\', '///foo/.//bar//'):
             self.assertIsInstance(self.pathmodule.normpath(path), str)
 
+    def test_normpath_issue106242(self):
+        for path in ('\x00', 'foo\x00bar', '\x00\x00', '\x00foo', 'foo\x00'):
+            self.assertEqual(self.pathmodule.normpath(path), path)
+
     def test_abspath_issue3426(self):
         # Check that abspath returns unicode when the arg is unicode
         # with both ASCII and non-ASCII cwds.
--- a/Lib/test/test_gettext.py
+++ b/Lib/test/test_gettext.py
@@ -320,6 +320,8 @@ class PluralFormsTestCase(GettextBaseTes
         eq(x, 'Hay %s fichero')
         x = gettext.ngettext('There is %s file', 'There are %s files', 2)
         eq(x, 'Hay %s ficheros')
+        x = gettext.gettext('There is %s file')
+        eq(x, 'Hay %s fichero')
 
     def test_plural_context_forms1(self):
         eq = self.assertEqual
@@ -329,6 +331,8 @@ class PluralFormsTestCase(GettextBaseTes
         x = gettext.npgettext('With context',
                               'There is %s file', 'There are %s files', 2)
         eq(x, 'Hay %s ficheros (context)')
+        x = gettext.pgettext('With context', 'There is %s file')
+        eq(x, 'Hay %s fichero (context)')
 
     def test_plural_forms2(self):
         eq = self.assertEqual
@@ -338,6 +342,8 @@ class PluralFormsTestCase(GettextBaseTes
         eq(x, 'Hay %s fichero')
         x = t.ngettext('There is %s file', 'There are %s files', 2)
         eq(x, 'Hay %s ficheros')
+        x = t.gettext('There is %s file')
+        eq(x, 'Hay %s fichero')
 
     def test_plural_context_forms2(self):
         eq = self.assertEqual
@@ -349,6 +355,8 @@ class PluralFormsTestCase(GettextBaseTes
         x = t.npgettext('With context',
                         'There is %s file', 'There are %s files', 2)
         eq(x, 'Hay %s ficheros (context)')
+        x = gettext.pgettext('With context', 'There is %s file')
+        eq(x, 'Hay %s fichero (context)')
 
     # Examples from http://www.gnu.org/software/gettext/manual/gettext.html
 
--- a/Lib/test/test_import/__init__.py
+++ b/Lib/test/test_import/__init__.py
@@ -17,6 +17,7 @@ import threading
 import time
 import unittest
 from unittest import mock
+import _imp
 
 from test.support import os_helper
 from test.support import (
@@ -529,6 +530,13 @@ class ImportTests(unittest.TestCase):
                                     env=env,
                                     cwd=os.path.dirname(pyexe))
 
+    def test_issue105979(self):
+        # this used to crash
+        with self.assertRaises(ImportError) as cm:
+            _imp.get_frozen_object("x", b"6\'\xd5Cu\x12")
+        self.assertIn("Frozen object named 'x' is invalid",
+                      str(cm.exception))
+
 
 @skip_if_dont_write_bytecode
 class FilePermissionTests(unittest.TestCase):
--- a/Lib/test/test_importlib/test_main.py
+++ b/Lib/test/test_importlib/test_main.py
@@ -56,7 +56,7 @@ class BasicTests(fixtures.DistInfoPkg, u
         dict(name=''),
     )
     def test_invalid_inputs_to_from_name(self, name):
-        with self.assertRaises(Exception):
+        with self.assertRaises(ValueError):
             Distribution.from_name(name)
 
 
--- a/Lib/test/test_logging.py
+++ b/Lib/test/test_logging.py
@@ -1981,17 +1981,17 @@ class SysLogHandlerTest(BaseTest):
         # The log message sent to the SysLogHandler is properly received.
         logger = logging.getLogger("slh")
         logger.error("sp\xe4m")
-        self.handled.wait()
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>sp\xc3\xa4m\x00')
         self.handled.clear()
         self.sl_hdlr.append_nul = False
         logger.error("sp\xe4m")
-        self.handled.wait()
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>sp\xc3\xa4m')
         self.handled.clear()
         self.sl_hdlr.ident = "h\xe4m-"
         logger.error("sp\xe4m")
-        self.handled.wait()
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>h\xc3\xa4m-sp\xc3\xa4m')
 
     def test_udp_reconnection(self):
@@ -1999,7 +1999,7 @@ class SysLogHandlerTest(BaseTest):
         self.sl_hdlr.close()
         self.handled.clear()
         logger.error("sp\xe4m")
-        self.handled.wait(0.1)
+        self.handled.wait(support.LONG_TIMEOUT)
         self.assertEqual(self.log_output, b'<11>sp\xc3\xa4m\x00')
 
 @unittest.skipUnless(hasattr(socket, "AF_UNIX"), "Unix sockets required")
--- a/Lib/test/test_mailbox.py
+++ b/Lib/test/test_mailbox.py
@@ -116,10 +116,13 @@ class TestMailbox(TestBase):
         self.assertMailboxEmpty()
 
     def test_add_that_raises_leaves_mailbox_empty(self):
+        class CustomError(Exception): ...
+        exc_msg = "a fake error"
+
         def raiser(*args, **kw):
-            raise Exception("a fake error")
+            raise CustomError(exc_msg)
         support.patch(self, email.generator.BytesGenerator, 'flatten', raiser)
-        with self.assertRaises(Exception):
+        with self.assertRaisesRegex(CustomError, exc_msg):
             self._box.add(email.message_from_string("From: Alphso"))
         self.assertEqual(len(self._box), 0)
         self._box.close()
--- a/Lib/test/test_mmap.py
+++ b/Lib/test/test_mmap.py
@@ -299,6 +299,27 @@ class MmapTests(unittest.TestCase):
         self.assertEqual(m.find(b'one', 1, -2), -1)
         self.assertEqual(m.find(bytearray(b'one')), 0)
 
+        for i in range(-n-1, n+1):
+            for j in range(-n-1, n+1):
+                for p in [b"o", b"on", b"two", b"ones", b"s"]:
+                    expected = data.find(p, i, j)
+                    self.assertEqual(m.find(p, i, j), expected, (p, i, j))
+
+    def test_find_does_not_access_beyond_buffer(self):
+        try:
+            flags = mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS
+            PAGESIZE = mmap.PAGESIZE
+            PROT_NONE = 0
+            PROT_READ = mmap.PROT_READ
+        except AttributeError as e:
+            raise unittest.SkipTest("mmap flags unavailable") from e
+        for i in range(0, 2049):
+            with mmap.mmap(-1, PAGESIZE * (i + 1),
+                           flags=flags, prot=PROT_NONE) as guard:
+                with mmap.mmap(-1, PAGESIZE * (i + 2048),
+                               flags=flags, prot=PROT_READ) as fm:
+                    fm.find(b"fo", -2)
+
 
     def test_rfind(self):
         # test the new 'end' parameter works as expected
--- a/Lib/test/test_ntpath.py
+++ b/Lib/test/test_ntpath.py
@@ -908,6 +908,7 @@ class PathLikeTests(NtpathTestCase):
         self._check_function(self.path.normcase)
         if sys.platform == 'win32':
             self.assertEqual(ntpath.normcase('\u03a9\u2126'), '')
+            self.assertEqual(ntpath.normcase('abc\x00def'), 'abc\x00def')
 
     def test_path_isabs(self):
         self._check_function(self.path.isabs)
--- a/Lib/test/test_opcache.py
+++ b/Lib/test/test_opcache.py
@@ -429,6 +429,35 @@ class TestLoadMethodCache(unittest.TestC
             self.assertFalse(f())
 
 
+class TestCallCache(unittest.TestCase):
+    def test_too_many_defaults_0(self):
+        def f():
+            pass
+
+        f.__defaults__ = (None,)
+        for _ in range(1025):
+            f()
+
+    def test_too_many_defaults_1(self):
+        def f(x):
+            pass
+
+        f.__defaults__ = (None, None)
+        for _ in range(1025):
+            f(None)
+            f()
+
+    def test_too_many_defaults_2(self):
+        def f(x, y):
+            pass
+
+        f.__defaults__ = (None, None, None)
+        for _ in range(1025):
+            f(None, None)
+            f(None)
+            f()
+
+
 if __name__ == "__main__":
     import unittest
     unittest.main()
--- a/Lib/test/test_pydoc.py
+++ b/Lib/test/test_pydoc.py
@@ -24,7 +24,8 @@ from collections import namedtuple
 from urllib.request import urlopen, urlcleanup
 from test.support import import_helper
 from test.support import os_helper
-from test.support.script_helper import assert_python_ok, assert_python_failure
+from test.support.script_helper import (assert_python_ok,
+                                        assert_python_failure, spawn_python)
 from test.support import threading_helper
 from test.support import (reap_children, captured_output, captured_stdout,
                           captured_stderr, is_emscripten, is_wasi,
@@ -631,6 +632,21 @@ class PydocDocTest(unittest.TestCase):
         # Testing that the subclasses section does not appear
         self.assertNotIn('Built-in subclasses', text)
 
+    def test_fail_help_cli(self):
+        elines = (missing_pattern % 'abd').splitlines()
+        with spawn_python("-c" "help()") as proc:
+            out, _ = proc.communicate(b"abd")
+            olines = out.decode().splitlines()[-9:-6]
+            olines[0] = olines[0].removeprefix('help> ')
+            self.assertEqual(elines, olines)
+
+    def test_fail_help_output_redirect(self):
+        with StringIO() as buf:
+            helper = pydoc.Helper(output=buf)
+            helper.help("abd")
+            expected = missing_pattern % "abd"
+            self.assertEqual(expected, buf.getvalue().strip().replace('\n', os.linesep))
+
     @unittest.skipIf(hasattr(sys, 'gettrace') and sys.gettrace(),
                      'trace function introduces __locals__ unexpectedly')
     @requires_docstrings
--- a/Lib/test/test_re.py
+++ b/Lib/test/test_re.py
@@ -1077,33 +1077,6 @@ class ReTests(unittest.TestCase):
     def test_category(self):
         self.assertEqual(re.match(r"(\s)", " ").group(1), " ")
 
-    @cpython_only
-    def test_case_helpers(self):
-        import _sre
-        for i in range(128):
-            c = chr(i)
-            lo = ord(c.lower())
-            self.assertEqual(_sre.ascii_tolower(i), lo)
-            self.assertEqual(_sre.unicode_tolower(i), lo)
-            iscased = c in string.ascii_letters
-            self.assertEqual(_sre.ascii_iscased(i), iscased)
-            self.assertEqual(_sre.unicode_iscased(i), iscased)
-
-        for i in list(range(128, 0x1000)) + [0x10400, 0x10428]:
-            c = chr(i)
-            self.assertEqual(_sre.ascii_tolower(i), i)
-            if i != 0x0130:
-                self.assertEqual(_sre.unicode_tolower(i), ord(c.lower()))
-            iscased = c != c.lower() or c != c.upper()
-            self.assertFalse(_sre.ascii_iscased(i))
-            self.assertEqual(_sre.unicode_iscased(i),
-                             c != c.lower() or c != c.upper())
-
-        self.assertEqual(_sre.ascii_tolower(0x0130), 0x0130)
-        self.assertEqual(_sre.unicode_tolower(0x0130), ord('i'))
-        self.assertFalse(_sre.ascii_iscased(0x0130))
-        self.assertTrue(_sre.unicode_iscased(0x0130))
-
     def test_not_literal(self):
         self.assertEqual(re.search(r"\s([^a])", " b").group(1), "b")
         self.assertEqual(re.search(r"\s([^a]*)", " bb").group(1), "bb")
@@ -1800,20 +1773,6 @@ class ReTests(unittest.TestCase):
         pat = re.compile(b'..')
         self.assertEqual(pat.sub(lambda m: b'bytes', b'a5'), b'bytes')
 
-    def test_dealloc(self):
-        # issue 3299: check for segfault in debug build
-        import _sre
-        # the overflow limit is different on wide and narrow builds and it
-        # depends on the definition of SRE_CODE (see sre.h).
-        # 2**128 should be big enough to overflow on both. For smaller values
-        # a RuntimeError is raised instead of OverflowError.
-        long_overflow = 2**128
-        self.assertRaises(TypeError, re.finditer, "a", {})
-        with self.assertRaises(OverflowError):
-            _sre.compile("abc", 0, [long_overflow], 0, {}, ())
-        with self.assertRaises(TypeError):
-            _sre.compile({}, 0, [], 0, [], [])
-
     def test_search_dot_unicode(self):
         self.assertTrue(re.search("123.*-", '123abc-'))
         self.assertTrue(re.search("123.*-", '123\xe9-'))
@@ -1871,21 +1830,6 @@ class ReTests(unittest.TestCase):
         self.assertRaises(OverflowError, re.compile, r".{%d,}?" % 2**128)
         self.assertRaises(OverflowError, re.compile, r".{%d,%d}" % (2**129, 2**128))
 
-    @cpython_only
-    def test_repeat_minmax_overflow_maxrepeat(self):
-        try:
-            from _sre import MAXREPEAT
-        except ImportError:
-            self.skipTest('requires _sre.MAXREPEAT constant')
-        string = "x" * 100000
-        self.assertIsNone(re.match(r".{%d}" % (MAXREPEAT - 1), string))
-        self.assertEqual(re.match(r".{,%d}" % (MAXREPEAT - 1), string).span(),
-                         (0, 100000))
-        self.assertIsNone(re.match(r".{%d,}?" % (MAXREPEAT - 1), string))
-        self.assertRaises(OverflowError, re.compile, r".{%d}" % MAXREPEAT)
-        self.assertRaises(OverflowError, re.compile, r".{,%d}" % MAXREPEAT)
-        self.assertRaises(OverflowError, re.compile, r".{%d,}?" % MAXREPEAT)
-
     def test_backref_group_name_in_exception(self):
         # Issue 17341: Poor error message when compiling invalid regex
         self.checkPatternError('(?P=<foo>)',
@@ -2452,6 +2396,26 @@ class ReTests(unittest.TestCase):
         self.assertTrue(template_re1.match('ahoy'))
         self.assertFalse(template_re1.match('nope'))
 
+    def test_bug_gh106052(self):
+        # gh-100061
+        self.assertEqual(re.match('(?>(?:.(?!D))+)', 'ABCDE').span(), (0, 2))
+        self.assertEqual(re.match('(?:.(?!D))++', 'ABCDE').span(), (0, 2))
+        self.assertEqual(re.match('(?>(?:.(?!D))*)', 'ABCDE').span(), (0, 2))
+        self.assertEqual(re.match('(?:.(?!D))*+', 'ABCDE').span(), (0, 2))
+        self.assertEqual(re.match('(?>(?:.(?!D))?)', 'CDE').span(), (0, 0))
+        self.assertEqual(re.match('(?:.(?!D))?+', 'CDE').span(), (0, 0))
+        self.assertEqual(re.match('(?>(?:.(?!D)){1,3})', 'ABCDE').span(), (0, 2))
+        self.assertEqual(re.match('(?:.(?!D)){1,3}+', 'ABCDE').span(), (0, 2))
+        # gh-106052
+        self.assertEqual(re.match("(?>(?:ab?c)+)", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?:ab?c)++", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?>(?:ab?c)*)", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?:ab?c)*+", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?>(?:ab?c)?)", "a").span(), (0, 0))
+        self.assertEqual(re.match("(?:ab?c)?+", "a").span(), (0, 0))
+        self.assertEqual(re.match("(?>(?:ab?c){1,3})", "aca").span(), (0, 2))
+        self.assertEqual(re.match("(?:ab?c){1,3}+", "aca").span(), (0, 2))
+
     @unittest.skipIf(multiprocessing is None, 'test requires multiprocessing')
     def test_regression_gh94675(self):
         pattern = re.compile(r'(?<=[({}])(((//[^\n]*)?[\n])([\000-\040])*)*'
@@ -2533,7 +2497,10 @@ ELSE
 
     def test_atomic_group(self):
         self.assertEqual(get_debug_out(r'(?>ab?)'), '''\
-ATOMIC_GROUP [(LITERAL, 97), (MAX_REPEAT, (0, 1, [(LITERAL, 98)]))]
+ATOMIC_GROUP
+  LITERAL 97
+  MAX_REPEAT 0 1
+    LITERAL 98
 
  0. INFO 4 0b0 1 2 (to 5)
  5: ATOMIC_GROUP 11 (to 17)
@@ -2717,6 +2684,64 @@ class ImplementationTest(unittest.TestCa
                     self.assertTrue(hasattr(mod, attr))
                 del sys.modules[name]
 
+    @cpython_only
+    def test_case_helpers(self):
+        import _sre
+        for i in range(128):
+            c = chr(i)
+            lo = ord(c.lower())
+            self.assertEqual(_sre.ascii_tolower(i), lo)
+            self.assertEqual(_sre.unicode_tolower(i), lo)
+            iscased = c in string.ascii_letters
+            self.assertEqual(_sre.ascii_iscased(i), iscased)
+            self.assertEqual(_sre.unicode_iscased(i), iscased)
+
+        for i in list(range(128, 0x1000)) + [0x10400, 0x10428]:
+            c = chr(i)
+            self.assertEqual(_sre.ascii_tolower(i), i)
+            if i != 0x0130:
+                self.assertEqual(_sre.unicode_tolower(i), ord(c.lower()))
+            iscased = c != c.lower() or c != c.upper()
+            self.assertFalse(_sre.ascii_iscased(i))
+            self.assertEqual(_sre.unicode_iscased(i),
+                             c != c.lower() or c != c.upper())
+
+        self.assertEqual(_sre.ascii_tolower(0x0130), 0x0130)
+        self.assertEqual(_sre.unicode_tolower(0x0130), ord('i'))
+        self.assertFalse(_sre.ascii_iscased(0x0130))
+        self.assertTrue(_sre.unicode_iscased(0x0130))
+
+    @cpython_only
+    def test_dealloc(self):
+        # issue 3299: check for segfault in debug build
+        import _sre
+        # the overflow limit is different on wide and narrow builds and it
+        # depends on the definition of SRE_CODE (see sre.h).
+        # 2**128 should be big enough to overflow on both. For smaller values
+        # a RuntimeError is raised instead of OverflowError.
+        long_overflow = 2**128
+        self.assertRaises(TypeError, re.finditer, "a", {})
+        with self.assertRaises(OverflowError):
+            _sre.compile("abc", 0, [long_overflow], 0, {}, ())
+        with self.assertRaises(TypeError):
+            _sre.compile({}, 0, [], 0, [], [])
+
+    @cpython_only
+    def test_repeat_minmax_overflow_maxrepeat(self):
+        try:
+            from _sre import MAXREPEAT
+        except ImportError:
+            self.skipTest('requires _sre.MAXREPEAT constant')
+        string = "x" * 100000
+        self.assertIsNone(re.match(r".{%d}" % (MAXREPEAT - 1), string))
+        self.assertEqual(re.match(r".{,%d}" % (MAXREPEAT - 1), string).span(),
+                         (0, 100000))
+        self.assertIsNone(re.match(r".{%d,}?" % (MAXREPEAT - 1), string))
+        self.assertRaises(OverflowError, re.compile, r".{%d}" % MAXREPEAT)
+        self.assertRaises(OverflowError, re.compile, r".{,%d}" % MAXREPEAT)
+        self.assertRaises(OverflowError, re.compile, r".{%d,}?" % MAXREPEAT)
+
+
 class ExternalTests(unittest.TestCase):
 
     def test_re_benchmarks(self):
--- a/Lib/test/test_regrtest.py
+++ b/Lib/test/test_regrtest.py
@@ -7,6 +7,7 @@ Note: test_regrtest cannot be run twice
 import contextlib
 import glob
 import io
+import locale
 import os.path
 import platform
 import re
@@ -1518,6 +1519,41 @@ class ArgsTestCase(BaseTestCase):
         for name in names:
             self.assertFalse(os.path.exists(name), name)
 
+    def test_mp_decode_error(self):
+        # gh-101634: If a worker stdout cannot be decoded, report a failed test
+        # and a non-zero exit code.
+        if sys.platform == 'win32':
+            encoding = locale.getencoding()
+        else:
+            encoding = sys.stdout.encoding
+            if encoding is None:
+                encoding = sys.__stdout__.encoding
+                if encoding is None:
+                    self.skipTest(f"cannot get regrtest worker encoding")
+
+        nonascii = b"byte:\xa0\xa9\xff\n"
+        try:
+            nonascii.decode(encoding)
+        except UnicodeDecodeError:
+            pass
+        else:
+            self.skipTest(f"{encoding} can decode non-ASCII bytes {nonascii!a}")
+
+        code = textwrap.dedent(fr"""
+            import sys
+            # bytes which cannot be decoded from UTF-8
+            nonascii = {nonascii!a}
+            sys.stdout.buffer.write(nonascii)
+            sys.stdout.buffer.flush()
+        """)
+        testname = self.create_test(code=code)
+
+        output = self.run_tests("--fail-env-changed", "-v", "-j1", testname,
+                                exitcode=EXITCODE_BAD_TEST)
+        self.check_executed_tests(output, [testname],
+                                  failed=[testname],
+                                  randomize=True)
+
 
 class TestUtils(unittest.TestCase):
     def test_format_duration(self):
--- a/Lib/test/test_shutil.py
+++ b/Lib/test/test_shutil.py
@@ -1629,6 +1629,49 @@ class TestArchives(BaseTest, unittest.Te
         formats = [name for name, params in get_archive_formats()]
         self.assertNotIn('xxx', formats)
 
+    def test_make_tarfile_rootdir_nodir(self):
+        # GH-99203
+        self.addCleanup(os_helper.unlink, f'{TESTFN}.tar')
+        for dry_run in (False, True):
+            with self.subTest(dry_run=dry_run):
+                tmp_dir = self.mkdtemp()
+                nonexisting_file = os.path.join(tmp_dir, 'nonexisting')
+                with self.assertRaises(FileNotFoundError) as cm:
+                    make_archive(TESTFN, 'tar', nonexisting_file, dry_run=dry_run)
+                self.assertEqual(cm.exception.errno, errno.ENOENT)
+                self.assertEqual(cm.exception.filename, nonexisting_file)
+                self.assertFalse(os.path.exists(f'{TESTFN}.tar'))
+
+                tmp_fd, tmp_file = tempfile.mkstemp(dir=tmp_dir)
+                os.close(tmp_fd)
+                with self.assertRaises(NotADirectoryError) as cm:
+                    make_archive(TESTFN, 'tar', tmp_file, dry_run=dry_run)
+                self.assertEqual(cm.exception.errno, errno.ENOTDIR)
+                self.assertEqual(cm.exception.filename, tmp_file)
+                self.assertFalse(os.path.exists(f'{TESTFN}.tar'))
+
+    @support.requires_zlib()
+    def test_make_zipfile_rootdir_nodir(self):
+        # GH-99203
+        self.addCleanup(os_helper.unlink, f'{TESTFN}.zip')
+        for dry_run in (False, True):
+            with self.subTest(dry_run=dry_run):
+                tmp_dir = self.mkdtemp()
+                nonexisting_file = os.path.join(tmp_dir, 'nonexisting')
+                with self.assertRaises(FileNotFoundError) as cm:
+                    make_archive(TESTFN, 'zip', nonexisting_file, dry_run=dry_run)
+                self.assertEqual(cm.exception.errno, errno.ENOENT)
+                self.assertEqual(cm.exception.filename, nonexisting_file)
+                self.assertFalse(os.path.exists(f'{TESTFN}.zip'))
+
+                tmp_fd, tmp_file = tempfile.mkstemp(dir=tmp_dir)
+                os.close(tmp_fd)
+                with self.assertRaises(NotADirectoryError) as cm:
+                    make_archive(TESTFN, 'zip', tmp_file, dry_run=dry_run)
+                self.assertEqual(cm.exception.errno, errno.ENOTDIR)
+                self.assertEqual(cm.exception.filename, tmp_file)
+                self.assertFalse(os.path.exists(f'{TESTFN}.zip'))
+
     ### shutil.unpack_archive
 
     def check_unpack_archive(self, format, **kwargs):
@@ -2451,7 +2494,7 @@ class _ZeroCopyFileTest(object):
     def test_same_file(self):
         self.addCleanup(self.reset)
         with self.get_files() as (src, dst):
-            with self.assertRaises(Exception):
+            with self.assertRaises((OSError, _GiveupOnFastCopy)):
                 self.zerocopy_fun(src, src)
         # Make sure src file is not corrupted.
         self.assertEqual(read_file(TESTFN, binary=True), self.FILEDATA)
--- a/Lib/test/test_sqlite3/test_userfunctions.py
+++ b/Lib/test/test_sqlite3/test_userfunctions.py
@@ -195,7 +195,6 @@ class FunctionTests(unittest.TestCase):
         self.con.create_function("returnblob", 0, func_returnblob)
         self.con.create_function("returnlonglong", 0, func_returnlonglong)
         self.con.create_function("returnnan", 0, lambda: float("nan"))
-        self.con.create_function("returntoolargeint", 0, lambda: 1 << 65)
         self.con.create_function("return_noncont_blob", 0,
                                  lambda: memoryview(b"blob")[::2])
         self.con.create_function("raiseexception", 0, func_raiseexception)
@@ -294,11 +293,6 @@ class FunctionTests(unittest.TestCase):
         cur.execute("select returnnan()")
         self.assertIsNone(cur.fetchone()[0])
 
-    def test_func_return_too_large_int(self):
-        cur = self.con.cursor()
-        self.assertRaisesRegex(sqlite.DataError, "string or blob too big",
-                               self.con.execute, "select returntoolargeint()")
-
     @with_tracebacks(ZeroDivisionError, name="func_raiseexception")
     def test_func_exception(self):
         cur = self.con.cursor()
@@ -444,9 +438,10 @@ class FunctionTests(unittest.TestCase):
     @with_tracebacks(OverflowError)
     def test_func_return_too_large_int(self):
         cur = self.con.cursor()
+        msg = "string or blob too big"
         for value in 2**63, -2**63-1, 2**64:
             self.con.create_function("largeint", 0, lambda value=value: value)
-            with self.assertRaises(sqlite.DataError):
+            with self.assertRaisesRegex(sqlite.DataError, msg):
                 cur.execute("select largeint()")
 
     @with_tracebacks(UnicodeEncodeError, "surrogates not allowed", "chr")
--- a/Lib/test/test_subprocess.py
+++ b/Lib/test/test_subprocess.py
@@ -1690,6 +1690,14 @@ class RunFuncTestCase(BaseTestCase):
         res = subprocess.run(args)
         self.assertEqual(res.returncode, 57)
 
+    @unittest.skipUnless(mswindows, "Maybe test trigger a leak on Ubuntu")
+    def test_run_with_an_empty_env(self):
+        # gh-105436: fix subprocess.run(..., env={}) broken on Windows
+        args = [sys.executable, "-c", 'pass']
+        # Ignore subprocess errors - we only care that the API doesn't
+        # raise an OSError
+        subprocess.run(args, env={})
+
     def test_capture_output(self):
         cp = self.run_python(("import sys;"
                               "sys.stdout.write('BDFL'); "
--- a/Lib/test/test_tcl.py
+++ b/Lib/test/test_tcl.py
@@ -23,14 +23,6 @@ except ImportError:
 
 tcl_version = tuple(map(int, _tkinter.TCL_VERSION.split('.')))
 
-_tk_patchlevel = None
-def get_tk_patchlevel():
-    global _tk_patchlevel
-    if _tk_patchlevel is None:
-        tcl = Tcl()
-        _tk_patchlevel = tcl.info_patchlevel()
-    return _tk_patchlevel
-
 
 class TkinterTest(unittest.TestCase):
 
@@ -574,7 +566,6 @@ class TclTest(unittest.TestCase):
                 (1, '2', (3.4,)) if self.wantobjects else
                 ('1', '2', '3.4')),
         ]
-        tk_patchlevel = get_tk_patchlevel()
         if not self.wantobjects:
             expected = ('12', '\u20ac', '\xe2\x82\xac', '3.4')
         else:
@@ -583,8 +574,8 @@ class TclTest(unittest.TestCase):
             (call('dict', 'create', 12, '\u20ac', b'\xe2\x82\xac', (3.4,)),
                 expected),
         ]
-        dbg_info = ('want objects? %s, Tcl version: %s, Tk patchlevel: %s'
-                    % (self.wantobjects, tcl_version, tk_patchlevel))
+        dbg_info = ('want objects? %s, Tcl version: %s, Tcl patchlevel: %s'
+                    % (self.wantobjects, tcl_version, self.interp.info_patchlevel()))
         for arg, res in testcases:
             self.assertEqual(splitlist(arg), res,
                              'arg=%a, %s' % (arg, dbg_info))
--- a/Lib/test/test_types.py
+++ b/Lib/test/test_types.py
@@ -226,8 +226,8 @@ class TypesTests(unittest.TestCase):
     def test_int__format__(self):
         def test(i, format_spec, result):
             # just make sure we have the unified type for integers
-            assert type(i) == int
-            assert type(format_spec) == str
+            self.assertIs(type(i), int)
+            self.assertIs(type(format_spec), str)
             self.assertEqual(i.__format__(format_spec), result)
 
         test(123456789, 'd', '123456789')
@@ -782,8 +782,8 @@ class UnionTests(unittest.TestCase):
 
     def test_or_type_operator_with_TypeVar(self):
         TV = typing.TypeVar('T')
-        assert TV | str == typing.Union[TV, str]
-        assert str | TV == typing.Union[str, TV]
+        self.assertEqual(TV | str, typing.Union[TV, str])
+        self.assertEqual(str | TV, typing.Union[str, TV])
         self.assertIs((int | TV)[int], int)
         self.assertIs((TV | int)[int], int)
 
@@ -887,43 +887,45 @@ class UnionTests(unittest.TestCase):
         ForwardBefore = 'Forward' | T
         def forward_after(x: ForwardAfter[int]) -> None: ...
         def forward_before(x: ForwardBefore[int]) -> None: ...
-        assert typing.get_args(typing.get_type_hints(forward_after)['x']) == (int, Forward)
-        assert typing.get_args(typing.get_type_hints(forward_before)['x']) == (int, Forward)
+        self.assertEqual(typing.get_args(typing.get_type_hints(forward_after)['x']),
+                         (int, Forward))
+        self.assertEqual(typing.get_args(typing.get_type_hints(forward_before)['x']),
+                         (int, Forward))
 
     def test_or_type_operator_with_Protocol(self):
         class Proto(typing.Protocol):
             def meth(self) -> int:
                 ...
-        assert Proto | str == typing.Union[Proto, str]
+        self.assertEqual(Proto | str, typing.Union[Proto, str])
 
     def test_or_type_operator_with_Alias(self):
-        assert list | str == typing.Union[list, str]
-        assert typing.List | str == typing.Union[typing.List, str]
+        self.assertEqual(list | str, typing.Union[list, str])
+        self.assertEqual(typing.List | str, typing.Union[typing.List, str])
 
     def test_or_type_operator_with_NamedTuple(self):
-        NT=namedtuple('A', ['B', 'C', 'D'])
-        assert NT | str == typing.Union[NT,str]
+        NT = namedtuple('A', ['B', 'C', 'D'])
+        self.assertEqual(NT | str, typing.Union[NT, str])
 
     def test_or_type_operator_with_TypedDict(self):
         class Point2D(typing.TypedDict):
             x: int
             y: int
             label: str
-        assert Point2D | str == typing.Union[Point2D, str]
+        self.assertEqual(Point2D | str, typing.Union[Point2D, str])
 
     def test_or_type_operator_with_NewType(self):
         UserId = typing.NewType('UserId', int)
-        assert UserId | str == typing.Union[UserId, str]
+        self.assertEqual(UserId | str, typing.Union[UserId, str])
 
     def test_or_type_operator_with_IO(self):
-        assert typing.IO | str == typing.Union[typing.IO, str]
+        self.assertEqual(typing.IO | str, typing.Union[typing.IO, str])
 
     def test_or_type_operator_with_SpecialForm(self):
-        assert typing.Any | str == typing.Union[typing.Any, str]
-        assert typing.NoReturn | str == typing.Union[typing.NoReturn, str]
-        assert typing.Optional[int] | str == typing.Union[typing.Optional[int], str]
-        assert typing.Optional[int] | str == typing.Union[int, str, None]
-        assert typing.Union[int, bool] | str == typing.Union[int, bool, str]
+        self.assertEqual(typing.Any | str, typing.Union[typing.Any, str])
+        self.assertEqual(typing.NoReturn | str, typing.Union[typing.NoReturn, str])
+        self.assertEqual(typing.Optional[int] | str, typing.Union[typing.Optional[int], str])
+        self.assertEqual(typing.Optional[int] | str, typing.Union[int, str, None])
+        self.assertEqual(typing.Union[int, bool] | str, typing.Union[int, bool, str])
 
     def test_or_type_operator_with_Literal(self):
         Literal = typing.Literal
@@ -955,12 +957,12 @@ class UnionTests(unittest.TestCase):
                          (Literal[1], Literal[Ints.B]))
 
     def test_or_type_repr(self):
-        assert repr(int | str) == "int | str"
-        assert repr((int | str) | list) == "int | str | list"
-        assert repr(int | (str | list)) == "int | str | list"
-        assert repr(int | None) == "int | None"
-        assert repr(int | type(None)) == "int | None"
-        assert repr(int | typing.GenericAlias(list, int)) == "int | list[int]"
+        self.assertEqual(repr(int | str), "int | str")
+        self.assertEqual(repr((int | str) | list), "int | str | list")
+        self.assertEqual(repr(int | (str | list)), "int | str | list")
+        self.assertEqual(repr(int | None), "int | None")
+        self.assertEqual(repr(int | type(None)), "int | None")
+        self.assertEqual(repr(int | typing.GenericAlias(list, int)), "int | list[int]")
 
     def test_or_type_operator_with_genericalias(self):
         a = list[int]
--- a/Lib/test/test_typing.py
+++ b/Lib/test/test_typing.py
@@ -4,6 +4,7 @@ from collections import defaultdict
 from functools import lru_cache, wraps
 import inspect
 import itertools
+import gc
 import pickle
 import re
 import sys
@@ -2643,6 +2644,104 @@ class ProtocolTests(BaseTestCase):
         with self.assertRaises(TypeError):
             issubclass(PG, PG[int])
 
+        only_classes_allowed = r"issubclass\(\) arg 1 must be a class"
+
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, P)
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, PG)
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, BadP)
+        with self.assertRaisesRegex(TypeError, only_classes_allowed):
+            issubclass(1, BadPG)
+
+    def test_implicit_issubclass_between_two_protocols(self):
+        @runtime_checkable
+        class CallableMembersProto(Protocol):
+            def meth(self): ...
+
+        # All the below protocols should be considered "subclasses"
+        # of CallableMembersProto at runtime,
+        # even though none of them explicitly subclass CallableMembersProto
+
+        class IdenticalProto(Protocol):
+            def meth(self): ...
+
+        class SupersetProto(Protocol):
+            def meth(self): ...
+            def meth2(self): ...
+
+        class NonCallableMembersProto(Protocol):
+            meth: Callable[[], None]
+
+        class NonCallableMembersSupersetProto(Protocol):
+            meth: Callable[[], None]
+            meth2: Callable[[str, int], bool]
+
+        class MixedMembersProto1(Protocol):
+            meth: Callable[[], None]
+            def meth2(self): ...
+
+        class MixedMembersProto2(Protocol):
+            def meth(self): ...
+            meth2: Callable[[str, int], bool]
+
+        for proto in (
+            IdenticalProto, SupersetProto, NonCallableMembersProto,
+            NonCallableMembersSupersetProto, MixedMembersProto1, MixedMembersProto2
+        ):
+            with self.subTest(proto=proto.__name__):
+                self.assertIsSubclass(proto, CallableMembersProto)
+
+        # These two shouldn't be considered subclasses of CallableMembersProto, however,
+        # since they don't have the `meth` protocol member
+
+        class EmptyProtocol(Protocol): ...
+        class UnrelatedProtocol(Protocol):
+            def wut(self): ...
+
+        self.assertNotIsSubclass(EmptyProtocol, CallableMembersProto)
+        self.assertNotIsSubclass(UnrelatedProtocol, CallableMembersProto)
+
+        # These aren't protocols at all (despite having annotations),
+        # so they should only be considered subclasses of CallableMembersProto
+        # if they *actually have an attribute* matching the `meth` member
+        # (just having an annotation is insufficient)
+
+        class AnnotatedButNotAProtocol:
+            meth: Callable[[], None]
+
+        class NotAProtocolButAnImplicitSubclass:
+            def meth(self): pass
+
+        class NotAProtocolButAnImplicitSubclass2:
+            meth: Callable[[], None]
+            def meth(self): pass
+
+        class NotAProtocolButAnImplicitSubclass3:
+            meth: Callable[[], None]
+            meth2: Callable[[int, str], bool]
+            def meth(self): pass
+            def meth(self, x, y): return True
+
+        self.assertNotIsSubclass(AnnotatedButNotAProtocol, CallableMembersProto)
+        self.assertIsSubclass(NotAProtocolButAnImplicitSubclass, CallableMembersProto)
+        self.assertIsSubclass(NotAProtocolButAnImplicitSubclass2, CallableMembersProto)
+        self.assertIsSubclass(NotAProtocolButAnImplicitSubclass3, CallableMembersProto)
+
+    def test_isinstance_checks_not_at_whim_of_gc(self):
+        self.addCleanup(gc.enable)
+        gc.disable()
+
+        with self.assertRaisesRegex(
+            TypeError,
+            "Protocols can only inherit from other protocols"
+        ):
+            class Foo(collections.abc.Mapping, Protocol):
+                pass
+
+        self.assertNotIsInstance([], collections.abc.Mapping)
+
     def test_protocols_issubclass_non_callable(self):
         class C:
             x = 1
@@ -3349,6 +3448,71 @@ class ProtocolTests(BaseTestCase):
 
         Foo()  # Previously triggered RecursionError
 
+    def test_empty_protocol_decorated_with_final(self):
+        @final
+        @runtime_checkable
+        class EmptyProtocol(Protocol): ...
+
+        self.assertIsSubclass(object, EmptyProtocol)
+        self.assertIsInstance(object(), EmptyProtocol)
+
+    def test_protocol_decorated_with_final_callable_members(self):
+        @final
+        @runtime_checkable
+        class ProtocolWithMethod(Protocol):
+            def startswith(self, string: str) -> bool: ...
+
+        self.assertIsSubclass(str, ProtocolWithMethod)
+        self.assertNotIsSubclass(int, ProtocolWithMethod)
+        self.assertIsInstance('foo', ProtocolWithMethod)
+        self.assertNotIsInstance(42, ProtocolWithMethod)
+
+    def test_protocol_decorated_with_final_noncallable_members(self):
+        @final
+        @runtime_checkable
+        class ProtocolWithNonCallableMember(Protocol):
+            x: int
+
+        class Foo:
+            x = 42
+
+        only_callable_members_please = (
+            r"Protocols with non-method members don't support issubclass()"
+        )
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(Foo, ProtocolWithNonCallableMember)
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(int, ProtocolWithNonCallableMember)
+
+        self.assertIsInstance(Foo(), ProtocolWithNonCallableMember)
+        self.assertNotIsInstance(42, ProtocolWithNonCallableMember)
+
+    def test_protocol_decorated_with_final_mixed_members(self):
+        @final
+        @runtime_checkable
+        class ProtocolWithMixedMembers(Protocol):
+            x: int
+            def method(self) -> None: ...
+
+        class Foo:
+            x = 42
+            def method(self) -> None: ...
+
+        only_callable_members_please = (
+            r"Protocols with non-method members don't support issubclass()"
+        )
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(Foo, ProtocolWithMixedMembers)
+
+        with self.assertRaisesRegex(TypeError, only_callable_members_please):
+            issubclass(int, ProtocolWithMixedMembers)
+
+        self.assertIsInstance(Foo(), ProtocolWithMixedMembers)
+        self.assertNotIsInstance(42, ProtocolWithMixedMembers)
+
 
 class GenericTests(BaseTestCase):
 
--- a/Lib/test/test_warnings/__init__.py
+++ b/Lib/test/test_warnings/__init__.py
@@ -388,9 +388,13 @@ class FilterTests(BaseTest):
             with self.module.catch_warnings(
                 module=self.module, action="error", category=FutureWarning
             ):
-                self.module.warn("Other types of warnings are not errors")
-                self.assertRaises(FutureWarning,
-                                  self.module.warn, FutureWarning("msg"))
+                with support.captured_stderr() as stderr:
+                    error_msg = "Other types of warnings are not errors"
+                    self.module.warn(error_msg)
+                    self.assertRaises(FutureWarning,
+                                      self.module.warn, FutureWarning("msg"))
+                    stderr = stderr.getvalue()
+                    self.assertIn(error_msg, stderr)
 
 class CFilterTests(FilterTests, unittest.TestCase):
     module = c_warnings
--- a/Lib/test/test_zipfile.py
+++ b/Lib/test/test_zipfile.py
@@ -3444,6 +3444,13 @@ with zipfile.ZipFile(io.BytesIO(), "w")
         assert e.suffixes == []
 
     @pass_alpharep
+    def test_suffix_no_filename(self, alpharep):
+        alpharep.filename = None
+        root = zipfile.Path(alpharep)
+        assert root.joinpath('example').suffix == ""
+        assert root.joinpath('example').suffixes == []
+
+    @pass_alpharep
     def test_stem(self, alpharep):
         """
         The final path component, without its suffix
@@ -3460,6 +3467,8 @@ with zipfile.ZipFile(io.BytesIO(), "w")
         d = root / "d"
         assert d.stem == "d"
 
+        assert (root / ".gitignore").stem == ".gitignore"
+
     @pass_alpharep
     def test_root_parent(self, alpharep):
         root = zipfile.Path(alpharep)
--- a/Lib/tkinter/__init__.py
+++ b/Lib/tkinter/__init__.py
@@ -4068,8 +4068,6 @@ class Image:
         elif kw: cnf = kw
         options = ()
         for k, v in cnf.items():
-            if callable(v):
-                v = self._register(v)
             options = options + ('-'+k, v)
         self.tk.call(('image', 'create', imgtype, name,) + options)
         self.name = name
@@ -4096,8 +4094,6 @@ class Image:
         for k, v in _cnfmerge(kw).items():
             if v is not None:
                 if k[-1] == '_': k = k[:-1]
-                if callable(v):
-                    v = self._register(v)
                 res = res + ('-'+k, v)
         self.tk.call((self.name, 'config') + res)
 
--- a/Lib/tkinter/test/support.py
+++ b/Lib/tkinter/test/support.py
@@ -80,28 +80,28 @@ def simulate_mouse_click(widget, x, y):
 
 import _tkinter
 tcl_version = tuple(map(int, _tkinter.TCL_VERSION.split('.')))
+tk_version = tuple(map(int, _tkinter.TK_VERSION.split('.')))
 
-def requires_tcl(*version):
-    if len(version) <= 2:
-        return unittest.skipUnless(tcl_version >= version,
-            'requires Tcl version >= ' + '.'.join(map(str, version)))
+def requires_tk(*version):
+    if len(version) <= 2 and tk_version >= version:
+        return lambda test: test
 
     def deco(test):
         @functools.wraps(test)
         def newtest(self):
-            if get_tk_patchlevel() < version:
-                self.skipTest('requires Tcl version >= ' +
+            root = getattr(self, 'root', None)
+            if get_tk_patchlevel(root) < version:
+                self.skipTest('requires Tk version >= ' +
                                 '.'.join(map(str, version)))
             test(self)
         return newtest
     return deco
 
 _tk_patchlevel = None
-def get_tk_patchlevel():
+def get_tk_patchlevel(root):
     global _tk_patchlevel
     if _tk_patchlevel is None:
-        tcl = tkinter.Tcl()
-        _tk_patchlevel = tcl.info_patchlevel()
+        _tk_patchlevel = tkinter._parse_version(root.tk.globalgetvar('tk_patchLevel'))
     return _tk_patchlevel
 
 units = {
--- a/Lib/tkinter/test/test_tkinter/test_images.py
+++ b/Lib/tkinter/test/test_tkinter/test_images.py
@@ -2,7 +2,7 @@ import unittest
 import tkinter
 from test import support
 from test.support import os_helper
-from tkinter.test.support import AbstractTkTest, AbstractDefaultRootTest, requires_tcl
+from tkinter.test.support import AbstractTkTest, AbstractDefaultRootTest, requires_tk
 
 support.requires('gui')
 
@@ -144,6 +144,14 @@ class BitmapImageTest(AbstractTkTest, un
         self.assertEqual(image['foreground'],
                          '-foreground {} {} #000000 yellow')
 
+    def test_bug_100814(self):
+        # gh-100814: Passing a callable option value causes AttributeError.
+        with self.assertRaises(tkinter.TclError):
+            tkinter.BitmapImage('::img::test', master=self.root, spam=print)
+        image = tkinter.BitmapImage('::img::test', master=self.root)
+        with self.assertRaises(tkinter.TclError):
+            image.configure(spam=print)
+
 
 class PhotoImageTest(AbstractTkTest, unittest.TestCase):
 
@@ -213,11 +221,11 @@ class PhotoImageTest(AbstractTkTest, uni
     def test_create_from_gif_data(self):
         self.check_create_from_data('gif')
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_create_from_png_file(self):
         self.check_create_from_file('png')
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_create_from_png_data(self):
         self.check_create_from_data('png')
 
@@ -274,6 +282,14 @@ class PhotoImageTest(AbstractTkTest, uni
         image.configure(palette='3/4/2')
         self.assertEqual(image['palette'], '3/4/2')
 
+    def test_bug_100814(self):
+        # gh-100814: Passing a callable option value causes AttributeError.
+        with self.assertRaises(tkinter.TclError):
+            tkinter.PhotoImage('::img::test', master=self.root, spam=print)
+        image = tkinter.PhotoImage('::img::test', master=self.root)
+        with self.assertRaises(tkinter.TclError):
+            image.configure(spam=print)
+
     def test_blank(self):
         image = self.create()
         image.blank()
--- a/Lib/tkinter/test/test_tkinter/test_widgets.py
+++ b/Lib/tkinter/test/test_tkinter/test_widgets.py
@@ -4,7 +4,7 @@ from tkinter import TclError
 import os
 from test.support import requires
 
-from tkinter.test.support import (requires_tcl,
+from tkinter.test.support import (requires_tk,
                                   get_tk_patchlevel, widget_eq,
                                   AbstractDefaultRootTest)
 from tkinter.test.widget_tests import (
@@ -614,7 +614,7 @@ class TextTest(AbstractWidgetTest, unitt
         widget = self.create()
         self.checkColorParam(widget, 'inactiveselectbackground')
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_configure_insertunfocussed(self):
         widget = self.create()
         self.checkEnumParam(widget, 'insertunfocussed',
@@ -919,7 +919,7 @@ class CanvasTest(AbstractWidgetTest, uni
         for i in range(4):
             self.assertIsInstance(coords[i], float)
 
-    @requires_tcl(8, 6)
+    @requires_tk(8, 6)
     def test_moveto(self):
         widget = self.create()
         i1 = widget.create_rectangle(1, 1, 20, 20, tags='group')
@@ -964,7 +964,7 @@ class ListboxTest(AbstractWidgetTest, un
         self.checkEnumParam(widget, 'activestyle',
                             'dotbox', 'none', 'underline')
 
-    test_configure_justify = requires_tcl(8, 6, 5)(StandardOptionsTests.test_configure_justify)
+    test_configure_justify = requires_tk(8, 6, 5)(StandardOptionsTests.test_configure_justify)
 
     def test_configure_listvariable(self):
         widget = self.create()
@@ -1103,7 +1103,7 @@ class ScaleTest(AbstractWidgetTest, unit
 
     def test_configure_from(self):
         widget = self.create()
-        conv = float if get_tk_patchlevel() >= (8, 6, 10) else float_round
+        conv = float if get_tk_patchlevel(self.root) >= (8, 6, 10) else float_round
         self.checkFloatParam(widget, 'from', 100, 14.9, 15.1, conv=conv)
 
     def test_configure_label(self):
@@ -1230,19 +1230,19 @@ class PanedWindowTest(AbstractWidgetTest
         widget = self.create()
         self.checkBooleanParam(widget, 'opaqueresize')
 
-    @requires_tcl(8, 6, 5)
+    @requires_tk(8, 6, 5)
     def test_configure_proxybackground(self):
         widget = self.create()
         self.checkColorParam(widget, 'proxybackground')
 
-    @requires_tcl(8, 6, 5)
+    @requires_tk(8, 6, 5)
     def test_configure_proxyborderwidth(self):
         widget = self.create()
         self.checkPixelsParam(widget, 'proxyborderwidth',
                               0, 1.3, 2.9, 6, -2, '10p',
                               conv=False)
 
-    @requires_tcl(8, 6, 5)
+    @requires_tk(8, 6, 5)
     def test_configure_proxyrelief(self):
         widget = self.create()
         self.checkReliefParam(widget, 'proxyrelief')
--- a/Lib/tkinter/test/test_ttk/test_style.py
+++ b/Lib/tkinter/test/test_ttk/test_style.py
@@ -170,7 +170,7 @@ class StyleTest(AbstractTkTest, unittest
                     newname = f'C.{name}'
                     self.assertEqual(style.map(newname), {})
                     style.map(newname, **default)
-                    if theme == 'alt' and name == '.' and get_tk_patchlevel() < (8, 6, 1):
+                    if theme == 'alt' and name == '.' and get_tk_patchlevel(self.root) < (8, 6, 1):
                         default['embossed'] = [('disabled', '1')]
                     self.assertEqual(style.map(newname), default)
                     for key, value in default.items():
--- a/Lib/tkinter/test/test_ttk/test_widgets.py
+++ b/Lib/tkinter/test/test_ttk/test_widgets.py
@@ -5,7 +5,7 @@ from test.support import requires, gc_co
 import sys
 
 from test.test_ttk_textonly import MockTclObj
-from tkinter.test.support import (AbstractTkTest, tcl_version, get_tk_patchlevel,
+from tkinter.test.support import (AbstractTkTest, tk_version, get_tk_patchlevel,
                                   simulate_mouse_click, AbstractDefaultRootTest)
 from tkinter.test.widget_tests import (add_standard_options,
     AbstractWidgetTest, StandardOptionsTests, IntegerSizeTests, PixelSizeTests,
@@ -20,7 +20,7 @@ class StandardTtkOptionsTests(StandardOp
         widget = self.create()
         self.assertEqual(widget['class'], '')
         errmsg='attempt to change read-only option'
-        if get_tk_patchlevel() < (8, 6, 0, 'beta', 3):
+        if get_tk_patchlevel(self.root) < (8, 6, 0, 'beta', 3):
             errmsg='Attempt to change read-only option'
         self.checkInvalidParam(widget, 'class', 'Foo', errmsg=errmsg)
         widget2 = self.create(class_='Foo')
@@ -562,7 +562,7 @@ class PanedWindowTest(AbstractWidgetTest
         widget = self.create()
         self.assertEqual(str(widget['orient']), 'vertical')
         errmsg='attempt to change read-only option'
-        if get_tk_patchlevel() < (8, 6, 0, 'beta', 3):
+        if get_tk_patchlevel(self.root) < (8, 6, 0, 'beta', 3):
             errmsg='Attempt to change read-only option'
         self.checkInvalidParam(widget, 'orient', 'horizontal',
                 errmsg=errmsg)
@@ -1528,7 +1528,7 @@ class TreeviewTest(AbstractWidgetTest, u
 
     def test_heading_callback(self):
         def simulate_heading_click(x, y):
-            if tcl_version >= (8, 6):
+            if tk_version >= (8, 6):
                 self.assertEqual(self.tv.identify_column(x), '#0')
                 self.assertEqual(self.tv.identify_region(x, y), 'heading')
             simulate_mouse_click(self.tv, x, y)
--- a/Lib/tkinter/test/widget_tests.py
+++ b/Lib/tkinter/test/widget_tests.py
@@ -2,7 +2,7 @@
 
 import unittest
 import tkinter
-from tkinter.test.support import (AbstractTkTest, tcl_version,
+from tkinter.test.support import (AbstractTkTest, tk_version,
                                   pixels_conv, tcl_obj_eq)
 import test.support
 
@@ -23,7 +23,7 @@ class AbstractWidgetTest(AbstractTkTest)
             return self._scaling
 
     def _str(self, value):
-        if not self._stringify and self.wantobjects and tcl_version >= (8, 6):
+        if not self._stringify and self.wantobjects and tk_version >= (8, 6):
             return value
         if isinstance(value, tuple):
             return ' '.join(map(self._str, value))
@@ -157,7 +157,7 @@ class AbstractWidgetTest(AbstractTkTest)
                          'flat', 'groove', 'raised', 'ridge', 'solid', 'sunken')
         errmsg='bad relief "spam": must be '\
                'flat, groove, raised, ridge, solid, or sunken'
-        if tcl_version < (8, 6):
+        if tk_version < (8, 6):
             errmsg = None
         self.checkInvalidParam(widget, name, 'spam',
                 errmsg=errmsg)
--- a/Lib/typing.py
+++ b/Lib/typing.py
@@ -1,9 +1,6 @@
 """
 The typing module: Support for gradual typing as defined by PEP 484 and subsequent PEPs.
 
-Any name not present in __all__ is an implementation detail
-that may be changed without notice. Use at your own risk!
-
 Among other things, the module includes the following:
 * Generic, Protocol, and internal machinery to support generic aliases.
   All subscripted types like X[int], Union[int, str] are generic aliases.
@@ -17,6 +14,9 @@ Among other things, the module includes
 * Special types: NewType, NamedTuple, TypedDict.
 * Deprecated wrapper submodules for re and io related types.
 * Deprecated aliases for builtin types and collections.abc ABCs.
+
+Any name not present in __all__ is an implementation detail
+that may be changed without notice. Use at your own risk!
 """
 
 from abc import abstractmethod, ABCMeta
@@ -207,10 +207,12 @@ def _should_unflatten_callable_args(typ,
     """Internal helper for munging collections.abc.Callable's __args__.
 
     The canonical representation for a Callable's __args__ flattens the
-    argument types, see https://bugs.python.org/issue42195. For example::
+    argument types, see https://github.com/python/cpython/issues/86361.
 
-        collections.abc.Callable[[int, int], str].__args__ == (int, int, str)
-        collections.abc.Callable[ParamSpec, str].__args__ == (ParamSpec, str)
+    For example::
+
+        assert collections.abc.Callable[[int, int], str].__args__ == (int, int, str)
+        assert collections.abc.Callable[ParamSpec, str].__args__ == (ParamSpec, str)
 
     As a result, if we need to reconstruct the Callable from its __args__,
     we need to unflatten it.
@@ -339,8 +341,9 @@ _cleanups = []
 
 
 def _tp_cache(func=None, /, *, typed=False):
-    """Internal wrapper caching __getitem__ of generic types with a fallback to
-    original function for non-hashable arguments.
+    """Internal wrapper caching __getitem__ of generic types.
+
+    For non-hashable arguments, the original function is used as a fallback.
     """
     def decorator(func):
         cached = functools.lru_cache(typed=typed)(func)
@@ -556,7 +559,7 @@ def Never(self, parameters):
                 case str():
                     print("It's a str")
                 case _:
-                    never_call_me(arg)  # ok, arg is of type Never
+                    never_call_me(arg)  # OK, arg is of type Never
     """
     raise TypeError(f"{self} is not subscriptable")
 
@@ -589,13 +592,13 @@ def LiteralString(self, parameters):
 
         from typing import LiteralString
 
-        def run_query(sql: LiteralString) -> ...
+        def run_query(sql: LiteralString) -> None:
             ...
 
         def caller(arbitrary_string: str, literal_string: LiteralString) -> None:
-            run_query("SELECT * FROM students")  # ok
-            run_query(literal_string)  # ok
-            run_query("SELECT * FROM " + literal_string)  # ok
+            run_query("SELECT * FROM students")  # OK
+            run_query(literal_string)  # OK
+            run_query("SELECT * FROM " + literal_string)  # OK
             run_query(arbitrary_string)  # type checker error
             run_query(  # type checker error
                 f"SELECT * FROM students WHERE name = {arbitrary_string}"
@@ -614,10 +617,12 @@ def ClassVar(self, parameters):
 
     An annotation wrapped in ClassVar indicates that a given
     attribute is intended to be used as a class variable and
-    should not be set on instances of that class. Usage::
+    should not be set on instances of that class.
+
+    Usage::
 
         class Starship:
-            stats: ClassVar[Dict[str, int]] = {} # class variable
+            stats: ClassVar[dict[str, int]] = {} # class variable
             damage: int = 10                     # instance variable
 
     ClassVar accepts only types and cannot be further subscribed.
@@ -741,7 +746,9 @@ def TypeAlias(self, parameters):
 
     Use TypeAlias to indicate that an assignment should
     be recognized as a proper type alias definition by type
-    checkers. For example::
+    checkers.
+
+    For example::
 
         Predicate: TypeAlias = Callable[..., bool]
 
@@ -754,8 +761,8 @@ def TypeAlias(self, parameters):
 def Concatenate(self, parameters):
     """Special form for annotating higher-order functions.
 
-    ``Concatenate`` can be sed in conjunction with ``ParamSpec`` and
-    ``Callable`` to represent a higher order function which adds, removes or
+    ``Concatenate`` can be used in conjunction with ``ParamSpec`` and
+    ``Callable`` to represent a higher-order function which adds, removes or
     transforms the parameters of a callable.
 
     For example::
@@ -1713,8 +1720,9 @@ def Unpack(self, parameters):
     """Type unpack operator.
 
     The type unpack operator takes the child types from some container type,
-    such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'. For
-    example::
+    such as `tuple[int, str]` or a `TypeVarTuple`, and 'pulls them out'.
+
+    For example::
 
         # For some generic class `Foo`:
         Foo[Unpack[tuple[int, str]]]  # Equivalent to Foo[int, str]
@@ -1883,7 +1891,7 @@ class _TypingEllipsis:
 
 
 _TYPING_INTERNALS = ['__parameters__', '__orig_bases__',  '__orig_class__',
-                     '_is_protocol', '_is_runtime_protocol']
+                     '_is_protocol', '_is_runtime_protocol', '__final__']
 
 _SPECIAL_NAMES = ['__abstractmethods__', '__annotations__', '__dict__', '__doc__',
                   '__init__', '__module__', '__new__', '__slots__',
@@ -2007,7 +2015,9 @@ class Protocol(Generic, metaclass=_Proto
                 ...
 
     Such classes are primarily used with static type checkers that recognize
-    structural subtyping (static duck-typing), for example::
+    structural subtyping (static duck-typing).
+
+    For example::
 
         class C:
             def meth(self) -> int:
@@ -2163,7 +2173,7 @@ class Annotated:
 
         assert Annotated[int, '$'].__metadata__ == ('$',)
 
-    - Nested Annotated are flattened::
+    - Nested Annotated types are flattened::
 
         assert Annotated[Annotated[T, Ann1, Ann2], Ann3] == Annotated[T, Ann1, Ann2, Ann3]
 
@@ -2174,17 +2184,17 @@ class Annotated:
 
     - Annotated can be used as a generic type alias::
 
-        Optimized = Annotated[T, runtime.Optimize()]
+        Optimized: TypeAlias = Annotated[T, runtime.Optimize()]
         assert Optimized[int] == Annotated[int, runtime.Optimize()]
 
-        OptimizedList = Annotated[List[T], runtime.Optimize()]
-        assert OptimizedList[int] == Annotated[List[int], runtime.Optimize()]
+        OptimizedList: TypeAlias = Annotated[list[T], runtime.Optimize()]
+        assert OptimizedList[int] == Annotated[list[int], runtime.Optimize()]
 
     - Annotated cannot be used with an unpacked TypeVarTuple::
 
-        Annotated[*Ts, Ann1]  # NOT valid
+        Variadic: TypeAlias = Annotated[*Ts, Ann1]  # NOT valid
 
-      This would be equivalent to
+      This would be equivalent to::
 
         Annotated[T1, T2, T3, ..., Ann1]
 
@@ -2264,7 +2274,7 @@ def assert_type(val, typ, /):
     emits an error if the value is not of the specified type::
 
         def greet(name: str) -> None:
-            assert_type(name, str)  # ok
+            assert_type(name, str)  # OK
             assert_type(name, int)  # type checker error
     """
     return val
@@ -2402,8 +2412,10 @@ def _strip_annotations(t):
 def get_origin(tp):
     """Get the unsubscripted version of a type.
 
-    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar
-    Annotated, and others. Return None for unsupported types. Examples::
+    This supports generic types, Callable, Tuple, Union, Literal, Final, ClassVar,
+    Annotated, and others. Return None for unsupported types.
+
+    Examples::
 
         assert get_origin(Literal[42]) is Literal
         assert get_origin(int) is None
@@ -2562,7 +2574,9 @@ def overload(func):
     """Decorator for overloaded functions/methods.
 
     In a stub file, place two or more stub definitions for the same
-    function in a row, each decorated with @overload.  For example::
+    function in a row, each decorated with @overload.
+
+    For example::
 
         @overload
         def utf8(value: None) -> None: ...
@@ -2573,7 +2587,7 @@ def overload(func):
 
     In a non-stub file (i.e. a regular .py file), do the same but
     follow it with an implementation.  The implementation should *not*
-    be decorated with @overload.  For example::
+    be decorated with @overload::
 
         @overload
         def utf8(value: None) -> None: ...
@@ -2685,11 +2699,13 @@ Callable = _CallableType(collections.abc
 Callable.__doc__ = \
     """Deprecated alias to collections.abc.Callable.
 
-    Callable[[int], str] signifies a function of (int) -> str.
+    Callable[[int], str] signifies a function that takes a single
+    parameter of type int and returns a str.
+
     The subscription syntax must always be used with exactly two
     values: the argument list and the return type.
-    The argument list must be a list of types, a ParamSpec or ellipsis.
-    The return type must be a single type.
+    The argument list must be a list of types, a ParamSpec,
+    Concatenate or ellipsis. The return type must be a single type.
 
     There is no syntax to indicate optional or keyword arguments;
     such function types are rarely used as callback types.
@@ -3073,7 +3089,9 @@ TypedDict.__mro_entries__ = lambda bases
 def Required(self, parameters):
     """Special typing construct to mark a TypedDict key as required.
 
-    This is mainly useful for total=False TypedDicts. For example::
+    This is mainly useful for total=False TypedDicts.
+
+    For example::
 
         class Movie(TypedDict, total=False):
             title: Required[str]
@@ -3115,7 +3133,9 @@ class NewType:
 
     NewType(name, tp) is considered a subtype of tp
     by static type checkers. At runtime, NewType(name, tp) returns
-    a dummy callable that simply returns its argument. Usage::
+    a dummy callable that simply returns its argument.
+
+    Usage::
 
         UserId = NewType('UserId', int)
 
--- a/Lib/unittest/test/test_runner.py
+++ b/Lib/unittest/test/test_runner.py
@@ -21,6 +21,13 @@ def getRunner():
                                    stream=io.StringIO())
 
 
+class CustomError(Exception):
+    pass
+
+# For test output compat:
+CustomErrorRepr = f"{__name__ + '.' if __name__ != '__main__' else ''}CustomError"
+
+
 def runTests(*cases):
     suite = unittest.TestSuite()
     for case in cases:
@@ -43,7 +50,7 @@ def cleanup(ordering, blowUp=False):
         ordering.append('cleanup_good')
     else:
         ordering.append('cleanup_exc')
-        raise Exception('CleanUpExc')
+        raise CustomError('CleanUpExc')
 
 
 class TestCM:
@@ -105,8 +112,8 @@ class TestCleanUp(unittest.TestCase):
         result = unittest.TestResult()
         outcome = test._outcome = _Outcome(result=result)
 
-        CleanUpExc = Exception('foo')
-        exc2 = Exception('bar')
+        CleanUpExc = CustomError('foo')
+        exc2 = CustomError('bar')
         def cleanup1():
             raise CleanUpExc
 
@@ -122,10 +129,10 @@ class TestCleanUp(unittest.TestCase):
         (_, msg2), (_, msg1) = result.errors
         self.assertIn('in cleanup1', msg1)
         self.assertIn('raise CleanUpExc', msg1)
-        self.assertIn('Exception: foo', msg1)
+        self.assertIn(f'{CustomErrorRepr}: foo', msg1)
         self.assertIn('in cleanup2', msg2)
         self.assertIn('raise exc2', msg2)
-        self.assertIn('Exception: bar', msg2)
+        self.assertIn(f'{CustomErrorRepr}: bar', msg2)
 
     def testCleanupInRun(self):
         blowUp = False
@@ -136,7 +143,7 @@ class TestCleanUp(unittest.TestCase):
                 ordering.append('setUp')
                 test.addCleanup(cleanup2)
                 if blowUp:
-                    raise Exception('foo')
+                    raise CustomError('foo')
 
             def testNothing(self):
                 ordering.append('test')
@@ -277,7 +284,7 @@ class TestClassCleanup(unittest.TestCase
                 ordering.append('setUpClass')
                 cls.addClassCleanup(cleanup, ordering)
                 if blowUp:
-                    raise Exception()
+                    raise CustomError()
             def testNothing(self):
                 ordering.append('test')
             @classmethod
@@ -303,7 +310,7 @@ class TestClassCleanup(unittest.TestCase
                 ordering.append('setUpClass')
                 cls.addClassCleanup(cleanup, ordering)
                 if blowUp:
-                    raise Exception()
+                    raise CustomError()
             def testNothing(self):
                 ordering.append('test')
             @classmethod
@@ -343,7 +350,7 @@ class TestClassCleanup(unittest.TestCase
         ordering = []
         blowUp = True
         suite = unittest.defaultTestLoader.loadTestsFromTestCase(TestableTest)
-        with self.assertRaises(Exception) as cm:
+        with self.assertRaises(CustomError) as cm:
             suite.debug()
         self.assertEqual(str(cm.exception), 'CleanUpExc')
         self.assertEqual(ordering,
@@ -363,10 +370,10 @@ class TestClassCleanup(unittest.TestCase
             @classmethod
             def tearDownClass(cls):
                 ordering.append('tearDownClass')
-                raise Exception('TearDownClassExc')
+                raise CustomError('TearDownClassExc')
 
         suite = unittest.defaultTestLoader.loadTestsFromTestCase(TestableTest)
-        with self.assertRaises(Exception) as cm:
+        with self.assertRaises(CustomError) as cm:
             suite.debug()
         self.assertEqual(str(cm.exception), 'TearDownClassExc')
         self.assertEqual(ordering, ['setUpClass', 'test', 'tearDownClass'])
@@ -376,7 +383,7 @@ class TestClassCleanup(unittest.TestCase
         ordering = []
         blowUp = True
         suite = unittest.defaultTestLoader.loadTestsFromTestCase(TestableTest)
-        with self.assertRaises(Exception) as cm:
+        with self.assertRaises(CustomError) as cm:
             suite.debug()
         self.assertEqual(str(cm.exception), 'TearDownClassExc')
         self.assertEqual(ordering, ['setUpClass', 'test', 'tearDownClass'])
@@ -389,16 +396,22 @@ class TestClassCleanup(unittest.TestCase
                 pass
 
         def cleanup1():
-            raise Exception('cleanup1')
+            raise CustomError('cleanup1')
 
         def cleanup2():
-            raise Exception('cleanup2')
+            raise CustomError('cleanup2')
 
         TestableTest.addClassCleanup(cleanup1)
         TestableTest.addClassCleanup(cleanup2)
-        with self.assertRaises(Exception) as e:
-            TestableTest.doClassCleanups()
-            self.assertEqual(e, 'cleanup1')
+        TestableTest.doClassCleanups()
+
+        self.assertEqual(len(TestableTest.tearDown_exceptions), 2)
+
+        e1, e2 = TestableTest.tearDown_exceptions
+        self.assertIsInstance(e1[1], CustomError)
+        self.assertEqual(str(e1[1]), 'cleanup2')
+        self.assertIsInstance(e2[1], CustomError)
+        self.assertEqual(str(e2[1]), 'cleanup1')
 
     def test_with_errors_addCleanUp(self):
         ordering = []
@@ -418,7 +431,7 @@ class TestClassCleanup(unittest.TestCase
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpClass', 'setUp', 'cleanup_exc',
                           'tearDownClass', 'cleanup_good'])
@@ -441,7 +454,7 @@ class TestClassCleanup(unittest.TestCase
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpClass', 'setUp', 'test', 'cleanup_good',
                           'tearDownClass', 'cleanup_exc'])
@@ -457,11 +470,11 @@ class TestClassCleanup(unittest.TestCase
                 ordering.append('setUpClass')
                 cls.addClassCleanup(cleanup, ordering, blowUp=True)
                 if class_blow_up:
-                    raise Exception('ClassExc')
+                    raise CustomError('ClassExc')
             def setUp(self):
                 ordering.append('setUp')
                 if method_blow_up:
-                    raise Exception('MethodExc')
+                    raise CustomError('MethodExc')
             def testNothing(self):
                 ordering.append('test')
             @classmethod
@@ -470,7 +483,7 @@ class TestClassCleanup(unittest.TestCase
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpClass', 'setUp', 'test',
                           'tearDownClass', 'cleanup_exc'])
@@ -480,9 +493,9 @@ class TestClassCleanup(unittest.TestCase
         method_blow_up = False
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: ClassExc')
+                         f'{CustomErrorRepr}: ClassExc')
         self.assertEqual(result.errors[1][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpClass', 'cleanup_exc'])
 
@@ -491,9 +504,9 @@ class TestClassCleanup(unittest.TestCase
         method_blow_up = True
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: MethodExc')
+                         f'{CustomErrorRepr}: MethodExc')
         self.assertEqual(result.errors[1][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpClass', 'setUp', 'tearDownClass',
                           'cleanup_exc'])
@@ -510,11 +523,11 @@ class TestClassCleanup(unittest.TestCase
             @classmethod
             def tearDownClass(cls):
                 ordering.append('tearDownClass')
-                raise Exception('TearDownExc')
+                raise CustomError('TearDownExc')
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: TearDownExc')
+                         f'{CustomErrorRepr}: TearDownExc')
         self.assertEqual(ordering,
                          ['setUpClass', 'test', 'tearDownClass', 'cleanup_good'])
 
@@ -607,7 +620,7 @@ class TestModuleCleanUp(unittest.TestCas
             module_cleanups.append((3, args, kwargs))
 
         def module_cleanup_bad(*args, **kwargs):
-            raise Exception('CleanUpExc')
+            raise CustomError('CleanUpExc')
 
         class Module(object):
             unittest.addModuleCleanup(module_cleanup_good, 1, 2, 3,
@@ -617,7 +630,7 @@ class TestModuleCleanUp(unittest.TestCas
                          [(module_cleanup_good, (1, 2, 3),
                            dict(four='hello', five='goodbye')),
                           (module_cleanup_bad, (), {})])
-        with self.assertRaises(Exception) as e:
+        with self.assertRaises(CustomError) as e:
             unittest.case.doModuleCleanups()
         self.assertEqual(str(e.exception), 'CleanUpExc')
         self.assertEqual(unittest.case._module_cleanups, [])
@@ -646,7 +659,7 @@ class TestModuleCleanUp(unittest.TestCas
                 ordering.append('setUpModule')
                 unittest.addModuleCleanup(cleanup, ordering)
                 if blowUp:
-                    raise Exception('setUpModule Exc')
+                    raise CustomError('setUpModule Exc')
             @staticmethod
             def tearDownModule():
                 ordering.append('tearDownModule')
@@ -666,7 +679,7 @@ class TestModuleCleanUp(unittest.TestCas
         result = runTests(TestableTest)
         self.assertEqual(ordering, ['setUpModule', 'cleanup_good'])
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: setUpModule Exc')
+                         f'{CustomErrorRepr}: setUpModule Exc')
 
         ordering = []
         blowUp = False
@@ -686,7 +699,7 @@ class TestModuleCleanUp(unittest.TestCas
                 ordering.append('setUpModule')
                 unittest.addModuleCleanup(cleanup, ordering)
                 if blowUp:
-                    raise Exception()
+                    raise CustomError()
             @staticmethod
             def tearDownModule():
                 ordering.append('tearDownModule')
@@ -697,7 +710,7 @@ class TestModuleCleanUp(unittest.TestCas
                 ordering.append('setUpModule2')
                 unittest.addModuleCleanup(cleanup, ordering)
                 if blowUp2:
-                    raise Exception()
+                    raise CustomError()
             @staticmethod
             def tearDownModule():
                 ordering.append('tearDownModule2')
@@ -786,7 +799,7 @@ class TestModuleCleanUp(unittest.TestCas
             @staticmethod
             def tearDownModule():
                 ordering.append('tearDownModule')
-                raise Exception('CleanUpExc')
+                raise CustomError('CleanUpExc')
 
         class TestableTest(unittest.TestCase):
             @classmethod
@@ -802,7 +815,7 @@ class TestModuleCleanUp(unittest.TestCas
         sys.modules['Module'] = Module
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering, ['setUpModule', 'setUpClass', 'test',
                                     'tearDownClass', 'tearDownModule',
                                     'cleanup_good'])
@@ -842,7 +855,7 @@ class TestModuleCleanUp(unittest.TestCas
         ordering = []
         blowUp = True
         suite = unittest.defaultTestLoader.loadTestsFromTestCase(TestableTest)
-        with self.assertRaises(Exception) as cm:
+        with self.assertRaises(CustomError) as cm:
             suite.debug()
         self.assertEqual(str(cm.exception), 'CleanUpExc')
         self.assertEqual(ordering, ['setUpModule', 'setUpClass', 'test',
@@ -860,7 +873,7 @@ class TestModuleCleanUp(unittest.TestCas
             @staticmethod
             def tearDownModule():
                 ordering.append('tearDownModule')
-                raise Exception('TearDownModuleExc')
+                raise CustomError('TearDownModuleExc')
 
         class TestableTest(unittest.TestCase):
             @classmethod
@@ -875,7 +888,7 @@ class TestModuleCleanUp(unittest.TestCas
         TestableTest.__module__ = 'Module'
         sys.modules['Module'] = Module
         suite = unittest.defaultTestLoader.loadTestsFromTestCase(TestableTest)
-        with self.assertRaises(Exception) as cm:
+        with self.assertRaises(CustomError) as cm:
             suite.debug()
         self.assertEqual(str(cm.exception), 'TearDownModuleExc')
         self.assertEqual(ordering, ['setUpModule', 'setUpClass', 'test',
@@ -886,7 +899,7 @@ class TestModuleCleanUp(unittest.TestCas
         ordering = []
         blowUp = True
         suite = unittest.defaultTestLoader.loadTestsFromTestCase(TestableTest)
-        with self.assertRaises(Exception) as cm:
+        with self.assertRaises(CustomError) as cm:
             suite.debug()
         self.assertEqual(str(cm.exception), 'TearDownModuleExc')
         self.assertEqual(ordering, ['setUpModule', 'setUpClass', 'test',
@@ -965,7 +978,7 @@ class TestModuleCleanUp(unittest.TestCas
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpModule', 'setUpClass', 'test', 'tearDownClass',
                           'cleanup_exc', 'tearDownModule', 'cleanup_good'])
@@ -995,7 +1008,7 @@ class TestModuleCleanUp(unittest.TestCas
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpModule', 'setUp', 'test', 'tearDown',
                           'cleanup_exc', 'tearDownModule', 'cleanup_good'])
@@ -1011,7 +1024,7 @@ class TestModuleCleanUp(unittest.TestCas
                 ordering.append('setUpModule')
                 unittest.addModuleCleanup(cleanup, ordering, blowUp=True)
                 if module_blow_up:
-                    raise Exception('ModuleExc')
+                    raise CustomError('ModuleExc')
             @staticmethod
             def tearDownModule():
                 ordering.append('tearDownModule')
@@ -1021,11 +1034,11 @@ class TestModuleCleanUp(unittest.TestCas
             def setUpClass(cls):
                 ordering.append('setUpClass')
                 if class_blow_up:
-                    raise Exception('ClassExc')
+                    raise CustomError('ClassExc')
             def setUp(self):
                 ordering.append('setUp')
                 if method_blow_up:
-                    raise Exception('MethodExc')
+                    raise CustomError('MethodExc')
             def testNothing(self):
                 ordering.append('test')
             @classmethod
@@ -1037,7 +1050,7 @@ class TestModuleCleanUp(unittest.TestCas
 
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering,
                          ['setUpModule', 'setUpClass', 'setUp', 'test',
                           'tearDownClass', 'tearDownModule',
@@ -1049,9 +1062,9 @@ class TestModuleCleanUp(unittest.TestCas
         method_blow_up = False
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: ModuleExc')
+                         f'{CustomErrorRepr}: ModuleExc')
         self.assertEqual(result.errors[1][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering, ['setUpModule', 'cleanup_exc'])
 
         ordering = []
@@ -1060,9 +1073,9 @@ class TestModuleCleanUp(unittest.TestCas
         method_blow_up = False
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: ClassExc')
+                         f'{CustomErrorRepr}: ClassExc')
         self.assertEqual(result.errors[1][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering, ['setUpModule', 'setUpClass',
                                     'tearDownModule', 'cleanup_exc'])
 
@@ -1072,9 +1085,9 @@ class TestModuleCleanUp(unittest.TestCas
         method_blow_up = True
         result = runTests(TestableTest)
         self.assertEqual(result.errors[0][1].splitlines()[-1],
-                         'Exception: MethodExc')
+                         f'{CustomErrorRepr}: MethodExc')
         self.assertEqual(result.errors[1][1].splitlines()[-1],
-                         'Exception: CleanUpExc')
+                         f'{CustomErrorRepr}: CleanUpExc')
         self.assertEqual(ordering, ['setUpModule', 'setUpClass', 'setUp',
                                     'tearDownClass', 'tearDownModule',
                                     'cleanup_exc'])
--- a/Lib/unittest/test/testmock/testasync.py
+++ b/Lib/unittest/test/testmock/testasync.py
@@ -427,9 +427,10 @@ class AsyncArguments(IsolatedAsyncioTest
         self.assertEqual(output, 10)
 
     async def test_add_side_effect_exception(self):
+        class CustomError(Exception): pass
         async def addition(var): pass
-        mock = AsyncMock(addition, side_effect=Exception('err'))
-        with self.assertRaises(Exception):
+        mock = AsyncMock(addition, side_effect=CustomError('side-effect'))
+        with self.assertRaisesRegex(CustomError, 'side-effect'):
             await mock(5)
 
     async def test_add_side_effect_coroutine(self):
--- a/Lib/urllib/parse.py
+++ b/Lib/urllib/parse.py
@@ -52,18 +52,18 @@ __all__ = ["urlparse", "urlunparse", "ur
 
 uses_relative = ['', 'ftp', 'http', 'gopher', 'nntp', 'imap',
                  'wais', 'file', 'https', 'shttp', 'mms',
-                 'prospero', 'rtsp', 'rtspu', 'sftp',
+                 'prospero', 'rtsp', 'rtsps', 'rtspu', 'sftp',
                  'svn', 'svn+ssh', 'ws', 'wss']
 
 uses_netloc = ['', 'ftp', 'http', 'gopher', 'nntp', 'telnet',
                'imap', 'wais', 'file', 'mms', 'https', 'shttp',
-               'snews', 'prospero', 'rtsp', 'rtspu', 'rsync',
+               'snews', 'prospero', 'rtsp', 'rtsps', 'rtspu', 'rsync',
                'svn', 'svn+ssh', 'sftp', 'nfs', 'git', 'git+ssh',
                'ws', 'wss']
 
 uses_params = ['', 'ftp', 'hdl', 'prospero', 'http', 'imap',
-               'https', 'shttp', 'rtsp', 'rtspu', 'sip', 'sips',
-               'mms', 'sftp', 'tel']
+               'https', 'shttp', 'rtsp', 'rtsps', 'rtspu', 'sip',
+               'sips', 'mms', 'sftp', 'tel']
 
 # These are not actually used anymore, but should stay for backwards
 # compatibility.  (They are undocumented, but have a public-looking name.)
@@ -72,7 +72,7 @@ non_hierarchical = ['gopher', 'hdl', 'ma
                     'telnet', 'wais', 'imap', 'snews', 'sip', 'sips']
 
 uses_query = ['', 'http', 'wais', 'imap', 'https', 'shttp', 'mms',
-              'gopher', 'rtsp', 'rtspu', 'sip', 'sips']
+              'gopher', 'rtsp', 'rtsps', 'rtspu', 'sip', 'sips']
 
 uses_fragment = ['', 'ftp', 'hdl', 'http', 'gopher', 'news',
                  'nntp', 'wais', 'https', 'shttp', 'snews',
--- a/Lib/zipfile.py
+++ b/Lib/zipfile.py
@@ -2420,21 +2420,24 @@ class Path:
         encoding, args, kwargs = _extract_text_encoding(*args, **kwargs)
         return io.TextIOWrapper(stream, encoding, *args, **kwargs)
 
+    def _base(self):
+        return pathlib.PurePosixPath(self.at or self.root.filename)
+
     @property
     def name(self):
-        return pathlib.Path(self.at).name or self.filename.name
+        return self._base().name
 
     @property
     def suffix(self):
-        return pathlib.Path(self.at).suffix or self.filename.suffix
+        return self._base().suffix
 
     @property
     def suffixes(self):
-        return pathlib.Path(self.at).suffixes or self.filename.suffixes
+        return self._base().suffixes
 
     @property
     def stem(self):
-        return pathlib.Path(self.at).stem or self.filename.stem
+        return self._base().stem
 
     @property
     def filename(self):
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -1764,8 +1764,7 @@ altinstall: commoninstall
 
 commoninstall:  check-clean-src @FRAMEWORKALTINSTALLFIRST@ \
 		altbininstall libinstall inclinstall libainstall \
-		sharedinstall oldsharedinstall altmaninstall \
-		@FRAMEWORKALTINSTALLLAST@
+		sharedinstall oldsharedinstall altmaninstall @FRAMEWORKALTINSTALLLAST@
 
 # Install shared libraries enabled by Setup
 DESTDIRS=	$(exec_prefix) $(LIBDIR) $(BINLIBDEST) $(DESTSHARED)
@@ -1839,7 +1838,11 @@ altbininstall: $(BUILDPYTHON) @FRAMEWORK
 			$(DESTDIR)$(BINDIR)/python$(VERSION)$(EXE); \
 	fi
 
-bininstall: altbininstall
+# We depend on commoninstall here to make sure the installation is already usable
+# before we possibly overwrite the global 'python3' symlink to avoid causing
+# problems for anything else trying to run 'python3' while we install, particularly
+# if we're installing in parallel with -j.
+bininstall: commoninstall altbininstall
 	if test ! -d $(DESTDIR)$(LIBPC); then \
 		echo "Creating directory $(LIBPC)"; \
 		$(INSTALL) -d -m $(DIRMODE) $(DESTDIR)$(LIBPC); \
--- a/Misc/ACKS
+++ b/Misc/ACKS
@@ -224,6 +224,7 @@ Erik Bray
 Brian Brazil
 Demian Brecht
 Dave Brennan
+Christopher Richard James Brett
 Tom Bridgman
 Anthony Briggs
 Keith Briggs
--- a/Modules/_ctypes/_ctypes.c
+++ b/Modules/_ctypes/_ctypes.c
@@ -5158,6 +5158,8 @@ static PyObject *
 Pointer_get_contents(CDataObject *self, void *closure)
 {
     StgDictObject *stgdict;
+    PyObject *keep, *ptr_probe;
+    CDataObject *ptr2ptr;
 
     if (*(void **)self->b_ptr == NULL) {
         PyErr_SetString(PyExc_ValueError,
@@ -5167,6 +5169,33 @@ Pointer_get_contents(CDataObject *self,
 
     stgdict = PyObject_stgdict((PyObject *)self);
     assert(stgdict); /* Cannot be NULL for pointer instances */
+
+    keep = GetKeepedObjects(self);
+    if (keep != NULL) {
+        // check if it's a pointer to a pointer:
+        // pointers will have '0' key in the _objects
+        ptr_probe = PyDict_GetItemString(keep, "0");
+
+        if (ptr_probe != NULL) {
+            ptr2ptr = (CDataObject*) PyDict_GetItemString(keep, "1");
+            if (ptr2ptr ==  NULL) {
+                PyErr_SetString(PyExc_ValueError,
+                "Unexpected NULL pointer in _objects");
+                return NULL;
+            }
+            // don't construct a new object,
+            // return existing one instead to preserve refcount
+            assert(
+                *(void**) self->b_ptr == ptr2ptr->b_ptr ||
+                *(void**) self->b_value.c == ptr2ptr->b_ptr ||
+                *(void**) self->b_ptr == ptr2ptr->b_value.c ||
+                *(void**) self->b_value.c == ptr2ptr->b_value.c
+            ); // double-check that we are returning the same thing
+            Py_INCREF(ptr2ptr);
+            return (PyObject *) ptr2ptr;
+        }
+    }
+
     return PyCData_FromBaseObj(stgdict->proto,
                              (PyObject *)self, 0,
                              *(void **)self->b_ptr);
--- a/Modules/_ctypes/callbacks.c
+++ b/Modules/_ctypes/callbacks.c
@@ -499,12 +499,22 @@ long Call_GetClassObject(REFCLSID rclsid
 
     {
         PyObject *py_rclsid = PyLong_FromVoidPtr((void *)rclsid);
+        if (py_rclsid == NULL) {
+            Py_DECREF(func);
+            PyErr_WriteUnraisable(context ? context : Py_None);
+            return E_FAIL;
+        }
         PyObject *py_riid = PyLong_FromVoidPtr((void *)riid);
+        if (py_riid == NULL) {
+            Py_DECREF(func);
+            Py_DECREF(py_rclsid);
+            PyErr_WriteUnraisable(context ? context : Py_None);
+            return E_FAIL;
+        }
         PyObject *py_ppv = PyLong_FromVoidPtr(ppv);
-        if (!py_rclsid || !py_riid || !py_ppv) {
-            Py_XDECREF(py_rclsid);
-            Py_XDECREF(py_riid);
-            Py_XDECREF(py_ppv);
+        if (py_ppv == NULL) {
+            Py_DECREF(py_rclsid);
+            Py_DECREF(py_riid);
             Py_DECREF(func);
             PyErr_WriteUnraisable(context ? context : Py_None);
             return E_FAIL;
--- a/Modules/_curses_panel.c
+++ b/Modules/_curses_panel.c
@@ -670,9 +670,7 @@ _curses_panel_exec(PyObject *mod)
     state->PyCursesError = PyErr_NewException(
         "_curses_panel.error", NULL, NULL);
 
-    Py_INCREF(state->PyCursesError);
-    if (PyModule_AddObject(mod, "error", state->PyCursesError) < 0) {
-        Py_DECREF(state->PyCursesError);
+    if (PyModule_AddObjectRef(mod, "error", state->PyCursesError) < 0) {
         return -1;
     }
 
--- a/Modules/_datetimemodule.c
+++ b/Modules/_datetimemodule.c
@@ -6878,24 +6878,49 @@ _datetime_exec(PyObject *module)
     assert(DI100Y == days_before_year(100+1));
 
     us_per_ms = PyLong_FromLong(1000);
+    if (us_per_ms == NULL) {
+        goto error;
+    }
     us_per_second = PyLong_FromLong(1000000);
+    if (us_per_second == NULL) {
+        goto error;
+    }
     us_per_minute = PyLong_FromLong(60000000);
+    if (us_per_minute == NULL) {
+        goto error;
+    }
     seconds_per_day = PyLong_FromLong(24 * 3600);
-    if (us_per_ms == NULL || us_per_second == NULL ||
-        us_per_minute == NULL || seconds_per_day == NULL) {
-        return -1;
+    if (seconds_per_day == NULL) {
+        goto error;
     }
 
     /* The rest are too big for 32-bit ints, but even
      * us_per_week fits in 40 bits, so doubles should be exact.
      */
     us_per_hour = PyLong_FromDouble(3600000000.0);
+    if (us_per_hour == NULL) {
+        goto error;
+    }
     us_per_day = PyLong_FromDouble(86400000000.0);
+    if (us_per_day == NULL) {
+        goto error;
+    }
     us_per_week = PyLong_FromDouble(604800000000.0);
-    if (us_per_hour == NULL || us_per_day == NULL || us_per_week == NULL) {
-        return -1;
+    if (us_per_week == NULL) {
+        goto error;
     }
+
     return 0;
+
+error:
+    Py_XDECREF(us_per_ms);
+    Py_XDECREF(us_per_second);
+    Py_XDECREF(us_per_minute);
+    Py_XDECREF(us_per_hour);
+    Py_XDECREF(us_per_day);
+    Py_XDECREF(us_per_week);
+    Py_XDECREF(seconds_per_day);
+    return -1;
 }
 
 static struct PyModuleDef datetimemodule = {
--- a/Modules/_decimal/_decimal.c
+++ b/Modules/_decimal/_decimal.c
@@ -247,14 +247,12 @@ value_error_int(const char *mesg)
     return -1;
 }
 
-#ifdef CONFIG_32
 static PyObject *
 value_error_ptr(const char *mesg)
 {
     PyErr_SetString(PyExc_ValueError, mesg);
     return NULL;
 }
-#endif
 
 static int
 type_error_int(const char *mesg)
@@ -541,6 +539,8 @@ getround(PyObject *v)
    initialized to new SignalDicts. Once a SignalDict is tied to
    a context, it cannot be deleted. */
 
+static const char *INVALID_SIGNALDICT_ERROR_MSG = "invalid signal dict";
+
 static int
 signaldict_init(PyObject *self, PyObject *args UNUSED, PyObject *kwds UNUSED)
 {
@@ -549,8 +549,11 @@ signaldict_init(PyObject *self, PyObject
 }
 
 static Py_ssize_t
-signaldict_len(PyObject *self UNUSED)
+signaldict_len(PyObject *self)
 {
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_int(INVALID_SIGNALDICT_ERROR_MSG);
+    }
     return SIGNAL_MAP_LEN;
 }
 
@@ -558,6 +561,9 @@ static PyObject *SignalTuple;
 static PyObject *
 signaldict_iter(PyObject *self UNUSED)
 {
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
     return PyTuple_Type.tp_iter(SignalTuple);
 }
 
@@ -565,6 +571,9 @@ static PyObject *
 signaldict_getitem(PyObject *self, PyObject *key)
 {
     uint32_t flag;
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
 
     flag = exception_as_flag(key);
     if (flag & DEC_ERRORS) {
@@ -580,6 +589,10 @@ signaldict_setitem(PyObject *self, PyObj
     uint32_t flag;
     int x;
 
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_int(INVALID_SIGNALDICT_ERROR_MSG);
+    }
+
     if (value == NULL) {
         return value_error_int("signal keys cannot be deleted");
     }
@@ -612,6 +625,10 @@ signaldict_repr(PyObject *self)
     const char *b[SIGNAL_MAP_LEN]; /* bool */
     int i;
 
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
+
     assert(SIGNAL_MAP_LEN == 9);
 
     for (cm=signal_map, i=0; cm->name != NULL; cm++, i++) {
@@ -634,6 +651,10 @@ signaldict_richcompare(PyObject *v, PyOb
 
     assert(PyDecSignalDict_Check(v));
 
+    if ((SdFlagAddr(v) == NULL) || (SdFlagAddr(w) == NULL)) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
+
     if (op == Py_EQ || op == Py_NE) {
         if (PyDecSignalDict_Check(w)) {
             res = (SdFlags(v)==SdFlags(w)) ^ (op==Py_NE) ? Py_True : Py_False;
@@ -662,6 +683,9 @@ signaldict_richcompare(PyObject *v, PyOb
 static PyObject *
 signaldict_copy(PyObject *self, PyObject *args UNUSED)
 {
+    if (SdFlagAddr(self) == NULL) {
+        return value_error_ptr(INVALID_SIGNALDICT_ERROR_MSG);
+    }
     return flags_as_dict(SdFlags(self));
 }
 
@@ -3658,9 +3682,13 @@ dec_as_integer_ratio(PyObject *self, PyO
             goto error;
         }
         Py_SETREF(numerator, _py_long_floor_divide(numerator, tmp));
+        if (numerator == NULL) {
+            Py_DECREF(tmp);
+            goto error;
+        }
         Py_SETREF(denominator, _py_long_floor_divide(denominator, tmp));
         Py_DECREF(tmp);
-        if (numerator == NULL || denominator == NULL) {
+        if (denominator == NULL) {
             goto error;
         }
     }
@@ -5918,21 +5946,15 @@ PyInit__decimal(void)
 
 
     /* Add types to the module */
-    Py_INCREF(&PyDec_Type);
-    CHECK_INT(PyModule_AddObject(m, "Decimal", (PyObject *)&PyDec_Type));
-    Py_INCREF(&PyDecContext_Type);
-    CHECK_INT(PyModule_AddObject(m, "Context",
-                                 (PyObject *)&PyDecContext_Type));
-    Py_INCREF(DecimalTuple);
-    CHECK_INT(PyModule_AddObject(m, "DecimalTuple", (PyObject *)DecimalTuple));
-
+    CHECK_INT(PyModule_AddObjectRef(m, "Decimal", (PyObject *)&PyDec_Type));
+    CHECK_INT(PyModule_AddObjectRef(m, "Context", (PyObject *)&PyDecContext_Type));
+    CHECK_INT(PyModule_AddObjectRef(m, "DecimalTuple", (PyObject *)DecimalTuple));
 
     /* Create top level exception */
     ASSIGN_PTR(DecimalException, PyErr_NewException(
                                      "decimal.DecimalException",
                                      PyExc_ArithmeticError, NULL));
-    Py_INCREF(DecimalException);
-    CHECK_INT(PyModule_AddObject(m, "DecimalException", DecimalException));
+    CHECK_INT(PyModule_AddObjectRef(m, "DecimalException", DecimalException));
 
     /* Create signal tuple */
     ASSIGN_PTR(SignalTuple, PyTuple_New(SIGNAL_MAP_LEN));
@@ -5972,8 +5994,7 @@ PyInit__decimal(void)
         Py_DECREF(base);
 
         /* add to module */
-        Py_INCREF(cm->ex);
-        CHECK_INT(PyModule_AddObject(m, cm->name, cm->ex));
+        CHECK_INT(PyModule_AddObjectRef(m, cm->name, cm->ex));
 
         /* add to signal tuple */
         Py_INCREF(cm->ex);
@@ -6003,45 +6024,39 @@ PyInit__decimal(void)
         ASSIGN_PTR(cm->ex, PyErr_NewException(cm->fqname, base, NULL));
         Py_DECREF(base);
 
-        Py_INCREF(cm->ex);
-        CHECK_INT(PyModule_AddObject(m, cm->name, cm->ex));
+        CHECK_INT(PyModule_AddObjectRef(m, cm->name, cm->ex));
     }
 
 
     /* Init default context template first */
     ASSIGN_PTR(default_context_template,
                PyObject_CallObject((PyObject *)&PyDecContext_Type, NULL));
-    Py_INCREF(default_context_template);
-    CHECK_INT(PyModule_AddObject(m, "DefaultContext",
-                                 default_context_template));
+    CHECK_INT(PyModule_AddObjectRef(m, "DefaultContext",
+                                    default_context_template));
 
 #ifndef WITH_DECIMAL_CONTEXTVAR
     ASSIGN_PTR(tls_context_key, PyUnicode_FromString("___DECIMAL_CTX__"));
-    Py_INCREF(Py_False);
-    CHECK_INT(PyModule_AddObject(m, "HAVE_CONTEXTVAR", Py_False));
+    CHECK_INT(PyModule_AddObjectRef(m, "HAVE_CONTEXTVAR", Py_False));
 #else
     ASSIGN_PTR(current_context_var, PyContextVar_New("decimal_context", NULL));
-    Py_INCREF(Py_True);
-    CHECK_INT(PyModule_AddObject(m, "HAVE_CONTEXTVAR", Py_True));
+    CHECK_INT(PyModule_AddObjectRef(m, "HAVE_CONTEXTVAR", Py_True));
 #endif
-    Py_INCREF(Py_True);
-    CHECK_INT(PyModule_AddObject(m, "HAVE_THREADS", Py_True));
+    CHECK_INT(PyModule_AddObjectRef(m, "HAVE_THREADS", Py_True));
 
     /* Init basic context template */
     ASSIGN_PTR(basic_context_template,
                PyObject_CallObject((PyObject *)&PyDecContext_Type, NULL));
     init_basic_context(basic_context_template);
-    Py_INCREF(basic_context_template);
-    CHECK_INT(PyModule_AddObject(m, "BasicContext",
-                                 basic_context_template));
+    CHECK_INT(PyModule_AddObjectRef(m, "BasicContext",
+                                    basic_context_template));
 
     /* Init extended context template */
     ASSIGN_PTR(extended_context_template,
                PyObject_CallObject((PyObject *)&PyDecContext_Type, NULL));
     init_extended_context(extended_context_template);
     Py_INCREF(extended_context_template);
-    CHECK_INT(PyModule_AddObject(m, "ExtendedContext",
-                                 extended_context_template));
+    CHECK_INT(PyModule_AddObjectRef(m, "ExtendedContext",
+                                    extended_context_template));
 
 
     /* Init mpd_ssize_t constants */
@@ -6060,8 +6075,7 @@ PyInit__decimal(void)
     /* Init string constants */
     for (i = 0; i < _PY_DEC_ROUND_GUARD; i++) {
         ASSIGN_PTR(round_map[i], PyUnicode_InternFromString(mpd_round_string[i]));
-        Py_INCREF(round_map[i]);
-        CHECK_INT(PyModule_AddObject(m, mpd_round_string[i], round_map[i]));
+        CHECK_INT(PyModule_AddObjectRef(m, mpd_round_string[i], round_map[i]));
     }
 
     /* Add specification version number */
--- a/Modules/_elementtree.c
+++ b/Modules/_elementtree.c
@@ -3263,10 +3263,14 @@ expat_start_handler(XMLParserObject* sel
         }
         while (attrib_in[0] && attrib_in[1]) {
             PyObject* key = makeuniversal(self, attrib_in[0]);
+            if (key == NULL) {
+                Py_DECREF(attrib);
+                Py_DECREF(tag);
+                return;
+            }
             PyObject* value = PyUnicode_DecodeUTF8(attrib_in[1], strlen(attrib_in[1]), "strict");
-            if (!key || !value) {
-                Py_XDECREF(value);
-                Py_XDECREF(key);
+            if (value == NULL) {
+                Py_DECREF(key);
                 Py_DECREF(attrib);
                 Py_DECREF(tag);
                 return;
--- a/Modules/_hashopenssl.c
+++ b/Modules/_hashopenssl.c
@@ -384,14 +384,15 @@ py_digest_by_digestmod(PyObject *module,
     } else {
         _hashlibstate *state = get_hashlib_state(module);
         // borrowed ref
-        name_obj = PyDict_GetItem(state->constructs, digestmod);
+        name_obj = PyDict_GetItemWithError(state->constructs, digestmod);
     }
     if (name_obj == NULL) {
-        _hashlibstate *state = get_hashlib_state(module);
-        PyErr_Clear();
-        PyErr_Format(
-            state->unsupported_digestmod_error,
-            "Unsupported digestmod %R", digestmod);
+        if (!PyErr_Occurred()) {
+            _hashlibstate *state = get_hashlib_state(module);
+            PyErr_Format(
+                state->unsupported_digestmod_error,
+                "Unsupported digestmod %R", digestmod);
+        }
         return NULL;
     }
 
--- a/Modules/_pickle.c
+++ b/Modules/_pickle.c
@@ -1116,39 +1116,49 @@ _Pickler_Write(PicklerObject *self, cons
 static PicklerObject *
 _Pickler_New(void)
 {
-    PicklerObject *self;
-
-    self = PyObject_GC_New(PicklerObject, &Pickler_Type);
-    if (self == NULL)
+    PyMemoTable *memo = PyMemoTable_New();
+    if (memo == NULL) {
         return NULL;
+    }
+
+    const Py_ssize_t max_output_len = WRITE_BUF_SIZE;
+    PyObject *output_buffer = PyBytes_FromStringAndSize(NULL, max_output_len);
+    if (output_buffer == NULL) {
+        goto error;
+    }
+
+    PicklerObject *self = PyObject_GC_New(PicklerObject, &Pickler_Type);
+    if (self == NULL) {
+        goto error;
+    }
 
+    self->memo = memo;
     self->pers_func = NULL;
+    self->pers_func_self = NULL;
     self->dispatch_table = NULL;
-    self->buffer_callback = NULL;
+    self->reducer_override = NULL;
     self->write = NULL;
+    self->output_buffer = output_buffer;
+    self->output_len = 0;
+    self->max_output_len = max_output_len;
     self->proto = 0;
     self->bin = 0;
     self->framing = 0;
     self->frame_start = -1;
+    self->buf_size = 0;
     self->fast = 0;
     self->fast_nesting = 0;
     self->fix_imports = 0;
     self->fast_memo = NULL;
-    self->max_output_len = WRITE_BUF_SIZE;
-    self->output_len = 0;
-    self->reducer_override = NULL;
-
-    self->memo = PyMemoTable_New();
-    self->output_buffer = PyBytes_FromStringAndSize(NULL,
-                                                    self->max_output_len);
-
-    if (self->memo == NULL || self->output_buffer == NULL) {
-        Py_DECREF(self);
-        return NULL;
-    }
+    self->buffer_callback = NULL;
 
     PyObject_GC_Track(self);
     return self;
+
+error:
+    PyMem_Free(memo);
+    Py_XDECREF(output_buffer);
+    return NULL;
 }
 
 static int
@@ -1599,13 +1609,29 @@ _Unpickler_MemoCleanup(UnpicklerObject *
 static UnpicklerObject *
 _Unpickler_New(void)
 {
-    UnpicklerObject *self;
-
-    self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);
-    if (self == NULL)
+    const int MEMO_SIZE = 32;
+    PyObject **memo = _Unpickler_NewMemo(MEMO_SIZE);
+    if (memo == NULL) {
         return NULL;
+    }
+
+    PyObject *stack = Pdata_New();
+    if (stack == NULL) {
+        goto error;
+    }
 
+    UnpicklerObject *self = PyObject_GC_New(UnpicklerObject, &Unpickler_Type);
+    if (self == NULL) {
+        goto error;
+    }
+
+    self->stack = (Pdata *)stack;
+    self->memo = memo;
+    self->memo_size = MEMO_SIZE;
+    self->memo_len = 0;
     self->pers_func = NULL;
+    self->pers_func_self = NULL;
+    memset(&self->buffer, 0, sizeof(Py_buffer));
     self->input_buffer = NULL;
     self->input_line = NULL;
     self->input_len = 0;
@@ -1623,19 +1649,14 @@ _Unpickler_New(void)
     self->marks_size = 0;
     self->proto = 0;
     self->fix_imports = 0;
-    memset(&self->buffer, 0, sizeof(Py_buffer));
-    self->memo_size = 32;
-    self->memo_len = 0;
-    self->memo = _Unpickler_NewMemo(self->memo_size);
-    self->stack = (Pdata *)Pdata_New();
-
-    if (self->memo == NULL || self->stack == NULL) {
-        Py_DECREF(self);
-        return NULL;
-    }
 
     PyObject_GC_Track(self);
     return self;
+
+error:
+    PyMem_Free(memo);
+    Py_XDECREF(stack);
+    return NULL;
 }
 
 /* Returns -1 (with an exception set) on failure, 0 on success. This may
@@ -1645,25 +1666,30 @@ _Unpickler_SetInputStream(UnpicklerObjec
 {
     /* Optional file methods */
     if (_PyObject_LookupAttr(file, &_Py_ID(peek), &self->peek) < 0) {
-        return -1;
+        goto error;
     }
     if (_PyObject_LookupAttr(file, &_Py_ID(readinto), &self->readinto) < 0) {
-        return -1;
+        goto error;
+    }
+    if (_PyObject_LookupAttr(file, &_Py_ID(read), &self->read) < 0) {
+        goto error;
+    }
+    if (_PyObject_LookupAttr(file, &_Py_ID(readline), &self->readline) < 0) {
+        goto error;
     }
-    (void)_PyObject_LookupAttr(file, &_Py_ID(read), &self->read);
-    (void)_PyObject_LookupAttr(file, &_Py_ID(readline), &self->readline);
     if (!self->readline || !self->read) {
-        if (!PyErr_Occurred()) {
-            PyErr_SetString(PyExc_TypeError,
-                            "file must have 'read' and 'readline' attributes");
-        }
-        Py_CLEAR(self->read);
-        Py_CLEAR(self->readinto);
-        Py_CLEAR(self->readline);
-        Py_CLEAR(self->peek);
-        return -1;
+        PyErr_SetString(PyExc_TypeError,
+                        "file must have 'read' and 'readline' attributes");
+        goto error;
     }
     return 0;
+
+error:
+    Py_CLEAR(self->read);
+    Py_CLEAR(self->readinto);
+    Py_CLEAR(self->readline);
+    Py_CLEAR(self->peek);
+    return -1;
 }
 
 /* Returns -1 (with an exception set) on failure, 0 on success. This may
@@ -4833,11 +4859,12 @@ _pickle_PicklerMemoProxy_copy_impl(Pickl
             PyObject *key, *value;
 
             key = PyLong_FromVoidPtr(entry.me_key);
+            if (key == NULL) {
+                goto error;
+            }
             value = Py_BuildValue("nO", entry.me_value, entry.me_key);
-
-            if (key == NULL || value == NULL) {
-                Py_XDECREF(key);
-                Py_XDECREF(value);
+            if (value == NULL) {
+                Py_DECREF(key);
                 goto error;
             }
             status = PyDict_SetItem(new_memo, key, value);
@@ -6033,13 +6060,21 @@ load_stack_global(UnpicklerObject *self)
     PyObject *global_name;
 
     PDATA_POP(self->stack, global_name);
+    if (global_name == NULL) {
+        return -1;
+    }
     PDATA_POP(self->stack, module_name);
-    if (module_name == NULL || !PyUnicode_CheckExact(module_name) ||
-        global_name == NULL || !PyUnicode_CheckExact(global_name)) {
+    if (module_name == NULL) {
+        Py_DECREF(global_name);
+        return -1;
+    }
+    if (!PyUnicode_CheckExact(module_name) ||
+        !PyUnicode_CheckExact(global_name))
+    {
         PickleState *st = _Pickle_GetGlobalState();
         PyErr_SetString(st->UnpicklingError, "STACK_GLOBAL requires str");
-        Py_XDECREF(global_name);
-        Py_XDECREF(module_name);
+        Py_DECREF(global_name);
+        Py_DECREF(module_name);
         return -1;
     }
     global = find_class(self, module_name, global_name);
--- a/Modules/_sqlite/connection.c
+++ b/Modules/_sqlite/connection.c
@@ -1792,10 +1792,12 @@ collation_callback(void *context, int te
     }
 
     string1 = PyUnicode_FromStringAndSize((const char*)text1_data, text1_length);
+    if (string1 == NULL) {
+        goto finally;
+    }
     string2 = PyUnicode_FromStringAndSize((const char*)text2_data, text2_length);
-
-    if (!string1 || !string2) {
-        goto finally; /* failed to allocate strings */
+    if (string2 == NULL) {
+        goto finally;
     }
 
     callback_context *ctx = (callback_context *)context;
--- a/Modules/_sre/sre_lib.h
+++ b/Modules/_sre/sre_lib.h
@@ -1334,6 +1334,10 @@ dispatch:
                     MARK_POP(ctx->lastmark);
                     LASTMARK_RESTORE();
 
+                    /* Restore the global Input Stream pointer
+                       since it can change after jumps. */
+                    state->ptr = ptr;
+
                     /* We have sufficient matches, so exit loop. */
                     break;
                 }
--- a/Modules/_ssl.c
+++ b/Modules/_ssl.c
@@ -650,6 +650,10 @@ PySSL_SetError(PySSLSocket *sslsock, int
                     errstr = "Some I/O error occurred";
                 }
             } else {
+                if (ERR_GET_LIB(e) == ERR_LIB_SSL &&
+                        ERR_GET_REASON(e) == SSL_R_CERTIFICATE_VERIFY_FAILED) {
+                    type = state->PySSLCertVerificationErrorObject;
+                }
                 p = PY_SSL_ERROR_SYSCALL;
             }
             break;
@@ -2800,7 +2804,7 @@ _ssl_session_dup(SSL_SESSION *session) {
     /* get length */
     slen = i2d_SSL_SESSION(session, NULL);
     if (slen == 0 || slen > 0xFF00) {
-        PyErr_SetString(PyExc_ValueError, "i2d() failed.");
+        PyErr_SetString(PyExc_ValueError, "i2d() failed");
         goto error;
     }
     if ((senc = PyMem_Malloc(slen)) == NULL) {
@@ -2809,12 +2813,13 @@ _ssl_session_dup(SSL_SESSION *session) {
     }
     p = senc;
     if (!i2d_SSL_SESSION(session, &p)) {
-        PyErr_SetString(PyExc_ValueError, "i2d() failed.");
+        PyErr_SetString(PyExc_ValueError, "i2d() failed");
         goto error;
     }
     const_p = senc;
     newsession = d2i_SSL_SESSION(NULL, &const_p, slen);
-    if (session == NULL) {
+    if (newsession == NULL) {
+        PyErr_SetString(PyExc_ValueError, "d2i() failed");
         goto error;
     }
     PyMem_Free(senc);
@@ -6052,17 +6057,26 @@ sslmodule_init_errorcodes(PyObject *modu
 
     errcode = error_codes;
     while (errcode->mnemonic != NULL) {
-        PyObject *mnemo, *key;
-        mnemo = PyUnicode_FromString(errcode->mnemonic);
-        key = Py_BuildValue("ii", errcode->library, errcode->reason);
-        if (mnemo == NULL || key == NULL)
+        PyObject *mnemo = PyUnicode_FromString(errcode->mnemonic);
+        if (mnemo == NULL) {
             return -1;
-        if (PyDict_SetItem(state->err_codes_to_names, key, mnemo))
+        }
+        PyObject *key = Py_BuildValue("ii", errcode->library, errcode->reason);
+        if (key == NULL) {
+            Py_DECREF(mnemo);
             return -1;
-        if (PyDict_SetItem(state->err_names_to_codes, mnemo, key))
+        }
+        if (PyDict_SetItem(state->err_codes_to_names, key, mnemo) < 0) {
+            Py_DECREF(key);
+            Py_DECREF(mnemo);
             return -1;
+        }
+        int rc = PyDict_SetItem(state->err_names_to_codes, mnemo, key);
         Py_DECREF(key);
         Py_DECREF(mnemo);
+        if (rc < 0) {
+            return -1;
+        }
         errcode++;
     }
 
@@ -6120,22 +6134,22 @@ sslmodule_init_versioninfo(PyObject *m)
     */
     libver = OpenSSL_version_num();
     r = PyLong_FromUnsignedLong(libver);
-    if (r == NULL || PyModule_AddObject(m, "OPENSSL_VERSION_NUMBER", r))
+    if (_PyModule_Add(m, "OPENSSL_VERSION_NUMBER", r) < 0)
         return -1;
 
     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);
     r = Py_BuildValue("IIIII", major, minor, fix, patch, status);
-    if (r == NULL || PyModule_AddObject(m, "OPENSSL_VERSION_INFO", r))
+    if (_PyModule_Add(m, "OPENSSL_VERSION_INFO", r) < 0)
         return -1;
 
     r = PyUnicode_FromString(OpenSSL_version(OPENSSL_VERSION));
-    if (r == NULL || PyModule_AddObject(m, "OPENSSL_VERSION", r))
+    if (_PyModule_Add(m, "OPENSSL_VERSION", r) < 0)
         return -1;
 
     libver = OPENSSL_VERSION_NUMBER;
     parse_openssl_version(libver, &major, &minor, &fix, &patch, &status);
     r = Py_BuildValue("IIIII", major, minor, fix, patch, status);
-    if (r == NULL || PyModule_AddObject(m, "_OPENSSL_API_VERSION", r))
+    if (_PyModule_Add(m, "_OPENSSL_API_VERSION", r) < 0)
         return -1;
 
     return 0;
--- a/Modules/_stat.c
+++ b/Modules/_stat.c
@@ -592,17 +592,17 @@ stat_exec(PyObject *module)
     ADD_INT_MACRO(module, FILE_ATTRIBUTE_TEMPORARY);
     ADD_INT_MACRO(module, FILE_ATTRIBUTE_VIRTUAL);
 
-    if (PyModule_AddObject(module, "IO_REPARSE_TAG_SYMLINK",
-                           PyLong_FromUnsignedLong(IO_REPARSE_TAG_SYMLINK)) < 0) {
-            return -1;
+    if (_PyModule_Add(module, "IO_REPARSE_TAG_SYMLINK",
+            PyLong_FromUnsignedLong(IO_REPARSE_TAG_SYMLINK)) < 0) {
+        return -1;
     }
-    if (PyModule_AddObject(module, "IO_REPARSE_TAG_MOUNT_POINT",
-                           PyLong_FromUnsignedLong(IO_REPARSE_TAG_MOUNT_POINT)) < 0) {
-            return -1;
+    if (_PyModule_Add(module, "IO_REPARSE_TAG_MOUNT_POINT",
+            PyLong_FromUnsignedLong(IO_REPARSE_TAG_MOUNT_POINT)) < 0) {
+        return -1;
     }
-    if (PyModule_AddObject(module, "IO_REPARSE_TAG_APPEXECLINK",
-                           PyLong_FromUnsignedLong(IO_REPARSE_TAG_APPEXECLINK)) < 0) {
-            return -1;
+    if (_PyModule_Add(module, "IO_REPARSE_TAG_APPEXECLINK",
+            PyLong_FromUnsignedLong(IO_REPARSE_TAG_APPEXECLINK)) < 0) {
+        return -1;
     }
 #endif
 
--- a/Modules/_testcapimodule.c
+++ b/Modules/_testcapimodule.c
@@ -44,6 +44,16 @@
 #  error "The public headers should not include <stdbool.h>, see bpo-46748"
 #endif
 
+#define NULLABLE(x) do { if (x == Py_None) x = NULL; } while (0);
+
+#define RETURN_INT(value) do {          \
+        int _ret = (value);             \
+        if (_ret == -1) {               \
+            return NULL;                \
+        }                               \
+        return PyLong_FromLong(_ret);   \
+    } while (0)
+
 // Forward declarations
 static struct PyModuleDef _testcapimodule;
 static PyType_Spec HeapTypeNameType_Spec;
@@ -2307,6 +2317,40 @@ unicode_asutf8andsize(PyObject *self, Py
     return Py_BuildValue("(Nn)", result, utf8_len);
 }
 
+/* Test PyUnicode_DecodeUTF8() */
+static PyObject *
+unicode_decodeutf8(PyObject *self, PyObject *args)
+{
+    const char *data;
+    Py_ssize_t size;
+    const char *errors = NULL;
+
+    if (!PyArg_ParseTuple(args, "y#|z", &data, &size, &errors))
+        return NULL;
+
+    return PyUnicode_DecodeUTF8(data, size, errors);
+}
+
+/* Test PyUnicode_DecodeUTF8Stateful() */
+static PyObject *
+unicode_decodeutf8stateful(PyObject *self, PyObject *args)
+{
+    const char *data;
+    Py_ssize_t size;
+    const char *errors = NULL;
+    Py_ssize_t consumed = 123456789;
+    PyObject *result;
+
+    if (!PyArg_ParseTuple(args, "y#|z", &data, &size, &errors))
+        return NULL;
+
+    result = PyUnicode_DecodeUTF8Stateful(data, size, errors, &consumed);
+    if (!result) {
+        return NULL;
+    }
+    return Py_BuildValue("(Nn)", result, consumed);
+}
+
 static PyObject *
 unicode_findchar(PyObject *self, PyObject *args)
 {
@@ -6415,6 +6459,35 @@ static PyObject *getargs_s_hash_int(PyOb
 static PyObject *getargs_s_hash_int2(PyObject *, PyObject *, PyObject*);
 static PyObject *gh_99240_clear_args(PyObject *, PyObject *);
 
+static PyObject *
+sys_getobject(PyObject *Py_UNUSED(module), PyObject *arg)
+{
+    const char *name;
+    Py_ssize_t size;
+    if (!PyArg_Parse(arg, "z#", &name, &size)) {
+        return NULL;
+    }
+    PyObject *result = PySys_GetObject(name);
+    if (result == NULL) {
+        result = PyExc_AttributeError;
+    }
+    return Py_NewRef(result);
+}
+
+static PyObject *
+sys_setobject(PyObject *Py_UNUSED(module), PyObject *args)
+{
+    const char *name;
+    Py_ssize_t size;
+    PyObject *value;
+    if (!PyArg_ParseTuple(args, "z#O", &name, &size, &value)) {
+        return NULL;
+    }
+    NULLABLE(value);
+    RETURN_INT(PySys_SetObject(name, value));
+}
+
+
 static PyMethodDef TestMethods[] = {
     {"exc_set_object",          exc_set_object,                  METH_VARARGS},
     {"raise_exception",         raise_exception,                 METH_VARARGS},
@@ -6562,7 +6635,8 @@ static PyMethodDef TestMethods[] = {
     {"unicode_asucs4",          unicode_asucs4,                  METH_VARARGS},
     {"unicode_asutf8",          unicode_asutf8,                  METH_VARARGS},
     {"unicode_asutf8andsize",   unicode_asutf8andsize,           METH_VARARGS},
-    {"unicode_findchar",        unicode_findchar,                METH_VARARGS},
+    {"unicode_decodeutf8",       unicode_decodeutf8,             METH_VARARGS},
+    {"unicode_decodeutf8stateful",unicode_decodeutf8stateful,    METH_VARARGS},    {"unicode_findchar",        unicode_findchar,                METH_VARARGS},
     {"unicode_copycharacters",  unicode_copycharacters,          METH_VARARGS},
 #if USE_UNICODE_WCHAR_CACHE
     {"unicode_legacy_string",   unicode_legacy_string,           METH_VARARGS},
@@ -6726,6 +6800,8 @@ static PyMethodDef TestMethods[] = {
     {"function_get_code", function_get_code, METH_O, NULL},
     {"function_get_globals", function_get_globals, METH_O, NULL},
     {"function_get_module", function_get_module, METH_O, NULL},
+    {"sys_getobject", sys_getobject, METH_O},
+    {"sys_setobject", sys_setobject, METH_VARARGS},
     {NULL, NULL} /* sentinel */
 };
 
--- a/Modules/_testinternalcapi.c
+++ b/Modules/_testinternalcapi.c
@@ -14,6 +14,7 @@
 #include "Python.h"
 #include "pycore_atomic_funcs.h" // _Py_atomic_int_get()
 #include "pycore_bitutils.h"     // _Py_bswap32()
+#include "pycore_bytesobject.h"  // _PyBytes_Find()
 #include "pycore_fileutils.h"    // _Py_normpath
 #include "pycore_frame.h"        // _PyInterpreterFrame
 #include "pycore_gc.h"           // PyGC_Head
@@ -380,6 +381,118 @@ test_edit_cost(PyObject *self, PyObject
 }
 
 
+static int
+check_bytes_find(const char *haystack0, const char *needle0,
+                 int offset, Py_ssize_t expected)
+{
+    Py_ssize_t len_haystack = strlen(haystack0);
+    Py_ssize_t len_needle = strlen(needle0);
+    Py_ssize_t result_1 = _PyBytes_Find(haystack0, len_haystack,
+                                        needle0, len_needle, offset);
+    if (result_1 != expected) {
+        PyErr_Format(PyExc_AssertionError,
+                    "Incorrect result_1: '%s' in '%s' (offset=%zd)",
+                    needle0, haystack0, offset);
+        return -1;
+    }
+    // Allocate new buffer with no NULL terminator.
+    char *haystack = PyMem_Malloc(len_haystack);
+    if (haystack == NULL) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    char *needle = PyMem_Malloc(len_needle);
+    if (needle == NULL) {
+        PyMem_Free(haystack);
+        PyErr_NoMemory();
+        return -1;
+    }
+    memcpy(haystack, haystack0, len_haystack);
+    memcpy(needle, needle0, len_needle);
+    Py_ssize_t result_2 = _PyBytes_Find(haystack, len_haystack,
+                                        needle, len_needle, offset);
+    PyMem_Free(haystack);
+    PyMem_Free(needle);
+    if (result_2 != expected) {
+        PyErr_Format(PyExc_AssertionError,
+                    "Incorrect result_2: '%s' in '%s' (offset=%zd)",
+                    needle0, haystack0, offset);
+        return -1;
+    }
+    return 0;
+}
+
+static int
+check_bytes_find_large(Py_ssize_t len_haystack, Py_ssize_t len_needle,
+                       const char *needle)
+{
+    char *zeros = PyMem_RawCalloc(len_haystack, 1);
+    if (zeros == NULL) {
+        PyErr_NoMemory();
+        return -1;
+    }
+    Py_ssize_t res = _PyBytes_Find(zeros, len_haystack, needle, len_needle, 0);
+    PyMem_RawFree(zeros);
+    if (res != -1) {
+        PyErr_Format(PyExc_AssertionError,
+                    "check_bytes_find_large(%zd, %zd) found %zd",
+                    len_haystack, len_needle, res);
+        return -1;
+    }
+    return 0;
+}
+
+static PyObject *
+test_bytes_find(PyObject *self, PyObject *Py_UNUSED(args))
+{
+    #define CHECK(H, N, O, E) do {               \
+        if (check_bytes_find(H, N, O, E) < 0) {  \
+            return NULL;                         \
+        }                                        \
+    } while (0)
+
+    CHECK("", "", 0, 0);
+    CHECK("Python", "", 0, 0);
+    CHECK("Python", "", 3, 3);
+    CHECK("Python", "", 6, 6);
+    CHECK("Python", "yth", 0, 1);
+    CHECK("ython", "yth", 1, 1);
+    CHECK("thon", "yth", 2, -1);
+    CHECK("Python", "thon", 0, 2);
+    CHECK("ython", "thon", 1, 2);
+    CHECK("thon", "thon", 2, 2);
+    CHECK("hon", "thon", 3, -1);
+    CHECK("Pytho", "zz", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "ab", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "ba", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "bb", 0, -1);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab", "ab", 0, 30);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaba", "ba", 0, 30);
+    CHECK("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabb", "bb", 0, 30);
+    #undef CHECK
+
+    // Hunt for segfaults
+    // n, m chosen here so that (n - m) % (m + 1) == 0
+    // This would make default_find in fastsearch.h access haystack[n].
+    if (check_bytes_find_large(2048, 2, "ab") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(4096, 16, "0123456789abcdef") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(8192, 2, "ab") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(16384, 4, "abcd") < 0) {
+        return NULL;
+    }
+    if (check_bytes_find_large(32768, 2, "ab") < 0) {
+        return NULL;
+    }
+    Py_RETURN_NONE;
+}
+
+
 static PyObject *
 normalize_path(PyObject *self, PyObject *filename)
 {
@@ -537,6 +650,7 @@ static PyMethodDef TestMethods[] = {
     {"reset_path_config", test_reset_path_config, METH_NOARGS},
     {"test_atomic_funcs", test_atomic_funcs, METH_NOARGS},
     {"test_edit_cost", test_edit_cost, METH_NOARGS},
+    {"test_bytes_find", test_bytes_find, METH_NOARGS},
     {"normalize_path", normalize_path, METH_O, NULL},
     {"get_getpath_codeobject", get_getpath_codeobject, METH_NOARGS, NULL},
     {"EncodeLocaleEx", encode_locale_ex, METH_VARARGS},
@@ -568,7 +682,7 @@ PyInit__testinternalcapi(void)
         return NULL;
     }
 
-    if (PyModule_AddObject(module, "SIZEOF_PYGC_HEAD",
+    if (_PyModule_Add(module, "SIZEOF_PYGC_HEAD",
                            PyLong_FromSsize_t(sizeof(PyGC_Head))) < 0) {
         goto error;
     }
--- a/Modules/_threadmodule.c
+++ b/Modules/_threadmodule.c
@@ -1648,8 +1648,8 @@ thread_module_exec(PyObject *module)
     // Round towards minus infinity
     timeout_max = floor(timeout_max);
 
-    if (PyModule_AddObject(module, "TIMEOUT_MAX",
-                           PyFloat_FromDouble(timeout_max)) < 0) {
+    if (_PyModule_Add(module, "TIMEOUT_MAX",
+                        PyFloat_FromDouble(timeout_max)) < 0) {
         return -1;
     }
 
--- a/Modules/_tkinter.c
+++ b/Modules/_tkinter.c
@@ -906,8 +906,9 @@ asBignumObj(PyObject *value)
         return NULL;
     }
     hexchars += neg + 2; /* skip sign and "0x" */
-    mp_init(&bigValue);
-    if (mp_read_radix(&bigValue, hexchars, 16) != MP_OKAY) {
+    if (mp_init(&bigValue) != MP_OKAY ||
+        mp_read_radix(&bigValue, hexchars, 16) != MP_OKAY)
+    {
         mp_clear(&bigValue);
         Py_DECREF(hexstr);
         PyErr_NoMemory();
--- a/Modules/_winapi.c
+++ b/Modules/_winapi.c
@@ -805,6 +805,17 @@ getenvironment(PyObject* environment)
     }
 
     envsize = PyList_GET_SIZE(keys);
+
+    if (envsize == 0) {
+        // A environment block must be terminated by two null characters --
+        // one for the last string and one for the block.
+        buffer = PyMem_Calloc(2, sizeof(wchar_t));
+        if (!buffer) {
+            PyErr_NoMemory();
+        }
+        goto cleanup;
+    }
+
     if (PyList_GET_SIZE(values) != envsize) {
         PyErr_SetString(PyExc_RuntimeError,
             "environment changed size during iteration");
@@ -878,7 +889,8 @@ getenvironment(PyObject* environment)
     *p++ = L'\0';
     assert(p == end);
 
- error:
+cleanup:
+error:
     Py_XDECREF(keys);
     Py_XDECREF(values);
     return buffer;
@@ -1559,24 +1571,26 @@ _winapi_LCMapStringEx_impl(PyObject *mod
     if (!locale_) {
         return NULL;
     }
-    Py_ssize_t srcLenAsSsize;
-    int srcLen;
-    wchar_t *src_ = PyUnicode_AsWideCharString(src, &srcLenAsSsize);
+    Py_ssize_t src_size;
+    wchar_t *src_ = PyUnicode_AsWideCharString(src, &src_size);
     if (!src_) {
         PyMem_Free(locale_);
         return NULL;
     }
-    srcLen = (int)srcLenAsSsize;
-    if (srcLen != srcLenAsSsize) {
-        srcLen = -1;
+    if (src_size > INT_MAX) {
+        PyMem_Free(locale_);
+        PyMem_Free(src_);
+        PyErr_SetString(PyExc_OverflowError, "input string is too long");
+        return NULL;
     }
 
-    int dest_size = LCMapStringEx(locale_, flags, src_, srcLen, NULL, 0,
+    int dest_size = LCMapStringEx(locale_, flags, src_, (int)src_size, NULL, 0,
                                   NULL, NULL, 0);
-    if (dest_size == 0) {
+    if (dest_size <= 0) {
+        DWORD error = GetLastError();
         PyMem_Free(locale_);
         PyMem_Free(src_);
-        return PyErr_SetFromWindowsErr(0);
+        return PyErr_SetFromWindowsErr(error);
     }
 
     wchar_t* dest = PyMem_NEW(wchar_t, dest_size);
@@ -1586,9 +1600,9 @@ _winapi_LCMapStringEx_impl(PyObject *mod
         return PyErr_NoMemory();
     }
 
-    int nmapped = LCMapStringEx(locale_, flags, src_, srcLen, dest, dest_size,
+    int nmapped = LCMapStringEx(locale_, flags, src_, (int)src_size, dest, dest_size,
                                 NULL, NULL, 0);
-    if (nmapped == 0) {
+    if (nmapped <= 0) {
         DWORD error = GetLastError();
         PyMem_Free(locale_);
         PyMem_Free(src_);
@@ -1596,9 +1610,9 @@ _winapi_LCMapStringEx_impl(PyObject *mod
         return PyErr_SetFromWindowsErr(error);
     }
 
-    PyObject *ret = PyUnicode_FromWideChar(dest, dest_size);
     PyMem_Free(locale_);
     PyMem_Free(src_);
+    PyObject *ret = PyUnicode_FromWideChar(dest, nmapped);
     PyMem_DEL(dest);
 
     return ret;
--- a/Modules/_zoneinfo.c
+++ b/Modules/_zoneinfo.c
@@ -581,14 +581,19 @@ zoneinfo_fromutc(PyObject *obj_self, PyO
         }
         else {
             PyObject *replace = PyObject_GetAttrString(tmp, "replace");
+            Py_DECREF(tmp);
+            if (replace == NULL) {
+                return NULL;
+            }
             PyObject *args = PyTuple_New(0);
+            if (args == NULL) {
+                Py_DECREF(replace);
+                return NULL;
+            }
             PyObject *kwargs = PyDict_New();
-
-            Py_DECREF(tmp);
-            if (args == NULL || kwargs == NULL || replace == NULL) {
-                Py_XDECREF(args);
-                Py_XDECREF(kwargs);
-                Py_XDECREF(replace);
+            if (kwargs == NULL) {
+                Py_DECREF(replace);
+                Py_DECREF(args);
                 return NULL;
             }
 
--- a/Modules/arraymodule.c
+++ b/Modules/arraymodule.c
@@ -741,10 +741,12 @@ array_richcompare(PyObject *v, PyObject
     k = 1;
     for (i = 0; i < Py_SIZE(va) && i < Py_SIZE(wa); i++) {
         vi = getarrayitem(v, i);
+        if (vi == NULL) {
+            return NULL;
+        }
         wi = getarrayitem(w, i);
-        if (vi == NULL || wi == NULL) {
-            Py_XDECREF(vi);
-            Py_XDECREF(wi);
+        if (wi == NULL) {
+            Py_DECREF(vi);
             return NULL;
         }
         k = PyObject_RichCompareBool(vi, wi, Py_EQ);
--- a/Modules/cmathmodule.c
+++ b/Modules/cmathmodule.c
@@ -1264,30 +1264,28 @@ static PyMethodDef cmath_methods[] = {
 static int
 cmath_exec(PyObject *mod)
 {
-    if (PyModule_AddObject(mod, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
+    if (_PyModule_Add(mod, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(mod, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
+    if (_PyModule_Add(mod, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
         return -1;
     }
     // 2pi
-    if (PyModule_AddObject(mod, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
+    if (_PyModule_Add(mod, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(mod, "inf", PyFloat_FromDouble(m_inf())) < 0) {
+    if (_PyModule_Add(mod, "inf", PyFloat_FromDouble(m_inf())) < 0) {
         return -1;
     }
 
-    if (PyModule_AddObject(mod, "infj",
-                           PyComplex_FromCComplex(c_infj())) < 0) {
+    if (_PyModule_Add(mod, "infj", PyComplex_FromCComplex(c_infj())) < 0) {
         return -1;
     }
 #if _PY_SHORT_FLOAT_REPR == 1
-    if (PyModule_AddObject(mod, "nan", PyFloat_FromDouble(m_nan())) < 0) {
+    if (_PyModule_Add(mod, "nan", PyFloat_FromDouble(m_nan())) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(mod, "nanj",
-                           PyComplex_FromCComplex(c_nanj())) < 0) {
+    if (_PyModule_Add(mod, "nanj", PyComplex_FromCComplex(c_nanj())) < 0) {
         return -1;
     }
 #endif
--- a/Modules/errnomodule.c
+++ b/Modules/errnomodule.c
@@ -79,9 +79,12 @@ end:
 static int
 errno_exec(PyObject *module)
 {
-    PyObject *module_dict = PyModule_GetDict(module);
+    PyObject *module_dict = PyModule_GetDict(module);  // Borrowed ref.
+    if (module_dict == NULL) {
+        return -1;
+    }
     PyObject *error_dict = PyDict_New();
-    if (!module_dict || !error_dict) {
+    if (error_dict == NULL) {
         return -1;
     }
     if (PyDict_SetItemString(module_dict, "errorcode", error_dict) < 0) {
--- a/Modules/grpmodule.c
+++ b/Modules/grpmodule.c
@@ -65,8 +65,14 @@ mkgrent(PyObject *module, struct group *
         Py_DECREF(v);
         return NULL;
     }
-    for (member = p->gr_mem; *member != NULL; member++) {
-        PyObject *x = PyUnicode_DecodeFSDefault(*member);
+    for (member = p->gr_mem; ; member++) {
+        char *group_member;
+        // member can be misaligned
+        memcpy(&group_member, member, sizeof(group_member));
+        if (group_member == NULL) {
+            break;
+        }
+        PyObject *x = PyUnicode_DecodeFSDefault(group_member);
         if (x == NULL || PyList_Append(w, x) != 0) {
             Py_XDECREF(x);
             Py_DECREF(w);
--- a/Modules/mathmodule.c
+++ b/Modules/mathmodule.c
@@ -3825,21 +3825,21 @@ math_ulp_impl(PyObject *module, double x
 static int
 math_exec(PyObject *module)
 {
-    if (PyModule_AddObject(module, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
+    if (_PyModule_Add(module, "pi", PyFloat_FromDouble(Py_MATH_PI)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(module, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
+    if (_PyModule_Add(module, "e", PyFloat_FromDouble(Py_MATH_E)) < 0) {
         return -1;
     }
     // 2pi
-    if (PyModule_AddObject(module, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
+    if (_PyModule_Add(module, "tau", PyFloat_FromDouble(Py_MATH_TAU)) < 0) {
         return -1;
     }
-    if (PyModule_AddObject(module, "inf", PyFloat_FromDouble(m_inf())) < 0) {
+    if (_PyModule_Add(module, "inf", PyFloat_FromDouble(m_inf())) < 0) {
         return -1;
     }
 #if _PY_SHORT_FLOAT_REPR == 1
-    if (PyModule_AddObject(module, "nan", PyFloat_FromDouble(m_nan())) < 0) {
+    if (_PyModule_Add(module, "nan", PyFloat_FromDouble(m_nan())) < 0) {
         return -1;
     }
 #endif
--- a/Modules/mmapmodule.c
+++ b/Modules/mmapmodule.c
@@ -351,12 +351,17 @@ mmap_gfind(mmap_object *self,
 
         Py_ssize_t res;
         CHECK_VALID_OR_RELEASE(NULL, view);
-        if (reverse) {
+        if (end < start) {
+            res = -1;
+        }
+        else if (reverse) {
+            assert(0 <= start && start <= end && end <= self->size);
             res = _PyBytes_ReverseFind(
                 self->data + start, end - start,
                 view.buf, view.len, start);
         }
         else {
+            assert(0 <= start && start <= end && end <= self->size);
             res = _PyBytes_Find(
                 self->data + start, end - start,
                 view.buf, view.len, start);
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -280,7 +280,7 @@ corresponding Unix manual entries for mo
 #  undef HAVE_SCHED_SETAFFINITY
 #endif
 
-#if defined(HAVE_SYS_XATTR_H) && defined(__linux__) && !defined(__FreeBSD_kernel__) && !defined(__GNU__)
+#if defined(HAVE_SYS_XATTR_H) && defined(HAVE_LINUX_LIMITS_H) && !defined(__FreeBSD_kernel__) && !defined(__GNU__)
 #  define USE_XATTRS
 #  include <linux/limits.h>  // Needed for XATTR_SIZE_MAX on musl libc.
 #endif
@@ -4552,7 +4552,9 @@ os__path_normpath_impl(PyObject *module,
     if (!buffer) {
         return NULL;
     }
-    PyObject *result = PyUnicode_FromWideChar(_Py_normpath(buffer, len), -1);
+    Py_ssize_t norm_len;
+    wchar_t *norm_path = _Py_normpath_and_size(buffer, len, &norm_len);
+    PyObject *result = PyUnicode_FromWideChar(norm_path, norm_len);
     PyMem_Free(buffer);
     return result;
 }
@@ -5691,7 +5693,7 @@ parse_envlist(PyObject* env, Py_ssize_t
 {
     Py_ssize_t i, pos, envc;
     PyObject *keys=NULL, *vals=NULL;
-    PyObject *key, *val, *key2, *val2, *keyval;
+    PyObject *key2, *val2, *keyval;
     EXECV_CHAR **envlist;
 
     i = PyMapping_Size(env);
@@ -5716,10 +5718,14 @@ parse_envlist(PyObject* env, Py_ssize_t
     }
 
     for (pos = 0; pos < i; pos++) {
-        key = PyList_GetItem(keys, pos);
-        val = PyList_GetItem(vals, pos);
-        if (!key || !val)
+        PyObject *key = PyList_GetItem(keys, pos);  // Borrowed ref.
+        if (key == NULL) {
             goto error;
+        }
+        PyObject *val = PyList_GetItem(vals, pos);  // Borrowed ref.
+        if (val == NULL) {
+            goto error;
+        }
 
 #if defined(HAVE_WEXECV) || defined(HAVE_WSPAWNV)
         if (!PyUnicode_FSDecoder(key, &key2))
@@ -12559,7 +12565,7 @@ setup_confname_table(struct constdef *ta
         }
         Py_DECREF(o);
     }
-    return PyModule_AddObject(module, tablename, d);
+    return _PyModule_Add(module, tablename, d);
 }
 
 /* Return -1 on failure, 0 on success. */
@@ -15833,11 +15839,9 @@ posixmodule_exec(PyObject *m)
 #endif
 
     /* Initialize environ dictionary */
-    PyObject *v = convertenviron();
-    Py_XINCREF(v);
-    if (v == NULL || PyModule_AddObject(m, "environ", v) != 0)
+    if (_PyModule_Add(m, "environ", convertenviron()) != 0) {
         return -1;
-    Py_DECREF(v);
+    }
 
     if (all_ins(m))
         return -1;
@@ -15845,42 +15849,34 @@ posixmodule_exec(PyObject *m)
     if (setup_confname_tables(m))
         return -1;
 
-    Py_INCREF(PyExc_OSError);
-    PyModule_AddObject(m, "error", PyExc_OSError);
+    if (PyModule_AddObjectRef(m, "error", PyExc_OSError) < 0) {
+        return -1;
+    }
 
 #if defined(HAVE_WAITID) && !defined(__APPLE__)
     waitid_result_desc.name = MODNAME ".waitid_result";
-    PyObject *WaitidResultType = (PyObject *)PyStructSequence_NewType(&waitid_result_desc);
-    if (WaitidResultType == NULL) {
+    state->WaitidResultType = (PyObject *)PyStructSequence_NewType(&waitid_result_desc);
+    if (PyModule_AddObjectRef(m, "waitid_result", state->WaitidResultType) < 0) {
         return -1;
     }
-    Py_INCREF(WaitidResultType);
-    PyModule_AddObject(m, "waitid_result", WaitidResultType);
-    state->WaitidResultType = WaitidResultType;
 #endif
 
     stat_result_desc.name = "os.stat_result"; /* see issue #19209 */
     stat_result_desc.fields[7].name = PyStructSequence_UnnamedField;
     stat_result_desc.fields[8].name = PyStructSequence_UnnamedField;
     stat_result_desc.fields[9].name = PyStructSequence_UnnamedField;
-    PyObject *StatResultType = (PyObject *)PyStructSequence_NewType(&stat_result_desc);
-    if (StatResultType == NULL) {
+    state->StatResultType = (PyObject *)PyStructSequence_NewType(&stat_result_desc);
+    if (PyModule_AddObjectRef(m, "stat_result", state->StatResultType) < 0) {
         return -1;
     }
-    Py_INCREF(StatResultType);
-    PyModule_AddObject(m, "stat_result", StatResultType);
-    state->StatResultType = StatResultType;
-    structseq_new = ((PyTypeObject *)StatResultType)->tp_new;
-    ((PyTypeObject *)StatResultType)->tp_new = statresult_new;
+    structseq_new = ((PyTypeObject *)state->StatResultType)->tp_new;
+    ((PyTypeObject *)state->StatResultType)->tp_new = statresult_new;
 
     statvfs_result_desc.name = "os.statvfs_result"; /* see issue #19209 */
-    PyObject *StatVFSResultType = (PyObject *)PyStructSequence_NewType(&statvfs_result_desc);
-    if (StatVFSResultType == NULL) {
+    state->StatVFSResultType = (PyObject *)PyStructSequence_NewType(&statvfs_result_desc);
+    if (PyModule_AddObjectRef(m, "statvfs_result", state->StatVFSResultType) < 0) {
         return -1;
     }
-    Py_INCREF(StatVFSResultType);
-    PyModule_AddObject(m, "statvfs_result", StatVFSResultType);
-    state->StatVFSResultType = StatVFSResultType;
 #ifdef NEED_TICKS_PER_SECOND
 #  if defined(HAVE_SYSCONF) && defined(_SC_CLK_TCK)
     ticks_per_second = sysconf(_SC_CLK_TCK);
@@ -15893,24 +15889,18 @@ posixmodule_exec(PyObject *m)
 
 #if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)
     sched_param_desc.name = MODNAME ".sched_param";
-    PyObject *SchedParamType = (PyObject *)PyStructSequence_NewType(&sched_param_desc);
-    if (SchedParamType == NULL) {
+    state->SchedParamType = (PyObject *)PyStructSequence_NewType(&sched_param_desc);
+    if (PyModule_AddObjectRef(m, "sched_param", state->SchedParamType) < 0) {
         return -1;
     }
-    Py_INCREF(SchedParamType);
-    PyModule_AddObject(m, "sched_param", SchedParamType);
-    state->SchedParamType = SchedParamType;
-    ((PyTypeObject *)SchedParamType)->tp_new = os_sched_param;
+    ((PyTypeObject *)state->SchedParamType)->tp_new = os_sched_param;
 #endif
 
     /* initialize TerminalSize_info */
-    PyObject *TerminalSizeType = (PyObject *)PyStructSequence_NewType(&TerminalSize_desc);
-    if (TerminalSizeType == NULL) {
+    state->TerminalSizeType = (PyObject *)PyStructSequence_NewType(&TerminalSize_desc);
+    if (PyModule_AddObjectRef(m, "terminal_size", state->TerminalSizeType) < 0) {
         return -1;
     }
-    Py_INCREF(TerminalSizeType);
-    PyModule_AddObject(m, "terminal_size", TerminalSizeType);
-    state->TerminalSizeType = TerminalSizeType;
 
     /* initialize scandir types */
     PyObject *ScandirIteratorType = PyType_FromModuleAndSpec(m, &ScandirIteratorType_spec, NULL);
@@ -15919,30 +15909,21 @@ posixmodule_exec(PyObject *m)
     }
     state->ScandirIteratorType = ScandirIteratorType;
 
-    PyObject *DirEntryType = PyType_FromModuleAndSpec(m, &DirEntryType_spec, NULL);
-    if (DirEntryType == NULL) {
+    state->DirEntryType = PyType_FromModuleAndSpec(m, &DirEntryType_spec, NULL);
+    if (PyModule_AddObjectRef(m, "DirEntry", state->DirEntryType) < 0) {
         return -1;
     }
-    Py_INCREF(DirEntryType);
-    PyModule_AddObject(m, "DirEntry", DirEntryType);
-    state->DirEntryType = DirEntryType;
 
     times_result_desc.name = MODNAME ".times_result";
-    PyObject *TimesResultType = (PyObject *)PyStructSequence_NewType(&times_result_desc);
-    if (TimesResultType == NULL) {
+    state->TimesResultType = (PyObject *)PyStructSequence_NewType(&times_result_desc);
+    if (PyModule_AddObjectRef(m, "times_result", state->TimesResultType) < 0) {
         return -1;
     }
-    Py_INCREF(TimesResultType);
-    PyModule_AddObject(m, "times_result", TimesResultType);
-    state->TimesResultType = TimesResultType;
 
-    PyTypeObject *UnameResultType = PyStructSequence_NewType(&uname_result_desc);
-    if (UnameResultType == NULL) {
+    state->UnameResultType = (PyObject *)PyStructSequence_NewType(&uname_result_desc);
+    if (PyModule_AddObjectRef(m, "uname_result", state->UnameResultType) < 0) {
         return -1;
     }
-    Py_INCREF(UnameResultType);
-    PyModule_AddObject(m, "uname_result", (PyObject *)UnameResultType);
-    state->UnameResultType = (PyObject *)UnameResultType;
 
     if ((state->billion = PyLong_FromLong(1000000000)) == NULL)
         return -1;
@@ -15984,9 +15965,7 @@ posixmodule_exec(PyObject *m)
         Py_DECREF(unicode);
     }
 
-    PyModule_AddObject(m, "_have_functions", list);
-
-    return 0;
+    return _PyModule_Add(m, "_have_functions", list);
 }
 
 
--- a/Modules/pyexpat.c
+++ b/Modules/pyexpat.c
@@ -1768,14 +1768,18 @@ add_error(PyObject *errors_module, PyObj
 static int
 add_errors_module(PyObject *mod)
 {
+    // add_submodule() returns a borrowed ref.
     PyObject *errors_module = add_submodule(mod, MODULE_NAME ".errors");
     if (errors_module == NULL) {
         return -1;
     }
 
     PyObject *codes_dict = PyDict_New();
+    if (codes_dict == NULL) {
+        return -1;
+    }
     PyObject *rev_codes_dict = PyDict_New();
-    if (codes_dict == NULL || rev_codes_dict == NULL) {
+    if (rev_codes_dict == NULL) {
         goto error;
     }
 
@@ -1796,19 +1800,17 @@ add_errors_module(PyObject *mod)
         goto error;
     }
 
-    Py_INCREF(codes_dict);
-    if (PyModule_AddObject(errors_module, "codes", codes_dict) < 0) {
-        Py_DECREF(codes_dict);
+    int rc = PyModule_AddObjectRef(errors_module, "codes", codes_dict);
+    Py_CLEAR(codes_dict);
+    if (rc < 0) {
         goto error;
     }
-    Py_CLEAR(codes_dict);
 
-    Py_INCREF(rev_codes_dict);
-    if (PyModule_AddObject(errors_module, "messages", rev_codes_dict) < 0) {
-        Py_DECREF(rev_codes_dict);
+    rc = PyModule_AddObjectRef(errors_module, "messages", rev_codes_dict);
+    Py_CLEAR(rev_codes_dict);
+    if (rc < 0) {
         goto error;
     }
-    Py_CLEAR(rev_codes_dict);
 
     return 0;
 
--- a/Modules/socketmodule.c
+++ b/Modules/socketmodule.c
@@ -5657,9 +5657,15 @@ gethost_common(struct hostent *h, struct
 
     /* SF #1511317: h_aliases can be NULL */
     if (h->h_aliases) {
-        for (pch = h->h_aliases; *pch != NULL; pch++) {
+        for (pch = h->h_aliases; ; pch++) {
             int status;
-            tmp = PyUnicode_FromString(*pch);
+            char *host_alias;
+            // pch can be misaligned
+            memcpy(&host_alias, pch, sizeof(host_alias));
+            if (host_alias == NULL) {
+                break;
+            }
+            tmp = PyUnicode_FromString(host_alias);
             if (tmp == NULL)
                 goto err;
 
@@ -5671,8 +5677,14 @@ gethost_common(struct hostent *h, struct
         }
     }
 
-    for (pch = h->h_addr_list; *pch != NULL; pch++) {
+    for (pch = h->h_addr_list; ; pch++) {
         int status;
+        char *host_address;
+        // pch can be misaligned
+        memcpy(&host_address, pch, sizeof(host_address));
+        if (host_address == NULL) {
+            break;
+        }
 
         switch (af) {
 
@@ -5684,7 +5696,7 @@ gethost_common(struct hostent *h, struct
 #ifdef HAVE_SOCKADDR_SA_LEN
             sin.sin_len = sizeof(sin);
 #endif
-            memcpy(&sin.sin_addr, *pch, sizeof(sin.sin_addr));
+            memcpy(&sin.sin_addr, host_address, sizeof(sin.sin_addr));
             tmp = make_ipv4_addr(&sin);
 
             if (pch == h->h_addr_list && alen >= sizeof(sin))
@@ -5701,7 +5713,7 @@ gethost_common(struct hostent *h, struct
 #ifdef HAVE_SOCKADDR_SA_LEN
             sin6.sin6_len = sizeof(sin6);
 #endif
-            memcpy(&sin6.sin6_addr, *pch, sizeof(sin6.sin6_addr));
+            memcpy(&sin6.sin6_addr, host_address, sizeof(sin6.sin6_addr));
             tmp = make_ipv6_addr(&sin6);
 
             if (pch == h->h_addr_list && alen >= sizeof(sin6))
--- a/Modules/timemodule.c
+++ b/Modules/timemodule.c
@@ -1775,11 +1775,9 @@ init_timezone(PyObject *m)
         return -1;
     }
 #endif // MS_WINDOWS
-    PyObject *tzname_obj = Py_BuildValue("(NN)", otz0, otz1);
-    if (tzname_obj == NULL) {
+    if (_PyModule_Add(m, "tzname", Py_BuildValue("(NN)", otz0, otz1)) < 0) {
         return -1;
     }
-    PyModule_AddObject(m, "tzname", tzname_obj);
 #else // !HAVE_DECL_TZNAME
     static const time_t YEAR = (365 * 24 + 6) * 3600;
     time_t t;
@@ -1822,10 +1820,9 @@ init_timezone(PyObject *m)
         PyModule_AddIntConstant(m, "daylight", janzone != julyzone);
         tzname_obj = Py_BuildValue("(zz)", janname, julyname);
     }
-    if (tzname_obj == NULL) {
+    if (_PyModule_Add(m, "tzname", tzname_obj) < 0) {
         return -1;
     }
-    PyModule_AddObject(m, "tzname", tzname_obj);
 #endif // !HAVE_DECL_TZNAME
 
     if (PyErr_Occurred()) {
--- a/Modules/xxsubtype.c
+++ b/Modules/xxsubtype.c
@@ -279,14 +279,12 @@ xxsubtype_exec(PyObject* m)
     if (PyType_Ready(&spamdict_type) < 0)
         return -1;
 
-    Py_INCREF(&spamlist_type);
-    if (PyModule_AddObject(m, "spamlist",
-                           (PyObject *) &spamlist_type) < 0)
+    if (PyModule_AddObjectRef(m, "spamlist",
+                              (PyObject *) &spamlist_type) < 0)
         return -1;
 
-    Py_INCREF(&spamdict_type);
-    if (PyModule_AddObject(m, "spamdict",
-                           (PyObject *) &spamdict_type) < 0)
+    if (PyModule_AddObjectRef(m, "spamdict",
+                              (PyObject *) &spamdict_type) < 0)
         return -1;
     return 0;
 }
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -1283,8 +1283,25 @@ _PyBytes_Find(const char *haystack, Py_s
               const char *needle, Py_ssize_t len_needle,
               Py_ssize_t offset)
 {
-    return stringlib_find(haystack, len_haystack,
-                          needle, len_needle, offset);
+    assert(len_haystack >= 0);
+    assert(len_needle >= 0);
+    // Extra checks because stringlib_find accesses haystack[len_haystack].
+    if (len_needle == 0) {
+        return offset;
+    }
+    if (len_needle > len_haystack) {
+        return -1;
+    }
+    assert(len_haystack >= 1);
+    Py_ssize_t res = stringlib_find(haystack, len_haystack - 1,
+                                    needle, len_needle, offset);
+    if (res == -1) {
+        Py_ssize_t last_align = len_haystack - len_needle;
+        if (memcmp(haystack + last_align, needle, len_needle) == 0) {
+            return offset + last_align;
+        }
+    }
+    return res;
 }
 
 Py_ssize_t
--- a/Objects/clinic/codeobject.c.h
+++ b/Objects/clinic/codeobject.c.h
@@ -157,12 +157,7 @@ exit:
 }
 
 PyDoc_STRVAR(code_replace__doc__,
-"replace($self, /, *, co_argcount=-1, co_posonlyargcount=-1,\n"
-"        co_kwonlyargcount=-1, co_nlocals=-1, co_stacksize=-1,\n"
-"        co_flags=-1, co_firstlineno=-1, co_code=None, co_consts=None,\n"
-"        co_names=None, co_varnames=None, co_freevars=None,\n"
-"        co_cellvars=None, co_filename=None, co_name=None,\n"
-"        co_qualname=None, co_linetable=None, co_exceptiontable=None)\n"
+"replace($self, /, **changes)\n"
 "--\n"
 "\n"
 "Return a copy of the code object with new values for the specified fields.");
@@ -174,13 +169,12 @@ static PyObject *
 code_replace_impl(PyCodeObject *self, int co_argcount,
                   int co_posonlyargcount, int co_kwonlyargcount,
                   int co_nlocals, int co_stacksize, int co_flags,
-                  int co_firstlineno, PyBytesObject *co_code,
-                  PyObject *co_consts, PyObject *co_names,
-                  PyObject *co_varnames, PyObject *co_freevars,
-                  PyObject *co_cellvars, PyObject *co_filename,
-                  PyObject *co_name, PyObject *co_qualname,
-                  PyBytesObject *co_linetable,
-                  PyBytesObject *co_exceptiontable);
+                  int co_firstlineno, PyObject *co_code, PyObject *co_consts,
+                  PyObject *co_names, PyObject *co_varnames,
+                  PyObject *co_freevars, PyObject *co_cellvars,
+                  PyObject *co_filename, PyObject *co_name,
+                  PyObject *co_qualname, PyObject *co_linetable,
+                  PyObject *co_exceptiontable);
 
 static PyObject *
 code_replace(PyCodeObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
@@ -197,7 +191,7 @@ code_replace(PyCodeObject *self, PyObjec
     int co_stacksize = self->co_stacksize;
     int co_flags = self->co_flags;
     int co_firstlineno = self->co_firstlineno;
-    PyBytesObject *co_code = NULL;
+    PyObject *co_code = NULL;
     PyObject *co_consts = self->co_consts;
     PyObject *co_names = self->co_names;
     PyObject *co_varnames = NULL;
@@ -206,8 +200,8 @@ code_replace(PyCodeObject *self, PyObjec
     PyObject *co_filename = self->co_filename;
     PyObject *co_name = self->co_name;
     PyObject *co_qualname = self->co_qualname;
-    PyBytesObject *co_linetable = (PyBytesObject *)self->co_linetable;
-    PyBytesObject *co_exceptiontable = (PyBytesObject *)self->co_exceptiontable;
+    PyObject *co_linetable = self->co_linetable;
+    PyObject *co_exceptiontable = self->co_exceptiontable;
 
     args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 0, 0, argsbuf);
     if (!args) {
@@ -284,7 +278,7 @@ code_replace(PyCodeObject *self, PyObjec
             _PyArg_BadArgument("replace", "argument 'co_code'", "bytes", args[7]);
             goto exit;
         }
-        co_code = (PyBytesObject *)args[7];
+        co_code = args[7];
         if (!--noptargs) {
             goto skip_optional_kwonly;
         }
@@ -383,7 +377,7 @@ code_replace(PyCodeObject *self, PyObjec
             _PyArg_BadArgument("replace", "argument 'co_linetable'", "bytes", args[16]);
             goto exit;
         }
-        co_linetable = (PyBytesObject *)args[16];
+        co_linetable = args[16];
         if (!--noptargs) {
             goto skip_optional_kwonly;
         }
@@ -392,7 +386,7 @@ code_replace(PyCodeObject *self, PyObjec
         _PyArg_BadArgument("replace", "argument 'co_exceptiontable'", "bytes", args[17]);
         goto exit;
     }
-    co_exceptiontable = (PyBytesObject *)args[17];
+    co_exceptiontable = args[17];
 skip_optional_kwonly:
     return_value = code_replace_impl(self, co_argcount, co_posonlyargcount, co_kwonlyargcount, co_nlocals, co_stacksize, co_flags, co_firstlineno, co_code, co_consts, co_names, co_varnames, co_freevars, co_cellvars, co_filename, co_name, co_qualname, co_linetable, co_exceptiontable);
 
@@ -436,4 +430,4 @@ code__varname_from_oparg(PyCodeObject *s
 exit:
     return return_value;
 }
-/*[clinic end generated code: output=9c521b6c79f90ff7 input=a9049054013a1b77]*/
+/*[clinic end generated code: output=d1bbf51b746ca2d0 input=a9049054013a1b77]*/
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -1875,27 +1875,28 @@ code_linesiterator(PyCodeObject *code, P
 }
 
 /*[clinic input]
+@text_signature "($self, /, **changes)"
 code.replace
 
     *
-    co_argcount: int(c_default="self->co_argcount") = -1
-    co_posonlyargcount: int(c_default="self->co_posonlyargcount") = -1
-    co_kwonlyargcount: int(c_default="self->co_kwonlyargcount") = -1
-    co_nlocals: int(c_default="self->co_nlocals") = -1
-    co_stacksize: int(c_default="self->co_stacksize") = -1
-    co_flags: int(c_default="self->co_flags") = -1
-    co_firstlineno: int(c_default="self->co_firstlineno") = -1
-    co_code: PyBytesObject(c_default="NULL") = None
-    co_consts: object(subclass_of="&PyTuple_Type", c_default="self->co_consts") = None
-    co_names: object(subclass_of="&PyTuple_Type", c_default="self->co_names") = None
-    co_varnames: object(subclass_of="&PyTuple_Type", c_default="NULL") = None
-    co_freevars: object(subclass_of="&PyTuple_Type", c_default="NULL") = None
-    co_cellvars: object(subclass_of="&PyTuple_Type", c_default="NULL") = None
-    co_filename: unicode(c_default="self->co_filename") = None
-    co_name: unicode(c_default="self->co_name") = None
-    co_qualname: unicode(c_default="self->co_qualname") = None
-    co_linetable: PyBytesObject(c_default="(PyBytesObject *)self->co_linetable") = None
-    co_exceptiontable: PyBytesObject(c_default="(PyBytesObject *)self->co_exceptiontable") = None
+    co_argcount: int(c_default="self->co_argcount") = unchanged
+    co_posonlyargcount: int(c_default="self->co_posonlyargcount") = unchanged
+    co_kwonlyargcount: int(c_default="self->co_kwonlyargcount") = unchanged
+    co_nlocals: int(c_default="self->co_nlocals") = unchanged
+    co_stacksize: int(c_default="self->co_stacksize") = unchanged
+    co_flags: int(c_default="self->co_flags") = unchanged
+    co_firstlineno: int(c_default="self->co_firstlineno") = unchanged
+    co_code: object(subclass_of="&PyBytes_Type", c_default="NULL") = unchanged
+    co_consts: object(subclass_of="&PyTuple_Type", c_default="self->co_consts") = unchanged
+    co_names: object(subclass_of="&PyTuple_Type", c_default="self->co_names") = unchanged
+    co_varnames: object(subclass_of="&PyTuple_Type", c_default="NULL") = unchanged
+    co_freevars: object(subclass_of="&PyTuple_Type", c_default="NULL") = unchanged
+    co_cellvars: object(subclass_of="&PyTuple_Type", c_default="NULL") = unchanged
+    co_filename: unicode(c_default="self->co_filename") = unchanged
+    co_name: unicode(c_default="self->co_name") = unchanged
+    co_qualname: unicode(c_default="self->co_qualname") = unchanged
+    co_linetable: object(subclass_of="&PyBytes_Type", c_default="self->co_linetable") = unchanged
+    co_exceptiontable: object(subclass_of="&PyBytes_Type", c_default="self->co_exceptiontable") = unchanged
 
 Return a copy of the code object with new values for the specified fields.
 [clinic start generated code]*/
@@ -1904,14 +1905,13 @@ static PyObject *
 code_replace_impl(PyCodeObject *self, int co_argcount,
                   int co_posonlyargcount, int co_kwonlyargcount,
                   int co_nlocals, int co_stacksize, int co_flags,
-                  int co_firstlineno, PyBytesObject *co_code,
-                  PyObject *co_consts, PyObject *co_names,
-                  PyObject *co_varnames, PyObject *co_freevars,
-                  PyObject *co_cellvars, PyObject *co_filename,
-                  PyObject *co_name, PyObject *co_qualname,
-                  PyBytesObject *co_linetable,
-                  PyBytesObject *co_exceptiontable)
-/*[clinic end generated code: output=b6cd9988391d5711 input=f6f68e03571f8d7c]*/
+                  int co_firstlineno, PyObject *co_code, PyObject *co_consts,
+                  PyObject *co_names, PyObject *co_varnames,
+                  PyObject *co_freevars, PyObject *co_cellvars,
+                  PyObject *co_filename, PyObject *co_name,
+                  PyObject *co_qualname, PyObject *co_linetable,
+                  PyObject *co_exceptiontable)
+/*[clinic end generated code: output=e75c48a15def18b9 input=18e280e07846c122]*/
 {
 #define CHECK_INT_ARG(ARG) \
         if (ARG < 0) { \
@@ -1936,13 +1936,14 @@ code_replace_impl(PyCodeObject *self, in
         if (code == NULL) {
             return NULL;
         }
-        co_code = (PyBytesObject *)code;
+        co_code = code;
     }
 
     if (PySys_Audit("code.__new__", "OOOiiiiii",
                     co_code, co_filename, co_name, co_argcount,
                     co_posonlyargcount, co_kwonlyargcount, co_nlocals,
                     co_stacksize, co_flags) < 0) {
+        Py_XDECREF(code);
         return NULL;
     }
 
@@ -1974,10 +1975,10 @@ code_replace_impl(PyCodeObject *self, in
 
     co = PyCode_NewWithPosOnlyArgs(
         co_argcount, co_posonlyargcount, co_kwonlyargcount, co_nlocals,
-        co_stacksize, co_flags, (PyObject*)co_code, co_consts, co_names,
+        co_stacksize, co_flags, co_code, co_consts, co_names,
         co_varnames, co_freevars, co_cellvars, co_filename, co_name,
         co_qualname, co_firstlineno,
-        (PyObject*)co_linetable, (PyObject*)co_exceptiontable);
+        co_linetable, co_exceptiontable);
 
 error:
     Py_XDECREF(code);
--- a/Objects/exceptions.c
+++ b/Objects/exceptions.c
@@ -210,22 +210,21 @@ BaseException_add_note(PyObject *self, P
         return NULL;
     }
 
-    if (!PyObject_HasAttr(self, &_Py_ID(__notes__))) {
-        PyObject *new_notes = PyList_New(0);
-        if (new_notes == NULL) {
+    PyObject *notes;
+    if (_PyObject_LookupAttr(self, &_Py_ID(__notes__), &notes) < 0) {
+        return NULL;
+    }
+    if (notes == NULL) {
+        notes = PyList_New(0);
+        if (notes == NULL) {
             return NULL;
         }
-        if (PyObject_SetAttr(self, &_Py_ID(__notes__), new_notes) < 0) {
-            Py_DECREF(new_notes);
+        if (PyObject_SetAttr(self, &_Py_ID(__notes__), notes) < 0) {
+            Py_DECREF(notes);
             return NULL;
         }
-        Py_DECREF(new_notes);
-    }
-    PyObject *notes = PyObject_GetAttr(self, &_Py_ID(__notes__));
-    if (notes == NULL) {
-        return NULL;
     }
-    if (!PyList_Check(notes)) {
+    else if (!PyList_Check(notes)) {
         Py_DECREF(notes);
         PyErr_SetString(PyExc_TypeError, "Cannot add note: __notes__ is not a list");
         return NULL;
@@ -943,11 +942,11 @@ exceptiongroup_subset(
     PyException_SetContext(eg, PyException_GetContext(orig));
     PyException_SetCause(eg, PyException_GetCause(orig));
 
-    if (PyObject_HasAttr(orig, &_Py_ID(__notes__))) {
-        PyObject *notes = PyObject_GetAttr(orig, &_Py_ID(__notes__));
-        if (notes == NULL) {
-            goto error;
-        }
+    PyObject *notes;
+    if (_PyObject_LookupAttr(orig, &_Py_ID(__notes__), &notes) < 0) {
+        goto error;
+    }
+    if (notes) {
         if (PySequence_Check(notes)) {
             /* Make a copy so the parts have independent notes lists. */
             PyObject *notes_copy = PySequence_List(notes);
--- a/Objects/frameobject.c
+++ b/Objects/frameobject.c
@@ -851,9 +851,6 @@ frame_dealloc(PyFrameObject *f)
     /* It is the responsibility of the owning generator/coroutine
      * to have cleared the generator pointer */
 
-    assert(f->f_frame->owner != FRAME_OWNED_BY_GENERATOR ||
-        _PyFrame_GetGenerator(f->f_frame)->gi_frame_state == FRAME_CLEARED);
-
     if (_PyObject_GC_IS_TRACKED(f)) {
         _PyObject_GC_UNTRACK(f);
     }
@@ -861,10 +858,14 @@ frame_dealloc(PyFrameObject *f)
     Py_TRASHCAN_BEGIN(f, frame_dealloc);
     PyCodeObject *co = NULL;
 
+    /* GH-106092: If f->f_frame was on the stack and we reached the maximum
+     * nesting depth for deallocations, the trashcan may have delayed this
+     * deallocation until after f->f_frame is freed. Avoid dereferencing
+     * f->f_frame unless we know it still points to valid memory. */
+    _PyInterpreterFrame *frame = (_PyInterpreterFrame *)f->_f_frame_data;
+
     /* Kill all local variables including specials, if we own them */
-    if (f->f_frame->owner == FRAME_OWNED_BY_FRAME_OBJECT) {
-        assert(f->f_frame == (_PyInterpreterFrame *)f->_f_frame_data);
-        _PyInterpreterFrame *frame = (_PyInterpreterFrame *)f->_f_frame_data;
+    if (f->f_frame == frame && frame->owner == FRAME_OWNED_BY_FRAME_OBJECT) {
         /* Don't clear code object until the end */
         co = frame->f_code;
         frame->f_code = NULL;
--- a/Objects/moduleobject.c
+++ b/Objects/moduleobject.c
@@ -881,26 +881,20 @@ static PyObject *
 module_get_annotations(PyModuleObject *m, void *Py_UNUSED(ignored))
 {
     PyObject *dict = PyObject_GetAttr((PyObject *)m, &_Py_ID(__dict__));
-
-    if ((dict == NULL) || !PyDict_Check(dict)) {
+    if (dict == NULL) {
+        return NULL;
+    }
+    if (!PyDict_Check(dict)) {
         PyErr_Format(PyExc_TypeError, "<module>.__dict__ is not a dictionary");
-        Py_XDECREF(dict);
+        Py_DECREF(dict);
         return NULL;
     }
 
-    PyObject *annotations;
-    /* there's no _PyDict_GetItemId without WithError, so let's LBYL. */
-    if (PyDict_Contains(dict, &_Py_ID(__annotations__))) {
-        annotations = PyDict_GetItemWithError(dict, &_Py_ID(__annotations__));
-        /*
-        ** _PyDict_GetItemIdWithError could still fail,
-        ** for instance with a well-timed Ctrl-C or a MemoryError.
-        ** so let's be totally safe.
-        */
-        if (annotations) {
-            Py_INCREF(annotations);
-        }
-    } else {
+    PyObject *annotations = PyDict_GetItemWithError(dict, &_Py_ID(__annotations__));
+    if (annotations) {
+        Py_INCREF(annotations);
+    }
+    else if (!PyErr_Occurred()) {
         annotations = PyDict_New();
         if (annotations) {
             int result = PyDict_SetItem(
@@ -919,8 +913,10 @@ module_set_annotations(PyModuleObject *m
 {
     int ret = -1;
     PyObject *dict = PyObject_GetAttr((PyObject *)m, &_Py_ID(__dict__));
-
-    if ((dict == NULL) || !PyDict_Check(dict)) {
+    if (dict == NULL) {
+        return -1;
+    }
+    if (!PyDict_Check(dict)) {
         PyErr_Format(PyExc_TypeError, "<module>.__dict__ is not a dictionary");
         goto exit;
     }
@@ -928,19 +924,17 @@ module_set_annotations(PyModuleObject *m
     if (value != NULL) {
         /* set */
         ret = PyDict_SetItem(dict, &_Py_ID(__annotations__), value);
-        goto exit;
     }
-
-    /* delete */
-    if (!PyDict_Contains(dict, &_Py_ID(__annotations__))) {
-        PyErr_Format(PyExc_AttributeError, "__annotations__");
-        goto exit;
+    else {
+        /* delete */
+        ret = PyDict_DelItem(dict, &_Py_ID(__annotations__));
+        if (ret < 0 && PyErr_ExceptionMatches(PyExc_KeyError)) {
+            PyErr_SetString(PyExc_AttributeError, "__annotations__");
+        }
     }
 
-    ret = PyDict_DelItem(dict, &_Py_ID(__annotations__));
-
 exit:
-    Py_XDECREF(dict);
+    Py_DECREF(dict);
     return ret;
 }
 
--- a/Objects/typeobject.c
+++ b/Objects/typeobject.c
@@ -912,24 +912,16 @@ type_get_annotations(PyTypeObject *type,
     }
 
     PyObject *annotations;
-    /* there's no _PyDict_GetItemId without WithError, so let's LBYL. */
-    if (PyDict_Contains(type->tp_dict, &_Py_ID(__annotations__))) {
-        annotations = PyDict_GetItemWithError(
-                type->tp_dict, &_Py_ID(__annotations__));
-        /*
-        ** PyDict_GetItemWithError could still fail,
-        ** for instance with a well-timed Ctrl-C or a MemoryError.
-        ** so let's be totally safe.
-        */
-        if (annotations) {
-            if (Py_TYPE(annotations)->tp_descr_get) {
-                annotations = Py_TYPE(annotations)->tp_descr_get(
-                        annotations, NULL, (PyObject *)type);
-            } else {
-                Py_INCREF(annotations);
-            }
+    annotations = PyDict_GetItemWithError(type->tp_dict, &_Py_ID(__annotations__));
+    if (annotations) {
+        if (Py_TYPE(annotations)->tp_descr_get) {
+            annotations = Py_TYPE(annotations)->tp_descr_get(
+                    annotations, NULL, (PyObject *)type);
+        } else {
+            Py_INCREF(annotations);
         }
-    } else {
+    }
+    else if (!PyErr_Occurred()) {
         annotations = PyDict_New();
         if (annotations) {
             int result = PyDict_SetItem(
@@ -960,11 +952,10 @@ type_set_annotations(PyTypeObject *type,
         result = PyDict_SetItem(type->tp_dict, &_Py_ID(__annotations__), value);
     } else {
         /* delete */
-        if (!PyDict_Contains(type->tp_dict, &_Py_ID(__annotations__))) {
-            PyErr_Format(PyExc_AttributeError, "__annotations__");
-            return -1;
-        }
         result = PyDict_DelItem(type->tp_dict, &_Py_ID(__annotations__));
+        if (result < 0 && PyErr_ExceptionMatches(PyExc_KeyError)) {
+            PyErr_SetString(PyExc_AttributeError, "__annotations__");
+        }
     }
 
     if (result == 0) {
--- a/Objects/unicodeobject.c
+++ b/Objects/unicodeobject.c
@@ -5120,6 +5120,9 @@ unicode_decode_utf8(const char *s, Py_ss
     }
     s += ascii_decode(s, end, PyUnicode_1BYTE_DATA(u));
     if (s == end) {
+        if (consumed) {
+            *consumed = size;
+        }
         return u;
     }
 
@@ -8454,25 +8457,30 @@ PyUnicode_BuildEncodingMap(PyObject* str
 
     if (need_dict) {
         PyObject *result = PyDict_New();
-        PyObject *key, *value;
         if (!result)
             return NULL;
         for (i = 0; i < length; i++) {
-            key = PyLong_FromLong(PyUnicode_READ(kind, data, i));
-            value = PyLong_FromLong(i);
-            if (!key || !value)
-                goto failed1;
-            if (PyDict_SetItem(result, key, value) == -1)
-                goto failed1;
+            Py_UCS4 c = PyUnicode_READ(kind, data, i);
+            PyObject *key = PyLong_FromLong(c);
+            if (key == NULL) {
+                Py_DECREF(result);
+                return NULL;
+            }
+            PyObject *value = PyLong_FromLong(i);
+            if (value == NULL) {
+                Py_DECREF(key);
+                Py_DECREF(result);
+                return NULL;
+            }
+            int rc = PyDict_SetItem(result, key, value);
             Py_DECREF(key);
             Py_DECREF(value);
+            if (rc < 0) {
+                Py_DECREF(result);
+                return NULL;
+            }
         }
         return result;
-      failed1:
-        Py_XDECREF(key);
-        Py_XDECREF(value);
-        Py_DECREF(result);
-        return NULL;
     }
 
     /* Create a three-level trie */
--- a/Parser/asdl_c.py
+++ b/Parser/asdl_c.py
@@ -602,6 +602,7 @@ class Obj2ModVisitor(PickleVisitor):
         args = [f.name for f in prod.fields]
         args.extend([a.name for a in prod.attributes])
         self.emit("*out = %s(%s);" % (ast_func_name(name), self.buildArgs(args)), 1)
+        self.emit("if (*out == NULL) goto failed;", 1)
         self.emit("return 0;", 1)
         self.emit("failed:", 0)
         self.emit("Py_XDECREF(tmp);", 1)
--- a/Python/Python-ast.c
+++ b/Python/Python-ast.c
@@ -10309,6 +10309,7 @@ obj2ast_comprehension(struct ast_state *
         Py_CLEAR(tmp);
     }
     *out = _PyAST_comprehension(target, iter, ifs, is_async, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -10727,6 +10728,7 @@ obj2ast_arguments(struct ast_state *stat
     }
     *out = _PyAST_arguments(posonlyargs, args, vararg, kwonlyargs, kw_defaults,
                             kwarg, defaults, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -10866,6 +10868,7 @@ obj2ast_arg(struct ast_state *state, PyO
     }
     *out = _PyAST_arg(arg, annotation, type_comment, lineno, col_offset,
                       end_lineno, end_col_offset, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -10988,6 +10991,7 @@ obj2ast_keyword(struct ast_state *state,
     }
     *out = _PyAST_keyword(arg, value, lineno, col_offset, end_lineno,
                           end_col_offset, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -11110,6 +11114,7 @@ obj2ast_alias(struct ast_state *state, P
     }
     *out = _PyAST_alias(name, asname, lineno, col_offset, end_lineno,
                         end_col_offset, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -11159,6 +11164,7 @@ obj2ast_withitem(struct ast_state *state
         Py_CLEAR(tmp);
     }
     *out = _PyAST_withitem(context_expr, optional_vars, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
@@ -11246,6 +11252,7 @@ obj2ast_match_case(struct ast_state *sta
         Py_CLEAR(tmp);
     }
     *out = _PyAST_match_case(pattern, guard, body, arena);
+    if (*out == NULL) goto failed;
     return 0;
 failed:
     Py_XDECREF(tmp);
--- a/Python/_warnings.c
+++ b/Python/_warnings.c
@@ -1231,25 +1231,29 @@ PyErr_WarnExplicit(PyObject *category, c
                    const char *module_str, PyObject *registry)
 {
     PyObject *message = PyUnicode_FromString(text);
+    if (message == NULL) {
+        return -1;
+    }
     PyObject *filename = PyUnicode_DecodeFSDefault(filename_str);
+    if (filename == NULL) {
+        Py_DECREF(message);
+        return -1;
+    }
     PyObject *module = NULL;
-    int ret = -1;
-
-    if (message == NULL || filename == NULL)
-        goto exit;
     if (module_str != NULL) {
         module = PyUnicode_FromString(module_str);
-        if (module == NULL)
-            goto exit;
+        if (module == NULL) {
+            Py_DECREF(filename);
+            Py_DECREF(message);
+            return -1;
+        }
     }
 
-    ret = PyErr_WarnExplicitObject(category, message, filename, lineno,
-                                   module, registry);
-
- exit:
-    Py_XDECREF(message);
+    int ret = PyErr_WarnExplicitObject(category, message, filename, lineno,
+                                       module, registry);
     Py_XDECREF(module);
-    Py_XDECREF(filename);
+    Py_DECREF(filename);
+    Py_DECREF(message);
     return ret;
 }
 
--- a/Python/bltinmodule.c
+++ b/Python/bltinmodule.c
@@ -2165,17 +2165,29 @@ builtin_input_impl(PyObject *module, PyO
 
         /* stdin is a text stream, so it must have an encoding. */
         stdin_encoding = PyObject_GetAttr(fin, &_Py_ID(encoding));
+        if (stdin_encoding == NULL) {
+            tty = 0;
+            goto _readline_errors;
+        }
         stdin_errors = PyObject_GetAttr(fin, &_Py_ID(errors));
-        if (!stdin_encoding || !stdin_errors ||
-                !PyUnicode_Check(stdin_encoding) ||
-                !PyUnicode_Check(stdin_errors)) {
+        if (stdin_errors == NULL) {
+            tty = 0;
+            goto _readline_errors;
+        }
+        if (!PyUnicode_Check(stdin_encoding) ||
+            !PyUnicode_Check(stdin_errors))
+        {
             tty = 0;
             goto _readline_errors;
         }
         stdin_encoding_str = PyUnicode_AsUTF8(stdin_encoding);
+        if (stdin_encoding_str == NULL) {
+            goto _readline_errors;
+        }
         stdin_errors_str = PyUnicode_AsUTF8(stdin_errors);
-        if (!stdin_encoding_str || !stdin_errors_str)
+        if (stdin_errors_str == NULL) {
             goto _readline_errors;
+        }
         tmp = PyObject_CallMethodNoArgs(fout, &_Py_ID(flush));
         if (tmp == NULL)
             PyErr_Clear();
@@ -2186,17 +2198,29 @@ builtin_input_impl(PyObject *module, PyO
             const char *stdout_encoding_str, *stdout_errors_str;
             PyObject *stringpo;
             stdout_encoding = PyObject_GetAttr(fout, &_Py_ID(encoding));
+            if (stdout_encoding == NULL) {
+                tty = 0;
+                goto _readline_errors;
+            }
             stdout_errors = PyObject_GetAttr(fout, &_Py_ID(errors));
-            if (!stdout_encoding || !stdout_errors ||
-                    !PyUnicode_Check(stdout_encoding) ||
-                    !PyUnicode_Check(stdout_errors)) {
+            if (stdout_errors == NULL) {
+                tty = 0;
+                goto _readline_errors;
+            }
+            if (!PyUnicode_Check(stdout_encoding) ||
+                !PyUnicode_Check(stdout_errors))
+            {
                 tty = 0;
                 goto _readline_errors;
             }
             stdout_encoding_str = PyUnicode_AsUTF8(stdout_encoding);
+            if (stdout_encoding_str == NULL) {
+                goto _readline_errors;
+            }
             stdout_errors_str = PyUnicode_AsUTF8(stdout_errors);
-            if (!stdout_encoding_str || !stdout_errors_str)
+            if (stdout_errors_str == NULL) {
                 goto _readline_errors;
+            }
             stringpo = PyObject_Str(prompt);
             if (stringpo == NULL)
                 goto _readline_errors;
--- a/Python/compile.c
+++ b/Python/compile.c
@@ -1736,8 +1736,12 @@ compiler_enter_scope(struct compiler *c,
     Py_INCREF(name);
     u->u_name = name;
     u->u_varnames = list2dict(u->u_ste->ste_varnames);
+    if (!u->u_varnames) {
+        compiler_unit_free(u);
+        return 0;
+    }
     u->u_cellvars = dictbytype(u->u_ste->ste_symbols, CELL, 0, 0);
-    if (!u->u_varnames || !u->u_cellvars) {
+    if (!u->u_cellvars) {
         compiler_unit_free(u);
         return 0;
     }
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -2179,12 +2179,14 @@ _Py_find_basename(const wchar_t *filenam
    path, which will be within the original buffer. Guaranteed to not
    make the path longer, and will not fail. 'size' is the length of
    the path, if known. If -1, the first null character will be assumed
-   to be the end of the path. */
+   to be the end of the path. 'normsize' will be set to contain the
+   length of the resulting normalized path. */
 wchar_t *
-_Py_normpath(wchar_t *path, Py_ssize_t size)
+_Py_normpath_and_size(wchar_t *path, Py_ssize_t size, Py_ssize_t *normsize)
 {
     assert(path != NULL);
-    if (!path[0] || size == 0) {
+    if ((size < 0 && !path[0]) || size == 0) {
+        *normsize = 0;
         return path;
     }
     wchar_t *pEnd = size >= 0 ? &path[size] : NULL;
@@ -2233,11 +2235,7 @@ _Py_normpath(wchar_t *path, Py_ssize_t s
                 *p2++ = lastC = *p1;
             }
         }
-        if (sepCount) {
-            minP2 = p2;      // Invalid path
-        } else {
-            minP2 = p2 - 1;  // Absolute path has SEP at minP2
-        }
+        minP2 = p2 - 1;
     }
 #else
     // Skip past two leading SEPs
@@ -2297,13 +2295,28 @@ _Py_normpath(wchar_t *path, Py_ssize_t s
         while (--p2 != minP2 && *p2 == SEP) {
             *p2 = L'\0';
         }
+    } else {
+        --p2;
     }
+    *normsize = p2 - path + 1;
 #undef SEP_OR_END
 #undef IS_SEP
 #undef IS_END
     return path;
 }
 
+/* In-place path normalisation. Returns the start of the normalized
+   path, which will be within the original buffer. Guaranteed to not
+   make the path longer, and will not fail. 'size' is the length of
+   the path, if known. If -1, the first null character will be assumed
+   to be the end of the path. */
+wchar_t *
+_Py_normpath(wchar_t *path, Py_ssize_t size)
+{
+    Py_ssize_t norm_length;
+    return _Py_normpath_and_size(path, size, &norm_length);
+}
+
 
 /* Get the current directory. buflen is the buffer size in wide characters
    including the null character. Decode the path from the locale encoding.
--- a/Python/import.c
+++ b/Python/import.c
@@ -1327,6 +1327,7 @@ unmarshal_frozen_code(struct frozen_info
     PyObject *co = PyMarshal_ReadObjectFromString(info->data, info->size);
     if (co == NULL) {
         /* Does not contain executable code. */
+        PyErr_Clear();
         set_frozen_error(FROZEN_INVALID, info->nameobj);
         return NULL;
     }
--- a/Python/initconfig.c
+++ b/Python/initconfig.c
@@ -49,7 +49,7 @@ Options (and corresponding environment v
          .pyc extension; also PYTHONOPTIMIZE=x\n\
 -OO    : do -O changes and also discard docstrings; add .opt-2 before\n\
          .pyc extension\n\
--P     : don't prepend a potentially unsafe path to sys.path\n\
+-P     : don't prepend a potentially unsafe path to sys.path; also PYTHONSAFEPATH\n\
 -q     : don't print version and copyright messages on interactive startup\n\
 -s     : don't add user site directory to sys.path; also PYTHONNOUSERSITE\n\
 -S     : don't imply 'import site' on initialization\n\
@@ -132,7 +132,6 @@ static const char usage_envvars[] =
 "PYTHONSTARTUP: file executed on interactive startup (no default)\n"
 "PYTHONPATH   : '%lc'-separated list of directories prefixed to the\n"
 "               default module search path.  The result is sys.path.\n"
-"PYTHONSAFEPATH: don't prepend a potentially unsafe path to sys.path.\n"
 "PYTHONHOME   : alternate <prefix> directory (or <prefix>%lc<exec_prefix>).\n"
 "               The default module search path uses %s.\n"
 "PYTHONPLATLIBDIR : override sys.platlibdir.\n"
@@ -172,6 +171,7 @@ static const char usage_envvars[] =
 "                          (-X int_max_str_digits=number)\n"
 "PYTHONNOUSERSITE        : disable user site directory (-s)\n"
 "PYTHONOPTIMIZE          : enable level 1 optimizations (-O)\n"
+"PYTHONSAFEPATH          : don't prepend a potentially unsafe path to sys.path (-P)\n"
 "PYTHONUNBUFFERED        : disable stdout/stderr buffering (-u)\n"
 "PYTHONVERBOSE           : trace import statements (-v)\n"
 "PYTHONWARNINGS=arg      : warning control (-W arg)\n";
--- a/Python/marshal.c
+++ b/Python/marshal.c
@@ -750,23 +750,28 @@ r_string(Py_ssize_t n, RFILE *p)
 static int
 r_byte(RFILE *p)
 {
-    int c = EOF;
-
     if (p->ptr != NULL) {
-        if (p->ptr < p->end)
-            c = (unsigned char) *p->ptr++;
-        return c;
+        if (p->ptr < p->end) {
+            return (unsigned char) *p->ptr++;
+        }
     }
-    if (!p->readable) {
+    else if (!p->readable) {
         assert(p->fp);
-        c = getc(p->fp);
+        int c = getc(p->fp);
+        if (c != EOF) {
+            return c;
+        }
     }
     else {
         const char *ptr = r_string(1, p);
-        if (ptr != NULL)
-            c = *(const unsigned char *) ptr;
+        if (ptr != NULL) {
+            return *(const unsigned char *) ptr;
+        }
+        return EOF;
     }
-    return c;
+    PyErr_SetString(PyExc_EOFError,
+                    "EOF read where not expected");
+    return EOF;
 }
 
 static int
@@ -827,10 +832,11 @@ r_PyLong(RFILE *p)
     digit d;
 
     n = r_long(p);
-    if (PyErr_Occurred())
-        return NULL;
     if (n == 0)
         return (PyObject *)_PyLong_New(0);
+    if (n == -1 && PyErr_Occurred()) {
+        return NULL;
+    }
     if (n < -SIZE32_MAX || n > SIZE32_MAX) {
         PyErr_SetString(PyExc_ValueError,
                        "bad marshal data (long size out of range)");
@@ -849,10 +855,6 @@ r_PyLong(RFILE *p)
         d = 0;
         for (j=0; j < PyLong_MARSHAL_RATIO; j++) {
             md = r_short(p);
-            if (PyErr_Occurred()) {
-                Py_DECREF(ob);
-                return NULL;
-            }
             if (md < 0 || md > PyLong_MARSHAL_BASE)
                 goto bad_digit;
             d += (digit)md << j*PyLong_MARSHAL_SHIFT;
@@ -863,10 +865,6 @@ r_PyLong(RFILE *p)
     d = 0;
     for (j=0; j < shorts_in_top_digit; j++) {
         md = r_short(p);
-        if (PyErr_Occurred()) {
-            Py_DECREF(ob);
-            return NULL;
-        }
         if (md < 0 || md > PyLong_MARSHAL_BASE)
             goto bad_digit;
         /* topmost marshal digit should be nonzero */
@@ -878,18 +876,17 @@ r_PyLong(RFILE *p)
         }
         d += (digit)md << j*PyLong_MARSHAL_SHIFT;
     }
-    if (PyErr_Occurred()) {
-        Py_DECREF(ob);
-        return NULL;
-    }
+    assert(!PyErr_Occurred());
     /* top digit should be nonzero, else the resulting PyLong won't be
        normalized */
     ob->ob_digit[size-1] = d;
     return (PyObject *)ob;
   bad_digit:
     Py_DECREF(ob);
-    PyErr_SetString(PyExc_ValueError,
-                    "bad marshal data (digit out of range in long)");
+    if (!PyErr_Occurred()) {
+        PyErr_SetString(PyExc_ValueError,
+                        "bad marshal data (digit out of range in long)");
+    }
     return NULL;
 }
 
@@ -912,8 +909,6 @@ r_float_str(RFILE *p)
     const char *ptr;
     n = r_byte(p);
     if (n == EOF) {
-        PyErr_SetString(PyExc_EOFError,
-            "EOF read where object expected");
         return -1;
     }
     ptr = r_string(n, p);
@@ -992,8 +987,10 @@ r_object(RFILE *p)
     PyObject *retval = NULL;
 
     if (code == EOF) {
-        PyErr_SetString(PyExc_EOFError,
-                        "EOF read where object expected");
+        if (PyErr_ExceptionMatches(PyExc_EOFError)) {
+            PyErr_SetString(PyExc_EOFError,
+                            "EOF read where object expected");
+        }
         return NULL;
     }
 
@@ -1045,7 +1042,10 @@ r_object(RFILE *p)
 
     case TYPE_INT:
         n = r_long(p);
-        retval = PyErr_Occurred() ? NULL : PyLong_FromLong(n);
+        if (n == -1 && PyErr_Occurred()) {
+            break;
+        }
+        retval = PyLong_FromLong(n);
         R_REF(retval);
         break;
 
@@ -1111,10 +1111,11 @@ r_object(RFILE *p)
         {
             const char *ptr;
             n = r_long(p);
-            if (PyErr_Occurred())
-                break;
             if (n < 0 || n > SIZE32_MAX) {
-                PyErr_SetString(PyExc_ValueError, "bad marshal data (bytes object size out of range)");
+                if (!PyErr_Occurred()) {
+                    PyErr_SetString(PyExc_ValueError,
+                        "bad marshal data (bytes object size out of range)");
+                }
                 break;
             }
             v = PyBytes_FromStringAndSize((char *)NULL, n);
@@ -1136,10 +1137,11 @@ r_object(RFILE *p)
         /* fall through */
     case TYPE_ASCII:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (string size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (string size out of range)");
+            }
             break;
         }
         goto _read_ascii;
@@ -1150,8 +1152,6 @@ r_object(RFILE *p)
     case TYPE_SHORT_ASCII:
         n = r_byte(p);
         if (n == EOF) {
-            PyErr_SetString(PyExc_EOFError,
-                "EOF read where object expected");
             break;
         }
     _read_ascii:
@@ -1178,10 +1178,11 @@ r_object(RFILE *p)
         const char *buffer;
 
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (string size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (string size out of range)");
+            }
             break;
         }
         if (n != 0) {
@@ -1203,16 +1204,18 @@ r_object(RFILE *p)
         }
 
     case TYPE_SMALL_TUPLE:
-        n = (unsigned char) r_byte(p);
-        if (PyErr_Occurred())
+        n = r_byte(p);
+        if (n == EOF) {
             break;
+        }
         goto _read_tuple;
     case TYPE_TUPLE:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (tuple size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (tuple size out of range)");
+            }
             break;
         }
     _read_tuple:
@@ -1238,10 +1241,11 @@ r_object(RFILE *p)
 
     case TYPE_LIST:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (list size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (list size out of range)");
+            }
             break;
         }
         v = PyList_New(n);
@@ -1296,10 +1300,11 @@ r_object(RFILE *p)
     case TYPE_SET:
     case TYPE_FROZENSET:
         n = r_long(p);
-        if (PyErr_Occurred())
-            break;
         if (n < 0 || n > SIZE32_MAX) {
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (set size out of range)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (set size out of range)");
+            }
             break;
         }
 
@@ -1377,20 +1382,20 @@ r_object(RFILE *p)
 
             /* XXX ignore long->int overflows for now */
             argcount = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (argcount == -1 && PyErr_Occurred())
                 goto code_error;
             posonlyargcount = (int)r_long(p);
-            if (PyErr_Occurred()) {
+            if (posonlyargcount == -1 && PyErr_Occurred()) {
                 goto code_error;
             }
             kwonlyargcount = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (kwonlyargcount == -1 && PyErr_Occurred())
                 goto code_error;
             stacksize = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (stacksize == -1 && PyErr_Occurred())
                 goto code_error;
             flags = (int)r_long(p);
-            if (PyErr_Occurred())
+            if (flags == -1 && PyErr_Occurred())
                 goto code_error;
             code = r_object(p);
             if (code == NULL)
@@ -1463,6 +1468,10 @@ r_object(RFILE *p)
             v = r_ref_insert(v, idx, flag, p);
 
           code_error:
+            if (v == NULL && !PyErr_Occurred()) {
+                PyErr_SetString(PyExc_TypeError,
+                    "NULL object in marshal data for code object");
+            }
             Py_XDECREF(code);
             Py_XDECREF(consts);
             Py_XDECREF(names);
@@ -1480,9 +1489,10 @@ r_object(RFILE *p)
     case TYPE_REF:
         n = r_long(p);
         if (n < 0 || n >= PyList_GET_SIZE(p->refs)) {
-            if (n == -1 && PyErr_Occurred())
-                break;
-            PyErr_SetString(PyExc_ValueError, "bad marshal data (invalid reference)");
+            if (!PyErr_Occurred()) {
+                PyErr_SetString(PyExc_ValueError,
+                    "bad marshal data (invalid reference)");
+            }
             break;
         }
         v = PyList_GET_ITEM(p->refs, n);
--- a/Python/modsupport.c
+++ b/Python/modsupport.c
@@ -658,13 +658,16 @@ PyModule_AddObjectRef(PyObject *mod, con
                      PyModule_GetName(mod));
         return -1;
     }
-
-    if (PyDict_SetItemString(dict, name, value)) {
-        return -1;
-    }
-    return 0;
+    return PyDict_SetItemString(dict, name, value);
 }
 
+int
+_PyModule_Add(PyObject *mod, const char *name, PyObject *value)
+{
+    int res = PyModule_AddObjectRef(mod, name, value);
+    Py_XDECREF(value);
+    return res;
+}
 
 int
 PyModule_AddObject(PyObject *mod, const char *name, PyObject *value)
@@ -679,25 +682,13 @@ PyModule_AddObject(PyObject *mod, const
 int
 PyModule_AddIntConstant(PyObject *m, const char *name, long value)
 {
-    PyObject *obj = PyLong_FromLong(value);
-    if (!obj) {
-        return -1;
-    }
-    int res = PyModule_AddObjectRef(m, name, obj);
-    Py_DECREF(obj);
-    return res;
+    return _PyModule_Add(m, name, PyLong_FromLong(value));
 }
 
 int
 PyModule_AddStringConstant(PyObject *m, const char *name, const char *value)
 {
-    PyObject *obj = PyUnicode_FromString(value);
-    if (!obj) {
-        return -1;
-    }
-    int res = PyModule_AddObjectRef(m, name, obj);
-    Py_DECREF(obj);
-    return res;
+    return _PyModule_Add(m, name, PyUnicode_FromString(value));
 }
 
 int
--- a/Python/pythonrun.c
+++ b/Python/pythonrun.c
@@ -1138,15 +1138,13 @@ print_exception_notes(struct exception_p
         return 0;
     }
 
-    if (!PyObject_HasAttr(value, &_Py_ID(__notes__))) {
-        return 0;
-    }
-    PyObject *notes = PyObject_GetAttr(value, &_Py_ID(__notes__));
-    if (notes == NULL) {
-        return -1;
+    PyObject *notes;
+    int res = _PyObject_LookupAttr(value, &_Py_ID(__notes__), &notes);
+    if (res <= 0) {
+        return res;
     }
     if (!PySequence_Check(notes)) {
-        int res = 0;
+        res = 0;
         if (write_indented_margin(ctx, f) < 0) {
             res = -1;
         }
--- a/Python/specialize.c
+++ b/Python/specialize.c
@@ -1500,9 +1500,9 @@ specialize_py_call(PyFunctionObject *fun
     }
     int argcount = code->co_argcount;
     int defcount = func->func_defaults == NULL ? 0 : (int)PyTuple_GET_SIZE(func->func_defaults);
-    assert(defcount <= argcount);
     int min_args = argcount-defcount;
-    if (nargs > argcount || nargs < min_args) {
+    // GH-105840: min_args is negative when somebody sets too many __defaults__!
+    if (min_args < 0 || nargs > argcount || nargs < min_args) {
         SPECIALIZATION_FAIL(CALL, SPEC_FAIL_WRONG_NUMBER_ARGUMENTS);
         return -1;
     }
--- a/Python/suggestions.c
+++ b/Python/suggestions.c
@@ -147,14 +147,14 @@ calculate_suggestions(PyObject *dir,
 
     for (int i = 0; i < dir_size; ++i) {
         PyObject *item = PyList_GET_ITEM(dir, i);
+        if (_PyUnicode_Equal(name, item)) {
+            continue;
+        }
         Py_ssize_t item_size;
         const char *item_str = PyUnicode_AsUTF8AndSize(item, &item_size);
         if (item_str == NULL) {
             return NULL;
         }
-        if (PyUnicode_CompareWithASCIIString(name, item_str) == 0) {
-            continue;
-        }
         // No more than 1/3 of the involved characters should need changed.
         Py_ssize_t max_distance = (name_size + item_size + 3) * MOVE_COST / 6;
         // Don't take matches we've already beaten.
@@ -225,19 +225,19 @@ offer_suggestions_for_name_error(PyNameE
     PyCodeObject *code = PyFrame_GetCode(frame);
     assert(code != NULL && code->co_localsplusnames != NULL);
     PyObject *varnames = _PyCode_GetVarnames(code);
+    Py_DECREF(code);
     if (varnames == NULL) {
         return NULL;
     }
     PyObject *dir = PySequence_List(varnames);
     Py_DECREF(varnames);
-    Py_DECREF(code);
     if (dir == NULL) {
         return NULL;
     }
 
     PyObject *suggestions = calculate_suggestions(dir, name);
     Py_DECREF(dir);
-    if (suggestions != NULL) {
+    if (suggestions != NULL|| PyErr_Occurred()) {
         return suggestions;
     }
 
@@ -247,7 +247,7 @@ offer_suggestions_for_name_error(PyNameE
     }
     suggestions = calculate_suggestions(dir, name);
     Py_DECREF(dir);
-    if (suggestions != NULL) {
+    if (suggestions != NULL || PyErr_Occurred()) {
         return suggestions;
     }
 
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -2360,15 +2360,21 @@ _PySys_AddXOptionWithError(const wchar_t
     const wchar_t *name_end = wcschr(s, L'=');
     if (!name_end) {
         name = PyUnicode_FromWideChar(s, -1);
+        if (name == NULL) {
+            goto error;
+        }
         value = Py_True;
         Py_INCREF(value);
     }
     else {
         name = PyUnicode_FromWideChar(s, name_end - s);
+        if (name == NULL) {
+            goto error;
+        }
         value = PyUnicode_FromWideChar(name_end + 1, -1);
-    }
-    if (name == NULL || value == NULL) {
-        goto error;
+        if (value == NULL) {
+            goto error;
+        }
     }
     if (PyDict_SetItem(opts, name, value) < 0) {
         goto error;
@@ -3014,20 +3020,26 @@ err_occurred:
 static int
 sys_add_xoption(PyObject *opts, const wchar_t *s)
 {
-    PyObject *name, *value;
+    PyObject *name, *value = NULL;
 
     const wchar_t *name_end = wcschr(s, L'=');
     if (!name_end) {
         name = PyUnicode_FromWideChar(s, -1);
+        if (name == NULL) {
+            goto error;
+        }
         value = Py_True;
         Py_INCREF(value);
     }
     else {
         name = PyUnicode_FromWideChar(s, name_end - s);
+        if (name == NULL) {
+            goto error;
+        }
         value = PyUnicode_FromWideChar(name_end + 1, -1);
-    }
-    if (name == NULL || value == NULL) {
-        goto error;
+        if (value == NULL) {
+            goto error;
+        }
     }
     if (PyDict_SetItem(opts, name, value) < 0) {
         goto error;
--- a/Tools/c-analyzer/c_parser/preprocessor/common.py
+++ b/Tools/c-analyzer/c_parser/preprocessor/common.py
@@ -1,6 +1,7 @@
 import contextlib
 import distutils.ccompiler
 import logging
+import os
 import shlex
 import subprocess
 import sys
@@ -40,7 +41,12 @@ def run_cmd(argv, *,
     kw.pop('kwargs')
     kwargs.update(kw)
 
-    proc = subprocess.run(argv, **kwargs)
+    # Remove LANG environment variable: the C parser doesn't support GCC
+    # localized messages
+    env = dict(os.environ)
+    env.pop('LANG', None)
+
+    proc = subprocess.run(argv, env=env, **kwargs)
     return proc.stdout
 
 
--- a/Tools/c-analyzer/cpython/ignored.tsv
+++ b/Tools/c-analyzer/cpython/ignored.tsv
@@ -1432,6 +1432,7 @@ Modules/_decimal/_decimal.c	-	invalid_ro
 Modules/_decimal/_decimal.c	-	invalid_signals_err	-
 Modules/_decimal/_decimal.c	-	signal_map	-
 Modules/_decimal/_decimal.c	-	ssize_constants	-
+Modules/_decimal/_decimal.c -   INVALID_SIGNALDICT_ERROR_MSG -
 Modules/_elementtree.c	-	ExpatMemoryHandler	-
 Modules/_io/_iomodule.c	-	static_types	-
 Modules/_io/textio.c	-	encodefuncs	-
--- a/Tools/clinic/clinic.py
+++ b/Tools/clinic/clinic.py
@@ -460,7 +460,7 @@ class PythonLanguage(Language):
 
 def permute_left_option_groups(l):
     """
-    Given [1, 2, 3], should yield:
+    Given [(1,), (2,), (3,)], should yield:
        ()
        (3,)
        (2, 3)
@@ -475,7 +475,7 @@ def permute_left_option_groups(l):
 
 def permute_right_option_groups(l):
     """
-    Given [1, 2, 3], should yield:
+    Given [(1,), (2,), (3,)], should yield:
       ()
       (1,)
       (1, 2)
@@ -1798,7 +1798,7 @@ class BufferSeries:
 
     def clear(self):
         for ta in self._array:
-            ta._text.clear()
+            ta.text.clear()
 
     def dump(self):
         texts = [ta.output() for ta in self._array]
@@ -4072,6 +4072,7 @@ class DSLParser:
         self.indent = IndentStack()
         self.kind = CALLABLE
         self.coexist = False
+        self.forced_text_signature: str | None = None
         self.parameter_continuation = ''
         self.preserve_output = False
 
@@ -4121,14 +4122,19 @@ class DSLParser:
 
         self.clinic.__dict__[name] = value
 
-    def directive_destination(self, name, command, *args):
-        if command == 'new':
-            self.clinic.add_destination(name, *args)
-            return
-
-        if command == 'clear':
-            self.clinic.get_destination(name).clear()
-        fail("unknown destination command", repr(command))
+    def directive_destination(
+            self,
+            name: str,
+            command: str,
+            *args
+    ) -> None:
+        match command:
+            case "new":
+                self.clinic.add_destination(name, *args)
+            case "clear":
+                self.clinic.get_destination(name).clear()
+            case _:
+                fail("unknown destination command", repr(command))
 
 
     def directive_output(self, command_or_name, destination=''):
@@ -4196,6 +4202,11 @@ class DSLParser:
             fail("Called @coexist twice!")
         self.coexist = True
 
+    def at_text_signature(self, text_signature):
+        if self.forced_text_signature:
+            fail("Called @text_signature twice!")
+        self.forced_text_signature = text_signature
+
     def parse(self, block):
         self.reset()
         self.block = block
@@ -4898,142 +4909,145 @@ class DSLParser:
             add(f.cls.name)
         else:
             add(f.name)
-        add('(')
-
-        # populate "right_bracket_count" field for every parameter
-        assert parameters, "We should always have a self parameter. " + repr(f)
-        assert isinstance(parameters[0].converter, self_converter)
-        # self is always positional-only.
-        assert parameters[0].is_positional_only()
-        parameters[0].right_bracket_count = 0
-        positional_only = True
-        for p in parameters[1:]:
-            if not p.is_positional_only():
-                positional_only = False
-            else:
-                assert positional_only
-            if positional_only:
-                p.right_bracket_count = abs(p.group)
-            else:
-                # don't put any right brackets around non-positional-only parameters, ever.
-                p.right_bracket_count = 0
+        if self.forced_text_signature:
+            add(self.forced_text_signature)
+        else:
+            add('(')
 
-        right_bracket_count = 0
+            # populate "right_bracket_count" field for every parameter
+            assert parameters, "We should always have a self parameter. " + repr(f)
+            assert isinstance(parameters[0].converter, self_converter)
+            # self is always positional-only.
+            assert parameters[0].is_positional_only()
+            parameters[0].right_bracket_count = 0
+            positional_only = True
+            for p in parameters[1:]:
+                if not p.is_positional_only():
+                    positional_only = False
+                else:
+                    assert positional_only
+                if positional_only:
+                    p.right_bracket_count = abs(p.group)
+                else:
+                    # don't put any right brackets around non-positional-only parameters, ever.
+                    p.right_bracket_count = 0
 
-        def fix_right_bracket_count(desired):
-            nonlocal right_bracket_count
-            s = ''
-            while right_bracket_count < desired:
-                s += '['
-                right_bracket_count += 1
-            while right_bracket_count > desired:
-                s += ']'
-                right_bracket_count -= 1
-            return s
+            right_bracket_count = 0
 
-        need_slash = False
-        added_slash = False
-        need_a_trailing_slash = False
-
-        # we only need a trailing slash:
-        #   * if this is not a "docstring_only" signature
-        #   * and if the last *shown* parameter is
-        #     positional only
-        if not f.docstring_only:
-            for p in reversed(parameters):
-                if not p.converter.show_in_signature:
-                    continue
-                if p.is_positional_only():
-                    need_a_trailing_slash = True
-                break
+            def fix_right_bracket_count(desired):
+                nonlocal right_bracket_count
+                s = ''
+                while right_bracket_count < desired:
+                    s += '['
+                    right_bracket_count += 1
+                while right_bracket_count > desired:
+                    s += ']'
+                    right_bracket_count -= 1
+                return s
+
+            need_slash = False
+            added_slash = False
+            need_a_trailing_slash = False
+
+            # we only need a trailing slash:
+            #   * if this is not a "docstring_only" signature
+            #   * and if the last *shown* parameter is
+            #     positional only
+            if not f.docstring_only:
+                for p in reversed(parameters):
+                    if not p.converter.show_in_signature:
+                        continue
+                    if p.is_positional_only():
+                        need_a_trailing_slash = True
+                    break
 
 
-        added_star = False
+            added_star = False
 
-        first_parameter = True
-        last_p = parameters[-1]
-        line_length = len(''.join(text))
-        indent = " " * line_length
-        def add_parameter(text):
-            nonlocal line_length
-            nonlocal first_parameter
-            if first_parameter:
-                s = text
-                first_parameter = False
-            else:
-                s = ' ' + text
-                if line_length + len(s) >= 72:
-                    add('\n')
-                    add(indent)
-                    line_length = len(indent)
+            first_parameter = True
+            last_p = parameters[-1]
+            line_length = len(''.join(text))
+            indent = " " * line_length
+            def add_parameter(text):
+                nonlocal line_length
+                nonlocal first_parameter
+                if first_parameter:
                     s = text
-            line_length += len(s)
-            add(s)
+                    first_parameter = False
+                else:
+                    s = ' ' + text
+                    if line_length + len(s) >= 72:
+                        add('\n')
+                        add(indent)
+                        line_length = len(indent)
+                        s = text
+                line_length += len(s)
+                add(s)
 
-        for p in parameters:
-            if not p.converter.show_in_signature:
-                continue
-            assert p.name
+            for p in parameters:
+                if not p.converter.show_in_signature:
+                    continue
+                assert p.name
 
-            is_self = isinstance(p.converter, self_converter)
-            if is_self and f.docstring_only:
-                # this isn't a real machine-parsable signature,
-                # so let's not print the "self" parameter
-                continue
+                is_self = isinstance(p.converter, self_converter)
+                if is_self and f.docstring_only:
+                    # this isn't a real machine-parsable signature,
+                    # so let's not print the "self" parameter
+                    continue
 
-            if p.is_positional_only():
-                need_slash = not f.docstring_only
-            elif need_slash and not (added_slash or p.is_positional_only()):
-                added_slash = True
-                add_parameter('/,')
-
-            if p.is_keyword_only() and not added_star:
-                added_star = True
-                add_parameter('*,')
-
-            p_add, p_output = text_accumulator()
-            p_add(fix_right_bracket_count(p.right_bracket_count))
-
-            if isinstance(p.converter, self_converter):
-                # annotate first parameter as being a "self".
-                #
-                # if inspect.Signature gets this function,
-                # and it's already bound, the self parameter
-                # will be stripped off.
-                #
-                # if it's not bound, it should be marked
-                # as positional-only.
-                #
-                # note: we don't print "self" for __init__,
-                # because this isn't actually the signature
-                # for __init__.  (it can't be, __init__ doesn't
-                # have a docstring.)  if this is an __init__
-                # (or __new__), then this signature is for
-                # calling the class to construct a new instance.
-                p_add('$')
+                if p.is_positional_only():
+                    need_slash = not f.docstring_only
+                elif need_slash and not (added_slash or p.is_positional_only()):
+                    added_slash = True
+                    add_parameter('/,')
+
+                if p.is_keyword_only() and not added_star:
+                    added_star = True
+                    add_parameter('*,')
+
+                p_add, p_output = text_accumulator()
+                p_add(fix_right_bracket_count(p.right_bracket_count))
+
+                if isinstance(p.converter, self_converter):
+                    # annotate first parameter as being a "self".
+                    #
+                    # if inspect.Signature gets this function,
+                    # and it's already bound, the self parameter
+                    # will be stripped off.
+                    #
+                    # if it's not bound, it should be marked
+                    # as positional-only.
+                    #
+                    # note: we don't print "self" for __init__,
+                    # because this isn't actually the signature
+                    # for __init__.  (it can't be, __init__ doesn't
+                    # have a docstring.)  if this is an __init__
+                    # (or __new__), then this signature is for
+                    # calling the class to construct a new instance.
+                    p_add('$')
 
-            if p.is_vararg():
-                p_add("*")
+                if p.is_vararg():
+                    p_add("*")
 
-            name = p.converter.signature_name or p.name
-            p_add(name)
+                name = p.converter.signature_name or p.name
+                p_add(name)
 
-            if not p.is_vararg() and p.converter.is_optional():
-                p_add('=')
-                value = p.converter.py_default
-                if not value:
-                    value = repr(p.converter.default)
-                p_add(value)
-
-            if (p != last_p) or need_a_trailing_slash:
-                p_add(',')
-
-            add_parameter(p_output())
-
-        add(fix_right_bracket_count(0))
-        if need_a_trailing_slash:
-            add_parameter('/')
-        add(')')
+                if not p.is_vararg() and p.converter.is_optional():
+                    p_add('=')
+                    value = p.converter.py_default
+                    if not value:
+                        value = repr(p.converter.default)
+                    p_add(value)
+
+                if (p != last_p) or need_a_trailing_slash:
+                    p_add(',')
+
+                add_parameter(p_output())
+
+            add(fix_right_bracket_count(0))
+            if need_a_trailing_slash:
+                add_parameter('/')
+            add(')')
 
         # PEP 8 says:
         #
@@ -5185,15 +5199,21 @@ with writing argument parsing code for b
 signatures ("docstrings") for CPython builtins.
 
 For more information see https://docs.python.org/3/howto/clinic.html""")
-    cmdline.add_argument("-f", "--force", action='store_true')
-    cmdline.add_argument("-o", "--output", type=str)
-    cmdline.add_argument("-v", "--verbose", action='store_true')
-    cmdline.add_argument("--converters", action='store_true')
+    cmdline.add_argument("-f", "--force", action='store_true',
+                         help="force output regeneration")
+    cmdline.add_argument("-o", "--output", type=str,
+                         help="redirect file output to OUTPUT")
+    cmdline.add_argument("-v", "--verbose", action='store_true',
+                         help="enable verbose mode")
+    cmdline.add_argument("--converters", action='store_true',
+                         help=("print a list of all supported converters "
+                               "and return converters"))
     cmdline.add_argument("--make", action='store_true',
-                         help="Walk --srcdir to run over all relevant files.")
+                         help="walk --srcdir to run over all relevant files")
     cmdline.add_argument("--srcdir", type=str, default=os.curdir,
-                         help="The directory tree to walk in --make mode.")
-    cmdline.add_argument("filename", type=str, nargs="*")
+                         help="the directory tree to walk in --make mode")
+    cmdline.add_argument("filename", metavar="FILE", type=str, nargs="*",
+                         help="the list of files to process")
     ns = cmdline.parse_args(argv)
 
     if ns.converters:
--- a/Tools/scripts/umarshal.py
+++ b/Tools/scripts/umarshal.py
@@ -125,10 +125,10 @@ class Reader:
         x |= buf[1] << 8
         x |= buf[2] << 16
         x |= buf[3] << 24
-        x |= buf[1] << 32
-        x |= buf[1] << 40
-        x |= buf[1] << 48
-        x |= buf[1] << 56
+        x |= buf[4] << 32
+        x |= buf[5] << 40
+        x |= buf[6] << 48
+        x |= buf[7] << 56
         x |= -(x & (1<<63))  # Sign-extend
         return x
 
--- a/configure.ac
+++ b/configure.ac
@@ -2246,6 +2246,10 @@ yes)
     AS_VAR_IF([ac_cv_disable_unused_parameter_warning], [yes],
               [CFLAGS_NODIST="$CFLAGS_NODIST -Wno-unused-parameter"])
 
+    PY_CHECK_CC_WARNING([disable], [int-conversion])
+    AS_VAR_IF([ac_cv_disable_int_conversion], [yes],
+              [CFLAGS_NODIST="$CFLAGS_NODIST -Wno-int-conversion"])
+
     PY_CHECK_CC_WARNING([disable], [missing-field-initializers])
     AS_VAR_IF([ac_cv_disable_missing_field_initializers_warning], [yes],
               [CFLAGS_NODIST="$CFLAGS_NODIST -Wno-missing-field-initializers"])
@@ -2664,7 +2668,7 @@ AC_DEFINE(STDC_HEADERS, 1, [Define to 1
 # checks for header files
 AC_CHECK_HEADERS([ \
   alloca.h asm/types.h bluetooth.h conio.h crypt.h direct.h dlfcn.h endian.h errno.h fcntl.h grp.h \
-  ieeefp.h io.h langinfo.h libintl.h libutil.h linux/auxvec.h sys/auxv.h linux/memfd.h \
+  ieeefp.h io.h langinfo.h libintl.h libutil.h linux/auxvec.h sys/auxv.h linux/limits.h linux/memfd.h \
   linux/random.h linux/soundcard.h \
   linux/tipc.h linux/wait.h netdb.h netinet/in.h netpacket/packet.h poll.h process.h pthread.h pty.h \
   sched.h setjmp.h shadow.h signal.h spawn.h stropts.h sys/audioio.h sys/bsdtty.h sys/devpoll.h \
--- a/pyconfig.h.in
+++ b/pyconfig.h.in
@@ -718,6 +718,9 @@
 /* Define if compiling using Linux 4.1 or later. */
 #undef HAVE_LINUX_CAN_RAW_JOIN_FILTERS
 
+/* Define to 1 if you have the <linux/limits.h> header file. */
+#undef HAVE_LINUX_LIMITS_H
+
 /* Define to 1 if you have the <linux/memfd.h> header file. */
 #undef HAVE_LINUX_MEMFD_H
 
